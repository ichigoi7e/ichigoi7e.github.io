<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java JDK</title>
      <link href="2021/03/24/Java-JDK/"/>
      <url>2021/03/24/Java-JDK/</url>
      
        <content type="html"><![CDATA[<h2 id="工厂模式在-Calendar-类中的应用"><a href="#工厂模式在-Calendar-类中的应用" class="headerlink" title="工厂模式在 Calendar 类中的应用"></a>工厂模式在 Calendar 类中的应用</h2><p>Calendar 类提供了大量跟日期相关的功能代码，同时，又提供了一个 getInstance() 工厂方法，用来根据不同的 TimeZone 和 Locale 创建不同的 Calendar 子类对象。也就是说，功能代码和工厂方法代码耦合在了一个类中。所以，即便我们去查看它的源码，如果不细心的话，也很难发现它用到了工厂模式。同时，因为它不单单是一个工厂类，所以，它并没有以 Factory 作为后缀来命名。从代码中，我们可以看出，getInstance() 方法可以根据不同 TimeZone 和 Locale，创建不同的 Calendar 子类对象，比如 BuddhistCalendar、JapaneseImperialCalendar、GregorianCalendar，这些<strong>细节完全封装在工厂方法中，使用者只需要传递当前的时区和地址</strong>，就能够获得一个 Calendar 类对象来使用，而获得的对象具体是哪个 Calendar 子类的对象，使用者在使用的时候并不关心：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span>, <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Calendar <span class="title">getInstance</span><span class="params">(TimeZone zone, Locale aLocale)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> createCalendar(zone, aLocale);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Calendar <span class="title">createCalendar</span><span class="params">(TimeZone zone,Locale aLocale)</span> </span>&#123;</span><br><span class="line">        CalendarProvider provider = LocaleProviderAdapter.getAdapter(CalendarProvider<span class="class">.<span class="keyword">class</span>, <span class="title">aLocale</span>).<span class="title">getCalendarProvider</span>()</span>;</span><br><span class="line">        <span class="keyword">if</span> (provider != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> provider.getInstance(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalArgumentException iae) &#123;</span><br><span class="line">                <span class="comment">// fall back to the default instantiation</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Calendar cal = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (aLocale.hasExtensions()) &#123;</span><br><span class="line">            String caltype = aLocale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">            <span class="keyword">if</span> (caltype != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">switch</span> (caltype) &#123;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">                        cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">                        cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">                        cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cal == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aLocale.getLanguage() == <span class="string">"th"</span> &amp;&amp; aLocale.getCountry() == <span class="string">"TH"</span>) &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> BuddhistCalendar(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (aLocale.getVariant() == <span class="string">"JP"</span> &amp;&amp; aLocale.getLanguage() == <span class="string">"ja"</span> &amp;&amp; aLocale.getCountry() == <span class="string">"JP"</span>) &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, aLocale);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cal = <span class="keyword">new</span> GregorianCalendar(zone, aLocale);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cal;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="建造者模式在-Calendar-类中的应用"><a href="#建造者模式在-Calendar-类中的应用" class="headerlink" title="建造者模式在 Calendar 类中的应用"></a>建造者模式在 Calendar 类中的应用</h2><p>我们知道，建造者模式有两种实现方法，一种是单独定义一个 Builder 类，另一种是<strong>将 Builder 实现为原始类的内部类</strong>。Calendar 就采用了第二种实现思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Calendar</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Cloneable</span>, <span class="title">Comparable</span>&lt;<span class="title">Calendar</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NFIELDS = FIELD_COUNT + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WEEK_YEAR = FIELD_COUNT;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> instant;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span>[] fields;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> nextStamp;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxFieldIndex;</span><br><span class="line">        <span class="keyword">private</span> String type;</span><br><span class="line">        <span class="keyword">private</span> TimeZone zone;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> lenient = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">private</span> Locale locale;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> firstDayOfWeek, minimalDaysInFirstWeek;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setInstant</span><span class="params">(<span class="keyword">long</span> instant)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (fields != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.instant = instant;</span><br><span class="line">            nextStamp = COMPUTED;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 省略 n 多 set() 方法</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Calendar <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (locale == <span class="keyword">null</span>) &#123;</span><br><span class="line">                locale = Locale.getDefault();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (zone == <span class="keyword">null</span>) &#123;</span><br><span class="line">                zone = TimeZone.getDefault();</span><br><span class="line">            &#125;</span><br><span class="line">            Calendar cal;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">                type = locale.getUnicodeLocaleType(<span class="string">"ca"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (type == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (locale.getCountry() == <span class="string">"TH"</span> &amp;&amp; locale.getLanguage() == <span class="string">"th"</span>) &#123;</span><br><span class="line">                    type = <span class="string">"buddhist"</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    type = <span class="string">"gregory"</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"gregory"</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> GregorianCalendar(zone, locale, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"iso8601"</span>:</span><br><span class="line">                GregorianCalendar gcal = <span class="keyword">new</span> GregorianCalendar(zone, locale, <span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">// make gcal a proleptic Gregorian</span></span><br><span class="line">                gcal.setGregorianChange(<span class="keyword">new</span> Date(Long.MIN_VALUE));</span><br><span class="line">                <span class="comment">// and week definition to be compatible with ISO 8601</span></span><br><span class="line">                setWeekDefinition(MONDAY, <span class="number">4</span>);</span><br><span class="line">                cal = gcal;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"buddhist"</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> BuddhistCalendar(zone, locale);</span><br><span class="line">                cal.clear();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"japanese"</span>:</span><br><span class="line">                cal = <span class="keyword">new</span> JapaneseImperialCalendar(zone, locale, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unknown calendar type: "</span> + type);</span><br><span class="line">            &#125;</span><br><span class="line">            cal.setLenient(lenient);</span><br><span class="line">            <span class="keyword">if</span> (firstDayOfWeek != <span class="number">0</span>) &#123;</span><br><span class="line">                cal.setFirstDayOfWeek(firstDayOfWeek);</span><br><span class="line">                cal.setMinimalDaysInFirstWeek(minimalDaysInFirstWeek);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isInstantSet()) &#123;</span><br><span class="line">                cal.setTimeInMillis(instant);</span><br><span class="line">                cal.complete();</span><br><span class="line">                <span class="keyword">return</span> cal;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (fields != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> weekDate = isSet(WEEK_YEAR) &amp;&amp; fields[WEEK_YEAR] &gt; fields[YEAR];</span><br><span class="line">                <span class="keyword">if</span> (weekDate &amp;&amp; !cal.isWeekDateSupported()) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"week date is unsupported by "</span> + type);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> stamp = MINIMUM_USER_STAMP; stamp &lt; nextStamp; stamp++) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt;= maxFieldIndex; index++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fields[index] == stamp) &#123;</span><br><span class="line">                            cal.set(index, fields[NFIELDS + index]);</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (weekDate) &#123;</span><br><span class="line">                    <span class="keyword">int</span> weekOfYear = isSet(WEEK_OF_YEAR) ? fields[NFIELDS + WEEK_OF_YEAR] : <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">int</span> dayOfWeek = isSet(DAY_OF_WEEK) ? fields[NFIELDS + DAY_OF_WEEK] : cal.getFirstDayOfWeek();</span><br><span class="line">                    cal.setWeekDate(fields[NFIELDS + WEEK_YEAR], weekOfYear, dayOfWeek);</span><br><span class="line">                &#125;</span><br><span class="line">                cal.complete();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> cal;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工厂模式是用来创建不同但是相关类型的对象（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。建造者模式用来创建一种类型的复杂对象，<strong>通过设置不同的可选参数，定制化地创建不同的对象</strong>。网上有一个经典的例子很好地解释了两者的区别:</p><blockquote><p>顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作不同的披萨。</p></blockquote><p>粗看 Calendar 的 Builder 类的 build() 方法，你可能会觉得它有点像工厂模式。你的感觉没错，前面一半代码确实跟 getInstance() 工厂方法类似，根据不同的 type 创建了不同的 Calendar 子类。实际上，后面一半代码才属于标准的建造者模式，根据 setXXX() 方法设置的参数，来定制化刚刚创建的 Calendar 子类对象。</p><h2 id="装饰器模式在-Collections-类中的应用"><a href="#装饰器模式在-Collections-类中的应用" class="headerlink" title="装饰器模式在 Collections 类中的应用"></a>装饰器模式在 Collections 类中的应用</h2><h2 id="适配器模式在-Collections-类中的应用"><a href="#适配器模式在-Collections-类中的应用" class="headerlink" title="适配器模式在 Collections 类中的应用"></a>适配器模式在 Collections 类中的应用</h2><p>## </p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>短网址系统背后的数据结构和算法</title>
      <link href="2021/03/24/%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>2021/03/24/%E7%9F%AD%E7%BD%91%E5%9D%80%E7%B3%BB%E7%BB%9F%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="短网址服务整体介绍"><a href="#短网址服务整体介绍" class="headerlink" title="短网址服务整体介绍"></a>短网址服务整体介绍</h2><p>刚刚我们讲了，短网址服务的一个核心功能，就是把原始的长网址转化成短网址。除了这个功能之外，短网址服务还有另外一个必不可少的功能。那就是，<strong>当用户点击短网址的时候，短网址服务会将浏览器重定向为原始网址</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/17.png" alt></p><a id="more"></a><h2 id="如何通过哈希算法生成短网址？"><a href="#如何通过哈希算法生成短网址？" class="headerlink" title="如何通过哈希算法生成短网址？"></a>如何通过哈希算法生成短网址？</h2><p>哈希算法可以将一个不管多长的字符串，转化成一个长度固定的哈希值。我们可以利用哈希算法，来生成短网址。前面我们已经提过一些哈希算法了，比如 MD5、SHA 等。但是，实际上，我们并不需要这些复杂的哈希算法。在生成短网址这个问题上，毕竟，我们<strong>不需要考虑反向解密的难度，只需要关心哈希算法的计算速度和冲突概率</strong>。能够满足这样要求的哈希算法有很多，其中比较著名并且应用广泛的一个哈希算法，那就是 <code>MurmurHash 算法</code>。尽管这个哈希算法在 2008 年才被发明出来，但现在它已经广泛应用到 Redis、MemCache、Cassandra、HBase、Lucene 等众多著名的软件中。</p><p>MurmurHash 算法提供了两种长度的哈希值，一种是 32bits，一种是 128bits。为了让最终生成的短网址尽可能短，我们可以选择 32bits 的哈希值。对于开头那个 GitHub 网址，经过 MurmurHash 计算后，得到的哈希值就是 181338494。我们再拼上短网址服务的域名，就变成了最终的短网址：<a href="https://t.cn/181338494" target="_blank" rel="noopener">https://t.cn/181338494</a> 。</p><h3 id="如何让短网址更短？"><a href="#如何让短网址更短？" class="headerlink" title="如何让短网址更短？"></a>如何让短网址更短？</h3><p>我们可以将 10 进制的哈希值，转化成更高进制的哈希值，这样哈希值就变短了。我们知道，16 进制中，我们用 A<del>F，来表示 10</del>15。在网址 URL 中，常用的合法字符有 0<del>9、a</del>z、A~Z 这样 62 个字符。为了让哈希值表示起来尽可能短，我们可以<strong>将 10 进制的哈希值转化成 62 进制</strong>。具体的计算过程，我写在这里了。最终用 62 进制表示的短网址就是 <a href="http://t.cn/cgSqq" target="_blank" rel="noopener">http://t.cn/cgSqq</a> ：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/18.png" alt></p><h3 id="如何解决哈希冲突问题？"><a href="#如何解决哈希冲突问题？" class="headerlink" title="如何解决哈希冲突问题？"></a>如何解决哈希冲突问题？</h3><p>哈希算法无法避免的一个问题，就是哈希冲突。尽管 MurmurHash 算法，冲突的概率非常低。但是，一旦冲突，就会导致两个原始网址被转化成同一个短网址。当用户访问短网址的时候，我们就无从判断，用户想要访问的是哪一个原始网址了。一般情况下，我们会<strong>保存短网址跟原始网址之间的对应关系</strong>，以便后续用户在访问短网址的时候，可以根据对应关系，查找到原始网址。存储这种对应关系的方式有很多，比如我们自己设计存储系统或者利用现成的数据库。假设短网址与原始网址之间的对应关系，存储在 MySQL 数据库中。</p><p>当有一个新的原始网址需要生成短网址的时候，我们先利用 MurmurHash 算法，生成短网址。然后，我们拿这个新生成的短网址，在 MySQL 数据库中查找。如果没有找到相同的短网址，这也就表明，这个新生成的短网址没有冲突。于是我们就将这个短网址返回给用户（请求生成短网址的用户），然后将这个短网址与原始网址之间的对应关系，存储到 MySQL 数据库中。如果我们在数据库中，<strong>找到了相同的短网址，那也并不一定说明就冲突了</strong>。我们从数据库中，将这个短网址对应的原始网址也取出来。如果数据库中的原始网址，跟我们现在正在处理的原始网址是一样的，这就说明已经有人请求过这个原始网址的短网址了。我们就可以拿这个短网址直接用。如果数据库中记录的原始网址，跟我们正在处理的原始网址不一样，那就说明哈希算法发生了冲突 – 不同的原始网址，经过计算，得到的短网址重复了。</p><p>我们可以<strong>给原始网址拼接一串特殊字符，比如“[DUPLICATED]”，然后再重新计算哈希值</strong>，两次哈希计算都冲突的概率，显然是非常低的。假设出现非常极端的情况，又发生冲突了，我们可以再换一个拼接字符串，比如“[OHMYGOD]”，再计算哈希值。然后把计算得到的哈希值，跟原始网址拼接了特殊字符串之后的文本，一并存储在 MySQL 数据库中。当用户访问短网址的时候，短网址服务先通过短网址，在数据库中查找到对应的原始网址。如果原始网址有拼接特殊字符（这个很容易通过字符串匹配算法找到），我们就先将特殊字符去掉，然后再将不包含特殊字符的原始网址返回给浏览器。</p><h3 id="如何优化哈希算法生成短网址的性能？"><a href="#如何优化哈希算法生成短网址的性能？" class="headerlink" title="如何优化哈希算法生成短网址的性能？"></a>如何优化哈希算法生成短网址的性能？</h3><p>为了判断生成的短网址是否冲突，我们需要拿生成的短网址，在数据库中查找。如果数据库中存储的数据非常多，那查找起来就会非常慢，势必影响短网址服务的性能。我们可以给短网址字段添加 B+ 树索引，这样通过短网址查询原始网址的速度就提高了很多。实际上，在真实的软件开发中，我们还可以通过一个小技巧，来进一步提高速度。我们知道，一般情况下，数据库和应用服务（只做计算不存储数据的业务逻辑部分）会部署在两个独立的服务器或者虚拟服务器上。那两条 SQL 语句的执行就需要两次网络通信。这种 <strong>IO 通信耗时以及 SQL 语句的执行，才是整个短网址服务的性能瓶颈所在</strong>。所以，为了提高性能，我们需要尽量减少 SQL 语句。</p><p>我们可以给数据库中的短网址字段，添加一个<code>唯一索引</code>（不只是索引，还要求表中不能有重复的数据）。当有新的原始网址需要生成短网址的时候，我们并不会先拿生成的短网址，在数据库中查找判重，而是<strong>直接将生成的短网址与对应的原始网址，尝试存储到数据库中</strong>。如果数据库能够将数据正常写入，那说明并没有违反唯一索引，也就是说，这个新生成的短网址并没有冲突。当然，如果数据库反馈违反唯一性索引异常，那我们还得重新执行刚刚讲过的“查询、写入”过程，SQL 语句执行的次数不减反增。但是，在大部分情况下，我们把新生成的短网址和对应的原始网址，插入到数据库的时候，并不会出现冲突。所以，<strong>大部分情况下，我们只需要执行一条写入的 SQL 语句</strong>就可以了。所以，从整体上看，总的 SQL 语句执行次数会大大减少。</p><p>实际上，我们还有另外一个优化 SQL 语句次数的方法，那就是借助<code>布隆过滤器</code>。我们把已经生成的短网址，构建成布隆过滤器。我们知道，布隆过滤器是比较节省内存的一种存储结构，长度是 10 亿的布隆过滤器，也只需要 125MB 左右的内存空间。当有新的短网址生成的时候，我们<strong>先拿这个新生成的短网址，在布隆过滤器中查找</strong>。如果查找的结果是不存在，那就说明这个新生成的短网址并没有冲突。这个时候，我们只需要再执行写入短网址和对应原始网页的 SQL 语句就可以了。通过先查询布隆过滤器，总的 SQL 语句的执行次数减少了。</p><h2 id="如何通过-ID-生成器生成短网址？"><a href="#如何通过-ID-生成器生成短网址？" class="headerlink" title="如何通过 ID 生成器生成短网址？"></a>如何通过 ID 生成器生成短网址？</h2><p>我们可以维护一个 ID 自增生成器。它可以生成 1, 2, 3, … 这样自增的整数 ID。当短网址服务接收到一个原始网址转化成短网址的请求之后，它先从 ID 生成器中取一个号码，然后将其转化成 62 进制表示法，拼接到短网址服务的域名后面，就形成了最终的短网址。最后，我们还是会把生成的短网址和对应的原始网址存储到数据库中。</p><h3 id="相同的原始网址可能会对应不同的短网址"><a href="#相同的原始网址可能会对应不同的短网址" class="headerlink" title="相同的原始网址可能会对应不同的短网址"></a>相同的原始网址可能会对应不同的短网址</h3><p>每次新来一个原始网址，我们就生成一个新的短网址，这种做法就会导致两个相同的原始网址生成了不同的短网址。这个该如何处理呢？实际上，我们有两种处理思路：</p><ol><li><strong>不做处理</strong>。实际上，相同的原始网址对应不同的短网址，这个用户是可以接受的。在大部分短网址的应用场景里，用户只关心短网址能否正确地跳转到原始网址。至于短网址长什么样子，他其实根本就不关心。所以，即便是同一个原始网址，两次生成的短网址不一样，也并不会影响到用户的使用；</li><li><strong>借助哈希算法生成短网址的处理思想</strong>。当要给一个原始网址生成短网址的时候，我们要先拿原始网址在数据库中查找，看数据库中是否已经存在相同的原始网址了。如果数据库中存在，那我们就取出对应的短网址，直接返回给用户；</li></ol><p>不过，这种处理思路有个问题，我们<strong>需要给数据库中的短网址和原始网址这两个字段，都添加索引</strong>。短网址上加索引是为了提高用户查询短网址对应的原始网页的速度，原始网址上加索引是为了加快刚刚讲的通过原始网址查询短网址的速度。这种解决思路虽然能满足“相同原始网址对应相同短网址”这样一个需求，但是是有代价的：一方面两个索引会占用更多的存储空间，另一方面索引还会导致插入、删除等操作性能的下降。</p><h3 id="如何实现高性能的-ID-生成器？"><a href="#如何实现高性能的-ID-生成器？" class="headerlink" title="如何实现高性能的 ID 生成器？"></a>如何实现高性能的 ID 生成器？</h3><p>实现 ID 生成器的方法有很多，比如利用数据库自增字段。当然我们也可以自己维护一个计数器，不停地加一加一。但是，一个计数器来应对频繁的短网址生成请求，显然是有点吃力的（因为计数器必须保证生成的 ID 不重复，笼统概念上讲，就是需要加锁）。如何提高 ID 生成器的性能呢？实际上，有很多解决思路，我这里给出两种思路：</p><ol><li>我们可以<strong>给 ID 生成器装多个前置发号器</strong>。我们批量地给每个前置发号器发送 ID 号码，当我们接受到短网址生成请求的时候，就选择一个前置发号器来取号码。这样通过多个前置发号器，明显提高了并发发号的能力：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/19.png" alt></li><li><strong>直接实现多个 ID 生成器同时服务</strong>。为了保证每个 ID 生成器生成的 ID 不重复，我们要求每个 ID 生成器按照一定的规则，来生成 ID 号码。比如，第一个 ID 生成器只能生成尾号为 0 的，第二个只能生成尾号为 1 的，以此类推。这样通过多个 ID 生成器同时工作，也提高了 ID 生成的效率：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/20.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务接口鉴权限流背后的数据结构和算法</title>
      <link href="2021/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>2021/03/23/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%8E%A5%E5%8F%A3%E9%89%B4%E6%9D%83%E9%99%90%E6%B5%81%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>大应用拆分成微服务之后，服务之间的调用关系变得更复杂，平台的整体复杂熵升高，出错的概率、Debug 问题的难度都高了好几个数量级。所以，为了解决这些问题，服务治理便成了微服务的一个技术重点。所谓服务治理，简单点讲，就是管理微服务，保证平台整体正常、平稳地运行。服务治理涉及的内容比较多，比如<strong>鉴权、限流、降级、熔断、监控告警</strong>等等。这些服务治理功能的实现，底层依赖大量的数据结构和算法。</p><h2 id="鉴权背景介绍"><a href="#鉴权背景介绍" class="headerlink" title="鉴权背景介绍"></a>鉴权背景介绍</h2><p>假设我们有一个微服务叫用户服务（User Service）。它提供很多用户相关的接口，比如获取用户信息、注册、登录等，给公司内部的其他应用使用。但是，并不是公司内部所有应用，都可以访问这个用户服务，<strong>也并不是每个有访问权限的应用，都可以访问用户服务的所有接口</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/09.png" alt></p><p>要实现接口鉴权功能，我们需要<strong>事先将应用对接口的访问权限规则设置好</strong>。当某个应用访问其中一个接口的时候，我们就可以拿应用的请求 URL，在规则中进行匹配。如果匹配成功，就说明允许访问；如果没有可以匹配的规则，那就说明这个应用没有这个接口的访问权限，我们就拒绝服务。</p><a id="more"></a><h2 id="如何实现快速鉴权？"><a href="#如何实现快速鉴权？" class="headerlink" title="如何实现快速鉴权？"></a>如何实现快速鉴权？</h2><p>接口的格式有很多，有类似 Dubbo 这样的 RPC 接口，也有类似 Spring Cloud 这样的 HTTP 接口，不同接口的鉴权实现方式是类似的。实际上，不同的规则和匹配模式，对应的数据结构和匹配算法也是不一样的。</p><h3 id="如何实现精确匹配规则？"><a href="#如何实现精确匹配规则？" class="headerlink" title="如何实现精确匹配规则？"></a>如何实现精确匹配规则？</h3><p>我们先来看最简单的一种匹配模式。只有当请求 URL 跟规则中配置的某个接口精确匹配时，这个请求才会被接受、处理:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/10.png" alt></p><p>针对这种匹配模式，我们可以将每个应用对应的权限规则，存储在一个字符串数组中。当用户请求到来时，我们拿用户的请求 URL，在这个字符串数组中逐一匹配，匹配的算法就是 KMP、BM、BF 等。规则不会经常变动，所以，为了加快匹配速度，我们可以<strong>按照字符串的大小给规则排序，把它组织成有序数组这种数据结构</strong>。当要查找某个 URL 能否匹配其中某条规则的时候，我们可以采用<code>二分查找</code>算法，在有序数组中进行匹配。而二分查找算法的时间复杂度是 O(logn)（n 表示规则的个数），这比起时间复杂度是 O(n) 的顺序遍历快了很多。对于规则中接口长度比较长，并且鉴权功能调用量非常大的情况，这种优化方法带来的性能提升还是非常可观的。</p><h3 id="如何实现前缀匹配规则？"><a href="#如何实现前缀匹配规则？" class="headerlink" title="如何实现前缀匹配规则？"></a>如何实现前缀匹配规则？</h3><p>我们再来看一种稍微复杂的匹配模式。只要某条规则可以匹配请求 URL 的前缀，我们就说这条规则能够跟这个请求 URL 匹配：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/11.png" alt></p><p>Trie 树非常适合用来做前缀匹配。所以，针对这个需求，我们可以将每个用户的规则集合，组织成 <code>Trie 树</code>这种数据结构。不过，Trie 树中的<strong>每个节点不是存储单个字符，而是存储接口被“/”分割之后的子目录</strong>。因为规则并不会经常变动，所以，在 Trie 树中，我们可以把每个节点的子节点们，组织成有序数组这种数据结构。在匹配的过程中，我们可以利用二分查找算法，决定从一个节点应该跳到哪一个子节点：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/12.png" alt></p><h3 id="如何实现模糊匹配规则？"><a href="#如何实现模糊匹配规则？" class="headerlink" title="如何实现模糊匹配规则？"></a>如何实现模糊匹配规则？</h3><p>如果我们的规则更加复杂，规则中包含通配符，比如“**”表示匹配任意多个子目录，“*”表示匹配任意一个子目录。只要用户请求 URL 可以跟某条规则模糊匹配，我们就说这条规则适用于这个请求：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/13.png" alt></p><p>实际上，我们可以结合实际情况，挖掘出这样一个隐形的条件，那就是，并不是每条规则都包含通配符，包含通配符的只是少数。于是，我们可以<strong>把不包含通配符的规则和包含通配符的规则分开处理</strong>。我们把不包含通配符的规则，组织成有序数组或者 Trie 树（具体组织成什么结构，视具体的需求而定，是精确匹配，就组织成有序数组，是前缀匹配，就组织成 Trie 树），而这一部分匹配就会非常高效。剩下的是<strong>少数包含通配符的规则，我们只要把它们简单存储在一个数组中</strong>就可以了。尽管匹配起来会比较慢，但是毕竟这种规则比较少，所以这种方法也是可以接受的。当接收到一个请求 URL 之后，我们可以先在不包含通配符的有序数组或者 Trie 树中查找。如果能够匹配，就不需要继续在通配符规则中匹配了；如果不能匹配，就继续在通配符规则中查找匹配。</p><h2 id="限流背景介绍"><a href="#限流背景介绍" class="headerlink" title="限流背景介绍"></a>限流背景介绍</h2><p>所谓限流，顾名思义，就是对接口调用的频率进行限制。比如每秒钟不能超过 100 次调用，超过之后，我们就拒绝服务。限流的原理听起来非常简单，但它在很多场景中，发挥着重要的作用。比如在秒杀、大促、双 11 等场景中，限流已经成为了保证系统平稳运行的一种标配的技术解决方案。按照不同的限流粒度，限流可以分为很多种类型。比如给每个接口限制不同的访问频率，或者给所有接口限制总的访问频率，又或者更细粒度地限制某个应用对某个接口的访问频率等等。</p><h2 id="如何实现精准限流？"><a href="#如何实现精准限流？" class="headerlink" title="如何实现精准限流？"></a>如何实现精准限流？</h2><p>最简单的限流算法叫<strong>固定时间窗口限流算法</strong>。这种算法是如何工作的呢？首先我们需要选定一个时间起点，之后每当有接口请求到来，我们就将计数器加一。如果在当前时间窗口内，根据限流规则（比如每秒钟最大允许 100 次访问请求），出现累加访问次数超过限流值的情况时，我们就拒绝后续的访问请求。当进入下一个时间窗口之后，计数器就清零重新计数：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/14.png" alt></p><p>这种基于固定时间窗口的限流算法的缺点是，限流策略过于粗略，无法应对两个时间窗口临界时间内的突发流量。假设我们的限流规则是，每秒钟不能超过 100 次接口请求。第一个 1s 时间窗口内，100 次接口请求都集中在最后 10ms 内。在第二个 1s 的时间窗口内，100 次接口请求都集中在最开始的 10ms 内。虽然两个时间窗口内流量都符合限流要求（&lt;= 100 个请求），但在两个时间窗口临界的 20ms 内，会集中有 200 次接口请求。固定时间窗口限流算法并不能对这种情况做限制，所以，集中在这 20ms 内的 200 次请求就有可能压垮系统：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/15.png" alt></p><p>为了解决这个问题，我们可以对固定时间窗口限流算法稍加改造。我们可以限制任意时间窗口（比如 1s）内，接口请求数都不能超过某个阈值（ 比如 100 次）。因此，相对于固定时间窗口限流算法，这个算法叫<strong>滑动时间窗口限流算法</strong>。流量经过滑动时间窗口限流算法整形之后，可以保证任意一个 1s 的时间窗口内，都不会超过最大允许的限流值，从流量曲线上来看会更加平滑。我们假设限流的规则是，在任意 1s 内，接口的请求次数都不能大于 K 次。我们就维护一个大小为 K+1 的<code>循环队列</code>，用来记录 1s 内到来的请求。注意，这里循环队列的大小等于限流次数加一，因为<strong>循环队列存储数据时会浪费一个存储单元</strong>。</p><p>当有新的请求到来时，我们将与这个新请求的时间间隔超过 1s 的请求，从队列中删除。然后，我们再来看循环队列中是否有空闲位置。如果有，则把新请求存储在队列尾部（tail 指针所指的位置）；如果没有，则说明这 1 秒内的请求次数已经超过了限流值 K，所以这个请求被拒绝服务：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/16.png" alt></p><p>即便滑动时间窗口限流算法可以保证任意时间窗口内，接口请求次数都不会超过最大限流值，但是仍然不能防止，在细时间粒度上访问过于集中的问题。比如我刚刚举的那个例子，第一个 1s 的时间窗口内，100 次请求都集中在最后 10ms 中，也就是说，基于时间窗口的限流算法，不管是固定时间窗口还是滑动时间窗口，只能在选定的时间粒度上限流，对选定时间粒度内的更加细粒度的访问频率不做限制。实际上，针对这个问题，还有很多更加平滑的限流算法，比如<code>令牌桶算法</code>、<code>漏桶算法</code>等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Disruptor 背后的数据结构和算法</title>
      <link href="2021/03/23/Disruptor-%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>2021/03/23/Disruptor-%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="基于循环队列的生产者-消费者模型"><a href="#基于循环队列的生产者-消费者模型" class="headerlink" title="基于循环队列的生产者-消费者模型"></a>基于循环队列的生产者-消费者模型</h2><p>非循环的顺序队列在添加、删除数据的工程中，会<strong>涉及数据的搬移操作，导致性能变差</strong>。而循环队列正好可以解决这个数据搬移的问题，所以，性能更加好。所以，大部分用到顺序队列的场景中，我们都选择用顺序队列中的循环队列。实际上，循环队列这种数据结构，就是我们今天要讲的内存消息队列的雏形。我借助循环队列，实现了一个最简单的生产者-消费者模型。为了方便你理解，对于生产者和消费者之间操作的同步，我并没有用到线程相关的操作。而是采用了“当队列满了之后，生产者就轮训等待；当队列空了之后，消费者就轮训等待”这样的措施：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Queue</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long[] data;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>, head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Queue</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = <span class="keyword">new</span> Long[size];</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(Long element)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % size == head) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        data[tail] = element;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == tail) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">long</span> ret = data[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % size;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">produce</span><span class="params">(Long data)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!queue.add(data)) &#123;</span><br><span class="line">            Thread.sleep(<span class="number">100</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Queue queue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(Queue queue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.queue = queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">consume</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Long data = queue.poll();</span><br><span class="line">            <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">                Thread.sleep(<span class="number">100</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> 消费数据的业务逻辑</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于加锁的并发生产者-消费者模型"><a href="#基于加锁的并发生产者-消费者模型" class="headerlink" title="基于加锁的并发生产者-消费者模型"></a>基于加锁的并发生产者-消费者模型</h2><p>如果我们只有一个生产者往队列中写数据，一个消费者从队列中读取数据，那上面的代码是没有问题的。但是，如果有多个生产者在并发地往队列中写入数据，或者多个消费者并发地从队列中消费数据，那上面的代码就不能正确工作了。在多个生产者或者多个消费者并发操作队列的情况下，刚刚的代码主要会有下面两个问题：</p><ul><li>多个生产者写入的数据可能会互相覆盖；</li><li>多个消费者可能会读取重复的数据；</li></ul><p>两个线程同时往队列中添加数据，也就相当于两个线程同时执行类 Queue 中的 add() 函数。我们假设队列的大小 size 是 10，当前的 tail 指向下标 7，head 指向下标 3，也就是说，队列中还有空闲空间。这个时候，线程 1 调用 add() 函数，往队列中添加一个值为 12 的数据；线程 2 调用 add() 函数，往队列中添加一个值为 15 的数据。在极端情况下，本来是往队列中添加了两个数据（12 和 15），最终可能只有一个数据添加成功，另一个数据会被覆盖：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/07.png" alt></p><p>那如何解决这种线程并发往队列中添加数据时，导致的数据覆盖、运行不正确问题呢？最简单的处理方法就是给这段代码加锁，同一时间只允许一个线程执行 add() 函数。这就相当于将这段代码的执行，由并行改成了串行，也就不存在我们刚刚说的问题了。不过，天下没有免费的午餐，<strong>加锁将并行改成串行，必然导致多个生产者同时生产数据的时候，执行效率的下降</strong>。当然，我们可以继续优化代码，用 <code>CAS</code>（Compare-And-Swap）操作等减少加锁的粒度。</p><h2 id="基于无锁的并发生产者-消费者模型"><a href="#基于无锁的并发生产者-消费者模型" class="headerlink" title="基于无锁的并发生产者-消费者模型"></a>基于无锁的并发生产者-消费者模型</h2><p>之前的实现思路中，队列只支持两个操作，添加数据和读取并移除数据，分别对应代码中的 add() 函数和 poll() 函数，而 Disruptor 采用了另一种实现思路。对于生产者来说，它往队列中添加数据之前，先申请可用空闲存储单元，并且是批量地申请连续的 n 个（n &gt;= 1）存储单元。当申请到这组连续的存储单元之后，后续往队列中添加元素，就可以不用加锁了，因为这组存储单元是这个线程独享的。不过，从刚刚的描述中，我们可以看出，申请存储单元的过程是需要加锁的。对于消费者来说，处理的过程跟生产者是类似的。它<strong>先去申请一批连续可读的存储单元（这个申请的过程也是需要加锁的），当申请到这批存储单元之后，后续的读取操作就可以不用加锁了</strong>。</p><p>不过，还有一个需要特别注意的地方，那就是，如果生产者 A 申请到了一组连续的存储单元，假设是下标为 3 到 6 的存储单元，生产者 B 紧跟着申请到了下标是 7 到 9 的存储单元，那在 3 到 6 没有完全写入数据之前，7 到 9 的数据是无法读取的。这个也是 Disruptor 实现思路的一个弊端：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/08.png" alt></p><p>实际上，Disruptor 采用的是 RingBuffer 和 AvailableBuffer 这两个结构，来实现我刚刚讲的功能。不过，因为我们主要聚焦在数据结构和算法上，所以我对这两种结构做了简化，但是基本思想是一致的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索引擎背后的数据结构和算法</title>
      <link href="2021/03/23/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>2021/03/23/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E8%83%8C%E5%90%8E%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="整体系统介绍"><a href="#整体系统介绍" class="headerlink" title="整体系统介绍"></a>整体系统介绍</h2><p>搜索引擎大致可以分为四个部分：<strong>搜集、分析、索引、查询</strong>：</p><ol><li>搜集，就是我们常说的利用爬虫爬取网页；</li><li>分析，主要负责网页内容抽取、分词，构建临时索引，计算 PageRank 值这几部分工作；</li><li>索引，主要负责通过分析阶段得到的临时索引，构建倒排索引；</li><li>查询，主要负责响应用户的请求，根据倒排索引获取相关网页，计算网页排名，返回查询结果给用户；</li></ol><h2 id="搜集"><a href="#搜集" class="headerlink" title="搜集"></a>搜集</h2><p>搜索引擎<strong>把整个互联网看作数据结构中的有向图</strong>，把每个页面看作一个顶点。如果某个页面中包含另外一个页面的链接，那我们就在两个顶点之间连一条有向边。我们可以利用图的遍历搜索算法，来遍历整个互联网中的网页。我们前面介绍过两种图的遍历方法，深度优先和广度优先。<strong>搜索引擎采用的是广度优先搜索策略</strong>。具体点讲的话，那就是，我们先找一些比较知名的网页（专业的叫法是权重比较高）的链接（比如新浪主页网址、腾讯主页网址等），作为种子网页链接，放入到队列中。爬虫按照广度优先的策略，不停地从队列中取出链接，然后去爬取对应的网页，解析出网页里包含的其他网页链接，再将解析出来的链接添加到队列中。</p><p>爬虫在爬取网页的过程中，涉及的四个重要的文件。其中，links.bin 和 bloom_filter.bin 这两个文件是爬虫自身所用的；另外的两个 doc_raw.bin 和 doc_id.bin 是作为搜集阶段的成果，供后面的分析、索引、查询用的。</p><h3 id="待爬取网页链接文件：links-bin"><a href="#待爬取网页链接文件：links-bin" class="headerlink" title="待爬取网页链接文件：links.bin"></a>待爬取网页链接文件：links.bin</h3><p>我们可以把整个页面看作一个大的字符串，然后利用字符串匹配算法，在这个大字符串中，搜索这样一个网页标签，然后顺序读取之间的字符串 – 这其实就是网页链接。在广度优先搜索爬取页面的过程中，爬虫会不停地解析页面链接，将其放到队列中。于是，队列中的链接就会越来越多，可能会多到内存放不下。所以，我们用一个存储在磁盘中的文件（links.bin）来作为广度优先搜索中的队列。爬虫从 links.bin 文件中，取出链接去爬取对应的页面。等爬取到网页之后，将解析出来的链接，直接存储到 links.bin 文件中。这样用文件来存储网页链接的方式，还有其他好处。比如，<strong>支持断点续爬</strong>。也就是说，当机器断电之后，网页链接不会丢失；当机器重启之后，还可以从之前爬取到的位置继续爬取。</p><a id="more"></a><h3 id="网页判重文件：bloom-filter-bin"><a href="#网页判重文件：bloom-filter-bin" class="headerlink" title="网页判重文件：bloom_filter.bin"></a>网页判重文件：bloom_filter.bin</h3><p>如果我们把布隆过滤器存储在内存中，那机器宕机重启之后，布隆过滤器就被清空了。这样就可能导致大量已经爬取的网页会被重复爬取。这个问题该怎么解决呢？我们可以<strong>定期地（比如每隔半小时）将布隆过滤器持久化到磁盘中</strong>，存储在 bloom_filter.bin 文件中。这样，即便出现机器宕机，也只会丢失布隆过滤器中的部分数据。当机器重启之后，我们就可以重新读取磁盘中的 bloom_filter.bin 文件，将其恢复到内存中。</p><h3 id="原始网页存储文件：doc-raw-bin"><a href="#原始网页存储文件：doc-raw-bin" class="headerlink" title="原始网页存储文件：doc_raw.bin"></a>原始网页存储文件：doc_raw.bin</h3><p>如果我们把每个网页都存储为一个独立的文件，那磁盘中的文件就会非常多，数量可能会有几千万，甚至上亿。常用的文件系统显然不适合存储如此多的文件。所以，我们可以把多个网页存储在一个文件中。<strong>每个网页之间，通过一定的标识进行分隔，方便后续读取</strong>。具体的存储格式，如下图所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/02.png" alt></p><p>当然，这样的一个文件也不能太大，因为文件系统对文件的大小也有一定的限制。所以，我们可以设置每个文件的大小不能超过一定的值（比如 1GB）。随着越来越多的网页被添加到文件中，文件的大小就会越来越大，<strong>当超过 1GB 的时候，我们就创建一个新的文件</strong>，用来存储新爬取的网页。假设一台机器的硬盘大小是 100GB 左右，一个网页的平均大小是 64KB。那在一台机器上，我们可以存储 100 万到 200 万左右的网页。假设我们的机器的带宽是 10MB，那下载 100GB 的网页，大约需要 10000 秒。也就是说，爬取 100 多万的网页，也就是只需要花费几小时的时间。</p><h3 id="网页链接及其编号的对应文件：doc-id-bin"><a href="#网页链接及其编号的对应文件：doc-id-bin" class="headerlink" title="网页链接及其编号的对应文件：doc_id.bin"></a>网页链接及其编号的对应文件：doc_id.bin</h3><p>我们可以按照网页被爬取的先后顺序，从小到大依次编号。具体是这样做的：我们维护一个中心的计数器，每爬取到一个网页之后，就从计数器中拿一个号码，分配给这个网页，然后计数器加一。在存储网页的同时，我们将<strong>网页链接跟编号之间的对应关系</strong>，存储在另一个 doc_id.bin 文件中。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>网页爬取下来之后，我们需要对网页进行离线分析。分析阶段主要包括两个步骤，第一个是抽取网页文本信息，第二个是分词并创建临时索引。经过分析阶段，我们得到了两个重要的文件，它们分别是临时索引文件（tmp_index.bin）和单词编号文件（term_id.bin）。</p><h3 id="抽取网页文本信息"><a href="#抽取网页文本信息" class="headerlink" title="抽取网页文本信息"></a>抽取网页文本信息</h3><p>网页是半结构化数据，里面夹杂着各种标签、JavaScript 代码、CSS 样式。对于搜索引擎来说，它只关心网页中的文本信息，也就是，网页显示在浏览器中时，能被用户肉眼看到的那部分信息。我们之所以把网页叫作半结构化数据，是因为它本身是按照一定的规则来书写的。这个规则就是 <code>HTML 语法规范</code>。我们依靠 HTML 标签来抽取网页中的文本信息。这个抽取的过程，大体可以分为两步：</p><ol><li>去掉 JavaScript 代码、CSS 格式以及下拉框中的内容。也就是 &lt;style&gt;&lt;/style&gt;, &lt;script&gt;&lt;/script&gt;, &lt;option&gt;&lt;/option&gt; 这三组标签之间的内容。我们可以利用 AC 自动机这种多模式串匹配算法，在网页这个大字符串中，一次性查找 &lt;style&gt;, &lt;script&gt;, &lt;option&gt; 这三个关键词。当找到某个关键词出现的位置之后，我们只需要依次往后遍历，直到对应结束标签（&lt;/style&gt;, &lt;/script&gt;, &lt;/option&gt;）为止，而这期间遍历到的字符串连带着标签就应该从网页中删除；</li><li>去掉所有 HTML 标签。这一步也是通过字符串匹配算法来实现的，过程跟第一步类似；</li></ol><h3 id="分词并创建临时索引"><a href="#分词并创建临时索引" class="headerlink" title="分词并创建临时索引"></a>分词并创建临时索引</h3><p>对于英文网页来说，分词非常简单。我们只需要通过空格、标点符号等分隔符，将每个单词分割开来就可以了。但是，对于中文来说，分词就复杂太多了。我这里介绍一种比较简单的思路，基于字典和规则的分词方法。其中，字典也叫词库，里面包含大量常用的词语（我们可以直接从网上下载别人整理好的）。我们借助词库并采用最长匹配规则，来对文本进行分词。所谓最长匹配，也就是匹配尽可能长的词语。具体到实现层面，我们可以将词库中的单词，构建成 Trie 树结构，然后拿网页文本在 Trie 树中匹配。</p><p>每个网页的文本信息在分词完成之后，我们都得到一组单词列表。我们把<strong>单词与网页之间的对应关系</strong>，写入到一个临时索引文件中（tmp_index.bin），这个临时索引文件用来构建倒排索引文件。临时索引文件的格式如下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/03.png" alt></p><p>在临时索引文件中，我们存储的是单词编号，也就是图中的 term_id，而非单词本身。这样做的目的主要是为了节省存储的空间。单词编号的方式，跟给网页编号类似。我们维护一个计数器，每当从网页文本信息中分割出一个新的单词的时候，我们就从计数器中取一个编号，分配给它，然后计数器加一。在这个过程中，我们<strong>还需要使用散列表，记录已经编过号的单词</strong>。在对网页文本信息分词的过程中，我们拿分割出来的单词，先到散列表中查找，如果找到，那就直接使用已有的编号；如果没有找到，我们再去计数器中拿号码，并且将这个新单词以及编号添加到散列表中。当所有的网页处理（分词及写入临时索引）完成之后，我们再将这个<strong>单词跟编号之间的对应关系</strong>，写入到磁盘文件中，并命名为 term_id.bin。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引阶段主要负责将分析阶段产生的临时索引，构建成倒排索引。<code>倒排索引</code>（Inverted Index）中记录了每个单词以及包含它的网页列表：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/04.png" alt></p><p>解决这个问题的方法有很多。考虑到临时索引文件很大，无法一次性加载到内存中，搜索引擎一般会选择<strong>使用多路归并排序的方法来实现</strong>。我们先对临时索引文件，按照单词编号的大小进行排序。因为临时索引很大，所以一般基于内存的排序算法就没法处理这个问题了。我们可以用之前讲到的归并排序的处理思想，将其分割成多个小文件，先对每个小文件独立排序，最后再合并在一起。当然，实际的软件开发中，我们其实可以直接利用 MapReduce 来处理。临时索引文件排序完成之后，相同的单词就被排列到了一起。我们只需要顺序地遍历排好序的临时索引文件，就能将每个单词对应的网页编号列表找出来，然后把它们存储在倒排索引文件中：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/05.png" alt></p><p>除了倒排文件之外，我们还需要一个文件，来记录每个单词编号在倒排索引文件中的偏移位置。我们把这个文件命名为 term_offset.bin。这个文件的作用是，帮助我们<strong>快速地查找某个单词编号在倒排索引中存储的位置</strong>，进而快速地从倒排索引中读取单词编号对应的网页编号列表：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/06.png" alt></p><p>经过索引阶段的处理，我们得到了两个有价值的文件，它们分别是倒排索引文件（index.bin）和记录单词编号在索引文件中的偏移位置的文件（term_offset.bin）。</p><h2 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h2><p>前面三个阶段的处理，只是为了最后的查询做铺垫。因此，现在我们就要利用之前产生的几个文件，来实现最终的用户搜索功能：</p><ul><li>doc_id.bin：记录网页链接和编号之间的对应关系；</li><li>term_id.bin：记录单词和编号之间的对应关系；</li><li>index.bin：倒排索引文件，记录每个单词编号以及对应包含它的网页编号列表；</li><li>term_offset.bin：记录每个单词编号在倒排索引文件中的偏移位置；</li></ul><p>这四个文件中，除了倒排索引文件（index.bin）比较大之外，其他的都比较小。为了方便快速查找数据，我们<strong>将其他三个文件都加载到内存中，并且组织成散列表这种数据结构</strong>。当用户在搜索框中，输入某个查询文本的时候，我们先对用户输入的文本进行分词处理。假设分词之后，我们得到 k 个单词；我们拿这 k 个单词，去 term_id.bin 对应的散列表中，查找对应的单词编号。经过这个查询之后，我们得到了这 k 个单词对应的单词编号；我们拿这 k 个单词编号，去 term_offset.bin 对应的散列表中，查找每个单词编号在倒排索引文件中的偏移位置。经过这个查询之后，我们得到了 k 个偏移位置；我们拿这 k 个偏移位置，去倒排索引中，查找 k 个单词对应的包含它的网页编号列表。经过这一步查询之后，我们得到了 k 个网页编号列表。</p><p>我们针对这 k 个网页编号列表，统计每个网页编号出现的次数。具体到实现层面，我们可以借助散列表来进行统计。统计得到的结果，我们按照出现次数的多少，从小到大排序。出现次数越多，说明包含越多的用户查询单词（用户输入的搜索文本，经过分词之后的单词）。经过这一系列查询，我们就得到了一组排好序的网页编号。我们拿着网页编号，去 doc_id.bin 文件中查找对应的网页链接，分页显示给用户就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis 常用数据类型对应的数据结构</title>
      <link href="2021/03/23/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>2021/03/23/Redis-%E5%B8%B8%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%AF%B9%E5%BA%94%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="Redis-数据库介绍"><a href="#Redis-数据库介绍" class="headerlink" title="Redis 数据库介绍"></a>Redis 数据库介绍</h2><p>Redis 是一种键值（Key-Value）数据库。相对于关系型数据库（比如 MySQL），Redis 也被叫作<strong>非关系型数据库</strong>。像 MySQL 这样的关系型数据库，表的结构比较复杂，会包含很多字段，可以通过 SQL 语句，来实现非常复杂的查询需求。而 Redis 中只包含“键”和“值”两部分，只能通过“键”来查询“值”。正是因为这样简单的存储结构，也让 Redis 的读写效率非常高；除此之外，Redis 主要是作为内存数据库来使用，也就是说，数据是存储在内存中的。尽管它经常被用作内存数据库，但是，它也支持将数据存储在硬盘中。Redis 中，键的数据类型是字符串，但是<strong>为了丰富数据存储的方式，方便开发者使用，值的数据类型有很多</strong>，常用的数据类型有这样几种，它们分别是字符串、列表、字典、集合、有序集合。</p><a id="more"></a><h2 id="列表（List）"><a href="#列表（List）" class="headerlink" title="列表（List）"></a>列表（List）</h2><p>列表这种数据类型支持存储一组数据。这种数据类型对应两种实现方法，一种是<code>压缩列表</code>（ziplist），另一种是双向循环链表。当列表中存储的数据量比较小的时候，列表就可以采用压缩列表的方式实现。具体需要同时满足下面两个条件：</p><ul><li>列表中保存的单个数据（有可能是字符串类型的）小于 64 字节；</li><li>列表中数据个数少于 512 个；</li></ul><p>压缩列表并不是基础数据结构，而是 Redis 自己设计的一种数据存储结构。它有点儿类似数组，通过一片连续的内存空间，来存储数据。不过，它跟数组不同的一点是，它<strong>允许存储的数据大小不同</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/00.png" alt></p><p>听到“压缩”两个字，直观的反应就是节省内存。之所以说这种存储结构节省内存，是相较于数组的存储思路而言的。我们知道，数组要求每个元素的大小相同，如果我们要存储不同长度的字符串，那我们就需要用最大长度的字符串大小作为元素的大小（假设是 20 个字节）。那当我们存储小于 20 个字节长度的字符串的时候，便会浪费部分存储空间：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/geek/01.png" alt></p><p>压缩列表这种存储结构，一方面比较节省内存，另一方面可以支持不同类型数据的存储。而且，因为数据存储在一片连续的内存空间，<strong>通过键来获取值为列表类型的数据，读取的效率也非常高</strong>。当列表中存储的数据量比较大的时候，也就是不能同时满足刚刚讲的两个条件的时候，列表就要通过<code>双向循环链表</code>来实现了。Redis 的这种双向链表的实现方式，非常值得借鉴。它<strong>额外定义一个 list 结构体，来组织链表的首、尾指针，还有长度等信息</strong>。这样，在使用的时候就会非常方便：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 以下是 C 语言代码，因为 Redis 是用 C 语言实现的</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">listnode</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">prev</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">listNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="keyword">void</span> *value;</span><br><span class="line">&#125; listNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list</span> &#123;</span></span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> len;</span><br><span class="line">    <span class="comment">// ....省略其他定义</span></span><br><span class="line">&#125; <span class="built_in">list</span>;</span><br></pre></td></tr></table></figure><h2 id="字典（Hash）"><a href="#字典（Hash）" class="headerlink" title="字典（Hash）"></a>字典（Hash）</h2><p>字典类型用来存储一组数据对，每个数据对又包含键值两部分。字典类型也有两种实现方式，一种是我们刚刚讲到的压缩列表，另一种是<code>散列表</code>。同样，只有当存储的数据量比较小的情况下，Redis 才使用压缩列表来实现字典类型。具体需要满足两个条件：</p><ul><li>字典中保存的键和值的大小都要小于 64 字节；</li><li>字典中键值对的个数要小于 512 个；</li></ul><p>当不能同时满足上面两个条件的时候，Redis 就使用散列表来实现字典类型。Redis 使用 <code>MurmurHash</code> 这种运行速度快、随机性好的哈希算法作为哈希函数。对于哈希冲突问题，Redis 使用链表法来解决。除此之外，Redis 还支持散列表的动态扩容、缩容。当数据动态增加之后，散列表的装载因子会不停地变大。为了避免散列表性能的下降，当装载因子大于 1 的时候，Redis 会触发扩容，将散列表扩大为原来大小的 2 倍左右；当数据动态减少之后，为了节省内存，当装载因子小于 0.1 的时候，Redis 就会触发缩容，缩小为字典中数据个数的大约 2 倍大小。</p><p>扩容缩容要做大量的数据搬移和哈希值的重新计算，所以比较耗时。针对这个问题，Redis <strong>使用渐进式扩容缩容策略，将数据的搬移分批进行</strong>，避免了大量数据一次性搬移导致的服务停顿。</p><h2 id="集合（Set）"><a href="#集合（Set）" class="headerlink" title="集合（Set）"></a>集合（Set）</h2><p>集合这种数据类型用来存储一组不重复的数据。这种数据类型也有两种实现方法，一种是基于<code>有序数组</code>，另一种是基于散列表。当要存储的数据，同时满足下面这样两个条件的时候，Redis 就采用有序数组，来实现集合这种数据类型：</p><ul><li>存储的数据都是整数；</li><li>存储的数据元素个数不超过 512 个；</li></ul><p>当不能同时满足这两个条件的时候，Redis 就使用散列表来存储集合中的数据。</p><h2 id="有序集合（Sorted-Set）"><a href="#有序集合（Sorted-Set）" class="headerlink" title="有序集合（Sorted Set）"></a>有序集合（Sorted Set）</h2><p>有序集合用来存储一组数据，并且每个数据会附带一个得分。通过得分的大小，我们将数据组织成跳表这样的数据结构，以支持快速地按照得分值、得分区间获取数据。实际上，跟 Redis 的其他数据类型一样，有序集合也并不仅仅只有跳表这一种实现方式。<strong>当数据量比较小的时候，Redis 会用压缩列表来实现有序集合</strong>。具体点说就是，使用压缩列表来实现有序集合的前提，有这样两个：</p><ul><li>所有数据的大小都要小于 64 字节；</li><li>元素个数要小于 128 个；</li></ul><h2 id="数据结构持久化"><a href="#数据结构持久化" class="headerlink" title="数据结构持久化"></a>数据结构持久化</h2><p>尽管 Redis 经常会被用作内存数据库，但是，它也支持数据落盘，也就是将内存中的数据存储到硬盘中。这样，当机器断电的时候，存储在 Redis 中的数据也不会丢失。在机器重新启动之后，Redis 只需要再将存储在硬盘中的数据，重新读取到内存，就可以继续工作了。Redis 的数据格式由“键”和“值”两部分组成，而“值”又支持很多数据类型，比如字符串、列表、字典、集合、有序集合。像字典、集合等类型，底层用到了散列表，散列表中有指针的概念，而指针指向的是内存中的存储地址。 那 Redis 是<strong>如何将这样一个跟具体内存地址有关的数据结构存储到磁盘中</strong>的呢？</p><p>实际上，Redis 遇到的这个问题并不特殊，很多场景中都会遇到。我们把它叫作<strong>数据结构的持久化问题</strong>，或者对象的持久化问题。这里的“持久化”，你可以笼统地理解为“存储到磁盘”。我们主要有两种解决思路：</p><ol><li><strong>清除原有的存储结构，只将数据存储到磁盘中</strong>。当我们需要从磁盘还原数据到内存的时候，再重新将数据组织成原来的数据结构。实际上，Redis 采用的就是这种持久化思路。不过，这种方式也有一定的弊端。那就是数据从硬盘还原到内存的过程，会耗用比较多的时间。比如，我们现在要将散列表中的数据存储到磁盘。当我们从磁盘中，取出数据重新构建散列表的时候，需要重新计算每个数据的哈希值。如果磁盘中存储的是几 GB 的数据，那重构数据结构的耗时就不可忽视了；</li><li><strong>保留原来的存储格式，将数据按照原有的格式存储在磁盘中</strong>。我们拿散列表这样的数据结构来举例。我们可以将散列表的大小、每个数据被散列到的槽的编号等信息，都保存在磁盘中。有了这些信息，我们从磁盘中将数据还原到内存中的时候，就可以避免重新计算哈希值；</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decision Making</title>
      <link href="2021/03/01/Decision-Making/"/>
      <url>2021/03/01/Decision-Making/</url>
      
        <content type="html"><![CDATA[<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>Given a set of values find an answer with an option to choose or ignore the current value.</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>If you decide to choose the current value use the previous result where the value was ignored; vice versa, if you decide to ignore the current value use previous result where value was used:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// i: indexing a set of values</span></span><br><span class="line"><span class="comment">// j: options to ignore j values</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; ++j) &#123;</span><br><span class="line">        dp[i][j] = max(&#123;dp[i][j], dp[i<span class="number">-1</span>][j] + arr[i], dp[i<span class="number">-1</span>][j<span class="number">-1</span>]&#125;);</span><br><span class="line">        dp[i][j<span class="number">-1</span>] = max(&#123;dp[i][j<span class="number">-1</span>], dp[i<span class="number">-1</span>][j<span class="number">-1</span>] + arr[i], arr[i]&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/house-robber/" target="_blank" rel="noopener">House Robber</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock with Transaction Fee</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock with Cooldown</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock III</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock IV</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dynamic Programming on Strings</title>
      <link href="2021/03/01/Dynamic-Programming-on-Strings/"/>
      <url>2021/03/01/Dynamic-Programming-on-Strings/</url>
      
        <content type="html"><![CDATA[<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>Given two strings <code>s1</code> and <code>s2</code>, return some result.</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>Most of the problems on this pattern requires a solution that can be accepted in O(n^2) complexity:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= m; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>]) &#123;</span><br><span class="line">            dp[i][j] = <span class="comment">/* code */</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="comment">/* code */</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>If you are given one string <code>s</code> the approach may little vary:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; n; ++l) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - l + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == s[j]) &#123;</span><br><span class="line">            dp[i][j] = <span class="comment">/* code */</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            dp[i][j] = <span class="comment">/* code */</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/longest-common-subsequence/" target="_blank" rel="noopener">Longest Common Subsequence</a><br><a href="https://leetcode.com/problems/palindromic-substrings/" target="_blank" rel="noopener">Palindromic Substrings</a><br><a href="https://leetcode.com/problems/longest-palindromic-subsequence/" target="_blank" rel="noopener">Longest Palindromic Subsequence</a><br><a href="https://leetcode.com/problems/shortest-common-supersequence/" target="_blank" rel="noopener">Shortest Common Supersequence</a><br><a href="https://leetcode.com/problems/edit-distance/" target="_blank" rel="noopener">Edit Distance</a><br><a href="https://leetcode.com/problems/distinct-subsequences/" target="_blank" rel="noopener">Distinct Subsequences</a><br><a href="https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/" target="_blank" rel="noopener">Minimum ASCII Delete Sum for Two Strings</a><br><a href="https://leetcode.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener">Longest Palindromic Substring</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merging Intervals</title>
      <link href="2021/03/01/Merging-Intervals/"/>
      <url>2021/03/01/Merging-Intervals/</url>
      
        <content type="html"><![CDATA[<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>Given a set of numbers find an optimal solution for a problem considering the current number and the best you can get from the left and right sides.</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>Find all optimal solutions for every interval and return the best possible answer:</p><blockquote><p>dp[i][j] = dp[i][k] + result[k] + dp[k+1][j]</p></blockquote><p>Get the best from the left and right sides and add a solution for the current position:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">1</span>; l &lt; n; ++l) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - l + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> j = i + l - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt; j; ++k) &#123;</span><br><span class="line">            dp[i][j] = max(dp[i][j], dp[i][k] + result[k] + dp[k+<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[<span class="number">0</span>][n<span class="number">-1</span>];</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/minimum-cost-tree-from-leaf-values/" target="_blank" rel="noopener">Minimum Cost Tree From Leaf Values</a><br><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">Unique Binary Search Trees</a><br><a href="https://leetcode.com/problems/minimum-score-triangulation-of-polygon/" target="_blank" rel="noopener">Minimum Score Triangulation of Polygon</a><br><a href="https://leetcode.com/problems/remove-boxes/" target="_blank" rel="noopener">Remove Boxes</a><br><a href="https://leetcode.com/problems/minimum-cost-to-merge-stones/" target="_blank" rel="noopener">Minimum Cost to Merge Stones</a><br><a href="https://leetcode.com/problems/burst-balloons/" target="_blank" rel="noopener">Burst Balloons</a><br><a href="https://leetcode.com/problems/guess-number-higher-or-lower-ii/" target="_blank" rel="noopener">Guess Number Higher or Lower II</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Distinct Ways</title>
      <link href="2021/03/01/Distinct-Ways/"/>
      <url>2021/03/01/Distinct-Ways/</url>
      
        <content type="html"><![CDATA[<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>Given a target find a number of distinct ways to reach the target.</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>Sum all possible ways to reach the current state:</p><blockquote><p>routes[i] = routes[i-1] + routes[i-2] + … + routes[i-k]</p></blockquote><p>Generate sum for all values in the target and return the value for the target:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways.size(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ways[j] &lt;= i) &#123;</span><br><span class="line">            dp[i] += dp[i-ways[j]];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[target];</span><br></pre></td></tr></table></figure><p><strong>Note</strong>:</p><blockquote><p>Some questions point out the number of repetitions, in that case, add one more loop to simulate every repetition.</p></blockquote><a id="more"></a><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a><br><a href="https://leetcode.com/problems/unique-paths/" target="_blank" rel="noopener">Unique Paths</a><br><a href="https://leetcode.com/problems/number-of-dice-rolls-with-target-sum/" target="_blank" rel="noopener">Number of Dice Rolls With Target Sum</a><br><a href="https://leetcode.com/problems/knight-probability-in-chessboard/" target="_blank" rel="noopener">Knight Probability in Chessboard</a><br><a href="https://leetcode.com/problems/target-sum/" target="_blank" rel="noopener">Target Sum</a><br><a href="https://leetcode.com/problems/combination-sum-iv/" target="_blank" rel="noopener">Combination Sum IV</a><br><a href="https://leetcode.com/problems/knight-dialer/" target="_blank" rel="noopener">Knight Dialer</a><br><a href="https://leetcode.com/problems/dice-roll-simulation/" target="_blank" rel="noopener">Dice Roll Simulation</a><br><a href="https://leetcode.com/problems/partition-equal-subset-sum/" target="_blank" rel="noopener">Partition Equal Subset Sum</a><br><a href="https://leetcode.com/problems/soup-servings/" target="_blank" rel="noopener">Soup Servings</a><br><a href="https://leetcode.com/problems/domino-and-tromino-tiling/" target="_blank" rel="noopener">Domino and Tromino Tiling</a><br><a href="https://leetcode.com/problems/minimum-swaps-to-make-sequences-increasing/" target="_blank" rel="noopener">Minimum Swaps To Make Sequences Increasing</a><br><a href="https://leetcode.com/problems/number-of-longest-increasing-subsequence/" target="_blank" rel="noopener">Number of Longest Increasing Subsequence</a><br><a href="https://leetcode.com/problems/unique-paths-ii/" target="_blank" rel="noopener">Unique Paths II</a><br><a href="https://leetcode.com/problems/out-of-boundary-paths/" target="_blank" rel="noopener">Out of Boundary Paths</a><br><a href="https://leetcode.com/problems/number-of-ways-to-stay-in-the-same-place-after-some-steps/" target="_blank" rel="noopener">Number of Ways to Stay in the Same Place After Some Steps</a><br><a href="https://leetcode.com/problems/count-vowels-permutation/" target="_blank" rel="noopener">Count Vowels Permutation</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Min/Max Path to Reach a Target</title>
      <link href="2021/03/01/Min-Max-Path-to-Reach-a-Target/"/>
      <url>2021/03/01/Min-Max-Path-to-Reach-a-Target/</url>
      
        <content type="html"><![CDATA[<h2 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h2><p>Given a target find minimum (maximum) cost/path/sum to reach the target.</p><h2 id="Approach"><a href="#Approach" class="headerlink" title="Approach"></a>Approach</h2><p>Choose minimum (maximum) path among all possible paths before the current state, then add value for the current state:</p><blockquote><p>routes[i] = min(routes[i-1], routes[i-2], …, routes[i-k]) + cost[i]</p></blockquote><p>Generate optimal solutions for all values in the target and return the value for the target:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= target; ++i) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; ways.size(); ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ways[j] &lt;= i) &#123;</span><br><span class="line">            dp[i] = min(dp[i], dp[i-ways[j]] + cost/path/sum);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[target];</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/min-cost-climbing-stairs/" target="_blank" rel="noopener">Min Cost Climbing Stairs</a><br><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">Minimum Path Sum</a><br><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Coin Change</a><br><a href="https://leetcode.com/problems/minimum-falling-path-sum/" target="_blank" rel="noopener">Minimum Falling Path Sum</a><br><a href="https://leetcode.com/problems/minimum-cost-for-tickets/" target="_blank" rel="noopener">Minimum Cost For Tickets</a><br><a href="https://leetcode.com/problems/2-keys-keyboard/" target="_blank" rel="noopener">2 Keys Keyboard</a><br><a href="https://leetcode.com/problems/perfect-squares/" target="_blank" rel="noopener">Perfect Squares</a><br><a href="https://leetcode.com/problems/last-stone-weight-ii/" target="_blank" rel="noopener">Last Stone Weight II</a><br><a href="https://leetcode.com/problems/triangle/" target="_blank" rel="noopener">Triangle</a><br><a href="https://leetcode.com/problems/ones-and-zeroes/" target="_blank" rel="noopener">Ones and Zeroes</a><br><a href="https://leetcode.com/problems/maximal-square/" target="_blank" rel="noopener">Maximal Square</a><br><a href="https://leetcode.com/problems/tiling-a-rectangle-with-the-fewest-squares/" target="_blank" rel="noopener">Tiling a Rectangle with the Fewest Squares</a><br><a href="https://leetcode.com/problems/dungeon-game/" target="_blank" rel="noopener">Dungeon Game</a><br><a href="https://leetcode.com/problems/minimum-number-of-refueling-stops/" target="_blank" rel="noopener">Minimum Number of Refueling Stops</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Additional Resources</title>
      <link href="2021/02/28/Additional-Resources/"/>
      <url>2021/02/28/Additional-Resources/</url>
      
        <content type="html"><![CDATA[<p>Here are some useful links for further reading:</p><ul><li><a href="https://www.allthingsdistributed.com/files/amazon-dynamo-sosp2007.pdf" target="_blank" rel="noopener">Dynamo</a> - Highly available key-value store;</li><li><a href="http://notes.stephenholiday.com/Kafka.pdf" target="_blank" rel="noopener">Kafka</a> - A distributed messaging system for log processing;</li><li><a href="https://www.akamai.com/es/es/multimedia/documents/technical-publication/consistent-hashing-and-random-trees-distributed-caching-protocols-for-relieving-hot-spots-on-the-world-wide-web-technical-publication.pdf" target="_blank" rel="noopener">Consistent Hashing</a> - Original paper;</li><li><a href="https://www.microsoft.com/en-us/research/uploads/prod/2016/12/paxos-simple-Copy.pdf" target="_blank" rel="noopener">Paxos</a> - Protocol for distributed consensus;</li><li><a href="http://sites.fas.harvard.edu/~cs265/papers/kung-1981.pdf" target="_blank" rel="noopener">Concurrency Controls</a> -<br>Optimistic methods for concurrency controls;</li><li><a href="http://highscalability.com/blog/2011/11/14/using-gossip-protocols-for-failure-detection-monitoring-mess.html" target="_blank" rel="noopener">Gossip Protocol</a> - For failure detection and more;</li><li><a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/chubby-osdi06.pdf" target="_blank" rel="noopener">Chubby</a> - Lock service for loosely-coupled distributed systems;</li><li><a href="https://www.usenix.org/legacy/event/usenix10/tech/full_papers/Hunt.pdf" target="_blank" rel="noopener">ZooKeeper</a> - Wait-free coordination for Internet-scale systems;</li><li><a href="https://static.googleusercontent.com/media/research.google.com/en//archive/mapreduce-osdi04.pdf" target="_blank" rel="noopener">MapReduce</a> - Simplified data processing on large clusters;</li><li><a href="https://storageconference.us/2010/Papers/MSST/Shvachko.pdf" target="_blank" rel="noopener">Hadoop</a> - A distributed file system;</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Ticketmaster</title>
      <link href="2021/02/28/Designing-Ticketmaster/"/>
      <url>2021/02/28/Designing-Ticketmaster/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-an-Online-Movie-Ticket-Booking-System"><a href="#What-is-an-Online-Movie-Ticket-Booking-System" class="headerlink" title="What is an Online Movie Ticket Booking System?"></a>What is an Online Movie Ticket Booking System?</h2><p>A movie ticket booking system provides its customers the ability to purchase theatre seats online. E-ticketing systems allow the customers to browse through movies currently being played and to book seats, anywhere anytime.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>Our ticket booking service should meet the following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Our ticket booking service should be able to list different cities where its affiliate cinemas are located;</li><li>Once the user selects the city, the service should display the movies released in that particular city;</li><li>Once the user selects a movie, the service should display the cinemas running that movie and its available showtimes;</li><li>The user should be able to choose a show at a particular cinema and book their tickets;</li><li>The service should be able to show the user the seating arrangement of the cinema hall. The user should be able to select multiple seats according to their preference;</li><li>The user should be able to distinguish available seats from booked ones;</li><li>Users should be able to put a hold on the seats for five minutes before they make a payment to finalize the booking;</li><li>The user should be able to wait if there is a chance that the seats might become available, e.g., when holds by other users expire;</li><li>Waiting customers should be serviced in a fair, first come, first serve manner;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>The system would need to be highly concurrent. There will be multiple booking requests for the same seat at any particular point in time. The service should handle this gracefully and fairly;</li><li>The core thing of the service is ticket booking, which means financial transactions. This means that the system should be secure and the database ACID compliant;</li></ol><a id="more"></a><h2 id="Some-Design-Considerations"><a href="#Some-Design-Considerations" class="headerlink" title="Some Design Considerations"></a>Some Design Considerations</h2><ol><li>For simplicity, let’s assume our service does not require any user authentication;</li><li>The system will not handle partial ticket orders. Either user gets all the tickets they want or they get nothing;</li><li>Fairness is mandatory for the system;</li><li>To stop system abuse, we can restrict users from booking more than ten seats at a time;</li><li>We can assume that traffic would spike on popular/much-awaited movie releases and the seats would fill up pretty fast. The system should be scalable and highly available to keep up with the surge in traffic;</li></ol><h2 id="Capacity-Estimation"><a href="#Capacity-Estimation" class="headerlink" title="Capacity Estimation"></a>Capacity Estimation</h2><p><strong>Traffic estimates</strong>: Let’s assume that our service has 3 billion page views per month and sells 10 million tickets a month;<br><strong>Storage estimates</strong>: Let’s assume that we have 500 cities and, on average each city has ten cinemas. If there are 2000 seats in each cinema and on average, there are two shows every day.<br>Let’s assume each seat booking needs 50 bytes (IDs, NumberOfSeats, ShowID, MovieID, SeatNumbers, SeatStatus, Timestamp, etc.) to store in the database. We would also need to store information about movies and cinemas; let’s assume it’ll take 50 bytes. So, to store all the data about all shows of all cinemas of all cities for a day:</p><blockquote><p>500 cities * 10 cinemas * 2000 seats * 2 shows * (50 + 50) bytes = 2 GB/day</p></blockquote><p>To store five years of this data, we would need around 3.6TB.</p><h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><p>We can have SOAP or REST APIs to expose the functionality of our service. The following could be the definition of the APIs to search movie shows and reserve seats:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchMovies(api_dev_key, keyword, city, lat_long, radius, start_datetime, end_datetime, postal_code, includeSpellcheck, results_per_page, sorting_order)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ol><li>api_dev_key: The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota;</li><li>keyword: Keyword to search on;</li><li>city: City to filter movies by;</li><li>lat_long: Latitude and longitude to filter by;</li><li>radius: Radius of the area in which we want to search for events;</li><li>start_datetime: Filter movies with a starting datetime;</li><li>end_datetime: Filter movies with an ending datetime;</li><li>postal_code: Filter movies by postal code/ZIP code;</li><li>include_spell_check: Yes, to include spell check suggestions in the response;</li><li>results_per_page: Number of results to return per page. Maximum is 30;</li><li>sorting_order: Sorting order of the search result. Some allowable values: “name, asc”, “name, desc”, “date, asc”, “date, desc”, “distance, asc”, etc.;</li></ol><p><strong>Returns</strong>: Here is a sample list of movies and their shows:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"MovieID"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"ShowID"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"Title"</span>: <span class="string">"Cars 2"</span>,</span><br><span class="line">        <span class="attr">"Description"</span>: <span class="string">"About cars."</span>,</span><br><span class="line">        <span class="attr">"Duration"</span>: <span class="number">120</span>,</span><br><span class="line">        <span class="attr">"Genre"</span>: <span class="string">"Animation"</span>,</span><br><span class="line">        <span class="attr">"Language"</span>: <span class="string">"English"</span>,</span><br><span class="line">        <span class="attr">"ReleaseDate"</span>: <span class="string">"8th Oct. 2014"</span>,</span><br><span class="line">        <span class="attr">"Country"</span>: <span class="string">"USA"</span>,</span><br><span class="line">        <span class="attr">"StartTime"</span>: <span class="string">"14:00"</span>,</span><br><span class="line">        <span class="attr">"EndTime"</span>: <span class="string">"16:00"</span>,</span><br><span class="line">        <span class="attr">"Seats"</span>: </span><br><span class="line">        [</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="attr">"Type"</span>: <span class="string">"Regular"</span>,</span><br><span class="line">                <span class="attr">"Price"</span>: <span class="number">14.99</span>,</span><br><span class="line">                <span class="attr">"Status"</span>: <span class="string">"Almost Full"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="attr">"Type"</span>: <span class="string">"Premium"</span>,</span><br><span class="line">                <span class="attr">"Price"</span>: <span class="number">24.99</span>,</span><br><span class="line">                <span class="attr">"Status"</span>: <span class="string">"Available"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">"MovieID"</span>: <span class="number">1</span>,</span><br><span class="line">        <span class="attr">"ShowID"</span>: <span class="number">2</span>,</span><br><span class="line">        <span class="attr">"Title"</span>: <span class="string">"Cars 2"</span>,</span><br><span class="line">        <span class="attr">"Description"</span>: <span class="string">"About cars."</span>,</span><br><span class="line">        <span class="attr">"Duration"</span>: <span class="number">120</span>,</span><br><span class="line">        <span class="attr">"Genre"</span>: <span class="string">"Animation"</span>,</span><br><span class="line">        <span class="attr">"Language"</span>: <span class="string">"English"</span>,</span><br><span class="line">        <span class="attr">"ReleaseDate"</span>: <span class="string">"8th Oct. 2014"</span>,</span><br><span class="line">        <span class="attr">"Country"</span>: <span class="string">"USA"</span>,</span><br><span class="line">        <span class="attr">"StartTime"</span>: <span class="string">"16:30"</span>,</span><br><span class="line">        <span class="attr">"EndTime"</span>: <span class="string">"18:30"</span>,</span><br><span class="line">        <span class="attr">"Seats"</span>: </span><br><span class="line">        [</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="attr">"Type"</span>: <span class="string">"Regular"</span>,</span><br><span class="line">                <span class="attr">"Price"</span>: <span class="number">14.99</span>,</span><br><span class="line">                <span class="attr">"Status"</span>: <span class="string">"Full"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;  </span><br><span class="line">                <span class="attr">"Type"</span>: <span class="string">"Premium"</span>,</span><br><span class="line">                <span class="attr">"Price"</span>: <span class="number">24.99</span>,</span><br><span class="line">                <span class="attr">"Status"</span>: <span class="string">"Almost Full"</span></span><br><span class="line">            &#125;</span><br><span class="line">        ]</span><br><span class="line">    &#125;,</span><br><span class="line"> ]</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reserveSeats(api_dev_key, session_id, movie_id, show_id, seats_to_reserve[])</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: Same as above;</li><li>session_id: User’s session ID to track this reservation. Once the reservation time expires, user’s reservation on the server will be removed using this ID;</li><li>movie_id: Movie to reserve;</li><li>show_id: Show to reserve;</li><li>seats_to_reserve: An array containing seat IDs to reserve;</li></ul><p><strong>Returns</strong>: Returns the status of the reservation, which would be one of the following:</p><ol><li>“Reservation Successful”;</li><li>“Reservation Failed - Show Full”;</li><li>“Reservation Failed - Retry, as other users are holding reserved seats”;</li></ol><h2 id="Database-Design"><a href="#Database-Design" class="headerlink" title="Database Design"></a>Database Design</h2><p>Here are a few observations about the data we are going to store:</p><ol><li>Each City can have multiple Cinemas;</li><li>Each Cinema will have multiple Halls;</li><li>Each Movie will have many Shows and each Show will have multiple Bookings;</li><li>A User can have multiple Bookings;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/66.png" alt></p><h2 id="High-Level-Design"><a href="#High-Level-Design" class="headerlink" title="High-Level Design"></a>High-Level Design</h2><p>At a high level, our web servers will manage users’ sessions and application servers will handle all the ticket management, storing data in the databases as well as working with the cache servers to process reservations:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/67.png" alt></p><h2 id="Detailed-Component-Design"><a href="#Detailed-Component-Design" class="headerlink" title="Detailed Component Design"></a>Detailed Component Design</h2><p>First, let’s try to build our service assuming it is being served from a single server.</p><p><strong>Ticket Booking Workflow</strong>: The following would be a typical ticket booking workflow:</p><ol><li>The user searches for a movie;</li><li>The user selects a movie;</li><li>The user is shown the available shows of the movie;</li><li>The user selects a show;</li><li>The user selects the number of seats to be reserved;</li><li>If the required number of seats are available, the user is shown a map of the theater to select seats. If not, the user is taken to “step 8” below;</li><li>Once the user selects the seat, the system will try to reserve those selected seats;</li><li>If seats can’t be reserved, we have the following options:<ul><li>Show is full; the user is shown the error message;</li><li>The seats the user wants to reserve are no longer available, but there are other seats available, so the user is taken back to the theater map to choose different seats;</li><li>There are no seats available to reserve, but all the seats are not booked yet, as there are some seats that other users are holding in the reservation pool and have not booked yet. The user will be taken to a waiting page where they can wait until the required seats get freed from the reservation pool. This waiting could result in the following options:<ul><li>If the required number of seats become available, the user is taken to the theater map page where they can choose seats;</li><li>While waiting, if all seats get booked or there are fewer seats in the reservation pool than the user intends to book, the user is shown the error message;</li><li>User cancels the waiting and is taken back to the movie search page;</li><li>At maximum, a user can wait one hour, after that user’s session gets expired and the user is taken back to the movie search page;</li></ul></li></ul></li><li>If seats are reserved successfully, the user has five minutes to pay for the reservation. After payment, the booking is marked complete. If the user is not able to pay within five minutes, all their reserved seats are freed to become available to other users;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/68.png" alt></p><p>We need two daemon services, one to keep track of all active reservations and remove any expired reservation from the system; let’s call it <code>ActiveReservationService</code>. The other service would be keeping track of all the waiting user requests and, as soon as the required number of seats become available, it will notify the (the longest waiting) user to choose the seats; let’s call it <code>WaitingUserService</code>.</p><h3 id="ActiveReservationsService"><a href="#ActiveReservationsService" class="headerlink" title="ActiveReservationsService"></a>ActiveReservationsService</h3><p>We can keep all the reservations of a “show” in memory in a data structure similar to LinkedHashMap or a TreeMap in addition to keeping all the data in the database. We will need a LinkedHashMap kind of data structure that allows us to jump to any reservation to remove it when the booking is complete. Also, since we will have expiry time associated with each reservation, the head of the HashMap will always point to the oldest reservation record so that the reservation can be expired when the timeout is reached.<br>To store every reservation for every show, we can have a HashTable where the “key” would be “ShowID”, and the “value” would be the LinkedHashMap containing “BookingID” and creation “Timestamp”:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Show ID: LinkedHashMap&lt;BookingID, TimeStamp&gt;</span><br><span class="line"><span class="number">123</span>    : &#123;(<span class="number">1</span>, <span class="number">1499818500</span>), (<span class="number">2</span>, <span class="number">1499818700</span>), (<span class="number">3</span>, <span class="number">1499818800</span>)&#125;</span><br></pre></td></tr></table></figure><p>In the database, we will store the reservation in the Booking table and the expiry time will be in the Timestamp column. The Status field will have a value of “Reserved (1)” and, as soon as a booking is complete, the system will update the Status to “Booked (2)” and remove the reservation record from the LinkedHashMap of the relevant show. When the reservation is expired, we can either remove it from the Booking table or mark it “Expired (3)” in addition to removing it from memory.<br>ActiveReservationsService will also work with the external financial service to process user payments. Whenever a booking is completed, or a reservation gets expired, WaitingUsersService will get a signal so that any waiting customer can be served.</p><h3 id="WaitingUsersService"><a href="#WaitingUsersService" class="headerlink" title="WaitingUsersService"></a>WaitingUsersService</h3><p>Just like ActiveReservationsService, we can keep all the waiting users of a show in memory in a LinkedHashMap or a TreeMap. We need a data structure similar to LinkedHashMap so that we can jump to any user to remove them from the HashMap when the user cancels their request. Also, since we are serving in a first-come-first-serve manner, the head of the LinkedHashMap would always be pointing to the longest waiting user, so that whenever seats become available, we can serve users in a fair manner.<br>We will have a HashTable to store all the waiting users for every Show. The “key” would be “ShowID”, and the “value” would be a LinkedHashMap containing ‘UserIDs’ and their wait-start-time.<br>Clients can use Long Polling for keeping themselves updated for their reservation status. Whenever seats become available, the server can use this request to notify the user.</p><p><strong>Reservation Expiration</strong>: On the server, ActiveReservationsService keeps track of expiry (based on reservation time) of active reservations. As the client will be shown a timer (for the expiration time), which could be a little out of sync with the server, we can add a buffer of five seconds on the server to safeguard from a broken experience, such that the client never times out after the server, preventing a successful purchase.</p><h2 id="Concurrency"><a href="#Concurrency" class="headerlink" title="Concurrency"></a>Concurrency</h2><p><strong>How to handle concurrency, such that no two users are able to book the same seat</strong>. We can use transactions in SQL databases to avoid any clashes. For example, if we are using an SQL server we can utilize Transaction Isolation Levels to lock the rows before we can update them. Here is the sample code:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> <span class="keyword">TRANSACTION</span> <span class="keyword">ISOLATION</span> <span class="keyword">LEVEL</span> <span class="keyword">SERIALIZABLE</span>;</span><br><span class="line"><span class="keyword">BEGIN</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line">    <span class="comment">-- suppose we intend to reserve three seats (IDs: 54, 55, 56) for ShowID=99 </span></span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Show_Seat <span class="keyword">WHERE</span> ShowID=<span class="number">99</span> &amp;&amp; ShowSeatID <span class="keyword">in</span> (<span class="number">54</span>, <span class="number">55</span>, <span class="number">56</span>) &amp;&amp; <span class="keyword">Status</span>=<span class="number">0</span></span><br><span class="line">    <span class="comment">-- if the number of rows returned by the above statement is three, we can update to </span></span><br><span class="line">    <span class="comment">-- return success otherwise return failure to the user.</span></span><br><span class="line">    <span class="keyword">UPDATE</span> Show_Seat</span><br><span class="line">    <span class="keyword">UPDATE</span> Booking</span><br><span class="line"><span class="keyword">COMMIT</span> <span class="keyword">TRANSACTION</span>;</span><br></pre></td></tr></table></figure><p>“Serializable” is the highest isolation level and guarantees safety from Dirty, Non-repeatable, and Phantoms reads. One thing to note here; within a transaction, if we read rows, we get a write lock on them so that they can’t be updated by anyone else.<br>Once the above database transaction is successful, we can start tracking the reservation in ActiveReservationService.</p><h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p><strong>What happens when ActiveReservationsService or WaitingUsersService crashes</strong>? Whenever ActiveReservationsService crashes, we can read all the active reservations from the “Booking” table. Remember that we keep the “Status” column as “Reserved (1)” until a reservation gets booked. Another option is to have a primary-secondary configuration so that, when the primary crashes, the secondary can take over. We are not storing the waiting users in the database, so, when WaitingUsersService crashes, we don’t have any means to recover that data unless we have a primary-secondary setup.<br>Similarly, we’ll have a primary-secondary setup for databases to make them fault-tolerant.</p><h2 id="Data-Partitioning"><a href="#Data-Partitioning" class="headerlink" title="Data Partitioning"></a>Data Partitioning</h2><p>If we partition by “MovieID”, then all the Shows of a movie will be on a single server. For a very hot movie, this could cause a lot of load on that server. A better approach would be to partition based on “ShowID”; this way, the load gets distributed among different servers.</p><p><strong>ActiveReservationService and WaitingUserService partitioning</strong>: Our web servers will manage all the active users’ sessions and handle all the communication with the users. We can use the Consistent Hashing to allocate application servers for both ActiveReservationService and WaitingUserService based upon the “ShowID”. This way, all reservations and waiting users of a particular show will be handled by a certain set of servers. Let’s assume for load balancing our Consistent Hashing allocates three servers for any Show, so whenever a reservation is expired, the server holding that reservation will do the following things:</p><ol><li>Update the database to remove the Booking (or mark it expired) and update the seats’ Status in Show_Seat table;</li><li>Remove the reservation from the LinkedHashMap;</li><li>Notify the user that their reservation has expired;</li><li>Broadcast a message to all WaitingUserService servers that are holding waiting users of that Show to figure out the longest waiting user. Consistent Hashing scheme will tell what servers are holding these users;</li><li>Send a message to the WaitingUserService server holding the longest waiting user to process their request if required seats have become available;</li></ol><p>Whenever a reservation is successful, following things will happen:</p><ol><li>The server holding that reservation sends a message to all servers holding the waiting users of that Show, so that those servers can expire all the waiting users that need more seats than the available seats;</li><li>Upon receiving the above message, all servers holding the waiting users will query the database to find how many free seats are available now. A database cache would greatly help here to run this query only once;</li><li>Expire all waiting users who want to reserve more seats than the available seats. For this, WaitingUserService has to iterate through the LinkedHashMap of all the waiting users;</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Uber backend</title>
      <link href="2021/02/27/Designing-Uber-backend/"/>
      <url>2021/02/27/Designing-Uber-backend/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Uber"><a href="#What-is-Uber" class="headerlink" title="What is Uber?"></a>What is Uber?</h2><p>Uber enables its customers to book drivers for taxi rides. Uber drivers use their personal cars to drive customers around. Both customers and drivers communicate with each other through their smartphones using the Uber app.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>Let’s start with building a simpler version of Uber.<br>There are two types of users (Drivers, Customers) in our system:</p><ul><li>Drivers need to regularly notify the service about their current location and their availability to pick passengers;</li><li>Passengers get to see all the nearby available drivers;</li><li>Customer can request a ride; nearby drivers are notified that a customer is ready to be picked up;</li><li>Once a driver and a customer accept a ride, they can constantly see each other’s current location until the trip finishes;</li><li>Upon reaching the destination, the driver marks the journey complete to become available for the next ride;</li></ul><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><ul><li>Let’s assume we have 300M customers and 1M drivers with 1M daily active customers and 500K daily active drivers;</li><li>Let’s assume 1M daily rides;</li><li>Let’s assume that all active drivers notify their current location every three seconds;</li><li>Once a customer puts in a request for a ride, the system should be able to contact drivers in real-time;</li></ul><a id="more"></a><h2 id="Basic-System-Design-and-Algorithm"><a href="#Basic-System-Design-and-Algorithm" class="headerlink" title="Basic System Design and Algorithm"></a>Basic System Design and Algorithm</h2><p>We will take the solution discussed in Designing Yelp and modify it to make it work for the above-mentioned “Uber” use cases. The biggest difference we have is that our QuadTree was not built keeping in mind that there would be frequent updates to it. So, we have two issues with our Dynamic Grid solution:</p><ul><li>Since all active drivers are reporting their locations every three seconds, we need to update our data structures to reflect that. If we have to update the QuadTree for every change in the driver’s position, it will take a lot of time and resources. To update a driver to its new location, we must find the right grid based on the driver’s previous location. If the new position does not belong to the current grid, we have to remove the driver from the current grid and move/reinsert the user to the correct grid. After this move, if the new grid reaches the maximum limit of drivers, we have to repartition it;</li><li>We need to have a quick mechanism to propagate the current location of all the nearby drivers to any active customer in that area. Also, when a ride is in progress, our system needs to notify both the driver and passenger about the current location of the car;</li></ul><p>Although our QuadTree helps us find nearby drivers quickly, a fast update in the tree is not guaranteed.</p><p><strong>Do we need to modify our QuadTree every time a driver reports their location</strong>? If we don’t update our QuadTree with every update from the driver, it will have some old data and will not reflect the current location of drivers correctly. If you recall, our purpose of building the QuadTree was to find nearby drivers (or places) efficiently. Since all active drivers report their location every three seconds, therefore there will be a lot more updates happening to our tree than querying for nearby drivers. So, what if we keep the latest position reported by all drivers in a hash table and update our QuadTree a little less frequently? Let’s assume we guarantee that a driver’s current location will be reflected in the QuadTree within 15 seconds. Meanwhile, we will maintain a hash table that will store the current location reported by drivers; let’s call this <code>DriverLocationHT</code>.</p><p><strong>How much memory we need for DriverLocationHT</strong>? We need to store DriveID, their present and old location, in the hash table. So, we need a total of 35 bytes to store one record:</p><ol><li>DriverID (3 bytes);</li><li>Old latitude (8 bytes);</li><li>Old longitude (8 bytes);</li><li>New latitude (8 bytes);</li><li>New longitude (8 bytes);</li></ol><p>If we have 1 million total drivers, we need the following memory (ignoring hash table overhead):</p><blockquote><p>1 million * 35 bytes = 35 MB</p></blockquote><p><strong>How much bandwidth will our service consume to receive location updates from all drivers</strong>? If we get DriverID and their location, it will be (3+16=19 bytes). If we receive this information every three seconds from 500K daily active drivers, we will be getting 9.5MB per three seconds.</p><p><strong>Do we need to distribute DriverLocationHT onto multiple servers</strong>? Although our memory and bandwidth requirements don’t require this, since all this information can easily be stored on one server, but, for scalability, performance, and fault tolerance, we should distribute DriverLocationHT onto multiple servers. We can distribute based on the DriverID to make the distribution completely random. Let’s call the machines holding DriverLocationHT the Driver Location server. Other than storing the driver’s location, each of these servers will do two things:</p><ol><li>As soon as the server receives an update for a driver’s location, they will broadcast that information to all the interested customers;</li><li>The server needs to notify the respective QuadTree server to refresh the driver’s location. As discussed above, this can happen every 15 seconds;</li></ol><p><strong>How can we efficiently broadcast the driver’s location to customers</strong>? We can have a Push Model where the server will push the positions to all the relevant users. We can have a dedicated Notification Service that can broadcast the current location of drivers to all the interested customers. We can build our Notification service on a publisher/subscriber model. When a customer opens the Uber app on their cell phone, they query the server to find nearby drivers. On the server side, before returning the list of drivers to the customer, we will subscribe the customer for all the updates from those drivers. We can maintain a list of customers (subscribers) interested in knowing the location of a driver and, whenever we have an update in DriverLocationHT for that driver, we can broadcast the current location of the driver to all subscribed customers. This way, our system makes sure that we always show the driver’s current position to the customer.</p><p><strong>How much memory will we need to store all these subscriptions</strong>? As we have estimated above, we will have 1M daily active customers and 500K daily active drivers. On average let’s assume that five customers subscribe to one driver. Let’s assume we store all this information in a hash table so that we can update it efficiently. We need to store driver and customer IDs to maintain the subscriptions. Assuming we will need 3 bytes for DriverID and 8 bytes for CustomerID, we will need 21MB of memory:</p><blockquote><p>(500K * 3) + (500K * 5 * 8 ) ≈ 21 MB</p></blockquote><p><strong>How much bandwidth will we need to broadcast the driver’s location to customers</strong>? For every active driver, we have five subscribers, so the total subscribers we have:</p><blockquote><p>5 * 500K = 2.5M</p></blockquote><p>To all these customers we need to send DriverID (3 bytes) and their location (16 bytes) every second, so, we need the following bandwidth:</p><blockquote><p>2.5M * 19 bytes = 47.5 MB/s</p></blockquote><p><strong>How can we efficiently implement Notification Service</strong>? We can either use HTTP long polling or push notifications.</p><p><strong>How will the new publishers/drivers get added for a current customer</strong>? As we have proposed above, customers will be subscribed to nearby drivers when they open the Uber app for the first time, what will happen when a new driver enters the area the customer is looking at? To add a new customer/driver subscription dynamically, we need to keep track of the area the customer is watching. This will make our solution complicated.</p><p><strong>How about if clients pull information about nearby drivers from the server</strong>? Clients can send their current location, and the server will find all the nearby drivers from the QuadTree to return them to the client. Upon receiving this information, the client can update their screen to reflect the current positions of the drivers. Clients can query every five seconds to limit the number of round trips to the server. This solution looks simpler compared to the push model described above:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/65.png" alt></p><p><strong>Do we need to repartition a grid as soon as it reaches the maximum limit</strong>? We can have a cushion to let each grid grow a little bigger beyond the limit before we decide to partition it. Let’s say our grids can grow/shrink an extra 10% before we partition/merge them. This should decrease the load for a grid partition or merge on high traffic grids.</p><p><strong>How would “Request Ride” use case work</strong>:</p><ol><li>The customer will put a request for a ride;</li><li>One of the Aggregator Servers will take the request and asks QuadTree Servers to return nearby drivers;</li><li>The Aggregator Server collects all the results and sorts them by ratings;</li><li>The Aggregator Server will send a notification to the top (say three) drivers simultaneously, whichever driver accepts the request first will be assigned the ride. The other drivers will receive a cancellation request. If none of the three drivers respond, the Aggregator will request a ride from the next three drivers from the list;</li><li>Once a driver accepts a request, the customer is notified;</li></ol><h2 id="Fault-Tolerance-and-Replication"><a href="#Fault-Tolerance-and-Replication" class="headerlink" title="Fault Tolerance and Replication"></a>Fault Tolerance and Replication</h2><p><strong>What if a Driver Location Server or Notification Server dies</strong>? We would need replicas of these servers, so that if the primary dies the secondary can take control. Also, we can store this data in some persistent storage like SSDs that can provide fast IOs; this will ensure that if both primary and secondary servers die we can recover the data from the persistent storage.</p><h2 id="Ranking"><a href="#Ranking" class="headerlink" title="Ranking"></a>Ranking</h2><p><strong>How can we return top rated drivers within a given radius</strong>? Let’s assume we keep track of the overall ratings of each driver in our database and QuadTree. An aggregated number can represent this popularity in our system, e.g., how many stars does a driver get out of ten? While searching for the top 10 drivers within a given radius, we can ask each partition of the QuadTree to return the top 10 drivers with a maximum rating. The aggregator server can then determine the top 10 drivers among all the drivers returned by different partitions.</p><h2 id="Advanced-Issues"><a href="#Advanced-Issues" class="headerlink" title="Advanced Issues"></a>Advanced Issues</h2><ol><li>How will we handle clients on slow and disconnecting networks?</li><li>What if a client gets disconnected when they are a part of a ride? How will we handle billing in such a scenario?</li><li>How about if clients pull all the information, compared to servers always pushing it?</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Yelp or Nearby Friends</title>
      <link href="2021/02/27/Designing-Yelp-or-Nearby-Friends/"/>
      <url>2021/02/27/Designing-Yelp-or-Nearby-Friends/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-Yelp-or-Proximity-Server"><a href="#Why-Yelp-or-Proximity-Server" class="headerlink" title="Why Yelp or Proximity Server?"></a>Why Yelp or Proximity Server?</h2><p>Proximity servers are used to discover nearby attractions like places, events, etc. If you haven’t used <a href="https://www.yelp.com/" target="_blank" rel="noopener">yelp.com</a> before, please try it before proceeding (you can search for nearby restaurants, theaters, etc.) and spend some time understanding different options that the website offers. This will help you a lot in understanding this chapter better.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p><strong>What do we wish to achieve from a Yelp like service</strong>? Our service will be storing information about different places so that users can perform a search on them. Upon querying, our service will return a list of places around the user.<br>Our Yelp-like service should meet the following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Users should be able to add/delete/update places;</li><li>Given their location (longitude/latitude), users should be able to find all nearby places within a given radius;</li><li>Users should be able to add feedback/review about a place. The feedback can have pictures, text, and a rating;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>Users should have a real-time search experience with minimum latency;</li><li>Our service should support a heavy search load. There will be a lot of search requests compared to adding a new place;</li></ol><a id="more"></a><h2 id="Scale-Estimation"><a href="#Scale-Estimation" class="headerlink" title="Scale Estimation"></a>Scale Estimation</h2><p>Let’s build our system assuming that we have 500M places and 100K Queries Per Second (QPS). Let’s also assume a 20% growth in the number of places and QPS each year.</p><h2 id="Database-Schema"><a href="#Database-Schema" class="headerlink" title="Database Schema"></a>Database Schema</h2><p>Each Place can have the following fields:</p><ol><li>LocationID (8 bytes): Uniquely identifies a location;</li><li>Name (256 bytes);</li><li>Latitude (8 bytes);</li><li>Longitude (8 bytes);</li><li>Description (512 bytes);</li><li>Category (1 byte): E.g., coffee shop, restaurant, theater, etc.;</li></ol><p>Although a four bytes number can uniquely identify 500M locations, with future growth in mind, we will go with 8 bytes for LocationID:</p><blockquote><p>8 + 256 + 8 + 8 + 512 + 1 = 793 bytes</p></blockquote><p>We also need to store reviews, photos, and ratings of a Place. We can have a separate table to store reviews for Places:</p><ol><li>LocationID;</li><li>ReviewID: Uniquely identifies a review, assuming any location will not have more than 2^32 reviews;</li><li>ReviewText;</li><li>Rating: How many stars a place gets out of ten;</li></ol><p>Similarly, we can have a separate table to store photos for Places and Reviews.</p><h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><p>We can have SOAP or REST APIs to expose the functionality of our service. The following could be the definition of the API for searching:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search(api_dev_key, search_terms, user_location, radius_filter, maximum_results_to_return, category_filter, sort, page_token)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota;</li><li>search_terms: A string containing the search terms;</li><li>user_location: Location of the user performing the search;</li><li>radius_filter: Optional search radius in meters;</li><li>maximum_results_to_return: Number of business results to return;</li><li>category_filter: Optional category to filter search results, e.g., Restaurants, Shopping Centers, etc.;</li><li>sort: Optional; Best Matched (0, default), Minimum Distance (1), Highest Rated (2);</li><li>page_token: This token will specify a page in the result set that should be returned;</li></ul><p><strong>Returns</strong>: A JSON containing information about a list of businesses matching the search query. Each result entry will have the business name, address, category, rating, and thumbnail.</p><h2 id="Basic-System-Design-and-Algorithm"><a href="#Basic-System-Design-and-Algorithm" class="headerlink" title="Basic System Design and Algorithm"></a>Basic System Design and Algorithm</h2><p>At a high level, we need to store and index each dataset described above (places, reviews, etc.). For users to query this massive database, the indexing should be read efficient, since while searching for the nearby places users expect to see the results in real-time.<br>Given that the location of a place doesn’t change that often, we don’t need to worry about frequent updates of the data. As a contrast, if we intend to build a service where objects do change their location frequently, e.g., people or taxis, then we might come up with a very different design.</p><h3 id="SQL-Solution"><a href="#SQL-Solution" class="headerlink" title="SQL Solution"></a>SQL Solution</h3><p>One simple solution could be to store all the data in a database like MySQL. Each place will be stored in a separate row, uniquely identified by LocationID. Each place will have its longitude and latitude stored separately in two different columns, and to perform a fast search; we should have indexes on both these fields.<br>To find all the nearby places of a given location (X, Y) within a radius “D”, we can query like this:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Places <span class="keyword">WHERE</span> Latitude <span class="keyword">BETWEEN</span> X-D <span class="keyword">AND</span> X+D <span class="keyword">AND</span> Longitude <span class="keyword">BETWEEN</span> Y-D <span class="keyword">AND</span> Y+D;</span><br></pre></td></tr></table></figure><p>The above query is not completely accurate, as we know that to find the distance between two points we have to use the distance formula (Pythagorean Theorem), but for simplicity let’s take this.</p><p><strong>How efficient would this query be</strong>? We have estimated 500M places to be stored in our service. Since we have two separate indexes, each index can return a huge list of places and performing an intersection on those two lists won’t be efficient. Another way to look at this problem is that there could be too many locations between “X-D” and “X+D”, and similarly between “Y-D” and “Y+D”. If we can somehow shorten these lists, it can improve the performance of our query.</p><h3 id="Grids"><a href="#Grids" class="headerlink" title="Grids"></a>Grids</h3><p>We can divide the whole map into smaller grids to group locations into smaller sets. Each grid will store all the Places residing within a specific range of longitude and latitude. This scheme would enable us to query only a few grids to find nearby places. Based on a given location and radius, we can find all the neighboring grids and then query these grids to find nearby places:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/62.png" alt></p><p>Let’s assume that GridID (a four bytes number) would uniquely identify grids in our system.</p><p><strong>What could be a reasonable grid size</strong>? Grid size could be equal to the distance we would like to query since we also want to reduce the number of grids. If the grid size is equal to the distance we want to query, then we only need to search within the grid which contains the given location and neighboring eight grids. Since our grids would be statically defined (from the fixed grid size), we can easily find the grid number of any location (lat, long) and its neighboring grids.<br>In the database, we can store the GridID with each location and have an index on it, too, for faster searching. Now, our query will look like:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Places <span class="keyword">WHERE</span> Latitude <span class="keyword">BETWEEN</span> X-D <span class="keyword">AND</span> X+D <span class="keyword">AND</span> Longitude <span class="keyword">BETWEEN</span> Y-D <span class="keyword">AND</span> Y+D <span class="keyword">AND</span> GridID <span class="keyword">IN</span> (GridID0, GridID1, GridID2, ..., GridID7);</span><br></pre></td></tr></table></figure><p>This will undoubtedly improve the runtime of our query.</p><p><strong>Should we keep our index in memory</strong>? Maintaining the index in memory will improve the performance of our service. We can keep our index in a hash table where “key” is the grid number and “value” is the list of places contained in that grid.</p><p><strong>How much memory will we need to store the index</strong>? Let’s assume our search radius is 10 miles; given that the total area of the earth is around 200 million square miles, we will have 20 million grids. We would need a four bytes number to uniquely identify each grid and, since LocationID is 8 bytes, we would need 4GB of memory (ignoring hash table overhead) to store the index:</p><blockquote><p>(4 * 20M) + (8 * 500M) ≈ 4 GB</p></blockquote><p>This solution can still run slow for those grids that have a lot of places since our places are not uniformly distributed among grids. We can have a thickly dense area with a lot of places, and on the other hand, we can have areas which are sparsely populated.<br>This problem can be solved if we can dynamically adjust our grid size such that whenever we have a grid with a lot of places we break it down to create smaller grids. A couple of challenges with this approach could be:</p><ol><li>How to map these grids to locations;</li><li>How to find all the neighboring grids of a grid;</li></ol><h3 id="Dynamic-Size-Grids"><a href="#Dynamic-Size-Grids" class="headerlink" title="Dynamic Size Grids"></a>Dynamic Size Grids</h3><p>Let’s assume we don’t want to have more than 500 places in a grid so that we can have a faster searching. So, whenever a grid reaches this limit, we break it down into four grids of equal size and distribute places among them. This means thickly populated areas like downtown San Francisco will have a lot of grids, and sparsely populated area like the Pacific Ocean will have large grids with places only around the coastal lines.</p><p><strong>What data-structure can hold this information</strong>? A tree in which each node has four children can serve our purpose. Each node will represent a grid and will contain information about all the places in that grid. If a node reaches our limit of 500 places, we will break it down to create four child nodes under it and distribute places among them. In this way, all the leaf nodes will represent the grids that cannot be further broken down. So leaf nodes will keep a list of places with them. This tree structure in which each node can have four children is called a <code>QuadTree</code>:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/63.png" alt></p><p><strong>How will we build a QuadTree</strong>? We will start with one node that will represent the whole world in one grid. Since it will have more than 500 locations, we will break it down into four nodes and distribute locations among them. We will keep repeating this process with each child node until there are no nodes left with more than 500 locations.</p><p><strong>How will we find the grid for a given location</strong>? We will start with the root node and search downward to find our required node/grid. At each step, we will see if the current node we are visiting has children. If it has, we will move to the child node that contains our desired location and repeat this process. If the node does not have any children, then that is our desired node.</p><p><strong>How will we find neighboring grids of a given grid</strong>? Since only leaf nodes contain a list of locations, we can connect all leaf nodes with a doubly linked list. This way we can iterate forward or backward among the neighboring leaf nodes to find out our desired locations. Another approach for finding adjacent grids would be through parent nodes. We can keep a pointer in each node to access its parent, and since each parent node has pointers to all of its children, we can easily find siblings of a node. We can keep expanding our search for neighboring grids by going up through the parent pointers.<br>Once we have nearby LocationIDs, we can query the backend database to find details about those places.</p><p><strong>What will be the search workflow</strong>? We will first find the node that contains the user’s location. If that node has enough desired places, we can return them to the user. If not, we will keep expanding to the neighboring nodes (either through the parent pointers or doubly linked list) until either we find the required number of places or exhaust our search based on the maximum radius.</p><p><strong>How much memory will be needed to store the QuadTree</strong>? For each Place, if we cache only LocationID and Lat/Long, we would need 12GB to store all places:</p><blockquote><p>24 * 500M = 12 GB</p></blockquote><p>Since each grid can have a maximum of 500 places, and we have 500M locations, how many total grids we will have:</p><blockquote><p>500M / 500 = 1M grids</p></blockquote><p>Which means we will have 1M leaf nodes and they will be holding 12GB of location data. A QuadTree with 1M leaf nodes will have approximately 1/3rd internal nodes, and each internal node will have 4 pointers (for its children). If each pointer is 8 bytes, then the memory we need to store all internal nodes would be:</p><blockquote><p>1M * 1/3 * 4 * 8 ≈ 10 MB</p></blockquote><p>So, total memory required to hold the whole QuadTree would be 12.01GB. This can easily fit into a modern-day server.</p><p><strong>How would we insert a new Place into our system</strong>? Whenever a new Place is added by a user, we need to insert it into the databases as well as in the QuadTree. If our tree resides on one server, it is easy to add a new Place, but if the QuadTree is distributed among different servers, first we need to find the grid/server of the new Place and then add it there.</p><h2 id="Data-Partitioning"><a href="#Data-Partitioning" class="headerlink" title="Data Partitioning"></a>Data Partitioning</h2><p>What if we have a huge number of places such that our index does not fit into a single machine’s memory? With 20% growth each year we will reach the memory limit of the server in the future. Also, what if one server cannot serve the desired read traffic? To resolve these issues, we must partition our QuadTree!</p><p><strong>Sharding based on regions</strong>: We can divide our places into regions (like zip codes), such that all places belonging to a region will be stored on a fixed node. To store a place we will find the server through its region and, similarly, while querying for nearby places we will ask the region server that contains user’s location. This approach has a couple of issues:</p><ol><li>What if a region becomes hot? There would be a lot of queries on the server holding that region, making it perform slow. This will affect the performance of our service;</li><li>Over time, some regions can end up storing a lot of places compared to others. Hence, maintaining a uniform distribution of places, while regions are growing is quite difficult;</li></ol><p>To recover from these situations, either we have to repartition our data or use consistent hashing.</p><p><strong>Sharding based on LocationID</strong>: Our hash function will map each LocationID to a server where we will store that place. While building our QuadTree, we will iterate through all the places and calculate the hash of each LocationID to find a server where it would be stored. To find places near a location, we have to query all servers and each server will return a set of nearby places. A centralized server will aggregate these results to return them to the user.</p><p><strong>Will we have different QuadTree structure on different partitions</strong>? Yes, this can happen since it is not guaranteed that we will have an equal number of places in any given grid on all partitions. However, we do make sure that all servers have approximately an equal number of Places. This different tree structure on different servers will not cause any issue though, as we will be searching all the neighboring grids within the given radius on all partitions.</p><h2 id="Replication-and-Fault-Tolerance"><a href="#Replication-and-Fault-Tolerance" class="headerlink" title="Replication and Fault Tolerance"></a>Replication and Fault Tolerance</h2><p>Having replicas of QuadTree servers can provide an alternate to data partitioning. To distribute read traffic, we can have replicas of each QuadTree server. We can have a primary-secondary configuration where replicas (secondaries) will only serve read traffic; all write traffic will first go to the primary and then applied to secondaries. Secondaries might not have some recently inserted places (a few milliseconds delay will be there), but this could be acceptable.<br>What will happen when a QuadTree server dies? We can have a secondary replica of each server and, if the primary dies, it can take control after the failover. Both primary and secondary servers will have the same QuadTree structure.</p><p><strong>What if both primary and secondary servers die at the same time</strong>? We have to allocate a new server and rebuild the same QuadTree on it. How can we do that, since we don’t know what places were kept on this server? The brute-force solution would be to iterate through the whole database and filter LocationIDs using our hash function to figure out all the required places that will be stored on this server. This would be inefficient and slow; also, during the time when the server is being rebuilt, we will not be able to serve any query from it, thus missing some places that should have been seen by users.</p><p><strong>How can we efficiently retrieve a mapping between Places and QuadTree server</strong>? We have to build a reverse index that will map all the Places to their QuadTree server. We can have a separate QuadTree Index server that will hold this information. We will need to build a HashMap where the “key” is the QuadTree server number and the “value” is a HashSet containing all the Places being kept on that QuadTree server. We need to store LocationID and Lat/Long with each place because information servers can build their QuadTrees through this. Notice that we are keeping Places’ data in a HashSet, this will enable us to add/remove Places from our index quickly. So now, whenever a QuadTree server needs to rebuild itself, it can simply ask the QuadTree Index server for all the Places it needs to store. This approach will surely be quite fast. We should also have a replica of the QuadTree Index server for fault tolerance. If a QuadTree Index server dies, it can always rebuild its index from iterating through the database:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/64.png" alt></p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>To deal with hot Places, we can introduce a cache in front of our database. We can use an off-the-shelf solution like Memcache, which can store all data about hot places. Application servers, before hitting the backend database, can quickly check if the cache has that Place. Based on clients‘ usage pattern, we can adjust how many cache servers we need. For cache eviction policy, Least Recently Used (LRU) seems suitable for our system.</p><h2 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h2><p>We can add LB layer at two places in our system:</p><ol><li>Between Clients and Application Servers;</li><li>Between Application Servers and Backend Server;</li></ol><p>Initially, a simple Round Robin approach can be adopted; that will distribute all incoming requests equally among backend servers. This LB is simple to implement and does not introduce any overhead. Another benefit of this approach is if a server is dead the load balancer will take it out of the rotation and will stop sending any traffic to it.<br>A problem with Round Robin LB is, it won’t take server load into consideration. If a server is overloaded or slow, the load balancer will not stop sending new requests to that server. To handle this, a more intelligent LB solution would be needed that periodically queries backend server about their load and adjusts traffic based on that.</p><h2 id="Ranking"><a href="#Ranking" class="headerlink" title="Ranking"></a>Ranking</h2><p><strong>How can we return most popular places within a given radius</strong>? Let’s assume we keep track of the overall popularity of each place. An aggregated number can represent this popularity in our system, e.g., how many stars a place gets out of ten (this would be an average of different rankings given by users)? We will store this number in the database as well as in the QuadTree. While searching for the top 100 places within a given radius, we can ask each partition of the QuadTree to return the top 100 places with maximum popularity. Then the aggregator server can determine the top 100 places among all the places returned by different partitions.<br>Remember that we didn’t build our system to update place’s data frequently. With this design, how can we modify the popularity of a place in our QuadTree? Although we can search a place and update its popularity in the QuadTree, it would take a lot of resources and can affect search requests and system throughput. Assuming the popularity of a place is not expected to reflect in the system within a few hours, we can decide to update it once or twice a day, especially when the load on the system is minimum.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Facebook&#39;s Newsfeed</title>
      <link href="2021/02/26/Designing-Facebook-s-Newsfeed/"/>
      <url>2021/02/26/Designing-Facebook-s-Newsfeed/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Facebook’s-Newsfeed"><a href="#What-is-Facebook’s-Newsfeed" class="headerlink" title="What is Facebook’s Newsfeed?"></a>What is Facebook’s Newsfeed?</h2><p>A Newsfeed is the constantly updating list of stories in the middle of Facebook’s homepage. It includes status updates, photos, videos, links, app activity, and “likes” from people, pages, and groups that a user follows on Facebook. In other words, it is a compilation of a complete scrollable version of your friends’ and your life story from photos, videos, locations, status updates, and other activities.<br>For any social media site you design - Twitter, Instagram, or Facebook - you will need a newsfeed system to display updates from friends and followers.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>Let’s design a newsfeed for Facebook with the following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Newsfeed will be generated based on the posts from the people, pages, and groups that a user follows;</li><li>A user may have many friends and follow a large number of pages/groups;</li><li>Feeds may contain images, videos, or just text;</li><li>Our service should support appending new posts as they arrive to the newsfeed for all active users;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>Our system should be able to generate any user’s newsfeed in real-time - maximum latency seen by the end user would be 2s;</li><li>A post shouldn’t take more than 5s to make it to a use’s feed assuming a new newsfeed request comes in;</li></ol><a id="more"></a><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p>Let’s assume on average a user has 300 friends and follows 200 pages.</p><p><strong>Traffic estimates</strong>: Let’s assume 300M daily active users with each user fetching their timeline an average of five times a day. This will result in 1.5B newsfeed requests per day or approximately 17,500 requests per second.</p><p><strong>Storage estimates</strong>: On average, let’s assume we need to have around 500 posts in every user’s feed that we want to keep in memory for a quick fetch. Let’s also assume that on average each post would be 1KB in size. This would mean that we need to store roughly 500KB of data per user. To store all this data for all the active users we would need 150TB of memory. If a server can hold 100GB we would need around 1500 machines to keep the top 500 posts in memory for all active users.</p><h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><blockquote><p>Once we have finalized the requirements, it’s always a good idea to define the system APIs. This should explicitly state what is expected from the system.</p></blockquote><p>We can have SOAP or REST APIs to expose the functionality of our service. The following could be the definition of the API for getting the newsfeed:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getUserFeed(api_dev_key, user_id, since_id, count, max_id, exclude_replies)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: The API developer key of a registered can be used to, among other things, throttle users based on their allocated quota;</li><li>user_id: The ID of the user for whom the system will generate the newsfeed;</li><li>since_id: Optional; returns results with an ID higher than (that is, more recent than) the specified ID;</li><li>count: Optional; specifies the number of feed items to try and retrieve up to a maximum of 200 per distinct request;</li><li>max_id: Optional; returns results with an ID less than (that is, older than) or equal to the specified ID;</li><li>exclude_replies: Optional; this parameter will prevent replies from appearing in the returned timeline;</li></ul><p><strong>Returns</strong>: Returns a JSON object containing a list of feed items.</p><h2 id="Database-Design"><a href="#Database-Design" class="headerlink" title="Database Design"></a>Database Design</h2><p>There are three primary objects: User, Entity (e.g. page, group, etc.), and FeedItem (or Post). Here are some observations about the relationships between these entities:</p><ul><li>A User can follow other entities and can become friends with other users;</li><li>Both users and entities can post FeedItems which can contain text, images, or videos;</li><li>Each FeedItem will have a UserID which will point to the User who created it. For simplicity, let’s assume that only users can create feed items, although, on Facebook Pages can post feed item too;</li><li>Each FeedItem can optionally have an EntityID pointing to the page or the group where that post was created;</li></ul><p>If we are using a relational database, we would need to model two relations: User-Entity relation and FeedItem-Media relation. Since each user can be friends with many people and follow a lot of entities, we can store this relation in a separate table. The “Type” column in “UserFollow” identifies if the entity being followed is a User or Entity. Similarly, we can have a table for FeedMedia relation:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/60.png" alt></p><h2 id="High-Level-System-Design"><a href="#High-Level-System-Design" class="headerlink" title="High-Level System Design"></a>High-Level System Design</h2><h3 id="Feed-Generation"><a href="#Feed-Generation" class="headerlink" title="Feed Generation"></a>Feed Generation</h3><p>Newsfeed is generated from the posts (or feed items) of users and entities (pages and groups) that a user follows. So, whenever our system receives a request to generate the feed for a user (say Jane), we will perform the following steps:</p><ol><li>Retrieve IDs of all users and entities that Jane follows;</li><li>Retrieve latest, most popular and relevant posts for those IDs. These are the potential posts that we can show in Jane’s newsfeed;</li><li>Rank these posts based on the relevance to Jane. This represents Jane’s current feed;</li><li>Store this feed in the cache and return top posts (say 20) to be rendered on Jane’s feed;</li><li>On the frontend, when Jane reaches the end of her current feed, she can fetch the next 20 posts from the server and so on;</li></ol><p>One thing to notice here is that we generated the feed once and stored it in the cache. What about new incoming posts from people that Jane follows? If Jane is online, we should have a mechanism to rank and add those new posts to her feed. We can periodically (say every five minutes) perform the above steps to rank and add the newer posts to her feed. Jane can then be notified that there are newer items in her feed that she can fetch.</p><h3 id="Feed-Publishing"><a href="#Feed-Publishing" class="headerlink" title="Feed Publishing"></a>Feed Publishing</h3><p>Whenever Jane loads her newsfeed page, she has to request and pull feed items from the server. When she reaches the end of her current feed, she can pull more data from the server. For newer items either the server can notify Jane and then she can pull, or the server can push, these new posts.</p><p>At a high level, we will need following components in our Newsfeed service:</p><ol><li><strong>Web Server</strong>: To maintain a connection with the user. This connection will be used to transfer data between the user and the server;</li><li><strong>Application Server</strong>: To execute the workflows of storing new posts in the database servers. We will also need some application servers to retrieve and to push the newsfeed to the end user;</li><li><strong>Metadata Database and Cache</strong>: To store the metadata about Users, Pages, and Groups;</li><li><strong>Posts Database and Cache</strong>: To store metadata about posts and their contents;</li><li><strong>Video/Photo Storage and Cache</strong>: Blob storage, to store all the media included in the posts;</li><li><strong>Newsfeed Generation Service</strong>: To gather and rank all the relevant posts for a user to generate newsfeed and store in the cache. This service will also receive live updates and will add these newer feed items to any user’s timeline;</li><li><strong>Feed Notification Service</strong>: To notify the user that there are newer items available for their newsfeed;</li></ol><p>Following is the high-level architecture diagram of our system. User B and C are following User A:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/61.png" alt></p><h2 id="Detailed-Component-Design"><a href="#Detailed-Component-Design" class="headerlink" title="Detailed Component Design"></a>Detailed Component Design</h2><h3 id="Feed-Generation-1"><a href="#Feed-Generation-1" class="headerlink" title="Feed Generation"></a>Feed Generation</h3><p>Let’s take the simple case of the newsfeed generation service fetching most recent posts from all the users and entities that Jane follows; the query would look like this:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">SELECT</span> FeedItemID <span class="keyword">FROM</span> FeedItem <span class="keyword">WHERE</span> UserID <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> EntityOrFriendID <span class="keyword">FROM</span> UserFollow <span class="keyword">WHERE</span> UserID = &lt;current_user_id&gt; <span class="keyword">and</span> <span class="keyword">type</span> = <span class="number">0</span>(<span class="keyword">user</span>))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line">(<span class="keyword">SELECT</span> FeedItemID <span class="keyword">FROM</span> FeedItem <span class="keyword">WHERE</span> EntityID <span class="keyword">in</span> (</span><br><span class="line">    <span class="keyword">SELECT</span> EntityOrFriendID <span class="keyword">FROM</span> UserFollow <span class="keyword">WHERE</span> UserID = &lt;current_user_id&gt; <span class="keyword">and</span> <span class="keyword">type</span> = <span class="number">1</span>(entity))</span><br><span class="line">)</span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> CreationDate <span class="keyword">DESC</span> </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p>Here are issues with this design for the feed generation service:</p><ol><li>Crazy slow for users with a lot of friends/follows as we have to perform sorting/merging/ranking of a huge number of posts;</li><li>We generate the timeline when a user loads their page. This would be quite slow and have a high latency;</li><li>For live updates, each status update will result in feed updates for all followers. This could result in high backlogs in our Newsfeed Generation Service;</li><li>For live updates, the server pushing (or notifying about) newer posts to users could lead to very heavy loads, especially for people or pages that have a lot of followers. To improve the efficiency, we can pre-generate the timeline and store it in a memory;</li></ol><p><strong>Offline generation for newsfeed</strong>: We can have dedicated servers that are continuously generating users’ newsfeed and storing them in memory. So, whenever a user requests for the new posts for their feed, we can simply serve it from the pre-generated, stored location. Using this scheme, user’s newsfeed is not compiled on load, but rather on a regular basis and returned to users whenever they request for it.<br>Whenever these servers need to generate the feed for a user, they will first query to see what was the last time the feed was generated for that user. Then, new feed data would be generated from that time onwards. We can store this data in a hash table where the “key” would be UserID and “value” would be a STRUCT like this:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Struct &#123;</span><br><span class="line">    LinkedHashMap&lt;FeedItemID, FeedItem&gt; feedItems;</span><br><span class="line">    DateTime lastGenerated;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>We can store FeedItemIDs in a data structure similar to <code>LinkedHashMap</code> or <code>TreeMap</code>, which can allow us to not only jump to any feed item but also iterate through the map easily. Whenever users want to fetch more feed items, they can send the last FeedItemID they currently see in their newsfeed, we can then jump to that FeedItemID in our hash-map and return next batch/page of feed items from there.</p><p><strong>How many feed items should we store in memory for a user’s feed</strong>? Initially, we can decide to store 500 feed items per user, but this number can be adjusted later based on the usage pattern. For example, if we assume that one page of a user’s feed has 20 posts and most of the users never browse more than ten pages of their feed, we can decide to store only 200 posts per user. For any user who wants to see more posts (more than what is stored in memory), we can always query backend servers.</p><p><strong>Should we generate (and keep in memory) newsfeed for all users</strong>? There will be a lot of users that don’t log-in frequently. Here are a few things we can do to handle this:</p><ol><li>A more straightforward approach could be, to use an LRU based cache that can remove users from memory that haven’t accessed their newsfeed for a long time;</li><li>A smarter solution can figure out the login pattern of users to pre-generate their newsfeed, e.g., at what time of the day a user is active and which days of the week does a user access their newsfeed? etc.;</li></ol><h3 id="Feed-Publishing-1"><a href="#Feed-Publishing-1" class="headerlink" title="Feed Publishing"></a>Feed Publishing</h3><p>The process of pushing a post to all the followers is called <code>Fanout</code>. By analogy, the push approach is called fanout-on-write, while the pull approach is called fanout-on-load. Let’s discuss different options for publishing feed data to users:<br><strong>Pull model or Fan-out-on-load</strong>: This method involves keeping all the recent feed data in memory so that users can pull it from the server whenever they need it. Clients can pull the feed data on a regular basis or manually whenever they need it. Possible problems with this approach are:</p><ol><li>New data might not be shown to the users until they issue a pull request;</li><li>It’s hard to find the right pull cadence, as most of the time pull requests will result in an empty response if there is no new data, causing waste of resources;</li></ol><p><strong>Push model or Fan-out-on-write</strong>: For a push system, once a user has published a post, we can immediately push this post to all the followers. The advantage is that when fetching feed you don’t need to go through your friend’s list and get feeds for each of them. It significantly reduces read operations. To efficiently handle this, users have to maintain a Long Poll request with the server for receiving the updates. A possible problem with this approach is that when a user has millions of followers (a celebrity-user) the server has to push updates to a lot of people;</p><p><strong>Hybrid</strong>: An alternate method to handle feed data could be to use a hybrid approach, i.e., to do a combination of fan-out-on-write and fan-out-on-load. Specifically, we can stop pushing posts from users with a high number of followers (a celebrity user) and only push data for those users who have a few hundred (or thousand) followers. For celebrity users, we can let the followers pull the updates. Since the push operation can be extremely costly for users who have a lot of friends or followers, by disabling fanout for them, we can save a huge number of resources. Another alternate approach could be that, once a user publishes a post, we can limit the fanout to only her online friends. Also, to get benefits from both the approaches, a combination of “push to notify” and “pull for serving” end-users is a great way to go. Purely a push or pull model is less versatile;</p><p><strong>How many feed items can we return to the client in each request</strong>? We should have a maximum limit for the number of items a user can fetch in one request (say 20). But, we should let the client specify how many feed items they want with each request as the user may like to fetch a different number of posts depending on the device (Mobile vs. Desktop).</p><p><strong>Should we always notify users if there are new posts available for their newsfeed</strong>? It could be useful for users to get notified whenever new data is available. However, on mobile devices, where data usage is relatively expensive, it can consume unnecessary bandwidth. Hence, at least for mobile devices, we can choose not to push data, instead, let users “Pull to Refresh” to get new posts.</p><h2 id="Feed-Ranking"><a href="#Feed-Ranking" class="headerlink" title="Feed Ranking"></a>Feed Ranking</h2><p>The most straightforward way to rank posts in a newsfeed is by the creation time of the posts, but today’s ranking algorithms are doing a lot more than that to ensure “important” posts are ranked higher. The high-level idea of ranking is first to select key “signals” that make a post important and then to find out how to combine them to calculate a final ranking score.<br>More specifically, we can select features that are relevant to the importance of any feed item, e.g., number of likes, comments, shares, time of the update, whether the post has images/videos, etc., and then, a score can be calculated using these features. This is generally enough for a simple ranking system. A better ranking system can significantly improve itself by constantly evaluating if we are making progress in user stickiness, retention, ads revenue, etc.</p><h2 id="Data-Partitioning"><a href="#Data-Partitioning" class="headerlink" title="Data Partitioning"></a>Data Partitioning</h2><ul><li><strong>Sharding posts and metadata</strong>: Since we have a huge number of new posts every day and our read load is extremely high too, we need to distribute our data onto multiple machines such that we can read/write it efficiently. For sharding our databases that are storing posts and their metadata, we can have a similar design as discussed under Designing Twitter;</li><li><strong>Sharding feed data</strong>: For feed data, which is being stored in memory, we can partition it based on UserID. We can try storing all the data of a user on one server. When storing, we can pass the UserID to our hash function that will map the user to a cache server where we will store the user’s feed objects. Also, for any given user, since we don’t expect to store more than 500 FeedItemIDs, we will not run into a scenario where feed data for a user doesn’t fit on a single server. To get the feed of a user, we would always have to query only one server. For future growth and replication, we must use Consistent Hashing.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing a Web Crawler</title>
      <link href="2021/02/26/Designing-a-Web-Crawler/"/>
      <url>2021/02/26/Designing-a-Web-Crawler/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-a-Web-Crawler"><a href="#What-is-a-Web-Crawler" class="headerlink" title="What is a Web Crawler?"></a>What is a Web Crawler?</h2><p>A web crawler is a software program which browses the World Wide Web in a methodical and automated manner. It collects documents by recursively fetching links from a set of starting pages. Many sites, particularly search engines, use web crawling as a means of providing up-to-date data. Search engines download all the pages to create an index on them to perform faster searches.<br>Some other uses of web crawlers are:</p><ul><li>To test web pages and links for valid syntax and structure;</li><li>To monitor sites to see when their structure or contents change;</li><li>To maintain mirror sites for popular Web sites;</li><li>To build a special-purpose index, e.g., one that has some understanding of the content stored in multimedia files on the Web;</li></ul><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>Let’s assume we need to crawl all the web:</p><ul><li><strong>Scalability</strong>: Our service needs to be scalable such that it can crawl the entire Web and can be used to fetch hundreds of millions of Web documents;</li><li><strong>Extensibility</strong>: Our service should be designed in a modular way with the expectation that new functionality will be added to it. There could be newer document types that need to be downloaded and processed in the future;</li></ul><a id="more"></a><h2 id="Some-Design-Considerations"><a href="#Some-Design-Considerations" class="headerlink" title="Some Design Considerations"></a>Some Design Considerations</h2><p>Crawling the web is a complex task, and there are many ways to go about it. We should be asking a few questions before going any further:<br><strong>Is it a crawler for HTML pages only</strong>? Or should we fetch and store other types of media, such as sound files, images, videos, etc.? This is important because the answer can change the design. If we are writing a general-purpose crawler to download different media types, we might want to break down the parsing module into different sets of modules: one for HTML, another for images, or another for videos, where each module extracts what is considered interesting for that media type.<br>Let’s assume for now that our crawler is going to deal with HTML only, but it should be extensible and make it easy to add support for new media types.</p><p><strong>What protocols are we looking at</strong>? HTTP? What about FTP links? What different protocols should our crawler handle? For the sake of the exercise, we will assume HTTP. Again, it shouldn’t be hard to extend the design to use FTP and other protocols later.</p><p><strong>What is the expected number of pages we will crawl</strong>? How big will the URL database become? Let’s assume we need to crawl one billion websites. Since a website can contain many, many URLs, let’s assume an upper bound of 15 billion different web pages that will be reached by our crawler.</p><p><strong>What is “RobotsExclusion” and how should we deal with it</strong>? Courteous web crawlers implement the Robots Exclusion Protocol, which allows Webmasters to declare parts of their sites off-limits to crawlers. The Robots Exclusion Protocol requires a web crawler to fetch a special document called <code>robot.txt</code> which contains these declarations from a Web site before downloading any real content from it.</p><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p>If we want to crawl 15 billion pages within four weeks, how many pages do we need to fetch per second:</p><blockquote><p>15B / (4 weeks * 7 days * 86400 seconds) ≈ 6200 pages/second</p></blockquote><p><strong>What about storage</strong>? Page sizes vary a lot, but, as mentioned above since, we will be dealing with HTML text only, let’s assume an average page size of 100KB. With each page, if we are storing 500 bytes of metadata, total storage we would need:</p><blockquote><p>15B * (100KB + 500) ≈ 1.5 petabytes</p></blockquote><p>Assuming a 70% capacity model (we don’t want to go above 70% of the total capacity of our storage system), total storage we will need:</p><blockquote><p>1.5 petabytes / 0.7 ≈ 2.14 petabytes</p></blockquote><h2 id="High-Level-Design"><a href="#High-Level-Design" class="headerlink" title="High-Level Design"></a>High-Level Design</h2><p>The basic algorithm executed by any web crawler is to take a list of seed URLs as its input and repeatedly execute the following steps:</p><ol><li>Pick a URL from the unvisited URL list;</li><li>Determine the IP Address of its host-name;</li><li>Establish a connection to the host to download the corresponding document;</li><li>Parse the document contents to look for new URLs;</li><li>Add the new URLs to the list of unvisited URLs;</li><li>Process the downloaded document, e.g., store it or index its contents, etc.;</li><li>Go back to step 1;</li></ol><h3 id="How-to-Crawl"><a href="#How-to-Crawl" class="headerlink" title="How to Crawl?"></a>How to Crawl?</h3><p><strong>Breadth First Search</strong> (BFS) is usually used. However, Depth First Search (DFS) is also utilized in some situations, such as, if your crawler has already established a connection with the website, it might just DFS all the URLs within this website to save some handshaking overhead.<br><strong>Path-Ascending Crawling</strong> can help discover a lot of isolated resources or resources for which no inbound link would have been found in regular crawling of a particular Web site. In this scheme, a crawler would ascend to every path in each URL that it intends to crawl. For example, when given a seed URL of <a href="http://foo.com/a/b/page.html" target="_blank" rel="noopener">http://foo.com/a/b/page.html</a>, it will attempt to crawl /a/b/, /a/, and /.</p><h3 id="Difficulties-in-Implementing-Efficient-Web-Crawler"><a href="#Difficulties-in-Implementing-Efficient-Web-Crawler" class="headerlink" title="Difficulties in Implementing Efficient Web Crawler"></a>Difficulties in Implementing Efficient Web Crawler</h3><p>There are two important characteristics of the Web that makes Web crawling a very difficult task:</p><ol><li><strong>Large volume of web pages</strong>: A large volume of web pages implies that web crawler can only download a fraction of the web pages at any time and hence it is critical that web crawler should be intelligent enough to prioritize download;</li><li><strong>Rate of change on web pages</strong>: Another problem with today’s dynamic world is that web pages on the internet change very frequently. As a result, by the time the crawler is downloading the last page from a site, the page may change, or a new page may be added to the site;</li></ol><p>A bare minimum crawler needs at least these components:</p><ol><li><strong>URL Frontier</strong>: To store the list of URLs to download and also prioritize which URLs should be crawled first;</li><li><strong>HTML Fetcher</strong>: To retrieve a web page from the server;</li><li><strong>Extractor</strong>: To extract links from HTML documents;</li><li><strong>Duplicate Eliminator</strong>: To make sure the same content is not extracted twice unintentionally;</li><li><strong>Datastore</strong>: To store retrieved pages, URLs, and other metadata;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/58.png" alt></p><h2 id="Detailed-Component-Design"><a href="#Detailed-Component-Design" class="headerlink" title="Detailed Component Design"></a>Detailed Component Design</h2><p>Let’s assume our crawler is running on one server and all the crawling is done by multiple working threads where each working thread performs all the steps needed to download and process a document in a loop.<br>The first step of this loop is to remove an absolute URL from the shared URL frontier for downloading. An absolute URL begins with a scheme (e.g., “HTTP”) which identifies the network protocol that should be used to download it. We can implement these protocols in a modular way for extensibility, so that later if our crawler needs to support more protocols, it can be easily done. Based on the URL’s scheme, the worker calls the appropriate protocol module to download the document. After downloading, the document is placed into a Document Input Stream (DIS). Putting documents into DIS will enable other modules to re-read the document multiple times.<br>Once the document has been written to the DIS, the worker thread invokes the dedupe test to determine whether this document (associated with a different URL) has been seen before. If so, the document is not processed any further and the worker thread removes the next URL from the frontier.<br>Next, our crawler needs to process the downloaded document. Each document can have a different MIME type like HTML page, Image, Video, etc. We can implement these MIME schemes in a modular way, so that later if our crawler needs to support more types, we can easily implement them. Based on the downloaded document’s MIME type, the worker invokes the process method of each processing module associated with that MIME type.<br>Furthermore, our HTML processing module will extract all links from the page. Each link is converted into an absolute URL and tested against a user-supplied URL filter to determine if it should be downloaded. If the URL passes the filter, the worker performs the URL-seen test, which checks if the URL has been seen before, namely, if it is in the URL frontier or has already been downloaded. If the URL is new, it is added to the frontier.</p><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/59.png" alt></p><h3 id="URL-Frontier"><a href="#URL-Frontier" class="headerlink" title="URL Frontier"></a>URL Frontier</h3><p>The URL frontier is the data structure that contains all the URLs that remain to be downloaded. We can crawl by performing a breadth-first traversal of the Web, starting from the pages in the seed set. Such traversals are easily implemented by using a FIFO queue.<br>Since we’ll be having a huge list of URLs to crawl, we can distribute our URL frontier into multiple servers. Let’s assume on each server we have multiple worker threads performing the crawling tasks. Let’s also assume that our hash function maps each URL to a server which will be responsible for crawling it.<br>Following politeness requirements must be kept in mind while designing a distributed URL frontier:</p><ol><li>Our crawler should not overload a server by downloading a lot of pages from it;</li><li>We should not have multiple machines connecting a web server;</li></ol><p>To implement this politeness constraint our crawler can have a collection of distinct FIFO sub-queues on each server. Each worker thread will have its separate sub-queue, from which it removes URLs for crawling. When a new URL needs to be added, the FIFO sub-queue in which it is placed will be determined by the URL’s canonical hostname. Our hash function can map each hostname to a thread number. Together, these two points imply that, at most, one worker thread will download documents from a given Web server, and also, by using the FIFO queue, it’ll not overload a Web server.</p><p><strong>How big will our URL frontier be</strong>? The size would be in the hundreds of millions of URLs. Hence, we need to store our URLs on a disk. We can implement our queues in such a way that they have separate buffers for enqueuing and dequeuing. Enqueue buffer, once filled, will be dumped to the disk, whereas dequeue buffer will keep a cache of URLs that need to be visited; it can periodically read from disk to fill the buffer.</p><h3 id="Fetcher-Module"><a href="#Fetcher-Module" class="headerlink" title="Fetcher Module"></a>Fetcher Module</h3><p>The purpose of a fetcher module is to download the document corresponding to a given URL using the appropriate network protocol like HTTP. As discussed above, Webmasters create robot.txt to make certain parts of their websites off-limits for the crawler. To avoid downloading this file on every request, our crawler’s HTTP protocol module can maintain a fixed-sized cache mapping host-names to their robot’s exclusion rules.</p><h3 id="Document-Input-Stream"><a href="#Document-Input-Stream" class="headerlink" title="Document Input Stream"></a>Document Input Stream</h3><p>Our crawler’s design enables the same document to be processed by multiple processing modules. To avoid downloading a document multiple times, we cache the document locally using an abstraction called a Document Input Stream (DIS).<br>A DIS is an input stream that caches the entire contents of the document read from the internet. It also provides methods to re-read the document. The DIS can cache small documents (64KB or less) entirely in memory, while larger documents can be temporarily written to a backing file.<br>Each worker thread has an associated DIS, which it reuses from document to document. After extracting a URL from the frontier, the worker passes that URL to the relevant protocol module, which initializes the DIS from a network connection to contain the document’s contents. The worker then passes the DIS to all relevant processing modules.</p><h3 id="Document-Dedupe-Test"><a href="#Document-Dedupe-Test" class="headerlink" title="Document Dedupe Test"></a>Document Dedupe Test</h3><p>Many documents on the Web are available under multiple, different URLs. There are also many cases in which documents are mirrored on various servers. Both of these effects will cause any web crawler to download the same document multiple times. To prevent the processing of a document more than once, we perform a dedupe test on each document to remove duplication.<br>To perform this test, we can calculate a 64-bit checksum of every processed document and store it in a database. For every new document, we can compare its checksum to all the previously calculated checksums to see the document has been seen before. We can use MD5 or SHA to calculate these checksums.</p><p><strong>How big would the checksum store be</strong>? If the whole purpose of our checksum store is to do dedupe, then we just need to keep a unique set containing checksums of all previously processed document. Considering 15 billion distinct web pages, we would need:</p><blockquote><p>15B * 8 bytes = 120 GB</p></blockquote><p>Although this can fit into a modern-day server’s memory, if we don’t have enough memory available, we can keep smaller LRU based cache on each server with everything backed by persistent storage. The dedupe test first checks if the checksum is present in the cache. If not, it has to check if the checksum resides in the back storage. If the checksum is found, we will ignore the document. Otherwise, it will be added to the cache and back storage.</p><h3 id="URL-Filter"><a href="#URL-Filter" class="headerlink" title="URL Filter"></a>URL Filter</h3><p>The URL filtering mechanism provides a customizable way to control the set of URLs that are downloaded. This is used to blacklist websites so that our crawler can ignore them. Before adding each URL to the frontier, the worker thread consults the user-supplied URL filter. We can define filters to restrict URLs by domain, prefix, or protocol type.</p><h3 id="Domain-Name-Resolution"><a href="#Domain-Name-Resolution" class="headerlink" title="Domain Name Resolution"></a>Domain Name Resolution</h3><p>Before contacting a Web server, a web crawler must use the Domain Name Service (DNS) to map the Web server’s hostname into an IP address. DNS name resolution will be a big bottleneck of our crawlers given the amount of URLs we will be working with. To avoid repeated requests, we can start caching DNS results by building our local DNS server.</p><h3 id="URL-Dedupe-Test"><a href="#URL-Dedupe-Test" class="headerlink" title="URL Dedupe Test"></a>URL Dedupe Test</h3><p>While extracting links, any web crawler will encounter multiple links to the same document. To avoid downloading and processing a document multiple times, a URL dedupe test must be performed on each extracted link before adding it to the URL frontier.<br>To perform the URL dedupe test, we can store all the URLs seen by our crawler in canonical form in a database. To save space, we do not store the textual representation of each URL in the URL set, but rather a fixed-sized checksum.<br>To reduce the number of operations on the database store, we can keep an in-memory cache of popular URLs on each host shared by all threads. The reason to have this cache is that links to some URLs are quite common, so caching the popular ones in memory will lead to a high in-memory hit rate.</p><p><strong>How much storage we would need for URL’s store</strong>? If the whole purpose of our checksum is to do URL dedupe, then we just need to keep a unique set containing checksums of all previously seen URLs. Considering 15 billion distinct URLs and 4 bytes for checksum, we would need:</p><blockquote><p>15B * 4 bytes = 60 GB</p></blockquote><p><strong>Can we use bloom filters for deduping</strong>? Bloom filters are a probabilistic data structure for set membership testing that may yield false positives. A large bit vector represents the set. An element is added to the set by computing “n” hash functions of the element and setting the corresponding bits. An element is deemed to be in the set if the bits at all “n” of the element’s hash locations are set. Hence, a document may incorrectly be deemed to be in the set, but false negatives are not possible.<br>The disadvantage of using a bloom filter for the URL seen test is that each false positive will cause the URL not to be added to the frontier and, therefore, the document will never be downloaded. The chance of a false positive can be reduced by making the bit vector larger.</p><h3 id="Checkpointing"><a href="#Checkpointing" class="headerlink" title="Checkpointing"></a>Checkpointing</h3><p>A crawl of the entire Web takes weeks to complete. To guard against failures, our crawler can write regular snapshots of its state to the disk. An interrupted or aborted crawl can easily be restarted from the latest checkpoint.</p><h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p>We should use consistent hashing for distribution among crawling servers. Consistent hashing will not only help in replacing a dead host but also help in distributing load among crawling servers.<br>All our crawling servers will be performing regular checkpointing and storing their FIFO queues to disks. If a server goes down, we can replace it. Meanwhile, consistent hashing should shift the load to other servers.</p><h2 id="Data-Partitioning"><a href="#Data-Partitioning" class="headerlink" title="Data Partitioning"></a>Data Partitioning</h2><p>Our crawler will be dealing with three kinds of data:</p><ol><li>URLs to visit;</li><li>URL checksums for dedupe;</li><li>Document checksums for dedupe;</li></ol><p>Since we are distributing URLs based on the hostnames, we can store these data on the same host. So, each host will store its set of URLs that need to be visited, checksums of all the previously visited URLs, and checksums of all the downloaded documents. Since we will be using consistent hashing, we can assume that URLs will be redistributed from overloaded hosts.<br>Each host will perform checkpointing periodically and dump a snapshot of all the data it is holding onto a remote server. This will ensure that if a server dies down another server can replace it by taking its data from the last snapshot.</p><h2 id="Crawler-Traps"><a href="#Crawler-Traps" class="headerlink" title="Crawler Traps"></a>Crawler Traps</h2><p>There are many crawler traps, spam sites, and cloaked content. A crawler trap is a URL or set of URLs that cause a crawler to crawl indefinitely. Some crawler traps are unintentional. For example, a symbolic link within a file system can create a cycle. Other crawler traps are introduced intentionally. For example, people have written traps that dynamically generate an infinite Web documents. The motivations behind such traps vary. Anti-spam traps are designed to catch crawlers used by spammers looking for email addresses, while other sites use traps to catch search engine crawlers to boost their search ratings.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Twitter Search</title>
      <link href="2021/02/24/Designing-Twitter-Search/"/>
      <url>2021/02/24/Designing-Twitter-Search/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Twitter-Search"><a href="#What-is-Twitter-Search" class="headerlink" title="What is Twitter Search?"></a>What is Twitter Search?</h2><p>Twitter users can update their status whenever they like. Each status (called tweet) consists of plain text and our goal is to design a system that allows searching over all the user tweets.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>We need to design a system that can efficiently store and query tweets:</p><ul><li>Let’s assume Twitter has 1.5 billion total users with 800 million daily active users;</li><li>On average Twitter gets 400 million tweets every day;</li><li>The average size of a tweet is 300 bytes;</li><li>Let’s assume there will be 500M searches every day;</li><li>The search query will consist of multiple words combined with AND/OR;</li></ul><a id="more"></a><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p>Since we have 400 million new tweets every day and each tweet on average is 300 bytes, the total storage we need, will be:</p><blockquote><p>400M * 300 = 120 GB/day</p></blockquote><p>Total storage per second:</p><blockquote><p>120 GB / 24 hours / 3600 seconds ≈ 1.38 MB/second</p></blockquote><h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><p>We can have SOAP or REST APIs to expose the functionality of our service; following could be the definition of the search API:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">search(api_dev_key, search_terms, maximum_results_to_return, sort, page_token)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota;</li><li>search_terms: A string containing the search terms;</li><li>maximum_results_to_return: Number of tweets to return;</li><li>sort: Optional; Latest First (0, default), Best Matched (1), Most Liked (2);</li><li>page_token: This token will specify a page in the result set that should be returned;</li></ul><p><strong>Return</strong>: A JSON containing information about a list of tweets matching the search query. Each result entry can have the user ID &amp; name, tweet text, tweet ID, creation time, number of likes, etc.</p><h2 id="High-Level-Design"><a href="#High-Level-Design" class="headerlink" title="High-Level Design"></a>High-Level Design</h2><p>At the high level, we need to store all the tweets in a database and also build an index that can keep track of which word appears in which tweet. This index will help us quickly find tweets that the users are trying to search for:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/56.png" alt></p><h2 id="Detailed-Component-Design"><a href="#Detailed-Component-Design" class="headerlink" title="Detailed Component Design"></a>Detailed Component Design</h2><h3 id="Storage"><a href="#Storage" class="headerlink" title="Storage"></a>Storage</h3><p>We need to store 120GB of new data every day. Given this huge amount of data, we need to come up with a data partitioning scheme that will be efficiently distributing the data onto multiple servers. If we plan for next five years, we will need the following storage:</p><blockquote><p>120 GB * 365 days * 5 years ≈ 200 TB</p></blockquote><p>If we never want to be more than 80% full at any time, we approximately will need 250TB of total storage. Let’s assume that we want to keep an extra copy of all tweets for fault tolerance; then, our total storage requirement will be 500TB. If we assume a modern server can store up to 4TB of data, we would need 125 such servers to hold all of the required data for the next five years.<br>Let’s start with a simplistic design where we store the tweets in a MySQL database. We can assume that we store the tweets in a table having two columns, TweetID and TweetText. Let’s assume we partition our data based on TweetID. If our TweetIDs are unique system-wide, we can define a hash function that can map a TweetID to a storage server where we can store that tweet object.</p><p><strong>How can we create system-wide unique TweetIDs</strong>? If we are getting 400M new tweets each day, then how many tweet objects we can expect in five years:</p><blockquote><p>400M * 365 days * 5 years = 730 billion</p></blockquote><p>This means we would need a five bytes number to identify TweetIDs uniquely. Let’s assume we have a service that can generate a unique TweetID whenever we need to store an object. We can feed the TweetID to our hash function to find the storage server and store our tweet object there.</p><h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>What should our index look like? Since our tweet queries will consist of words, let’s build the index that can tell us which word comes in which tweet object. Let’s first estimate how big our index will be. If we want to build an index for all the English words and some famous nouns like people names, city names, etc., and if we assume that we have around 300K English words and 200K nouns, then we will have 500k total words in our index. Let’s assume that the average length of a word is five characters. If we are keeping our index in memory, we need 2.5MB of memory to store all the words:</p><blockquote><p>500K * 5 = 2.5 MB</p></blockquote><p>Let’s assume that we want to keep the index in memory for all the tweets from only past two years. Since we will be getting 730B tweets in 5 years, this will give us 292B tweets in two years. Given that each TweetID will be 5 bytes, how much memory will we need to store all the TweetIDs:</p><blockquote><p>292B * 5 = 1460 GB</p></blockquote><p>So our index would be like a big distributed hash table, where “key” would be the word and “value” will be a list of TweetIDs of all those tweets which contain that word. Assuming on average we have 40 words in each tweet and since we will not be indexing prepositions and other small words like “the”, “an”, “and” etc., let’s assume we will have around 15 words in each tweet that need to be indexed. This means each TweetID will be stored 15 times in our index. So total memory we will need to store our index:</p><blockquote><p>(1460 * 15) GB + 2.5MB ≈ 21 TB</p></blockquote><p>Assuming a high-end server has 144GB of memory, we would need 152 such servers to hold our index.</p><h3 id="Partition"><a href="#Partition" class="headerlink" title="Partition"></a>Partition</h3><p>We can partition our data based on two criteria:<br><strong>Sharding based on Words</strong>: While building our index, we will iterate through all the words of a tweet and calculate the hash of each word to find the server where it would be indexed. To find all tweets containing a specific word we have to query only the server which contains this word.<br>We have a couple of issues with this approach:</p><ol><li>What if a word becomes hot? Then there will be a lot of queries on the server holding that word. This high load will affect the performance of our service;</li><li>Over time, some words can end up storing a lot of TweetIDs compared to others, therefore, maintaining a uniform distribution of words while tweets are growing is quite tricky;</li></ol><p>To recover from these situations we either have to repartition our data or use Consistent Hashing.</p><p><strong>Sharding based on the tweet object</strong>: While storing, we will pass the TweetID to our hash function to find the server and index all the words of the tweet on that server. While querying for a particular word, we have to query all the servers, and each server will return a set of TweetIDs. A centralized server will aggregate these results to return them to the user:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/57.png" alt></p><h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p>What will happen when an index server dies? We can have a secondary replica of each server and if the primary server dies it can take control after the failover. Both primary and secondary servers will have the same copy of the index.<br>What if both primary and secondary servers die at the same time? We have to allocate a new server and rebuild the same index on it. How can we do that? We don’t know what words/tweets were kept on this server. If we were using “Sharding based on the tweet object”, the brute-force solution would be to iterate through the whole database and filter TweetIDs using our hash function to figure out all the required tweets that would be stored on this server. This would be inefficient and also during the time when the server was being rebuilt we would not be able to serve any query from it, thus missing some tweets that should have been seen by the user.</p><p>How can we efficiently retrieve a mapping between tweets and the index server? We have to build a reverse index that will map all the TweetID to their index server. Our Index-Builder server can hold this information. We will need to build a Hash Table where the “key” will be the index server number and the “value” will be a HashSet containing all the TweetIDs being kept at that index server. Notice that we are keeping all the TweetIDs in a HashSet; this will enable us to add/remove tweets from our index quickly. So now, whenever an index server has to rebuild itself, it can simply ask the Index-Builder server for all the tweets it needs to store and then fetch those tweets to build the index. This approach will surely be fast. We should also have a replica of the Index-Builder server for fault tolerance.</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>To deal with hot tweets we can introduce a cache in front of our database. We can use Memcached, which can store all such hot tweets in memory. Application servers, before hitting the backend database, can quickly check if the cache has that tweet. Based on clients’ usage patterns, we can adjust how many cache servers we need. For cache eviction policy, Least Recently Used (LRU) seems suitable for our system.</p><h2 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h2><p>We can add a load balancing layer at two places in our system:</p><ol><li>Between Clients and Application Servers;</li><li>Between Application Servers and Backend Servers;</li></ol><p>Initially, a simple Round Robin approach can be adopted; that distributes incoming requests equally among backend servers. This LB is simple to implement and does not introduce any overhead. Another benefit of this approach is LB will take dead servers out of the rotation and will stop sending any traffic to it. A problem with Round Robin LB is it won’t take server load into consideration. If a server is overloaded or slow, the LB will not stop sending new requests to that server. To handle this, a more intelligent LB solution can be placed that periodically queries the backend server about their load and adjust traffic based on that.</p><h2 id="Ranking"><a href="#Ranking" class="headerlink" title="Ranking"></a>Ranking</h2><p>How about if we want to rank the search results by social graph distance, popularity, relevance, etc?<br>Let’s assume we want to rank tweets by popularity, like how many likes or comments a tweet is getting, etc. In such a case, our ranking algorithm can calculate a “popularity number” (based on the number of likes, etc.) and store it with the index. Each partition can sort the results based on this popularity number before returning results to the aggregator server. The aggregator server combines all these results, sorts them based on the popularity number, and sends the top results to the user.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing an API Rate Limiter</title>
      <link href="2021/02/20/Designing-an-API-Rate-Limiter/"/>
      <url>2021/02/20/Designing-an-API-Rate-Limiter/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-a-Rate-Limiter"><a href="#What-is-a-Rate-Limiter" class="headerlink" title="What is a Rate Limiter?"></a>What is a Rate Limiter?</h2><p>Imagine we have a service which is receiving a huge number of requests, but it can only serve a limited number of requests per second. To handle this problem we would need some kind of throttling or rate limiting mechanism that would allow only a certain number of requests so our service can respond to all of them. A rate limiter, at a high level, limits the number of events an entity (user, device, IP, etc.) can perform in a particular time window. For example:</p><ul><li>A user can send only one message per second;</li><li>A user is allowed only three failed credit card transactions per day;</li><li>A single IP can only create twenty accounts per day;</li></ul><p>In general, a rate limiter caps how many requests a sender can issue in a specific time window. It then blocks requests once the cap is reached.</p><a id="more"></a><h2 id="Why-do-We-Need-API-Rate-Limiting"><a href="#Why-do-We-Need-API-Rate-Limiting" class="headerlink" title="Why do We Need API Rate Limiting?"></a>Why do We Need API Rate Limiting?</h2><p>Rate Limiting helps to protect services against abusive behaviors targeting the application layer like Denial-of-Service (DoS) attacks, brute-force password attempts, brute-force credit card transactions, etc. These attacks are usually a barrage of HTTP/S requests which may look like they are coming from real users, but are typically generated by machines (or bots). As a result, these attacks are often harder to detect and can more easily bring down a service, application, or an API.<br>Rate limiting is also used to prevent revenue loss, to reduce infrastructure costs, to stop spam, and to stop online harassment. Following is a list of scenarios that can benefit from Rate limiting by making a service (or API) more reliable:</p><ul><li><strong>Misbehaving clients/scripts</strong>: Either intentionally or unintentionally, some entities can overwhelm a service by sending a large number of requests. Another scenario could be when a user is sending a lot of lower-priority requests and we want to make sure that it doesn’t affect the high-priority traffic. For example, users sending a high volume of requests for analytics data should not be allowed to hamper critical transactions for other users;</li><li><strong>Security</strong>: By limiting the number of the second-factor attempts (in 2-factor auth) that the users are allowed to perform, for example, the number of times they’re allowed to try with a wrong password;</li><li><strong>To prevent abusive behavior and bad design practices</strong>: Without API limits, developers of client applications would use sloppy development tactics, for example, requesting the same information over and over again;</li><li><strong>To keep costs and resource usage under control</strong>: Services are generally designed for normal input behavior, for example, a user writing a single post in a minute. Computers could easily push thousands/second through an API. Rate limiter enables controls on service APIs;</li><li><strong>Revenue:</strong> Certain services might want to limit operations based on the tier of their customer’s service and thus create a revenue model based on rate limiting. There could be default limits for all the APIs a service offers. To go beyond that, the user has to buy higher limits;</li><li><strong>To eliminate spikiness in traffic</strong>: Make sure the service stays up for everyone else;</li></ul><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>Our Rate Limiter should meet the following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Limit the number of requests an entity can send to an API within a time window, e.g., 15 requests per second;</li><li>The APIs are accessible through a cluster, so the rate limit should be considered across different servers. The user should get an error message whenever the defined threshold is crossed within a single server or across a combination of servers;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>The system should be highly available. The rate limiter should always work since it protects our service from external attacks;</li><li>Our rate limiter should not introduce substantial latencies affecting the user experience;</li></ol><h2 id="How-to-Do-Rate-Limiting"><a href="#How-to-Do-Rate-Limiting" class="headerlink" title="How to Do Rate Limiting?"></a>How to Do Rate Limiting?</h2><p>Rate Limiting is a process that is used to define the rate and speed at which consumers can access APIs. <code>Throttling</code> is the process of controlling the usage of the APIs by customers during a given period. Throttling can be defined at the application level and/or API level. When a throttle limit is crossed, the server returns HTTP status “429 - Too many requests”.</p><h2 id="What-are-Different-Types-of-Throttling"><a href="#What-are-Different-Types-of-Throttling" class="headerlink" title="What are Different Types of Throttling?"></a>What are Different Types of Throttling?</h2><p>Here are the three famous throttling types that are used by different services:</p><ul><li><strong>Hard Throttling</strong>: The number of API requests cannot exceed the throttle limit;</li><li><strong>Soft Throttling</strong>: In this type, we can set the API request limit to exceed a certain percentage. For example, if we have rate-limit of 100 messages a minute and 10% exceed-limit, our rate limiter will allow up to 110 messages per minute;</li><li><strong>Elastic or Dynamic Throttling</strong>: Under Elastic throttling, the number of requests can go beyond the threshold if the system has some resources available. For example, if a user is allowed only 100 messages a minute, we can let the user send more than 100 messages a minute when there are free resources available in the system;</li></ul><h2 id="What-are-Different-Types-of-Algorithms-Used-for-Rate-Limiting"><a href="#What-are-Different-Types-of-Algorithms-Used-for-Rate-Limiting" class="headerlink" title="What are Different Types of Algorithms Used for Rate Limiting?"></a>What are Different Types of Algorithms Used for Rate Limiting?</h2><p>Following are the two types of algorithms used for Rate Limiting:</p><ul><li><strong>Fixed Window Algorithm</strong>: In this algorithm, the time window is considered from the start of the time-unit to the end of the time-unit. For example, a period would be considered 0-60 seconds for a minute irrespective of the time frame at which the API request has been made. In the diagram below, there are two messages between 0-1 second and three messages between 1-2 seconds. If we have a rate limiting of two messages a second, this algorithm will throttle only “m5”;</li><li><strong>Sliding Window Algorithm</strong>: In this algorithm, the time window is considered from the fraction of the time at which the request is made plus the time window length. For example, if there are two messages sent at the 300th millisecond and 400th millisecond of a second, we’ll count them as two messages from the 300th millisecond of that second up to the 300th millisecond of next second. In the above diagram, keeping two messages a second, we’ll throttle “m3” and “m4”;</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/49.png" alt></p><h2 id="High-Level-Design-for-Rate-Limiter"><a href="#High-Level-Design-for-Rate-Limiter" class="headerlink" title="High-Level Design for Rate Limiter"></a>High-Level Design for Rate Limiter</h2><p>Rate Limiter will be responsible for deciding which request will be served by the API servers and which request will be declined. Once a new request arrives, the Web Server first asks the Rate Limiter to decide if it will be served or throttled. If the request is not throttled, then it’ll be passed to the API servers:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/50.png" alt></p><h2 id="Basic-System-Design-and-Algorithm"><a href="#Basic-System-Design-and-Algorithm" class="headerlink" title="Basic System Design and Algorithm"></a>Basic System Design and Algorithm</h2><p>Let’s take the example where we want to limit the number of requests per user. Under this scenario, for each unique user, we would keep a count representing how many requests the user has made and a timestamp when we started counting the requests. We can keep it in a hash-table, where the “key” would be the “UserID” and “value” would be a structure containing an integer for the “Count” and an integer for the Epoch time:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserID:  &#123;Count, StartTime&#125;</span><br><span class="line">Kristie: &#123;<span class="number">3</span>    , <span class="number">1499818564</span>&#125;</span><br></pre></td></tr></table></figure><p>Let’s assume our rate limiter is allowing three requests per minute per user, so whenever a new request comes in, our rate limiter will perform the following steps:</p><ol><li>If the “UserID” is not present in the hash-table, insert it, set the “Count” to 1, set “StartTime” to the current time (normalized to a minute), and allow the request;</li><li>Otherwise, find the record of the “UserID” and if “CurrentTime – StartTime &gt;= 1 min”, set the “StartTime” to the current time, “Count” to 1, and allow the request;</li><li>If “CurrentTime - StartTime &lt;= 1 min” and:<ul><li>If “Count &lt; 3”, increment the Count and allow the request;</li><li>If “Count &gt;= 3”, reject the request;</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/51.png" alt></p><p><strong>What are some of the problems with our algorithm</strong>?<br>This is a <strong>Fixed Window</strong> algorithm since we’re resetting the “StartTime” at the end of every minute, which means it can potentially allow twice the number of requests per minute. Imagine if Kristie sends three requests at the last second of a minute, then she can immediately send three more requests at the very first second of the next minute, resulting in 6 requests in the span of two seconds:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/52.png" alt></p><p><strong>Atomicity</strong>: In a distributed environment, the “read-and-then-write” behavior can create a race condition. Imagine if Kristie’s current “Count” is “2” and that she issues two more requests. If two separate processes served each of these requests and concurrently read the Count before either of them updated it, each process would think that Kristie could have one more request and that she had not hit the rate limit:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/53.png" alt></p><p>If we are using Redis to store our key-value, one solution to resolve the atomicity problem is to use <code>Distributed Lock</code> for the duration of the read-update operation. This, however, would come at the expense of slowing down concurrent requests from the same user and introducing another layer of complexity. We can use Memcached, but it would have comparable complications.<br>If we are using a simple hash-table, we can have a custom implementation for “locking” each record to solve our atomicity problems.</p><p><strong>How much memory would we need to store all of the user data</strong>? Let’s assume the simple solution where we are keeping all of the data in a hash-table.<br>Let’s assume “UserID” takes 8 bytes. Let’s also assume a 2 byte “Count”, which can count up to 65k, is sufficient for our use case. Although epoch time will need 4 bytes, we can choose to store only the minute and second part, which can fit into 2 bytes. Hence, we need a total of 12 bytes to store a user’s data:</p><blockquote><p>8 + 2 + 2 = 12 bytes</p></blockquote><p>Let’s assume our hash-table has an overhead of 20 bytes for each record. If we need to track one million users at any time, the total memory we would need would be 32MB:</p><blockquote><p>(12 + 20) bytes * 1 million = 32 MB</p></blockquote><p>If we assume that we would need a 4-byte number to lock each user’s record to resolve our atomicity problems, we would require a total 36MB memory.<br>This can easily fit on a single server; however we would not like to route all of our traffic through a single machine. Also, if we assume a rate limit of 10 requests per second, this would translate into 10 million QPS for our rate limiter! This would be too much for a single server. Practically, we can assume we would use a Redis or Memcached kind of a solution in a distributed setup. We’ll be storing all the data in the remote Redis servers and all the Rate Limiter servers will read (and update) these servers before serving or throttling any request.</p><h2 id="Sliding-Window-Algorithm"><a href="#Sliding-Window-Algorithm" class="headerlink" title="Sliding Window Algorithm"></a>Sliding Window Algorithm</h2><p>We can maintain a sliding window if we can keep track of each request per user. We can store the timestamp of each request in a Redis <code>Sorted Set</code> in our “value” field of hash-table:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UserID:  &#123;Sorted Set&lt;UnixTime&gt;&#125;</span><br><span class="line">Kristie: &#123;<span class="number">1499818000</span>, <span class="number">1499818500</span>, <span class="number">1499818860</span>&#125;</span><br></pre></td></tr></table></figure><p>Let’s assume our rate limiter is allowing three requests per minute per user, so, whenever a new request comes in, the Rate Limiter will perform following steps:</p><ol><li>Remove all the timestamps from the Sorted Set that are older than “CurrentTime - 1 minute”;</li><li>Count the total number of elements in the sorted set. Reject the request if this count is greater than our throttling limit of “3”;</li><li>Insert the current time in the sorted set and accept the request;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/54.png" alt></p><p><strong>How much memory would we need to store all of the user data for sliding window</strong>? Let’s assume “UserID” takes 8 bytes. Each epoch time will require 4 bytes. Let’s suppose we need a rate limiting of 500 requests per hour. Let’s assume 20 bytes overhead for hash-table and 20 bytes overhead for the Sorted Set. At max, we would need a total of 12KB to store one user’s data:</p><blockquote><p>8 + (4 + 20 (sorted set overhead)) * 500 + 20 (hash-table overhead) ≈ 12 KB</p></blockquote><p>Here we are reserving 20 bytes overhead per element. In a sorted set, we can assume that we need at least two pointers to maintain order among elements — one pointer to the previous element and one to the next element. On a 64bit machine, each pointer will cost 8 bytes. So we will need 16 bytes for pointers. We added an extra word (4 bytes) for storing other overhead.<br>If we need to track one million users at any time, total memory we would need would be 12GB:</p><blockquote><p>12KB * 1 million = 12 GB</p></blockquote><p>Sliding Window Algorithm takes a lot of memory compared to the Fixed Window; this would be a scalability issue.</p><h2 id="Sliding-Window-with-Counters"><a href="#Sliding-Window-with-Counters" class="headerlink" title="Sliding Window with Counters"></a>Sliding Window with Counters</h2><p>What if we keep track of request counts for each user using multiple fixed time windows, e.g., 1/60th the size of our rate limit’s time window. For example, if we have an hourly rate limit we can keep a count for each minute and calculate the sum of all counters in the past hour when we receive a new request to calculate the throttling limit. This would reduce our memory footprint. Let’s take an example where we rate-limit at 500 requests per hour with an additional limit of 10 requests per minute. This means that when the sum of the counters with timestamps in the past hour exceeds the request threshold (500), Kristie has exceeded the rate limit. In addition to that, she can’t send more than ten requests per minute. This would be a reasonable and practical consideration, as none of the real users would send frequent requests. Even if they do, they will see success with retries since their limits get reset every minute.</p><p>We can store our counters in a <code>Redis Hash</code> since it offers incredibly efficient storage for fewer than 100 keys. When each request increments a counter in the hash, it also sets the hash to expire an hour later. We will normalize each “time” to a minute:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/55.png" alt></p><p><strong>How much memory we would need to store all the user data for sliding window with counters</strong>? Let’s assume “UserID” takes 8 bytes. Each epoch time will need 4 bytes, and the Counter would need 2 bytes. Let’s suppose we need a rate limiting of 500 requests per hour. Assume 20 bytes overhead for hash-table and 20 bytes for Redis hash. Since we’ll keep a count for each minute, at max, we would need 60 entries for each user. We would need a total of 1.6KB to store one user’s data:</p><blockquote><p>8 + (4 + 2 + 20 (Redis hash overhead)) * 60 + 20 (hash-table overhead) ≈ 1.6 KB</p></blockquote><p>If we need to track one million users at any time, total memory we would need would be 1.6GB:</p><blockquote><p>1.6KB * 1 million = 1.6 GB</p></blockquote><p>So, our “Sliding Window with Counters” algorithm uses 86% less memory than the simple sliding window algorithm.</p><h2 id="Data-Sharding-and-Caching"><a href="#Data-Sharding-and-Caching" class="headerlink" title="Data Sharding and Caching"></a>Data Sharding and Caching</h2><p>We can shard based on the “UserID” to distribute the user’s data. For fault tolerance and replication we should use Consistent Hashing. If we want to have different throttling limits for different APIs, we can choose to shard per user per API. Take the example of URL Shortening Service; we can have different rate limiter for createURL() and deleteURL() APIs for each user or IP.<br>If our APIs are partitioned, a practical consideration could be to have a separate (somewhat smaller) rate limiter for each API shard as well. Let’s take the example of our URL Shortening Service where we want to limit each user not to create more than 100 short URLs per hour. Assuming we are using Hash-Based Partitioning for our createURL() API, we can rate limit each partition to allow a user to create not more than three short URLs per minute in addition to 100 short URLs per hour.</p><p>Our system can get huge benefits from caching recent active users. Application servers can quickly check if the cache has the desired record before hitting backend servers. Our rate limiter can significantly benefit from the write-back cache by updating all counters and timestamps in cache only. The write to the permanent storage can be done at fixed intervals. This way we can ensure minimum latency added to the user’s requests by the rate limiter. The reads can always hit the cache first; which will be extremely useful once the user has hit their maximum limit and the rate limiter will only be reading data without any updates.</p><h2 id="Should-We-Rate-Limit-by-IP-or-by-User"><a href="#Should-We-Rate-Limit-by-IP-or-by-User" class="headerlink" title="Should We Rate Limit by IP or by User?"></a>Should We Rate Limit by IP or by User?</h2><p>Let’s discuss the pros and cons of using each one of these schemes:</p><ul><li><strong>IP</strong>: In this scheme, we throttle requests per-IP; although it’s not optimal in terms of differentiating between “good” and “bad” actors, it’s still better than not have rate limiting at all. The biggest problem with IP based throttling is when multiple users share a single public IP like in an internet cafe or smartphone users that are using the same gateway. One bad user can cause throttling to other users. Another issue could arise while caching IP-based limits, as there are a huge number of IPv6 addresses available to a hacker from even one computer, it’s trivial to make a server run out of memory tracking IPv6 addresses;</li><li><strong>User</strong>: Rate limiting can be done on APIs after user authentication. Once authenticated, the user will be provided with a token which the user will pass with each request. This will ensure that we will rate limit against a particular API that has a valid authentication token. But what if we have to rate limit on the login API itself? The weakness of this rate-limiting would be that a hacker can perform a denial of service attack against a user by entering wrong credentials up to the limit; after that the actual user will not be able to log-in;</li></ul><p><strong>How about if we combine the above two schemes</strong>?<br><strong>Hybrid</strong>: A right approach could be to do both per-IP and per-user rate limiting, as they both have weaknesses when implemented alone, though, this will result in more cache entries with more details per entry, hence requiring more memory and storage.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Typeahead Suggestion</title>
      <link href="2021/02/18/Designing-Typeahead-Suggestion/"/>
      <url>2021/02/18/Designing-Typeahead-Suggestion/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Typeahead-Suggestion"><a href="#What-is-Typeahead-Suggestion" class="headerlink" title="What is Typeahead Suggestion?"></a>What is Typeahead Suggestion?</h2><p>Typeahead suggestions enable users to search for known and frequently searched terms. As the user types into the search box, it tries to predict the query based on the characters the user has entered and gives a list of suggestions to complete the query. Typeahead suggestions help the user to articulate their search queries better. It’s not about speeding up the search process but rather about guiding the users and lending them a helping hand in constructing their search query.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><ul><li><strong>Functional Requirements</strong>: As the user types in their query, our service should suggest top 10 terms starting with whatever the user has typed;</li><li><strong>Non-Function Requirements</strong>: The suggestions should appear in real-time. The user should be able to see the suggestions within 200ms;</li></ul><a id="more"></a><h2 id="Basic-System-Design-and-Algorithm"><a href="#Basic-System-Design-and-Algorithm" class="headerlink" title="Basic System Design and Algorithm"></a>Basic System Design and Algorithm</h2><p>The problem we are trying to solve is that we have a lot of “strings” that we need to store in such a way that users can search with any prefix. Our service will suggest the next terms matching the given prefix. For example, if our database contains the following terms: cap, cat, captain, or capital, and the user has typed in “cap”, our system should suggest “cap”, “captain” and “capital”.<br>As we have to serve a lot of queries with minimum latency, we need to come up with a scheme that can efficiently store our data such that it can be queried quickly. We can’t depend upon some database for this; we need to store our index in memory in a highly efficient data structure.<br>One of the most appropriate data structures that can serve our purpose is the Trie. A trie is a tree-like data structure used to store phrases where each node stores a character of the phrase in a sequential manner. For example, if we need to store “cap, cat, caption, captain, capital” in the trie, it would look like:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/46.png" alt></p><p>Now if the user has typed “cap”, our service can traverse the trie to go to the node “P” to find all the terms that start with this prefix (e.g., cap-tion, cap-ital, etc.).<br>We can merge nodes that have only one branch to save storage space. The above trie can be stored like this:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/47.png" alt></p><p><strong>Should we have case insensitive trie</strong>? For simplicity and search use case, let’s assume our data is case insensitive.</p><p><strong>How to find top suggestion</strong>? Now that we can find all the terms for a given prefix, how can we find the top 10 terms for the given prefix? One simple solution could be to store the count of searches that terminated at each node, e.g., if users have searched about “CAPTAIN” 100 times and “CAPTION” 500 times, we can store this number with the last character of the phrase. Now if the user types “CAP” we know the top most searched word under the prefix “CAP” is “CAPTION”. So, to find the top suggestions for a given prefix, we can traverse the sub-tree under it.</p><p><strong>Given a prefix, how much time will it take to traverse its sub-tree</strong>? Given the amount of data we need to index, we should expect a huge tree. Even traversing a sub-tree would take really long, e.g., the phrase “system design interview questions” is 30 levels deep. Since we have very strict latency requirements we do need to improve the efficiency of our solution.</p><p><strong>Can we store top suggestions with each node</strong>? This can surely speed up our searches but will require a lot of extra storage. We can store top 10 suggestions at each node that we can return to the user. We have to bear the big increase in our storage capacity to achieve the required efficiency.<br>We can optimize our storage by storing only references of the terminal nodes rather than storing the entire phrase. To find the suggested terms we need to traverse back using the parent reference from the terminal node. We will also need to store the frequency with each reference to keep track of top suggestions.</p><p><strong>How would we build this trie</strong>? We can efficiently build our trie bottom up. Each parent node will recursively call all the child nodes to calculate their top suggestions and their counts. Parent nodes will combine top suggestions from all of their children to determine their top suggestions.</p><p><strong>How to update the trie</strong>? Assuming five billion searches every day, which would give us approximately 60K queries per second. If we try to update our trie for every query it’ll be extremely resource intensive and this can hamper our read requests, too. One solution to handle this could be to update our trie offline after a certain interval.<br>As the new queries come in we can log them and also track their frequencies. Either we can log every query or do sampling and log every 1000th query. For example, if we don’t want to show a term which is searched for less than 1000 times, it’s safe to log every 1000th searched term.<br>We can have a Map Reduce set-up to process all the logging data periodically say every hour. These MR jobs will calculate frequencies of all searched terms in the past hour. We can then update our trie with this new data. We can take the current snapshot of the trie and update it with all the new terms and their frequencies. We should do this offline as we don’t want our read queries to be blocked by update trie requests. We can have two options:</p><ol><li>We can make a copy of the trie on each server to update it offline. Once done we can switch to start using it and discard the old one;</li><li>We can have a primary-secondary configuration for each trie server. We can update the secondary while the primary is serving traffic. Once the update is complete, we can make the secondary our new primary. We can later update our old primary, which can then start serving traffic, too;</li></ol><p><strong>How can we update the frequencies of typeahead suggestions</strong>? Since we are storing frequencies of our typeahead suggestions with each node, we need to update them too! We can update only differences in frequencies rather than recounting all search terms from scratch. If we’re keeping count of all the terms searched in the last 10 days, we’ll need to subtract the counts from the time period no longer included and add the counts for the new time period being included. We can add and subtract frequencies based on Exponential Moving Average of each term. In EMA, we give more weight to the latest data. It’s also known as the exponentially weighted moving average.<br>After inserting a new term in the trie, we’ll go to the terminal node of the phrase and increase its frequency. Since we’re storing the top 10 queries in each node, it is possible that this particular search term jumped into the top 10 queries of a few other nodes. So, we need to update the top 10 queries of those nodes then. We have to traverse back from the node to all the way up to the root. For every parent, we check if the current query is part of the top 10. If so, we update the corresponding frequency. If not, we check if the current query’s frequency is high enough to be a part of the top 10. If so, we insert this new term and remove the term with the lowest frequency.</p><p><strong>How can we remove a term from the trie</strong>? Let’s say we have to remove a term from the trie because of some legal issue or hate or piracy etc. We can completely remove such terms from the trie when the regular update happens, meanwhile, we can add a filtering layer on each server which will remove any such term before sending them to users.</p><p><strong>What could be different ranking criteria for suggestions</strong>? In addition to a simple count, for terms ranking, we have to consider other factors too, e.g., freshness, user location, language, demographics, personal history, etc.</p><h2 id="Permanent-Storage-of-the-Trie"><a href="#Permanent-Storage-of-the-Trie" class="headerlink" title="Permanent Storage of the Trie"></a>Permanent Storage of the Trie</h2><p><strong>How to store trie in a file so that we can rebuild our trie easily</strong>? - this will be needed when a machine restarts. We can take a snapshot of our trie periodically and store it in a file. This will enable us to rebuild a trie if the server goes down. To store, we can start with the root node and save the trie level-by-level. With each node, we can store what character it contains and how many children it has. Right after each node, we should put all of its children. Let’s assume we have the following trie:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/48.png" alt></p><p>If we store this trie in a file with the above-mentioned scheme, we will have: “C2, A2, R1, T, P, O1, D”. From this, we can easily rebuild our trie.<br>If you’ve noticed, we are not storing top suggestions and their counts with each node. It is hard to store this information; as our trie is being stored top-down, we don’t have child nodes created before the parent, so there is no easy way to store their references. For this, we have to recalculate all the top terms with counts. This can be done while we are building the trie. Each node will calculate its top suggestions and pass it to its parent. Each parent node will merge results from all of its children to figure out its top suggestions.</p><h2 id="Scale-Estimation"><a href="#Scale-Estimation" class="headerlink" title="Scale Estimation"></a>Scale Estimation</h2><p>If we are building a service that has the same scale as that of Google we can expect 5 billion searches every day, which would give us approximately 60K queries per second.<br>Since there will be a lot of duplicates in 5 billion queries, we can assume that only 20% of these will be unique. If we only want to index the top 50% of the search terms, we can get rid of a lot of less frequently searched queries. Let’s assume we will have 100 million unique terms for which we want to build an index.</p><p><strong>Storage estimates</strong>: If on the average each query consists of 3 words and if the average length of a word is 5 characters, this will give us 15 characters of average query size. Assuming we need 2 bytes to store a character, we will need 30 bytes to store an average query. So total storage we will need:</p><blockquote><p>100 million * 30 bytes = 3 GB</p></blockquote><p>We can expect some growth in this data every day, but we should also be removing some terms that are not searched anymore. If we assume we have 2% new queries every day and if we are maintaining our index for the last one year, total storage we should expect:</p><blockquote><p>3GB + (0.02 * 3 GB * 365 days) ≈ 25 GB</p></blockquote><h2 id="Data-Partition"><a href="#Data-Partition" class="headerlink" title="Data Partition"></a>Data Partition</h2><p>Although our index can easily fit on one server, we can still partition it in order to meet our requirements of higher efficiency and lower latencies. How can we efficiently partition our data to distribute it onto multiple servers?</p><p><strong>Range based partitioning</strong>: What if we store our phrases in separate partitions based on their first letter. So we save all the terms starting with the letter “A” in one partition and those that start with the letter “B” into another partition and so on. We can even combine certain less frequently occurring letters into one partition. We should come up with this partitioning scheme statically so that we can always store and search terms in a predictable manner.<br>The main problem with this approach is that it can lead to unbalanced servers, for instance, if we decide to put all terms starting with the letter “E” into one partition, but later we realize that we have too many terms that start with letter “E” that we can’t fit into one partition.<br>We can see that the above problem will happen with every statically defined scheme. It is not possible to calculate if each of our partitions will fit on one server statically.</p><p><strong>Partition based on the maximum capacity of the server</strong>: Let’s say we partition our trie based on the maximum memory capacity of the servers. We can keep storing data on a server as long as it has memory available. Whenever a sub-tree cannot fit into a server, we break our partition there to assign that range to this server and move on to the next server to repeat this process. Let’s say if our first trie server can store all terms from “A” to “AABC”, which mean our next server will store from “AABD” onwards. If our second server could store up to “BXA”, the next server will start from “BXB”, and so on. We can keep a hash table to quickly access this partitioning scheme:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Server <span class="number">1</span>, A-AABC</span><br><span class="line">Server <span class="number">2</span>, AABD-BXA</span><br><span class="line">Server <span class="number">3</span>, BXB-CDA</span><br></pre></td></tr></table></figure><p>For querying, if the user has typed “A” we have to query both servers 1 and 2 to find the top suggestions. When the user has typed “AA”, we still have to query server 1 and 2, but when the user has typed “AAA” we only need to query server 1.<br>We can have a load balancer in front of our trie servers which can store this mapping and redirect traffic. Also, if we are querying from multiple servers, either we need to merge the results on the server-side to calculate the overall top results or make our clients do that. If we prefer to do this on the server-side, we need to introduce another layer of servers between load balancers and trie severs (let’s call them aggregator). These servers will aggregate results from multiple trie servers and return the top results to the client.<br>Partitioning based on the maximum capacity can still lead us to hotspots, e.g., if there are a lot of queries for terms starting with “cap”, the server holding it will have a high load compared to others.</p><p><strong>Partition based on the hash of the term</strong>: Each term will be passed to a hash function, which will generate a server number and we will store the term on that server. This will make our term distribution random and hence minimize hotspots. The disadvantage of this scheme is, to find typeahead suggestions for a term we have to ask all the servers and then aggregate the results.</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>We should realize that caching the top searched terms will be extremely helpful in our service. There will be a small percentage of queries that will be responsible for most of the traffic. We can have separate cache servers in front of the trie servers holding the most frequently searched terms and their typeahead suggestions. Application servers should check these cache servers before hitting the trie servers to see if they have the desired searched terms. This will save us time to traverse the trie.<br>We can also build a simple Machine Learning model that can try to predict the engagement on each suggestion based on simple counting, personalization, or trending data, and cache these terms beforehand.</p><h2 id="Replication-and-Load-Balancer"><a href="#Replication-and-Load-Balancer" class="headerlink" title="Replication and Load Balancer"></a>Replication and Load Balancer</h2><p>We should have replicas for our trie servers both for load balancing and also for fault tolerance. We also need a load balancer that keeps track of our data partitioning scheme and redirects traffic based on the prefixes.</p><h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p><strong>What will happen when a trie server goes down?</strong> As discussed above we can have a primary-secondary configuration; if the primary dies, the secondary can take over after failover. Any server that comes back up, can rebuild the trie based on the last snapshot.</p><h2 id="Typeahead-Client"><a href="#Typeahead-Client" class="headerlink" title="Typeahead Client"></a>Typeahead Client</h2><p>We can perform the following optimizations on the client-side to improve user’s experience:</p><ul><li>The client should only try hitting the server if the user has not pressed any key for 50ms;</li><li>If the user is constantly typing, the client can cancel the in-progress requests;</li><li>Initially, the client can wait until the user enters a couple of characters;</li><li>Clients can pre-fetch some data from the server to save future requests;</li><li>Clients can store the recent history of suggestions locally. Recent history has a very high rate of being reused;</li><li>Establishing an early connection with the server turns out to be one of the most important factors. As soon as the user opens the search engine website, the client can open a connection with the server. So when a user types in the first character, the client doesn’t waste time in establishing the connection;</li><li>The server can push some part of their cache to CDNs and Internet Service Providers (ISPs) for efficiency;</li></ul><h2 id="Personalization"><a href="#Personalization" class="headerlink" title="Personalization"></a>Personalization</h2><p>Users will receive some typeahead suggestions based on their historical searches, location, language, etc. We can store the personal history of each user separately on the server and also cache them on the client. The server can add these personalized terms in the final set before sending it to the user. Personalized searches should always come before others.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Youtube or Netflix</title>
      <link href="2021/02/18/Designing-Youtube-or-Netflix/"/>
      <url>2021/02/18/Designing-Youtube-or-Netflix/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-Youtube"><a href="#Why-Youtube" class="headerlink" title="Why Youtube?"></a>Why Youtube?</h2><p>Youtube is one of the most popular video sharing websites in the world. Users of the service can upload, view, share, rate, and report videos as well as add comments on videos.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>For the sake of this exercise, we plan to design a simpler version of Youtube with following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Users should be able to upload videos;</li><li>Users should be able to share and view videos;</li><li>Users should be able to perform searches based on video titles;</li><li>Our services should be able to record stats of videos, e.g., likes/dislikes, total number of views, etc;</li><li>Users should be able to add and view comments on videos;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>The system should be highly reliable, any video uploaded should not be lost;</li><li>The system should be highly available. Consistency can take a hit (in the interest of availability); if a user doesn’t see a video for a while, it should be fine;</li><li>Users should have a real-time experience while watching videos and should not feel any lag;</li></ol><p><strong>Not in Scope</strong>: Video recommendations, most popular videos, channels, subscriptions, watch later, favorites, etc.</p><a id="more"></a><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p>Let’s assume we have 1.5 billion total users, 800 million of whom are daily active users. If, on average, a user views five videos per day then the total video-views per second would be:</p><blockquote><p>800M * 5 / 86400 sec ≈ 46K videos/sec</p></blockquote><p>Let’s assume our upload:view ratio is 1:200, i.e., for every video upload we have 200 videos viewed, giving us 230 videos uploaded per second:</p><blockquote><p>46K / 200 = 230 videos/sec</p></blockquote><p><strong>Storage estimates</strong>: Let’s assume that every minute 500 hours worth of videos are uploaded to Youtube. If on average, one minute of video needs 50MB of storage (videos need to be stored in multiple formats), the total storage needed for videos uploaded in a minute would be:</p><blockquote><p>500 hours * 60 min * 50MB = 1500 GB/min (25 GB/sec)</p></blockquote><p>These are estimated numbers ignoring video compression and replication, which would change real numbers.</p><p><strong>Bandwidth estimates</strong>: With 500 hours of video uploads per minute (which is 30000 mins of video uploads per minute), assuming uploading each minute of the video takes 10MB of the bandwidth, we would be getting 300GB of uploads every minute:</p><blockquote><p>500 hours * 60 mins * 10MB = 300 GB/min (5 GB/sec)</p></blockquote><p>Assuming an upload:view ratio of 1:200, we would need 1TB/s outgoing bandwidth.</p><h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><p>We can have SOAP or REST APIs to expose the functionality of our service. The following could be the definitions of the APIs for uploading and searching videos:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uploadVideo(api_dev_key, video_title, video_description, tags[], category_id, default_language, recording_details, video_contents)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota;</li><li>video_title: Title of the video;</li><li>video_description: Optional description of the video;</li><li>tags: Optional tags for the video;</li><li>category_id: Category of the video, e.g., Film, Song, People, etc;</li><li>default_language: For example English, Mandarin, Hindi, etc;</li><li>recording_details: Location where the video was recorded;</li><li>video_contents: Video to be uploaded;</li></ul><p><strong>Returns</strong>: A successful upload will return HTTP 202 (request accepted) and once the video encoding is completed the user is notified through email with a link to access the video.</p><p>We can also expose a queryable API to let users know the current status of their uploaded video:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">searchVideo(api_dev_key, search_query, user_location, maximum_videos_to_return, page_token)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: The API developer key of a registered account of our service;</li><li>search_query: A string containing the search terms;</li><li>user_location: Optional location of the user performing the search;</li><li>maximum_videos_to_return: Maximum number of results returned in one request;</li><li>page_token: This token will specify a page in the result set that should be returned;</li></ul><p><strong>Returns</strong>: A JSON containing information about the list of video resources matching the search query.</p><p>Each video resource will have a video title, a thumbnail, a video creation date, and a view count:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">streamVideo(api_dev_key, video_id, offset, codec, resolution)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: The API developer key of a registered account of our service;</li><li>video_id: A string to identify the video;</li><li>offset: We should be able to stream video from any offset; this offset would be a time in seconds from the beginning of the video. If we support playing/pausing a video from multiple devices, we will need to store the offset on the server. This will enable the users to start watching a video on any device from the same point where they left off;</li><li>codec &amp; resolution: We should send the codec and resolution info in the API from the client to support play/pause from multiple devices. Imagine you are watching a video on your TV’s Netflix app, paused it, and started watching it on your phone’s Netflix app. In this case, you would need codec and resolution, as both these devices have a different resolution and use a different codec.</li></ul><p><strong>Returns</strong>: A media stream (a video chunk) from the given offset;</p><h2 id="High-Level-Design"><a href="#High-Level-Design" class="headerlink" title="High-Level Design"></a>High-Level Design</h2><p>At a high level we would need the following components:</p><ol><li><strong>Processing Queue</strong>: Each uploaded video will be pushed to a processing queue to be de-queued later for encoding, thumbnail generation, and storage;</li><li><strong>Encoder</strong>: To encode each uploaded video into multiple formats;</li><li><strong>Thumbnails Generator</strong>: To generate a few thumbnails for each video;</li><li><strong>Video and Thumbnail Storage</strong>: To store video and thumbnail files in some distributed file storage;</li><li><strong>User Database</strong>: To store user’s information, e.g., name, email, address, etc;</li><li><strong>Video Metadata Storage</strong>: A metadata database to store all the information about videos like title, file path in the system, uploading user, total views, likes, dislikes, etc. It will also be used to store all the video comments;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/44.png" alt></p><h2 id="Database-Schema"><a href="#Database-Schema" class="headerlink" title="Database Schema"></a>Database Schema</h2><p><strong>Video Metadata Storage</strong>:<br>Videos metadata can be stored in a SQL database. The following information should be stored with each video:</p><ul><li>VideoID;</li><li>Title;</li><li>Description;</li><li>Size;</li><li>Thumbnail;</li><li>Uploader/User;</li><li>Total number of likes;</li><li>Total number of dislikes;</li><li>Total number of views;</li></ul><p>For each video comment, we need to store following information:</p><ul><li>CommentID;</li><li>VideoID;</li><li>UserID;</li><li>Comment;</li><li>TimeOfCreation;</li></ul><p><strong>User Data Storage</strong>: UserID, Name, email, address, age, registration details, etc.</p><h2 id="Detailed-Component-Design"><a href="#Detailed-Component-Design" class="headerlink" title="Detailed Component Design"></a>Detailed Component Design</h2><p>The service would be read-heavy, so we will focus on building a system that can retrieve videos quickly. We can expect our read:write ratio to be 200:1, which means for every video upload, there are 200 video views.</p><p><strong>Where would videos be stored</strong>? Videos can be stored in a distributed file storage system like HDFS or GlusterFS.</p><p><strong>How should we efficiently manage read traffic</strong>? We should segregate our read traffic from write traffic. Since we will have multiple copies of each video, we can distribute our read traffic on different servers. For metadata, we can have primary-secondary configurations where writes will go to primary first and then get applied at all the secondaries. Such configurations can cause some staleness in data, e.g., when a new video is added, its metadata would be inserted in the primary first, and before it gets applied to the secondary, our secondaries would not be able to see it; and therefore, it will be returning stale results to the user. This staleness might be acceptable in our system as it would be very short-lived, and the user would be able to see the new videos after a few milliseconds.</p><p><strong>Where would thumbnails be stored</strong>? There will be a lot more thumbnails than videos. If we assume that every video will have five thumbnails, we need to have a very efficient storage system that can serve huge read traffic. There will be two consideration before deciding which storage system should be used for thumbnails:</p><ol><li>Thumbnails are small files, say, a maximum of 5KB each;</li><li>Read traffic for thumbnails will be huge compared to videos. Users will be watching one video at a time, but they might be looking at a page with 20 thumbnails of other videos;</li></ol><p>Let’s evaluate storing all the thumbnails on a disk. Given that we have a huge number of files, we have to perform many seeks to different locations on the disk to read these files. This is quite inefficient and will result in higher latencies.<br>Bigtable can be a reasonable choice here as it combines multiple files into one block to store on the disk and is very efficient in reading a small amount of data. Both of these are the two most significant requirements for our service. Keeping hot thumbnails in the cache will also help improve the latencies and, given that thumbnails files are small in size, we can easily cache a large number of such files in memory.</p><p><strong>Video uploads</strong>: Since videos could be huge, if while uploading, the connection drops, we should support resuming from the same point.</p><p><strong>Video encoding</strong>: Newly uploaded videos are stored on the server, and a new task is added to the processing queue to encode the video into multiple formats. Once all the encoding is completed, the uploader will be notified, and the video is made available for view/sharing.</p><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/45.png" alt></p><h2 id="Metadata-Sharding"><a href="#Metadata-Sharding" class="headerlink" title="Metadata Sharding"></a>Metadata Sharding</h2><p>Since we have a huge number of new videos every day and our read load is extremely high, therefore, we need to distribute our data onto multiple machines so that we can perform read/write operations efficiently. We have many options to shard our data. Let’s go through different strategies of sharding this data one by one.</p><p><strong>Sharding based on UserID</strong>: We can try storing all the data for a particular user on one server. While storing, we can pass the UserID to our hash function, which will map the user to a database server where we will store all the metadata for that user’s videos. While querying for videos of a user, we can ask our hash function to find the server holding the user’s data and then read it from there. To search videos by titles, we will have to query all servers, and each server will return a set of videos. A centralized server will then aggregate and rank these results before returning them to the user.<br>This approach has a couple of issues:</p><ol><li>What if a user becomes popular? There could be a lot of queries on the server holding that user; this could create a performance bottleneck. This will also affect the overall performance of our service;</li><li>Over time, some users can end up storing a lot of videos compared to others. Maintaining a uniform distribution of growing user data is quite tricky;</li></ol><p>To recover from these situations, either we have to repartition/redistribute our data or used consistent hashing to balance the load between servers.</p><p><strong>Sharding based on VideoID</strong>: Our hash function will map each VideoID to a random server where we will store that Video’s metadata. To find videos of a user, we will query all servers, and each server will return a set of videos. A centralized server will aggregate and rank these results before returning them to the user. This approach solves our problem of popular users but shifts it to popular videos.<br>We can further improve our performance by introducing a cache to store hot videos in front of the database servers.</p><h2 id="Video-Deduplication"><a href="#Video-Deduplication" class="headerlink" title="Video Deduplication"></a>Video Deduplication</h2><p>With a huge number of users uploading a massive amount of video data, our service will have to deal with widespread video duplication. Duplicate videos often differ in aspect ratios or encodings, contain overlays or additional borders, or be excerpts from a longer original video. The proliferation of duplicate videos can have an impact on many levels:</p><ol><li>Data Storage: We could be wasting storage space by keeping multiple copies of the same video;</li><li>Caching: Duplicate videos would result in degraded cache efficiency by taking up space that could be used for unique content;</li><li>Network Usage: Duplicate videos will also increase the amount of data that must be sent over the network to in-network caching systems;</li><li>Energy Consumption: Higher storage, inefficient cache, and network usage could result in energy wastage;</li></ol><p>For the end-user, these inefficiencies will be realized in the form of duplicate search results, longer video startup times, and interrupted streaming.<br>For our service, deduplication makes most sense early; when a user is uploading a video as compared to post-processing it to find duplicate videos later. Inline deduplication will save us a lot of resources that can be used to encode, transfer, and store the duplicate copy of the video. As soon as any user starts uploading a video, our service can run video matching algorithms (e.g., Block Matching, Phase Correlation, etc.) to find duplications. If we already have a copy of the video being uploaded, we can either stop the upload and use the existing copy or continue the upload and use the newly uploaded video if it is of higher quality. If the newly uploaded video is a subpart of an existing video or vice versa, we can intelligently divide the video into smaller chunks so that we only upload the parts that are missing.</p><h2 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h2><p>We should use Consistent Hashing among our cache servers, which will also help in balancing the load between cache servers. Since we will be using a static hash-based scheme to map videos to hostnames, it can lead to an uneven load on the logical replicas due to each video’s different popularity. For instance, if a video becomes popular, the logical replica corresponding to that video will experience more traffic than other servers. These uneven loads for logical replicas can then translate into uneven load distribution on corresponding physical servers. To resolve this issue, any busy server in one location can redirect a client to a less busy server in the same cache location. We can use dynamic HTTP redirections for this scenario.<br>However, the use of redirections also has its drawbacks:</p><ol><li>Since our service tries to load balance locally, it leads to multiple redirections if the host that receives the redirection can’t serve the video;</li><li>Each redirection requires a client to make an additional HTTP request. It also leads to higher delays before the video starts playing back;</li><li>Inter-tier (or cross data-center) redirections lead a client to a distant cache location because the higher tier caches are only present at a small number of locations;</li></ol><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>To serve globally distributed users, our service needs a massive-scale video delivery system. Our service should push its content closer to the user using a large number of geographically distributed video cache servers. We need to have a strategy that will maximize user performance and also evenly distributes the load on its cache servers.<br>We can introduce a cache for metadata servers to cache hot database rows. Using Memcache to cache the data and Application servers before hitting the database can quickly check if the cache has the desired rows. Least Recently Used (LRU) can be a reasonable cache eviction policy for our system. Under this policy, we discard the least recently viewed row first.</p><p><strong>How can we build a more intelligent cache</strong>? If we go with the 80-20 rule, i.e., 20% of daily read volume for videos is generating 80% of traffic, meaning that certain videos are so popular that the majority of people view them; it follows that we can try caching 20% of daily read volume of videos and metadata.</p><h2 id="Content-Delivery-Network"><a href="#Content-Delivery-Network" class="headerlink" title="Content Delivery Network"></a>Content Delivery Network</h2><p>A CDN is a system of distributed servers that deliver web content to a user based on the user’s geographic locations, the origin of the web page, and a content delivery server.<br>Our service can move popular videos to CDNs:</p><ul><li>CDNs replicate content in multiple places. There’s a better chance of videos being closer to the user and, with fewer hops, videos will stream from a friendlier network;</li><li>CDN machines make heavy use of caching and can mostly serve videos out of memory;</li></ul><p>Less popular videos (1-20 views per day) that are not cached by CDNs can be served by our servers in various data centers.</p><h2 id="Fault-Tolerance"><a href="#Fault-Tolerance" class="headerlink" title="Fault Tolerance"></a>Fault Tolerance</h2><p>We should use Consistent Hashing for distribution among database servers. Consistent hashing will not only help in replacing a dead server but also help in distributing load among servers.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Twitter</title>
      <link href="2021/02/17/Designing-Twitter/"/>
      <url>2021/02/17/Designing-Twitter/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Twitter"><a href="#What-is-Twitter" class="headerlink" title="What is Twitter?"></a>What is Twitter?</h2><p>Twitter is an online social networking service where users post and read short 140-character messages called “tweets”. Registered users can post and read tweets, but those who are not registered can only read them. Users access Twitter through their website interface, SMS, or mobile app.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>We will be designing a simpler version of Twitter with the following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Users should be able to post new tweets;</li><li>A user should be able to follow other users;</li><li>Users should be able to mark tweets as favorites;</li><li>The service should be able to create and display a user’s timeline consisting of top tweets from all the people the user follows;</li><li>Tweets can contain photos and videos;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>Our service needs to be highly available;</li><li>Acceptable latency of the system is 200ms for timeline generation;</li><li>Consistency can take a hit (in the interest of availability); if a user doesn’t see a tweet for a while, it should be fine;</li></ol><p><strong>Extended Requirements</strong>:</p><ol><li>Searching for tweets;</li><li>Replying to a tweet;</li><li>Trending topics – current hot topics/searches;</li><li>Tagging other users;</li><li>Tweet Notification;</li><li>Who to follow? Suggestions?</li><li>Moments;</li></ol><a id="more"></a><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p>Let’s assume we have one billion total users with 200 million Daily Active Users (DAU). Also assume we have 100 million new tweets every day and on average each user follows 200 people.</p><p><strong>How many favorites per day</strong>? If, on average, each user favorites five tweets per day we will have:</p><blockquote><p>200M users * 5 favorites = 1B favorites</p></blockquote><p><strong>How many total tweet-views will our system generate</strong>? Let’s assume on average a user visits their timeline two times a day and visits five other people’s pages. On each page if a user sees 20 tweets, then our system will generate 28B/day total tweet-views:</p><blockquote><p>200M DAU * ((2 + 5) * 20 tweets) = 28 B/day</p></blockquote><p><strong>Storage estimates</strong>: Let’s say each tweet has 140 characters and we need two bytes to store a character without compression. Let’s assume we need 30 bytes to store metadata with each tweet (like ID, timestamp, user ID, etc.). Total storage we would need:</p><blockquote><p>100M * (280 + 30) bytes ≈ 30 GB/day</p></blockquote><p>What would our storage needs be for five years? How much storage we would need for users’ data, follows, favorites? We will leave this for the exercise.<br>Not all tweets will have media, let’s assume that on average every fifth tweet has a photo and every tenth has a video. Let’s also assume on average a photo is 200KB and a video is 2MB. This will lead us to have 24TB of new media every day:</p><blockquote><p>(100M/5 photos * 200KB) + (100M/10 videos * 2MB) ≈ 24 TB/day</p></blockquote><p><strong>Bandwidth estimates</strong>: Since total ingress is 24TB per day, this would translate into 290MB/sec. Remember that we have 28B tweet views per day. We must show the photo of every tweet (if it has a photo), but let’s assume that the users watch every 3rd video they see in their timeline. So, total egress will be:</p><blockquote><p>(28B * 280 bytes) / 86400s of text + (28B/5 * 200KB ) / 86400s of photos + (28B/10/3 * 2MB ) / 86400s of videos ≈ 35 GB/s</p></blockquote><h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><blockquote><p>Once we’ve finalized the requirements, it’s always a good idea to define the system APIs. This should explicitly state what is expected from the system.</p></blockquote><p>We can have SOAP or REST APIs to expose the functionality of our service. Following could be the definition of the API for posting a new tweet:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tweet(api_dev_key, tweet_data, tweet_location, user_location, media_ids)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota;</li><li>tweet_data: The text of the tweet, typically up to 140 characters;</li><li>tweet_location: Optional location (longitude, latitude) this Tweet refers to;</li><li>user_location: Optional location (longitude, latitude) of the user adding the tweet;</li><li>media_ids: Optional list of media_ids to be associated with the Tweet. (all the media photo, video, etc. need to be uploaded separately);</li></ul><p><strong>Returns</strong>: A successful post will return the URL to access that tweet. Otherwise, an appropriate HTTP error is returned.</p><h2 id="High-Level-System-Design"><a href="#High-Level-System-Design" class="headerlink" title="High-Level System Design"></a>High-Level System Design</h2><p>We need a system that can efficiently store all the new tweets, “100M/86400s ≈ 1150” tweets per second and read “28B/86400s ≈ 325K” tweets per second. It is clear from the requirements that this will be a read-heavy system.<br>At a high level, we need multiple application servers to serve all these requests with load balancers in front of them for traffic distributions. On the backend, we need an efficient database that can store all the new tweets and can support a huge number of reads. We also need some file storage to store photos and videos:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/40.png" alt></p><p>Although our expected daily write load is 100 million and read load is 28 billion tweets. This means on average our system will receive around 1160 new tweets and 325K read requests per second. This traffic will be distributed unevenly throughout the day, though, at peak time we should expect at least a few thousand write requests and around 1M read requests per second. We should keep this in mind while designing the architecture of our system.</p><h2 id="Database-Schema"><a href="#Database-Schema" class="headerlink" title="Database Schema"></a>Database Schema</h2><p>We need to store data about users, their tweets, their favorite tweets, and people they follow:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/41.png" alt></p><p>For choosing between SQL and NoSQL databases to store the above schema, please see “Database Schema” under Designing Instagram.</p><h2 id="Data-Sharding"><a href="#Data-Sharding" class="headerlink" title="Data Sharding"></a>Data Sharding</h2><p>Since we have a huge number of new tweets every day and our read load is extremely high too, we need to distribute our data onto multiple machines such that we can read/write it efficiently. We have many options to shard our data; let’s go through them one by one.</p><p><strong>Sharding based on UserID</strong>: We can try storing all the data of a user on one server. While storing, we can pass the UserID to our hash function that will map the user to a database server where we will store all of the user’s tweets, favorites, follows, etc. While querying for tweets/follows/favorites of a user, we can ask our hash function where can we find the data of a user and then read it from there. This approach has a couple of issues:</p><ol><li>What if a user becomes hot? There could be a lot of queries on the server holding the user. This high load will affect the performance of our service;</li><li>Over time some users can end up storing a lot of tweets or having a lot of follows compared to others. Maintaining a uniform distribution of growing user data is quite difficult;</li></ol><p>To recover from these situations either we have to repartition/redistribute our data or use consistent hashing.</p><p><strong>Sharding based on TweetID</strong>: Our hash function will map each TweetID to a random server where we will store that Tweet. To search for tweets, we have to query all servers, and each server will return a set of tweets. A centralized server will aggregate these results to return them to the user. Let’s look into timeline generation example; here are the number of steps our system has to perform to generate a user’s timeline:</p><ol><li>Our application (app) server will find all the people the user follows;</li><li>App server will send the query to all database servers to find tweets from these people;</li><li>Each database server will find the tweets for each user, sort them by recency and return the top tweets;</li><li>App server will merge all the results and sort them again to return the top results to the user;</li></ol><p>This approach solves the problem of hot users, but, in contrast to sharding by UserID, we have to query all database partitions to find tweets of a user, which can result in higher latencies.<br>We can further improve our performance by introducing cache to store hot tweets in front of the database servers.</p><p><strong>Sharding based on Tweet creation time</strong>: Storing tweets based on creation time will give us the advantage of fetching all the top tweets quickly and we only have to query a very small set of servers. The problem here is that the traffic load will not be distributed, e.g., while writing, all new tweets will be going to one server and the remaining servers will be sitting idle. Similarly, while reading, the server holding the latest data will have a very high load as compared to servers holding old data.</p><p><strong>What if we can combine sharding by TweetID and Tweet creation time</strong>? If we don’t store tweet creation time separately and use TweetID to reflect that, we can get benefits of both the approaches. This way it will be quite quick to find the latest Tweets. For this, we must make each TweetID universally unique in our system and each TweetID should contain a timestamp too.<br>We can use epoch time for this. Let’s say our TweetID will have two parts: the first part will be representing epoch seconds and the second part will be an auto-incrementing sequence. So, to make a new TweetID, we can take the current epoch time and append an auto-incrementing number to it. We can figure out the shard number from this TweetID and store it there:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/42.png" alt></p><p>What could be the size of our TweetID? Let’s say our epoch time starts today, how many bits we would need to store the number of seconds for the next 50 years:</p><blockquote><p>86400 sec/day * 365 (days a year) * 50 (years) ≈ 1.6 B</p></blockquote><p>We would need 31 bits to store this number. Since on average we are expecting 1150 new tweets per second, we can allocate 17 bits to store auto incremented sequence; this will make our TweetID 48 bits long. So, every second we can store (2^17 ≈ 130K) new tweets. We can reset our auto incrementing sequence every second. For fault tolerance and better performance, we can have two database servers to generate auto-incrementing keys for us, one generating even numbered keys and the other generating odd numbered keys.<br>If we assume our current epoch seconds are “1483228800”, our TweetID will look like this:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1483228800</span> <span class="number">000001</span></span><br><span class="line"><span class="number">1483228800</span> <span class="number">000002</span></span><br><span class="line"><span class="number">1483228800</span> <span class="number">000003</span></span><br><span class="line"><span class="number">1483228800</span> <span class="number">000004</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>If we make our TweetID 64bits (8 bytes) long, we can easily store tweets for the next 100 years and also store them for milliseconds granularity.<br>In the above approach, we still have to query all the servers for timeline generation, but our reads (and writes) will be substantially quicker:</p><ol><li>Since we don’t have any secondary index (on creation time) this will reduce our write latency;</li><li>While reading, we don’t need to filter on creation-time as our primary key has epoch time included in it;</li></ol><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>We can introduce a cache for database servers to cache hot tweets and users. We can use an off-the-shelf solution like Memcache that can store the whole tweet objects. Application servers, before hitting database, can quickly check if the cache has desired tweets. Based on clients’ usage patterns we can determine how many cache servers we need.</p><p><strong>Which cache replacement policy would best fit our needs</strong>? When the cache is full and we want to replace a tweet with a newer/hotter tweet, how would we choose? Least Recently Used (LRU) can be a reasonable policy for our system. Under this policy, we discard the least recently viewed tweet first.</p><p><strong>How can we have a more intelligent cache</strong>? If we go with 80-20 rule, that is 20% of tweets generating 80% of read traffic which means that certain tweets are so popular that a majority of people read them. This dictates that we can try to cache 20% of daily read volume from each shard.</p><p><strong>What if we cache the latest data</strong>? Our service can benefit from this approach. Let’s say if 80% of our users see tweets from the past three days only; we can try to cache all the tweets from the past three days. Let’s say we have dedicated cache servers that cache all the tweets from all the users from the past three days. As estimated above, we are getting 100 million new tweets or 30GB of new data every day (without photos and videos). If we want to store all the tweets from last three days, we will need less than 100GB of memory. This data can easily fit into one server, but we should replicate it onto multiple servers to distribute all the read traffic to reduce the load on cache servers. So whenever we are generating a user’s timeline, we can ask the cache servers if they have all the recent tweets for that user. If yes, we can simply return all the data from the cache. If we don’t have enough tweets in the cache, we have to query the backend server to fetch that data. On a similar design, we can try caching photos and videos from the last three days.<br>Our cache would be like a hash table where “key” would be “OwnerID” and “value” would be a doubly linked list containing all the tweets from that user in the past three days. Since we want to retrieve the most recent data first, we can always insert new tweets at the head of the linked list, which means all the older tweets will be near the tail of the linked list. Therefore, we can remove tweets from the tail to make space for newer tweets:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/43.png" alt></p><h2 id="Timeline-Generation"><a href="#Timeline-Generation" class="headerlink" title="Timeline Generation"></a>Timeline Generation</h2><p>For a detailed discussion about timeline generation, take a look at <a href>Designing Facebook’s News Feed</a>.</p><h2 id="Replication-and-Fault-Tolerance"><a href="#Replication-and-Fault-Tolerance" class="headerlink" title="Replication and Fault Tolerance"></a>Replication and Fault Tolerance</h2><p>Since our system is read-heavy, we can have multiple secondary database servers for each DB partition. Secondary servers will be used for read traffic only. All writes will first go to the primary server and then will be replicated to secondary servers. This scheme will also give us fault tolerance, since whenever the primary server goes down we can failover to a secondary server.</p><h2 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h2><p>We can add load balancing layer at three places in our system:</p><ol><li>Between Clients and Application Servers;</li><li>Between Application Servers and Database Replication Servers;</li><li>Between Aggregation Servers and Cache Servers;</li></ol><p>Initially, a simple Round Robin approach can be adopted; that distributes incoming requests equally among servers. This LB is simple to implement and does not introduce any overhead. Another benefit of this approach is that if a server is dead, LB will take it out of the rotation and will stop sending any traffic to it. A problem with Round Robin LB is that it won’t take servers load into consideration. If a server is overloaded or slow, the LB will not stop sending new requests to that server. To handle this, a more intelligent LB solution can be placed that periodically queries backend server about their load and adjusts traffic based on that.</p><h2 id="Monitoring"><a href="#Monitoring" class="headerlink" title="Monitoring"></a>Monitoring</h2><p>Having the ability to monitor our systems is crucial. We should constantly collect data to get an instant insight into how our system is doing. We can collect following metrics/counters to get an understanding of the performance of our service:</p><ol><li>New tweets per day/second, what is the daily peak?</li><li>Timeline delivery stats, how many tweets per day/second our service is delivering;</li><li>Average latency that is seen by the user to refresh timeline;</li></ol><p>By monitoring these counters, we will realize if we need more replication, load balancing, or caching.</p><h2 id="Extended-Requirements"><a href="#Extended-Requirements" class="headerlink" title="Extended Requirements"></a>Extended Requirements</h2><p><strong>How do we serve feeds</strong>? Get all the latest tweets from the people someone follows and merge/sort them by time. Use pagination to fetch/show tweets. Only fetch top N tweets from all the people someone follows. This N will depend on the client’s viewport, since on a mobile we show fewer tweets compared to a Web client. We can also cache next top tweets to speed things up.</p><p><strong>Alternately</strong>, we can pre-generate the feed to improve efficiency; for details please see “Ranking and News Feed Generation” under Designing Instagram.</p><p><strong>Retweet</strong>: With each Tweet object in the database, we can store the ID of the original Tweet and not store any contents on this retweet object.</p><p><strong>Trending Topics</strong>: We can cache most frequently occurring hashtags or search queries in the last N seconds and keep updating them after every M seconds. We can rank trending topics based on the frequency of tweets or search queries or retweets or likes. We can give more weight to topics which are shown to more people.</p><p><strong>Who to follow? How to give suggestions</strong>? This feature will improve user engagement. We can suggest friends of people someone follows. We can go two or three levels down to find famous people for the suggestions. We can give preference to people with more followers.<br>As only a few suggestions can be made at any time, use Machine Learning to shuffle and re-prioritize. ML signals could include people with recently increased follow-ship, common followers if the other person is following this user, common location or interests, etc.</p><p><strong>Moments</strong>: Get top news for different websites for past 1 or 2 hours, figure out related tweets, prioritize them, categorize them (news, support, financial, entertainment, etc.) using ML - Supervised Learning or Clustering. Then we can show these articles as trending topics in Moments.</p><p><strong>Search</strong>: Search involves Indexing, Ranking, and Retrieval of tweets. A similar solution is discussed in Design Twitter Search.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Facebook Messenger</title>
      <link href="2021/02/14/Designing-Facebook-Messenger/"/>
      <url>2021/02/14/Designing-Facebook-Messenger/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Facebook-Messenger"><a href="#What-is-Facebook-Messenger" class="headerlink" title="What is Facebook Messenger?"></a>What is Facebook Messenger?</h2><p>Facebook Messenger is a software application which provides text-based instant messaging services to its users. Messenger users can chat with their Facebook friends both from cell-phones and Facebook’s website.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>Our Messenger should meet the following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Messenger should support one-on-one conversations between users;</li><li>Messenger should keep track of the online/offline statuses of its users;</li><li>Messenger should support the persistent storage of chat history;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>Users should have real-time chat experience with minimum latency;</li><li>Our system should be highly consistent; users should be able to see the same chat history on all their devices;</li><li>Messenger’s high availability is desirable; we can tolerate lower availability in the interest of consistency;</li></ol><p><strong>Extended Requirements</strong>:</p><ol><li>Group Chats: Messenger should support multiple people talking to each other in a group;</li><li>Push notifications: Messenger should be able to notify users of new messages when they are offline;</li></ol><a id="more"></a><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p>Let’s assume that we have 500 million daily active users and on average each user sends 40 messages daily; this gives us 20 billion messages per day.</p><p><strong>Storage estimates</strong>: Let’s assume that on average a message is 100 bytes, so to store all the messages for one day we would need 2TB of storage:</p><blockquote><p>20 billion messages * 100 bytes = 2 TB/day</p></blockquote><p>To store five years of chat history, we would need 3.6 petabytes of storage:</p><blockquote><p>2 TB * 365 days * 5 years ≈ 3.6 PB</p></blockquote><p>Other than the chat messages, we would also need to store users’ information, messages’ metadata (ID, Timestamp, etc.). Not to mention, the above calculation doesn’t take data compression and replication into consideration.</p><p><strong>Bandwidth estimates</strong>: If our service is getting 2TB of data every day, this will give us 25MB of incoming data for each second:</p><blockquote><p>2 TB / 86400 sec ≈ 25 MB/s</p></blockquote><p>Since each incoming message needs to go out to another user, we will need the same amount of bandwidth 25MB/s for both upload and download.</p><p><strong>High-level estimates</strong>:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/36.png" alt></p><h2 id="High-Level-Design"><a href="#High-Level-Design" class="headerlink" title="High-Level Design"></a>High-Level Design</h2><p>At a high level, we will need a chat server that will be the central piece, orchestrating all the communications between users. When a user wants to send a message to another user, they will connect to the chat server and send the message to the server; the server then passes that message to the other user and also stores it in the database:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/37.png" alt></p><p>The detailed workflow would look like this:</p><ol><li>User A sends a message to User B through the chat server;</li><li>The server receives the message and sends an acknowledgment to User A;</li><li>The server stores the message in its database and sends the message to User B;</li><li>User B receives the message and sends the acknowledgment to the server;</li><li>The server notifies User A that the message has been delivered successfully to User B;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/38.png" alt></p><h2 id="Detailed-Component-Design"><a href="#Detailed-Component-Design" class="headerlink" title="Detailed Component Design"></a>Detailed Component Design</h2><p>Let’s try to build a simple solution first where everything runs on one server. At the high level our system needs to handle the following use cases:</p><ol><li>Receive incoming messages and deliver outgoing messages;</li><li>Store and retrieve messages from the database;</li><li>Keep a record of which user is online or has gone offline, and notify all the relevant users about these status changes;</li></ol><p>Let’s talk about these scenarios one by one.</p><h3 id="Messages-Handling"><a href="#Messages-Handling" class="headerlink" title="Messages Handling"></a>Messages Handling</h3><p><strong>How would we efficiently send/receive messages</strong>? To send messages, a user needs to connect to the server and post messages for the other users. To get a message from the server, the user has two options:</p><ol><li>Pull model: Users can periodically ask the server if there are any new messages for them;</li><li>Push model: Users can keep a connection open with the server and can depend upon the server to notify them whenever there are new messages;</li></ol><p>If we go with our first approach, then the server needs to keep track of messages that are still waiting to be delivered, and as soon as the receiving user connects to the server to ask for any new message, the server can return all the pending messages. To minimize latency for the user, they have to check the server quite frequently, and most of the time they will be getting an empty response if there are no pending message. This will waste a lot of resources and does not look like an efficient solution;<br>If we go with our second approach, where all the active users keep a connection open with the server, then as soon as the server receives a message it can immediately pass the message to the intended user. This way, the server does not need to keep track of the pending messages, and we will have minimum latency, as the messages are delivered instantly on the opened connection.</p><p><strong>How will clients maintain an open connection with the server</strong>? We can use HTTP Long Polling or WebSockets. In long polling, clients can request information from the server with the expectation that the server may not respond immediately. If the server has no new data for the client when the poll is received, instead of sending an empty response, the server holds the request open and waits for response information to become available. Once it does have new information, the server immediately sends the response to the client, completing the open request. Upon receipt of the server response, the client can immediately issue another server request for future updates. This gives a lot of improvements in latencies, throughputs, and performance. The long polling request can timeout or can receive a disconnect from the server, in that case, the client has to open a new request.</p><p><strong>How can the server keep track of all the opened connection to redirect messages to the users efficiently</strong>? The server can maintain a hash table, where “key” would be the UserID and “value” would be the connection object. So whenever the server receives a message for a user, it looks up that user in the hash table to find the connection object and sends the message on the open request.</p><p><strong>What will happen when the server receives a message for a user who has gone offline</strong>? If the receiver has disconnected, the server can notify the sender about the delivery failure. If it is a temporary disconnect, e.g., the receiver’s long-poll request just timed out, then we should expect a reconnect from the user. In that case, we can ask the sender to retry sending the message. This retry could be embedded in the client’s logic so that users don’t have to retype the message. The server can also store the message for a while and retry sending it once the receiver reconnects.</p><p><strong>How many chat servers we need</strong>? Let’s plan for 500 million connections at any time. Assuming a modern server can handle 50K concurrent connections at any time, we would need 10K such servers.</p><p><strong>How do we know which server holds the connection to which user</strong>? We can introduce a software load balancer in front of our chat servers; that can map each UserID to a server to redirect the request.</p><p><strong>How should the server process a “deliver message” request</strong>? The server needs to do the following things upon receiving a new message:</p><ol><li>Store the message in the database;</li><li>Send the message to the receiver;</li><li>Send an acknowledgment to the sender;</li></ol><p>The chat server will first find the server that holds the connection for the receiver and pass the message to that server to send it to the receiver. The chat server can then send the acknowledgment to the sender; we don’t need to wait for storing the message in the database (this can happen in the background).</p><p><strong>How does the messenger maintain the sequencing of the messages</strong>? We can store a timestamp with each message, which is the time the message is received by the server. This will still not ensure the correct ordering of messages for clients. The scenario where the server timestamp cannot determine the exact order of messages would look like this:</p><ol><li>User-1 sends a message M1 to the server for User-2;</li><li>The server receives M1 at T1;</li><li>Meanwhile, User-2 sends a message M2 to the server for User-1;</li><li>The server receives the message M2 at T2, such that T2 &gt; T1;</li><li>The server sends message M1 to User-2 and M2 to User-1;</li></ol><p>So User-1 will see M1 first and then M2, whereas User-2 will see M2 first and then M1.<br>To resolve this, we need to keep a sequence number with every message for each client. This sequence number will determine the exact ordering of messages for EACH user. With this solution, both clients will see a different view of the message sequence, but this view will be consistent for them on all devices.</p><h3 id="Storing-and-Retrieving-the-Messages-from-the-Database"><a href="#Storing-and-Retrieving-the-Messages-from-the-Database" class="headerlink" title="Storing and Retrieving the Messages from the Database"></a>Storing and Retrieving the Messages from the Database</h3><p>Whenever the chat server receives a new message, it needs to store it in the database. To do so, we have two options:</p><ol><li>Start a separate thread, which will work with the database to store the message;</li><li>Send an asynchronous request to the database to store the message;</li></ol><p>We have to keep certain things in mind while designing our database:</p><ol><li>How to efficiently work with the database connection pool;</li><li>How to retry failed requests;</li><li>Where to log those requests that failed even after some retries;</li><li>How to retry these logged requests (that failed after the retry) when all the issues have resolved;</li></ol><p><strong>Which storage system we should use</strong>? We need to have a database that can support a very high rate of small updates and also fetch a range of records quickly. This is required because we have a huge number of small messages that need to be inserted in the database and, while querying, a user is mostly interested in sequentially accessing the messages.<br>We cannot use RDBMS like MySQL or NoSQL like MongoDB because we cannot afford to read/write a row from the database every time a user receives/sends a message. This will not only make the basic operations of our service run with high latency but also create a huge load on databases.<br>Both of our requirements can be easily met with a wide-column database solution like HBase. HBase is a column-oriented key-value NoSQL database that can store multiple values against one key into multiple columns. HBase is modeled after Google’s BigTable and runs on top of Hadoop Distributed File System (HDFS). HBase groups data together to store new data in a memory buffer and, once the buffer is full, it dumps the data to the disk. This way of storage not only helps to store a lot of small data quickly but also fetching rows by the key or scanning ranges of rows. HBase is also an efficient database to store variable-sized data, which is also required by our service.</p><p><strong>How should clients efficiently fetch data from the server</strong>? Clients should paginate while fetching data from the server. Page size could be different for different clients, e.g., cell phones have smaller screens, so we need a fewer number of messages/conversations in the viewport.</p><h3 id="Managing-User’s-Status"><a href="#Managing-User’s-Status" class="headerlink" title="Managing User’s Status"></a>Managing User’s Status</h3><p>We need to keep track of user’s online/offline status and notify all the relevant users whenever a status change happens. Since we are maintaining a connection object on the server for all active users, we can easily figure out the user’s current status from this. With 500M active users at any time, if we have to broadcast each status change to all the relevant active users, it will consume a lot of resources. We can do the following optimization around this:</p><ol><li>Whenever a client starts the app, it can pull the current status of all users in their friends’ list;</li><li>Whenever a user sends a message to another user that has gone offline, we can send a failure to the sender and update the status on the client;</li><li>Whenever a user comes online, the server can always broadcast that status with a delay of a few seconds to see if the user does not go offline immediately;</li><li>Clients can pull the status from the server about those users that are being shown on the user’s viewport. This should not be a frequent operation, as the server is broadcasting the online status of users and we can live with the stale offline status of users for a while;</li><li>Whenever the client starts a new chat with another user, we can pull the status at that time;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/39.png" alt></p><p><strong>Design Summary</strong>: Clients will open a connection to the chat server to send a message; the server will then pass it to the requested user. All the active users will keep a connection open with the server to receive messages. Whenever a new message arrives, the chat server will push it to the receiving user on the long poll request. Messages can be stored in HBase, which supports quick small updates, and range based searches. The servers can broadcast the online status of a user to other relevant users. Clients can pull status updates for users who are visible in the client’s viewport on a less frequent basis.</p><h2 id="Data-Partitioning"><a href="#Data-Partitioning" class="headerlink" title="Data Partitioning"></a>Data Partitioning</h2><p>Since we will be storing a lot of data (3.6PB for five years), we need to distribute it onto multiple database servers. What will be our partitioning scheme?</p><p><strong>Partitioning based on UserID</strong>: Let’s assume we partition based on the hash of the UserID so that we can keep all messages of a user on the same database. If one DB shard is 4TB, we will have “3.6PB/4TB = 900” shards for five years. For simplicity, let’s assume we keep 1K shards. So we will find the shard number by “hash(UserID) % 1000” and then store/retrieve the data from there. This partitioning scheme will also be very quick to fetch chat history for any user.<br>In the beginning, we can start with fewer database servers with multiple shards residing on one physical server. Since we can have multiple database instances on a server, we can easily store multiple partitions on a single server. Our hash function needs to understand this logical partitioning scheme so that it can map multiple logical partitions on one physical server.<br>Since we will store an unlimited history of messages, we can start with a big number of logical partitions, which will be mapped to fewer physical servers, and as our storage demand increases, we can add more physical servers to distribute our logical partitions.</p><p><strong>Partitioning based on MessageID</strong>: If we store different messages of a user on separate database shards, fetching a range of messages of a chat would be very slow, so we should not adopt this scheme.</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>We can cache a few recent messages (say last 15) in a few recent conversations that are visible in a user’s viewport (say last 5). Since we decided to store all of the user’s messages on one shard, the cache for a user should entirely reside on one machine too.</p><h2 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h2><p>We will need a load balancer in front of our chat servers; that can map each UserID to a server that holds the connection for the user and then direct the request to that server. Similarly, we would need a load balancer for our cache servers.</p><h2 id="Fault-Tolerance-and-Replication"><a href="#Fault-Tolerance-and-Replication" class="headerlink" title="Fault Tolerance and Replication"></a>Fault Tolerance and Replication</h2><p><strong>What will happen when a chat server fails</strong>? Our chat servers are holding connections with the users. If a server goes down, should we devise a mechanism to transfer those connections to some other servers? It’s extremely hard to failover TCP connections to other servers; an easier approach can be to have clients automatically reconnect if the connection is lost.</p><p><strong>Should we store multiple copies of user messages</strong>? We cannot have only one copy of the user’s data, because if the server holding the data crashes or is down permanently, we don’t have any mechanism to recover that data. For this, either we have to store multiple copies of the data on different servers or use techniques like Reed-Solomon Encoding to distribute and replicate it.</p><h2 id="Extended-Requirements"><a href="#Extended-Requirements" class="headerlink" title="Extended Requirements"></a>Extended Requirements</h2><ul><li><strong>Group chat</strong>: We can have separate group-chat objects in our system that can be stored on the chat servers. A group-chat object is identified by GroupChatID and will also maintain a list of people who are part of that chat. Our load balancer can direct each group chat message based on GroupChatID and the server handling that group chat can iterate through all the users of the chat to find the server handling the connection of each user to deliver the message.<br>In databases, we can store all the group chats in a separate table partitioned based on GroupChatID;</li><li><strong>Push notifications</strong>: In our current design, users can only send messages to active users and if the receiving user is offline, we send a failure to the sending user. Push notifications will enable our system to send messages to offline users.<br>Each user can opt-in from their device (or a web browser) to get notifications whenever there is a new message or event. Each manufacturer maintains a set of servers that handles pushing these notifications to the user.<br>To have push notifications in our system, we would need to set up a Notification Server, which will take the messages for offline users and send them to the manufacture’s push notification server, which will then send them to the user’s device.</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Dropbox</title>
      <link href="2021/02/14/Designing-Dropbox/"/>
      <url>2021/02/14/Designing-Dropbox/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-Cloud-Storage"><a href="#Why-Cloud-Storage" class="headerlink" title="Why Cloud Storage?"></a>Why Cloud Storage?</h2><p>Cloud file storage services have become very popular recently as they simplify the storage and exchange of digital resources among multiple devices. The shift from using single personal computers to using multiple devices with different platforms and operating systems such as smartphones and tablets each with portable access from various geographical locations at any time, is believed to be accountable for the huge popularity of cloud storage services. Following are some of the top benefits of such services:</p><ul><li><strong>Availability</strong>: The motto of cloud storage services is to have data availability anywhere, anytime. Users can access their files/photos from any device whenever and wherever they like;</li><li><strong>Reliability and Durability</strong>: Another benefit of cloud storage is that it offers 100% reliability and durability of data. Cloud storage ensures that users will never lose their data by keeping multiple copies of the data stored on different geographically located servers;</li><li><strong>Scalability</strong>: Users will never have to worry about getting out of storage space. With cloud storage you have unlimited storage as long as you are ready to pay for it;</li></ul><p>If you haven’t used <a href="https://www.dropbox.com/?_hp=b&landing=dbv2" target="_blank" rel="noopener">dropbox.com</a> before, we would highly recommend creating an account there and uploading/editing a file and also going through the different options their service offers. This will help you a lot in understanding this chapter.</p><a id="more"></a><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><blockquote><p>You should always clarify requirements at the beginning of the interview. Be sure to ask questions to find the exact scope of the system that the interviewer has in mind.</p></blockquote><p>What do we wish to achieve from a Cloud Storage system? Here are the top-level requirements for our system:</p><ul><li>Users should be able to upload and download their files/photos from any device;</li><li>Users should be able to share files or folders with other users;</li><li>Our service should support automatic synchronization between devices, i.e., after updating a file on one device, it should get synchronized on all devices;</li><li>The system should support storing large files up to a GB;</li><li>ACID is required. Atomicity, Consistency, Isolation and Durability of all file operations should be guaranteed;</li><li>Our system should support offline editing. Users should be able to add/delete/modify files while offline, and as soon as they come online, all their changes should be synced to the remote servers and other online devices;</li></ul><p><strong>Extended Requirements</strong>: The system should support snapshotting of the data, so that users can go back to any version of the files.</p><h2 id="Some-Design-Considerations"><a href="#Some-Design-Considerations" class="headerlink" title="Some Design Considerations"></a>Some Design Considerations</h2><ul><li>We should expect huge read and write volumes;</li><li>Read to write ratio is expected to be nearly the same;</li><li>Internally, files can be stored in small parts or chunks (say 4MB); this can provide a lot of benefits, i.e., all failed operations shall only be retried for smaller parts of a file. If a user fails to upload a file, then only the failing chunk will be retried;</li><li>We can reduce the amount of data exchange by transferring updated chunks only;</li><li>By removing duplicate chunks, we can save storage space and bandwidth usage;</li><li>Keeping a local copy of the metadata (file name, size, etc.) with the client can save us a lot of round trips to the server;</li><li>For small changes, clients can intelligently upload the diffs instead of the whole chunk;</li></ul><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><ul><li>Let’s assume that we have 500M total users, and 100M Daily Active Users (DAU);</li><li>Let’s assume that on average each user connects from three different devices;</li><li>On average if a user has 200 files/photos, we will have 100 billion total files;</li><li>Let’s assume that average file size is 100KB, this would give us ten petabytes of total storage:<blockquote><p>100B * 100KB = 10PB</p></blockquote></li><li>Let’s also assume that we will have one million active connections per minute;</li></ul><h2 id="High-Level-Design"><a href="#High-Level-Design" class="headerlink" title="High-Level Design"></a>High-Level Design</h2><p>The user will specify a folder as the workspace on their device. Any file/photo/folder placed in this folder will be uploaded to the cloud, and whenever a file is modified or deleted, it will be reflected in the same way in the cloud storage. The user can specify similar workspaces on all their devices and any modification done on one device will be propagated to all other devices to have the same view of the workspace everywhere.</p><p>At a high level, we need to store files and their metadata information like File Name, File Size, Directory, etc., and who this file is shared with. So, we need some servers that can help the clients to upload/download files to Cloud Storage and some servers that can facilitate updating metadata about files and users. We also need some mechanism to notify all clients whenever an update happens so they can synchronize their files:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/32.png" alt></p><p>Block servers will work with the clients to upload/download files from cloud storage and Metadata servers will keep metadata of files updated in a SQL or NoSQL database. Synchronization servers will handle the workflow of notifying all clients about different changes for synchronization.</p><h2 id="Component-Design"><a href="#Component-Design" class="headerlink" title="Component Design"></a>Component Design</h2><p>Let’s go through the major components of our system one by one.</p><h3 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h3><p>The Client Application monitors the workspace folder on the user’s machine and syncs all files/folders in it with the remote Cloud Storage. The client application will work with the storage servers to upload, download, and modify actual files to backend Cloud Storage. The client also interacts with the remote Synchronization Service to handle any file metadata updates, e.g., change in the file name, size, modification date, etc.</p><p>Here are some of the essential operations for the client:</p><ol><li>Upload and download files;</li><li>Detect file changes in the workspace folder;</li><li>Handle conflict due to offline or concurrent updates;</li></ol><p><strong>How do we handle file transfer efficiently</strong>? As mentioned above, we can break each file into smaller chunks so that we transfer only those chunks that are modified and not the whole file. Let’s say we divide each file into fixed sizes of 4MB chunks. We can statically calculate what could be an optimal chunk size based on:</p><ol><li>Storage devices we use in the cloud to optimize space utilization and Input/Output Operations Per Second (IOPS);</li><li>Network bandwidth;</li><li>Average file size in the storage;</li></ol><p>In our metadata, we should also keep a record of each file and the chunks that constitute it.</p><p><strong>Should we keep a copy of metadata with Client</strong>? Keeping a local copy of metadata not only enable us to do offline updates but also saves a lot of round trips to update remote metadata.</p><p><strong>How can clients efficiently listen to changes happening with other clients</strong>? One solution could be that the clients periodically check with the server if there are any changes. The problem with this approach is that we will have a delay in reflecting changes locally as clients will be checking for changes periodically compared to a server notifying whenever there is some change. If the client frequently checks the server for changes, it will not only be wasting bandwidth, as the server has to return an empty response most of the time, but will also be keeping the server busy. Pulling information in this manner is not scalable.<br>A solution to the above problem could be to use HTTP long polling. With long polling the client requests information from the server with the expectation that the server may not respond immediately. If the server has no new data for the client when the poll is received, instead of sending an empty response, the server holds the request open and waits for response information to become available. Once it does have new information, the server immediately sends an HTTP/S response to the client, completing the open HTTP/S request. Upon receipt of the server response, the client can immediately issue another server request for future updates.</p><p>Based on the above considerations, we can divide our client into following four parts:</p><ol><li><strong>Internal Metadata Database</strong> will keep track of all the files, chunks, their versions, and their location in the file system;</li><li><strong>Chunker</strong> will split the files into smaller pieces called chunks. It will also be responsible for reconstructing a file from its chunks. Our chunking algorithm will detect the parts of the files that have been modified by the user and only transfer those parts to the Cloud Storage; this will save us bandwidth and synchronization time;</li><li><strong>Watcher</strong> will monitor the local workspace folders and notify the Indexer of any action performed by the users, e.g., when users create, delete, or update files or folders. Watcher also listens to any changes happening on other clients that are broadcasted by Synchronization Service;</li><li><strong>Indexer</strong> will process the events received from the Watcher and update the internal metadata database with information about the chunks of the modified files. Once the chunks are successfully submitted/downloaded to the Cloud Storage, the Indexer will communicate with the remote Synchronization Service to broadcast changes to other clients and update remote metadata database;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/33.png" alt></p><p><strong>How should clients handle slow servers</strong>? Clients should exponentially back-off if the server is busy/not-responding. Meaning, if a server is too slow to respond, clients should delay their retries and this delay should increase exponentially.</p><p><strong>Should mobile clients sync remote changes immediately</strong>? Unlike desktop or web clients, mobile clients usually sync on demand to save user’s bandwidth and space.</p><h3 id="Metadata-Database"><a href="#Metadata-Database" class="headerlink" title="Metadata Database"></a>Metadata Database</h3><p>The Metadata Database is responsible for maintaining the versioning and metadata information about files/chunks, users, and workspaces. The Metadata Database can be a relational database such as MySQL, or a NoSQL database service such as DynamoDB. Regardless of the type of the database, the Synchronization Service should be able to provide a consistent view of the files using a database, especially if more than one user is working with the same file simultaneously. Since NoSQL data stores do not support ACID properties in favor of scalability and performance, we need to incorporate the support for ACID properties programmatically in the logic of our Synchronization Service in case we opt for this kind of database. However, using a relational database can simplify the implementation of the Synchronization Service as they natively support ACID properties.</p><p>The Metadata Database should be storing information about following objects:</p><ol><li>Chunks;</li><li>Files;</li><li>User;</li><li>Devices;</li><li>Workspace (sync folders);</li></ol><h3 id="Synchronization-Service"><a href="#Synchronization-Service" class="headerlink" title="Synchronization Service"></a>Synchronization Service</h3><p>The Synchronization Service is the component that processes file updates made by a client and applies these changes to other subscribed clients. It also synchronizes clients’ local databases with the information stored in the remote Metadata Database. The Synchronization Service is the most important part of the system architecture due to its critical role in managing the metadata and synchronizing users’ files. Desktop clients communicate with the Synchronization Service to either obtain updates from the Cloud Storage or send files and updates to the Cloud Storage and, potentially, other users. If a client was offline for a period, it polls the system for new updates as soon as they come online. When the Synchronization Service receives an update request, it checks with the Metadata Database for consistency and then proceeds with the update. Subsequently, a notification is sent to all subscribed users or devices to report the file update.</p><p>The Synchronization Service should be designed in such a way that it transmits less data between clients and the Cloud Storage to achieve a better response time. To meet this design goal, the Synchronization Service can employ a differencing algorithm to reduce the amount of the data that needs to be synchronized. Instead of transmitting entire files from clients to the server or vice versa, we can just transmit the difference between two versions of a file. Therefore, only the part of the file that has been changed is transmitted. This also decreases bandwidth consumption and cloud data storage for the end user. As described above, we will be dividing our files into 4MB chunks and will be transferring modified chunks only. Server and clients can calculate a hash (e.g., SHA-256) to see whether to update the local copy of a chunk or not. On the server, if we already have a chunk with a similar hash (even from another user), we don’t need to create another copy, we can use the same chunk.</p><p>To be able to provide an efficient and scalable synchronization protocol we can consider using a communication middleware between clients and the Synchronization Service. The messaging middleware should provide scalable message queuing and change notifications to support a high number of clients using pull or push strategies. This way, multiple Synchronization Service instances can receive requests from a global Request Queue, and the communication middleware will be able to balance its load.</p><h3 id="Message-Queuing-Service"><a href="#Message-Queuing-Service" class="headerlink" title="Message Queuing Service"></a>Message Queuing Service</h3><p>An important part of our architecture is a messaging middleware that should be able to handle a substantial number of requests. A scalable Message Queuing Service that supports asynchronous message-based communication between clients and the Synchronization Service best fits the requirements of our application. The Message Queuing Service supports asynchronous and loosely coupled message-based communication between distributed components of the system. The Message Queuing Service should be able to efficiently store any number of messages in a highly available, reliable and scalable queue.</p><p>The Message Queuing Service will implement two types of queues in our system. The Request Queue is a global queue and all clients will share it. Clients’ requests to update the Metadata Database will be sent to the Request Queue first, from there the Synchronization Service will take it to update metadata. The Response Queues that correspond to individual subscribed clients are responsible for delivering the update messages to each client. Since a message will be deleted from the queue once received by a client, we need to create separate Response Queues for each subscribed client to share update messages:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/34.png" alt></p><h3 id="Cloud-Block-Storage"><a href="#Cloud-Block-Storage" class="headerlink" title="Cloud/Block Storage"></a>Cloud/Block Storage</h3><p>Cloud/Block Storage stores chunks of files uploaded by the users. Clients directly interact with the storage to send and receive objects from it. Separation of the metadata from storage enables us to use any storage either in the cloud or in-house:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/35.png" alt></p><h2 id="File-Processing-Workflow"><a href="#File-Processing-Workflow" class="headerlink" title="File Processing Workflow"></a>File Processing Workflow</h2><p>The sequence below shows the interaction between the components of the application in a scenario when Client A updates a file that is shared with Client B and C, so they should receive the update too. If the other clients are not online at the time of the update, the Message Queuing Service keeps the update notifications in separate response queues for them until they come online later:</p><ol><li>Client A uploads chunks to cloud storage;</li><li>Client A updates metadata and commits changes;</li><li>Client A gets confirmation and notifications are sent to Clients B and C about the changes;</li><li>Client B and C receive metadata changes and download updated chunks;</li></ol><h2 id="Data-Deduplication"><a href="#Data-Deduplication" class="headerlink" title="Data Deduplication"></a>Data Deduplication</h2><p>Data deduplication is a technique used for eliminating duplicate copies of data to improve storage utilization. It can also be applied to network data transfers to reduce the number of bytes that must be sent. For each new incoming chunk, we can calculate a hash of it and compare that hash with all the hashes of the existing chunks to see if we already have the same chunk present in our storage.</p><p>We can implement deduplication in two ways in our system:</p><ul><li><strong>Post-process deduplication</strong>: With post-process deduplication, new chunks are first stored on the storage device and later some process analyzes the data looking for duplication. The benefit is that clients will not need to wait for the hash calculation or lookup to complete before storing the data, thereby ensuring that there is no degradation in storage performance. Drawbacks of this approach are:<ol><li>We will unnecessarily be storing duplicate data, though for a short time;</li><li>Duplicate data will be transferred consuming bandwidth;</li></ol></li><li><strong>In-line deduplication</strong>: Alternatively, deduplication hash calculations can be done in real-time as the clients are entering data on their device. If our system identifies a chunk that it has already stored, only a reference to the existing chunk will be added in the metadata, rather than a full copy of the chunk. This approach will give us optimal network and storage usage;</li></ul><h2 id="Metadata-Partitioning"><a href="#Metadata-Partitioning" class="headerlink" title="Metadata Partitioning"></a>Metadata Partitioning</h2><p>To scale out metadata DB, we need to partition it so that it can store information about millions of users and billions of files/chunks. We need to come up with a partitioning scheme that would divide and store our data in different DB servers.</p><p><strong>Vertical Partitioning</strong>: We can partition our database in such a way that we store tables related to one particular feature on one server. For example, we can store all the user related tables in one database and all files/chunks related tables in another database. Although this approach is straightforward to implement it has some issues:</p><ol><li>Will we still have scale issues? What if we have trillions of chunks to be stored and our database cannot support storing such a huge number of records? How would we further partition such tables?</li><li>Joining two tables in two separate databases can cause performance and consistency issues. How frequently do we have to join user and file tables?</li></ol><p><strong>Range Based Partitioning</strong>: What if we store files/chunks in separate partitions based on the first letter of the File Path? In that case, we save all the files starting with the letter “A” in one partition and those that start with the letter “B” into another partition and so on. This approach is called range based partitioning. We can even combine certain less frequently occurring letters into one database partition. We should come up with this partitioning scheme statically so that we can always store/find a file in a predictable manner.<br>The main problem with this approach is that it can lead to unbalanced servers. For example, if we decide to put all files starting with the letter “E” into a DB partition, and later we realize that we have too many files that start with the letter “E”, to such an extent that we cannot fit them into one DB partition.</p><p><strong>Hash-Based Partitioning</strong>: In this scheme we take a hash of the object we are storing and based on this hash we figure out the DB partition to which this object should go. In our case, we can take the hash of the “FileID” of the File object we are storing to determine the partition the file will be stored. Our hashing function will randomly distribute objects into different partitions, e.g., our hashing function can always map any ID to a number between [1, 256], and this number would be the partition we will store our object.</p><h2 id="Caching"><a href="#Caching" class="headerlink" title="Caching"></a>Caching</h2><p>We can have two kinds of caches in our system. To deal with hot files/chunks we can introduce a cache for Block storage. We can use an off-the-shelf solution like Memcached that can store whole chunks with its respective IDs/Hashes and Block servers before hitting Block storage can quickly check if the cache has desired chunk. Based on clients’ usage pattern we can determine how many cache servers we need. A high-end commercial server can have 144GB of memory; one such server can cache 36K chunks. Similarly, we can have a cache for Metadata Database.</p><p><strong>Which cache replacement policy would best fit our needs</strong>? When the cache is full, and we want to replace a chunk with a newer/hotter chunk, how would we choose? Least Recently Used (LRU) can be a reasonable policy for our system. Under this policy, we discard the least recently used chunk first.</p><h2 id="Load-Balancer"><a href="#Load-Balancer" class="headerlink" title="Load Balancer"></a>Load Balancer</h2><p>We can add the Load balancing layer at two places in our system:</p><ol><li>Between Clients and Block servers;</li><li>Between Clients and Metadata servers;</li></ol><p>Initially, a simple Round Robin approach can be adopted that distributes incoming requests equally among backend servers. This LB is simple to implement and does not introduce any overhead. Another benefit of this approach is if a server is dead, LB will take it out of the rotation and will stop sending any traffic to it. A problem with Round Robin LB is, it won’t take server load into consideration. If a server is overloaded or slow, the LB will not stop sending new requests to that server. To handle this, a more intelligent LB solution can be placed that periodically queries backend server about their load and adjusts traffic based on that.</p><h2 id="Security-Permissions-and-File-Sharing"><a href="#Security-Permissions-and-File-Sharing" class="headerlink" title="Security, Permissions and File Sharing"></a>Security, Permissions and File Sharing</h2><p>One of the primary concerns users will have while storing their files in the cloud is the privacy and security of their data, especially since in our system users can share their files with other users or even make them public to share it with everyone. To handle this, we will be storing the permissions of each file in our metadata DB to reflect what files are visible or modifiable by any user.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Instagram</title>
      <link href="2021/02/13/Designing-Instagram/"/>
      <url>2021/02/13/Designing-Instagram/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Instagram"><a href="#What-is-Instagram" class="headerlink" title="What is Instagram?"></a>What is Instagram?</h2><p>Instagram is a social networking service that enables its users to upload and share their photos and videos with other users. Instagram users can choose to share information either publicly or privately. Anything shared publicly can be seen by any other user, whereas privately shared content can only be accessed by the specified set of people. Instagram also enables its users to share through many other social networking platforms, such as Facebook, Twitter, Flickr, and Tumblr.</p><p>We plan to design a simpler version of Instagram for this design problem, where a user can share photos and follow other users. The “News Feed” for each user will consist of top photos of all the people the user follows.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>We’ll focus on the following set of requirements while designing Instagram:<br><strong>Functional Requirements</strong>:</p><ol><li>Users should be able to upload/download/view photos;</li><li>Users can perform searches based on photo/video titles;</li><li>Users can follow other users;</li><li>The system should generate and display a user’s News Feed consisting of top photos from all the people the user follows;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>Our service needs to be highly available;</li><li>The acceptable latency of the system is 200ms for News Feed generation;</li><li>Consistency can take a hit (in the interest of availability) if a user doesn’t see a photo for a while; it should be fine;</li><li>The system should be highly reliable; any uploaded photo or video should never be lost;</li></ol><p><strong>Not in Scope</strong>: Adding tags to photos, searching photos on tags, commenting on photos, tagging users to photos, who to follow, etc.</p><a id="more"></a><h2 id="Some-Design-Considerations"><a href="#Some-Design-Considerations" class="headerlink" title="Some Design Considerations"></a>Some Design Considerations</h2><p>The system would be read-heavy, so we will focus on building a system that can retrieve photos quickly:</p><ol><li>Practically, users can upload as many photos as they like; therefore, efficient management of storage should be a crucial factor in designing this system;</li><li>Low latency is expected while viewing photos;</li><li>Data should be 100% reliable. If a user uploads a photo, the system will guarantee that it will never be lost;</li></ol><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><ul><li>Let’s assume we have 500M total users, with 1M daily active users;</li><li>2M new photos every day, 23 new photos every second;</li><li>Average photo file size: 200KB;</li><li>Total space required for 1 day of photos:<blockquote><p>2M * 200KB = 400 GB</p></blockquote></li><li>Total space required for 10 years:<blockquote><p>400GB * 365 (days a year) * 10 (years) = 1425 TB</p></blockquote></li></ul><h2 id="High-Level-System-Design"><a href="#High-Level-System-Design" class="headerlink" title="High-Level System Design"></a>High-Level System Design</h2><p>At a high level, we need to support two scenarios, one to upload photos and the other to view/search photos. Our service would need some object storage servers to store photos and some database servers to store metadata information about the photos:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/28.png" alt></p><h2 id="Database-Schema"><a href="#Database-Schema" class="headerlink" title="Database Schema"></a>Database Schema</h2><blockquote><p>Defining the DB schema in the early stages of the interview would help to understand the data flow among various components and later would guide towards data partitioning.</p></blockquote><p>We need to store data about users, their uploaded photos, and the people they follow. The Photo table will store all data related to a photo; we need to have an index on (PhotoID, CreationDate) since we need to fetch recent photos first:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/29.png" alt></p><p>A straightforward approach for storing the above schema would be to use an RDBMS like MySQL since we require joins. But relational databases come with their challenges, especially when we need to scale them.</p><p>We can store photos in a distributed file storage like HDFS or S3.<br>We can store the above schema in a distributed key-value store to enjoy the benefits offered by NoSQL. All the metadata related to photos can go to a table where the “key” would be the “PhotoID” and the “value” would be an object containing PhotoLocation, UserLocation, CreationTimestamp, etc.</p><p>If we go with a NoSQL database, we need an additional table to store the relationships between users and photos to know who owns which photo. Let’s call this table “UserPhoto”. We also need to store the list of people a user follows. Let’s call it “UserFollow”. For both of these tables, we can use a wide-column datastore like Cassandra. For the “UserPhoto” table, the “key” would be “UserID”, and the “value” would be the list of “PhotoIDs” the user owns, stored in different columns. We will have a similar scheme for the “UserFollow” table.</p><p>Cassandra or key-value stores, in general, always maintain a certain number of replicas to offer reliability. Also, in such data stores, deletes don’t get applied instantly; data is retained for certain days (to support undeleting) before getting removed from the system permanently.</p><h2 id="Data-Size-Estimation"><a href="#Data-Size-Estimation" class="headerlink" title="Data Size Estimation"></a>Data Size Estimation</h2><p>Let’s estimate how much data will be going into each table and how much total storage we will need for 10 years.</p><p><strong>User</strong>: Assuming each “int” and “dateTime” is four bytes, each row in the User’s table will be of 68 bytes:</p><blockquote><p>UserID (4 bytes) + Name (20 bytes) + Email (32 bytes) + DateOfBirth (4 bytes) + CreationDate (4 bytes) + LastLogin (4 bytes) = 68 bytes</p></blockquote><p>If we have 500 million users, we will need 32GB of total storage:</p><blockquote><p>500 million * 68 ≈ 32 GB</p></blockquote><p><strong>Photo</strong>: Each row in Photo’s table will be of 284 bytes:</p><blockquote><p>PhotoID (4 bytes) + UserID (4 bytes) + PhotoPath (256 bytes) + PhotoLatitude (4 bytes) + PhotoLongitude(4 bytes) + UserLatitude (4 bytes) + UserLongitude (4 bytes) + CreationDate (4 bytes) = 284 bytes</p></blockquote><p>If 2M new photos get uploaded every day, we will need 0.5GB of storage for one day:</p><blockquote><p>2M * 284 bytes ≈ 0.5 GB</p></blockquote><p>For 10 years we will need 1.88TB of storage.</p><p><strong>UserFollow</strong>: Each row in the UserFollow table will consist of 8 bytes. If we have 500 million users and on average each user follows 500 users. We would need 1.82TB of storage for the UserFollow table:</p><blockquote><p>500 million users * 500 followers * 8 bytes ≈ 1.82TB</p></blockquote><p>Total space required for all tables for 10 years will be 3.7TB:</p><blockquote><p>32GB + 1.88TB + 1.82TB ≈ 3.7 TB</p></blockquote><h2 id="Component-Design"><a href="#Component-Design" class="headerlink" title="Component Design"></a>Component Design</h2><p>Photo uploads (or writes) can be slow as they have to go to the disk, whereas reads will be faster, especially if they are being served from cache.</p><p>Uploading users can consume all the available connections, as uploading is a slow process. This means that “reads” cannot be served if the system gets busy with all the “write” requests. We should keep in mind that web servers have a connection limit before designing our system. If we assume that a web server can have a maximum of 500 connections at any time, then it can’t have more than 500 concurrent uploads or reads. To handle this bottleneck, we can split reads and writes into separate services. We will have dedicated servers for reads and different servers for writes to ensure that uploads don’t hog the system:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/30.png" alt></p><p>Separating photos’ read and write requests will also allow us to scale and optimize each of these operations independently.</p><h2 id="Reliability-and-Redundancy"><a href="#Reliability-and-Redundancy" class="headerlink" title="Reliability and Redundancy"></a>Reliability and Redundancy</h2><p>Losing files is not an option for our service. Therefore, we will store multiple copies of each file so that if one storage server dies, we can retrieve the photo from the other copy present on a different storage server.<br>This same principle also applies to other components of the system. If we want to have high availability of the system, we need to have multiple replicas of services running in the system so that even if a few services die down, the system remains available and running. Redundancy removes the single point of failure in the system:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/31.png" alt></p><p>If only one instance of a service is required to run at any point, we can run a redundant secondary copy of the service that is not serving any traffic, but it can take control after the failover when the primary has a problem.<br>Creating redundancy in a system can remove single points of failure and provide a backup or spare functionality if needed in a crisis. For example, if there are two instances of the same service running in production and one fails or degrades, the system can failover to the healthy copy. Failover can happen automatically or require manual intervention.</p><h2 id="Data-Sharding"><a href="#Data-Sharding" class="headerlink" title="Data Sharding"></a>Data Sharding</h2><p>Let’s discuss different schemes for metadata sharding.</p><p><strong>Partitioning based on UserID</strong>: Let’s assume we shard based on the “UserID” so that we can keep all photos of a user on the same shard. If one DB shard is 1TB, we will need four shards to store 3.7TB of data. Let’s assume, for better performance and scalability, we keep 10 shards.<br>So we’ll find the shard number by <code>UserID % 10</code> and then store the data there. To uniquely identify any photo in our system, we can append the shard number with each PhotoID.</p><p><strong>How can we generate PhotoIDs</strong>? Each DB shard can have its own auto-increment sequence for PhotoIDs, and since we will append ShardID with each PhotoID, it will make it unique throughout our system.</p><p><strong>What are the different issues with this partitioning scheme</strong>?</p><ol><li>How would we handle hot users? Several people follow such hot users, and a lot of other people see any photo they upload;</li><li>Some users will have a lot of photos compared to others, thus making a non-uniform distribution of storage;</li><li>What if we cannot store all pictures of a user on one shard? If we distribute photos of a user onto multiple shards, will it cause higher latencies?</li><li>Storing all photos of a user on one shard can cause issues like unavailability of all of the user’s data if that shard is down or higher latency if it is serving high load, etc.;</li></ol><p><strong>Partitioning based on PhotoID</strong>: If we can generate unique PhotoIDs first and then find a shard number through <code>PhotoID % 10</code>, the above problems will have been solved. We would not need to append ShardID with PhotoID in this case, as PhotoID will itself be unique throughout the system.</p><p><strong>How can we generate PhotoIDs</strong>? Here, we cannot have an auto-incrementing sequence in each shard to define PhotoID because we need to know PhotoID first to find the shard where it will be stored. One solution could be that we dedicate a separate database instance to generate auto-incrementing IDs. If our PhotoID can fit into 64 bits, we can define a table containing only a 64 bit ID field. So whenever we would like to add a photo in our system, we can insert a new row in this table and take that ID to be our PhotoID of the new photo.</p><p><strong>Wouldn’t this key generating DB be a single point of failure</strong>? Yes, it would be. A workaround for that could be to define two such databases, one generating even-numbered IDs and the other odd-numbered. For MySQL, the following script can define such sequences:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">KeyGeneratingServer1:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 1</span><br><span class="line"></span><br><span class="line">KeyGeneratingServer2:</span><br><span class="line">auto-increment-increment = 2</span><br><span class="line">auto-increment-offset = 2</span><br></pre></td></tr></table></figure><p>We can put a load balancer in front of both of these databases to round-robin between them and to deal with downtime. Both these servers could be out of sync, with one generating more keys than the other, but this will not cause any issue in our system. We can extend this design by defining separate ID tables for Users, Photo-Comments, or other objects present in our system.</p><p><strong>Alternately</strong>, we can implement a “key” generation scheme similar to what we have discussed in URL Shortening Service.</p><p><strong>How can we plan for the future growth of our system</strong>? We can have a large number of logical partitions to accommodate future data growth, such that in the beginning, multiple logical partitions reside on a single physical database server. Since each database server can have multiple database instances running on it, we can have separate databases for each logical partition on any server. So whenever we feel that a particular database server has a lot of data, we can migrate some logical partitions from it to another server. We can maintain a config file (or a separate database) that can map our logical partitions to database servers; this will enable us to move partitions around easily. Whenever we want to move a partition, we only have to update the config file to announce the change.</p><h2 id="Ranking-and-News-Feed-Generation"><a href="#Ranking-and-News-Feed-Generation" class="headerlink" title="Ranking and News Feed Generation"></a>Ranking and News Feed Generation</h2><p>To create the News Feed for any given user, we need to fetch the latest, most popular, and relevant photos of the people the user follows.</p><p>For simplicity, let’s assume we need to fetch the top 100 photos for a user’s News Feed. Our application server will first get a list of people the user follows and then fetch metadata info of each user’s latest 100 photos. In the final step, the server will submit all these photos to our ranking algorithm, which will determine the top 100 photos (based on recency, likeness, etc.) and return them to the user. A possible problem with this approach would be higher latency as we have to query multiple tables and perform sorting/merging/ranking on the results. To improve the efficiency, we can pre-generate the News Feed and store it in a separate table.</p><p><strong>Pre-generating the News Feed</strong>: We can have dedicated servers that are continuously generating users’ News Feeds and storing them in a “UserNewsFeed” table. So whenever any user needs the latest photos for their News-Feed, we will simply query this table and return the results to the user.<br>Whenever these servers need to generate the News Feed of a user, they will first query the UserNewsFeed table to find the last time the News Feed was generated for that user. Then, new News-Feed data will be generated from that time onwards (following the steps mentioned above).</p><p><strong>What are the different approaches for sending News Feed contents to the users</strong>?</p><ol><li><strong>Pull</strong>: Clients can pull the News-Feed contents from the server at a regular interval or manually whenever they need it. Possible problems with this approach are:<ol><li>New data might not be shown to the users until clients issue a pull request;</li><li>Most of the time, pull requests will result in an empty response if there is no new data;</li></ol></li><li><strong>Push</strong>: Servers can push new data to the users as soon as it is available. To efficiently manage this, users have to maintain a Long Poll request with the server for receiving the updates. A possible problem with this approach is a user who follows a lot of people or a celebrity user who has millions of followers; in this case, the server has to push updates quite frequently;</li><li><strong>Hybrid</strong>: We can adopt a hybrid approach. We can move all the users who have a high number of followers to a pull-based model and only push data to those who have a few hundred (or thousand) follows. Another approach could be that the server pushes updates to all the users not more than a certain frequency and letting users with a lot of followers/updates to pull data regularly.</li></ol><h2 id="News-Feed-Creation-with-Sharded-Data"><a href="#News-Feed-Creation-with-Sharded-Data" class="headerlink" title="News Feed Creation with Sharded Data"></a>News Feed Creation with Sharded Data</h2><p>One of the most important requirements to create the News Feed for any given user is to fetch the latest photos from all people the user follows. For this, we need to have a mechanism to sort photos on their time of creation. To efficiently do this, we can make photo creation time part of the PhotoID. As we will have a primary index on PhotoID, it will be quite quick to find the latest PhotoIDs.<br>We can use epoch time for this. Let’s say our PhotoID will have two parts; the first part will be representing epoch time, and the second part will be an auto-incrementing sequence. So to make a new PhotoID, we can take the current epoch time and append an auto-incrementing ID from our key-generating DB. We can figure out the shard number from this PhotoID (PhotoID % 10) and store the photo there.</p><p><strong>What could be the size of our PhotoID</strong>? Let’s say our epoch time starts today; how many bits we would need to store the number of seconds for the next 50 years?</p><blockquote><p>86400 sec/day * 365 (days a year) * 50 (years) ≈ 1.6 billion seconds</p></blockquote><p>We would need 31 bits to store this number. Since, on average, we are expecting 23 new photos per second, we can allocate 9 additional bits to store the auto-incremented sequence. So every second, we can store 2^9 new photos. We are allocating 9 bits for the sequence number which is more than what we require; we are doing this to get a full byte number (as 40 bits = 5 bytes). We can reset our auto-incrementing sequence every second.</p><h2 id="Cache-and-Load-Balancing"><a href="#Cache-and-Load-Balancing" class="headerlink" title="Cache and Load Balancing"></a>Cache and Load Balancing</h2><p>Our service would need a massive-scale photo delivery system to serve globally distributed users. Our service should push its content closer to the user using a large number of geographically distributed photo cache servers and use CDNs.</p><p>We can introduce a cache for metadata servers to cache hot database rows. We can use Memcache to cache the data, and Application Servers before hitting the database, can quickly check if the cache has desired rows. Least Recently Used (LRU) can be a reasonable cache eviction policy for our system. Under this policy, we discard the least recently viewed row first.</p><p><strong>How can we build a more intelligent cache</strong>? If we go with the eighty-twenty rule, i.e., 20% of daily read volume for photos is generating 80% of the traffic, which means that certain photos are so popular that most people read them. This dictates that we can try caching 20% of the daily read volume of photos and metadata.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing Pastebin</title>
      <link href="2021/02/12/Designing-Pastebin/"/>
      <url>2021/02/12/Designing-Pastebin/</url>
      
        <content type="html"><![CDATA[<h2 id="What-is-Pastebin"><a href="#What-is-Pastebin" class="headerlink" title="What is Pastebin?"></a>What is Pastebin?</h2><p>Pastebin like services enable users to store plain text or images over the network (typically the Internet) and generate unique URLs to access the uploaded data. Such services are also used to share data over the network quickly, as users would just need to pass the URL to let other users see it.</p><p>If you haven’t used <a href="https://pastebin.com/" target="_blank" rel="noopener">pastebin.com</a> before, please try creating a new “Paste” there and spend some time going through the different options their service offers. This will help you a lot in understanding this chapter.</p><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><p>Our Pastebin service should meet the following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Users should be able to upload or “paste” their data and get a unique URL to access it;</li><li>Users will only be able to upload text;</li><li>Data and links will expire after a specific time span automatically; users should also be able to specify expiration time;</li><li>Users should optionally be able to pick a custom alias for their paste;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>The system should be highly reliable, any data uploaded should not be lost;</li><li>The system should be highly available. This is required because if our service is down, users will not be able to access their pastes;</li><li>Users should be able to access their pastes in real-time with minimum latency;</li><li>Paste links should not be guessable (not predictable);</li></ol><p><strong>Extended Requirements</strong>:</p><ol><li>Analytics, e.g., how many times a paste was accessed?</li><li>Our service should also be accessible through REST APIs by other services;</li></ol><a id="more"></a><h2 id="Some-Design-Considerations"><a href="#Some-Design-Considerations" class="headerlink" title="Some Design Considerations"></a>Some Design Considerations</h2><p>Pastebin shares some requirements with URL Shortening Service, but there are some additional design considerations we should keep in mind.</p><p><strong>What should be the limit on the amount of text user can paste at a time</strong>? We can limit users not to paste bigger than 10MB to stop the abuse of the service.</p><p><strong>Should we impose size limits on custom URLs</strong>? Since our service supports custom URLs, users can pick any URL that they like, but providing a custom URL is not mandatory. However, it is reasonable (and often desirable) to impose a size limit on custom URLs, so that we have a consistent URL database.</p><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p><strong>Traffic estimates</strong>: Pastebin services are not expected to have traffic similar to Twitter or Facebook, let’s assume here that we get one million new pastes added to our system every day. This leaves us with five million reads per day.<br>New pastes per second:</p><blockquote><p>1M / (24 hours * 3600 seconds) ≈ 12 pastes/sec</p></blockquote><p>Paste reads per second:</p><blockquote><p>5M / (24 hours * 3600 seconds) ≈ 58 reads/sec</p></blockquote><p><strong>Storage estimates</strong>: Users can upload maximum 10MB of data; commonly Pastebin like services are used to share source code, configs, or logs. Such texts are not huge, so let’s assume that each paste on average contains 10KB.<br>At this rate, we will be storing 10GB of data per day:</p><blockquote><p>1M * 10KB = 10 GB/day</p></blockquote><p>If we want to store this data for ten years we would need the total storage capacity of 36TB.<br>With 1M pastes every day we will have 3.6 billion pastes in 10 years. We need to generate and store keys to uniquely identify these pastes. If we use base64 encoding ([A-Z, a-z, 0-9, ., -]) we would need six letters strings:</p><blockquote><p>64^6 ≈ 68.7 billion unique strings</p></blockquote><p>If it takes one byte to store one character, total size required to store 3.6B keys would be:</p><blockquote><p>3.6B * 6 = 21.6 GB</p></blockquote><p>21.6GB is negligible compared to 36TB. To keep some margin, we will assume a 70% capacity model (meaning we don’t want to use more than 70% of our total storage capacity at any point), which raises our storage needs to 51.4TB.</p><p><strong>Bandwidth estimates</strong>: For write requests, we expect 12 new pastes per second, resulting in 120KB of ingress per second:</p><blockquote><p>12 * 10KB = 120 KB/s</p></blockquote><p>As for the read request, we expect 58 requests per second. Therefore, total data egress (sent to users) will be 0.58 MB/s:</p><blockquote><p>58 * 10KB = 0.58 MB/s</p></blockquote><p>Although total ingress and egress are not big, we should keep these numbers in mind while designing our service.</p><p><strong>Memory estimates</strong>: We can cache some of the hot pastes that are frequently accessed. Following the 80-20 rule, meaning 20% of hot pastes generate 80% of traffic, we would like to cache these 20% pastes.<br>Since we have 5M read requests per day, to cache 20% of these requests, we would need:</p><blockquote><p>0.2 * 5M * 10KB = 10 GB</p></blockquote><h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><p>We can have SOAP or REST APIs to expose the functionality of our service. Following could be the definitions of the APIs to create/retrieve/delete pastes:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">addPaste(api_dev_key, paste_data, custom_url=None user_name=None, paste_name=None, expire_date=None)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>:</p><ul><li>api_dev_key: The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota;</li><li>paste_data: Textual data of the paste;</li><li>custom_url: Optional custom URL;</li><li>user_name: Optional user name to be used to generate URL;</li><li>paste_name: Optional name of the paste;</li><li>expire_date: Optional expiration date for the paste;</li></ul><p><strong>Returns</strong>: A successful insertion returns the URL through which the paste can be accessed, otherwise, it will return an error code.</p><p>Similarly, we can have Retrieve and Delete Paste APIs:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">getPaste(api_dev_key, api_paste_key)</span><br></pre></td></tr></table></figure><p>Where “api_paste_key” is a string representing the Paste Key of the paste to be retrieved. This API will return the textual data of the paste.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deletePaste(api_dev_key, api_paste_key)</span><br></pre></td></tr></table></figure><p>A successful deletion returns “true”, otherwise returns “false”.</p><h2 id="Database-Design"><a href="#Database-Design" class="headerlink" title="Database Design"></a>Database Design</h2><p>A few observations about the nature of the data we are storing:</p><ol><li>We need to store billions of records;</li><li>Each metadata object we are storing would be small (less than 1KB);</li><li>Each paste object we are storing can be of medium size (it can be a few MB);</li><li>There are no relationships between records, except if we want to store which user created what paste;</li><li>Our service is read-heavy;</li></ol><p><strong>Database Schema</strong>: We would need two tables, one for storing information about the pastes and the other for users’ data:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/25.png" alt></p><p>Here, “URLHash” is the URL equivalent of the TinyURL, and “ContentKey” is a reference to an external object storing the contents of the paste; we’ll discuss the external storage of the paste contents later in the chapter.</p><h2 id="High-Level-Design"><a href="#High-Level-Design" class="headerlink" title="High-Level Design"></a>High-Level Design</h2><p>At a high level, we need an application layer that will serve all the read and write requests. Application layer will talk to a storage layer to store and retrieve data. We can segregate our storage layer with one database storing metadata related to each paste, users, etc., while the other storing the paste contents in some object storage (like Amazon S3). This division of data will also allow us to scale them individually:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/26.png" alt></p><h2 id="Component-Design"><a href="#Component-Design" class="headerlink" title="Component Design"></a>Component Design</h2><h3 id="Application-layer"><a href="#Application-layer" class="headerlink" title="Application layer"></a>Application layer</h3><p>Our application layer will process all incoming and outgoing requests. The application servers will be talking to the backend data store components to serve the requests.</p><p><strong>How to handle a write-request</strong>? Upon receiving a write-request, our application server will generate a six-letter random string, which would serve as the key of the paste (if the user has not provided a custom key). The application server will then store the contents of the paste and the generated key in the database. After the successful insertion, the server can return the key to the user. One possible problem here could be that the insertion fails because of a duplicate key. Since we are generating a random key, there is a possibility that the newly generated key could match an existing one. In that case, we should regenerate a new key and try again. We should keep retrying until we don’t see failure due to the duplicate key. We should return an error to the user if the custom key they have provided is already present in our database.</p><p>Another solution for the above problem could be to run a standalone <strong>Key Generation Service (KGS)</strong> that generates random six letters strings beforehand and stores them in a database (let’s call it key-DB). Whenever we want to store a new paste, we will just take one of the already generated keys and use it. This approach will make things quite simple and fast since we will not be worrying about duplications or collisions. KGS will make sure all the keys inserted in key-DB are unique. KGS can use two tables to store keys, one for keys that are not used yet and one for all the used keys. As soon as KGS gives some keys to an application server, it can move these to the used keys table. KGS can always keep some keys in memory so that whenever a server needs them, it can quickly provide them. As soon as KGS loads some keys in memory, it can move them to the used keys table, this way we can make sure each server gets unique keys. If KGS dies before using all the keys loaded in memory, we will be wasting those keys. We can ignore these keys given that we have a huge number of them.</p><p><strong>Isn’t KGS a single point of failure</strong>? Yes, it is. To solve this, we can have a standby replica of KGS and whenever the primary server dies it can take over to generate and provide keys.</p><p><strong>Can each app server cache some keys from key-DB</strong>? Yes, this can surely speed things up. Although in this case, if the application server dies before consuming all the keys, we will end up losing those keys. This could be acceptable since we have 68.7B unique six letters keys, which are a lot more than we require.</p><p><strong>How does it handle a paste read request</strong>? Upon receiving a read paste request, the application service layer contacts the datastore. The datastore searches for the key, and if it is found, it returns the paste’s contents. Otherwise, an error code is returned.</p><h3 id="Datastore-layer"><a href="#Datastore-layer" class="headerlink" title="Datastore layer"></a>Datastore layer</h3><p>We can divide our datastore layer into two:</p><ol><li>Metadata database: We can use a relational database like MySQL or a Distributed Key-Value store like Dynamo or Cassandra;</li><li>Object storage: We can store our contents in an Object Storage like Amazon S3. Whenever we feel like hitting our full capacity on content storage, we can easily increase it by adding more servers;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/27.png" alt></p><h2 id="Purging-or-DB-Cleanup"><a href="#Purging-or-DB-Cleanup" class="headerlink" title="Purging or DB Cleanup"></a>Purging or DB Cleanup</h2><p>Please see <a href="https://snlndod.github.io/2021/02/08/Designing-a-URL-Shortening-Service-Like-TinyURL/" target="_blank" rel="noopener">Designing a URL Shortening Service Like TinyURL</a>.</p><h2 id="Data-Partitioning-and-Replication"><a href="#Data-Partitioning-and-Replication" class="headerlink" title="Data Partitioning and Replication"></a>Data Partitioning and Replication</h2><p>Please see <a href="https://snlndod.github.io/2021/02/08/Designing-a-URL-Shortening-Service-Like-TinyURL/" target="_blank" rel="noopener">Designing a URL Shortening Service Like TinyURL</a>.</p><h2 id="Cache-and-Load-Balancer"><a href="#Cache-and-Load-Balancer" class="headerlink" title="Cache and Load Balancer"></a>Cache and Load Balancer</h2><p>Please see <a href="https://snlndod.github.io/2021/02/08/Designing-a-URL-Shortening-Service-Like-TinyURL/" target="_blank" rel="noopener">Designing a URL Shortening Service Like TinyURL</a>.</p><h2 id="Security-and-Permissions"><a href="#Security-and-Permissions" class="headerlink" title="Security and Permissions"></a>Security and Permissions</h2><p>Please see <a href="https://snlndod.github.io/2021/02/08/Designing-a-URL-Shortening-Service-Like-TinyURL/" target="_blank" rel="noopener">Designing a URL Shortening Service Like TinyURL</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Designing a URL Shortening Service Like TinyURL</title>
      <link href="2021/02/08/Designing-a-URL-Shortening-Service-Like-TinyURL/"/>
      <url>2021/02/08/Designing-a-URL-Shortening-Service-Like-TinyURL/</url>
      
        <content type="html"><![CDATA[<h2 id="Why-do-We-Need-URL-Shortening"><a href="#Why-do-We-Need-URL-Shortening" class="headerlink" title="Why do We Need URL Shortening?"></a>Why do We Need URL Shortening?</h2><p>URL shortening is used to create shorter aliases for long URLs. We call these shortened aliases “short links”. Users are redirected to the original URL when they hit these short links. Short links save a lot of space when displayed, printed, messaged, or tweeted. Additionally, users are less likely to mistype shorter URLs.</p><p>For example, if we shorten this page through TinyURL:</p><blockquote><p><a href="https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904/" target="_blank" rel="noopener">https://www.educative.io/collection/page/5668639101419520/5649050225344512/5668600916475904/</a></p></blockquote><p>We would get:</p><blockquote><p><a href="http://tinyurl.com/jlg8zpc" target="_blank" rel="noopener">http://tinyurl.com/jlg8zpc</a></p></blockquote><p>The shortened URL is nearly one-third the size of the actual URL.<br>URL shortening is used to optimize links across devices, track individual links to analyze audience, measure ad campaigns’ performance, or hide affiliated original URLs.</p><p>If you haven’t used <a href="https://tinyurl.com/app" target="_blank" rel="noopener">tinyurl.com</a> before, please try creating a new shortened URL and spend some time going through the various options their service offers. This will help you a lot in understanding this chapter.</p><a id="more"></a><h2 id="Requirements-and-Goals-of-the-System"><a href="#Requirements-and-Goals-of-the-System" class="headerlink" title="Requirements and Goals of the System"></a>Requirements and Goals of the System</h2><blockquote><p>You should always clarify requirements at the beginning of the interview. Be sure to ask questions to find the exact scope of the system that the interviewer has in mind.</p></blockquote><p>Our URL shortening system should meet the following requirements:<br><strong>Functional Requirements</strong>:</p><ol><li>Given a URL, our service should generate a shorter and unique alias of it. This is called a short link. This link should be short enough to be easily copied and pasted into applications;</li><li>When users access a short link, our service should redirect them to the original link;</li><li>Users should optionally be able to pick a custom short link for their URL;</li><li>Links will expire after a standard default time span. Users should be able to specify the expiration time;</li></ol><p><strong>Non-Functional Requirements</strong>:</p><ol><li>The system should be highly available. This is required because, if our service is down, all the URL redirections will start failing;</li><li>URL redirection should happen in real-time with minimal latency;</li><li>Shortened links should not be guessable (not predictable);</li></ol><p><strong>Extended Requirements</strong>:</p><ol><li>Analytics ,e.g., how many times a redirection happened?</li><li>Our service should also be accessible through REST APIs by other services;</li></ol><h2 id="Capacity-Estimation-and-Constraints"><a href="#Capacity-Estimation-and-Constraints" class="headerlink" title="Capacity Estimation and Constraints"></a>Capacity Estimation and Constraints</h2><p>Our system will be read-heavy. There will be lots of redirection requests compared to new URL shortenings. Let’s assume a 100:1 ratio between read and write.</p><p><strong>Traffic estimates</strong>: Assuming, we will have 500M new URL shortenings per month, with 100:1 read/write ratio, we can expect 50B redirections during the same period:</p><blockquote><p>100 * 500M = 50B</p></blockquote><p>What would be Queries Per Second (QPS) for our system? New URLs shortenings per second:</p><blockquote><p>500 million / (30 days * 24 hours * 3600 seconds) ≈ 200 URLs/s</p></blockquote><p>Considering 100:1 read/write ratio, URLs redirections per second will be:</p><blockquote><p>100 * 200 URLs/s = 20K/s</p></blockquote><p><strong>Storage estimates</strong>: Let’s assume we store every URL shortening request (and associated shortened link) for 5 years. Since we expect to have 500M new URLs every month, the total number of objects we expect to store will be 30 billion:</p><blockquote><p>500 million * 5 years * 12 months = 30 billion</p></blockquote><p>Let’s assume that each stored object will be approximately 500 bytes. We will need 15TB of total storage:</p><blockquote><p>30 billion * 500 bytes = 15 TB</p></blockquote><p><strong>Bandwidth estimates</strong>: For write requests, since we expect 200 new URLs every second, total incoming data for our service will be 100KB per second:</p><blockquote><p>200 * 500 bytes = 100 KB/s</p></blockquote><p>For read requests, since every second we expect 20K URLs redirections, total outgoing data for our service would be 10MB per second:</p><blockquote><p>20K * 500 bytes = 10 MB/s</p></blockquote><p><strong>Memory estimates</strong>: If we want to cache some of the hot URLs that are frequently accessed, how much memory will we need to store them? If we follow the 80-20 rule, meaning 20% of URLs generate 80% of traffic, we would like to cache these 20% hot URLs. Since we have 20K requests per second, we will be getting 1.7 billion requests per day:</p><blockquote><p>20K * 3600 seconds * 24 hours ≈ 1.7 billion</p></blockquote><p>To cache 20% of these requests, we will need 170GB of memory:</p><blockquote><p>0.2 * 1.7 billion * 500 bytes = 170 GB</p></blockquote><p>One thing to note here is that since there will be many duplicate requests (of the same URL), our actual memory usage will be less than 170GB.</p><p><strong>High-level estimates</strong>: Assuming 500 million new URLs per month and 100:1 read:write ratio, following is the summary of the high-level estimates for our service:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/19.png" alt></p><h2 id="System-APIs"><a href="#System-APIs" class="headerlink" title="System APIs"></a>System APIs</h2><blockquote><p>Once we’ve finalized the requirements, it’s always a good idea to define the system APIs. This should explicitly state what is expected from the system.</p></blockquote><p>We can have SOAP or REST APIs to expose the functionality of our service. Following could be the definitions of the APIs for creating and deleting URLs:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">createURL(api_dev_key, original_url, custom_alias=None, user_name=None, expire_date=None)</span><br></pre></td></tr></table></figure><p><strong>Parameters</strong>: </p><ul><li>api_dev_key: The API developer key of a registered account. This will be used to, among other things, throttle users based on their allocated quota;</li><li>original_url: Original URL to be shortened;</li><li>custom_alias: Optional custom key for the URL;</li><li>user_name: Optional user name to be used in the encoding;</li><li>expire_date: Optional expiration date for the shortened URL;</li></ul><p><strong>Returns</strong>: A successful insertion returns the shortened URL; otherwise, it returns an error code.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deleteURL(api_dev_key, url_key)</span><br></pre></td></tr></table></figure><p>Where “url_key” is a string representing the shortened URL to be retrieved; a successful deletion returns “URL Removed”.</p><p><strong>How do we detect and prevent abuse</strong>? A malicious user can put us out of business by consuming all URL keys in the current design. To prevent abuse, we can limit users via their api_dev_key. Each api_dev_key can be limited to a certain number of URL creations and redirections per some time period (which may be set to a different duration per developer key).</p><h2 id="Database-Design"><a href="#Database-Design" class="headerlink" title="Database Design"></a>Database Design</h2><blockquote><p>Defining the DB schema in the early stages of the interview would help to understand the data flow among various components and later would guide towards data partitioning.</p></blockquote><p>A few observations about the nature of the data we will store:</p><ul><li>We need to store billions of records;</li><li>Each object we store is small (less than 1K);</li><li>There are no relationships between records - other than storing which user created a URL;</li><li>Our service is read-heavy;</li></ul><p><strong>Database Schema</strong>: We would need two tables: one for storing information about the URL mappings and one for the user’s data who created the short link:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/20.png" alt></p><p><strong>What kind of database should we use</strong>? Since we anticipate storing billions of rows, and we don’t need to use relationships between objects – a NoSQL store like DynamoDB, Cassandra or Riak is a better choice. A NoSQL choice would also be easier to scale.</p><h2 id="Basic-System-Design-and-Algorithm"><a href="#Basic-System-Design-and-Algorithm" class="headerlink" title="Basic System Design and Algorithm"></a>Basic System Design and Algorithm</h2><p>The problem we are solving here is how to generate a short and unique key for a given URL.<br>In the TinyURL, the shortened URL is “<a href="http://tinyurl.com/jlg8zpc&quot;" target="_blank" rel="noopener">http://tinyurl.com/jlg8zpc&quot;</a>. The last seven characters of this URL is the short key we want to generate. We’ll explore two solutions here.</p><h3 id="Encoding-actual-URL"><a href="#Encoding-actual-URL" class="headerlink" title="Encoding actual URL"></a>Encoding actual URL</h3><p>We can compute a unique hash (e.g., MD5 or SHA256, etc.) of the given URL. The hash can then be encoded for display. This encoding could be base36 ([a-z, 0-9]) or base62 ([A-Z, a-z, 0-9]) and if we add “+” and “/“ we can use Base64 encoding. A reasonable question would be, what should be the length of the short key? 6, 8, or 10 characters?</p><p>Using base64 encoding, a 6 letters long key would result in 64^6 ≈ 68.7 billion possible strings; Using base64 encoding, an 8 letters long key would result in 64^8 ≈ 281 trillion possible strings.<br>With 68.7B unique strings, let’s assume six letter keys would suffice for our system.</p><p>If we use the MD5 algorithm as our hash function, it’ll produce a 128 bits hash value. After base64 encoding, well get a string having more than 21 characters (since each base64 character encodes 6 bits of the hash value). Now we only have space for 6 characters per short key; how will we choose our key then? We can take the first 6 letters for the key. This could result in key duplication; to resolve that, we can choose some other characters out of the encoding string or swap some characters.</p><p><strong>What are the different issues with our solution</strong>? We have the following couple of problems with our encoding scheme:</p><ol><li>If multiple users enter the same URL, they can get the same shortened URL, which is not acceptable;</li><li>What if parts of the URL are URL-encoded? e.g., <a href="http://www.educative.io/distributed.php?id=design" target="_blank" rel="noopener">http://www.educative.io/distributed.php?id=design</a> and <a href="http://www.educative.io/distributed.php%3Fid%3Ddesign" target="_blank" rel="noopener">http://www.educative.io/distributed.php%3Fid%3Ddesign</a> are identical except for the URL encoding;</li></ol><p><strong>Workaround for the issues</strong>: We can append an increasing sequence number to each input URL to make it unique and then generate its hash. We don’t need to store this sequence number in the databases, though. Possible problems with this approach could be an ever-increasing sequence number. Can it overflow? Appending an increasing sequence number will also impact the performance of the service.</p><p>Another solution could be to append the user id (which should be unique) to the input URL. However, if the user has not signed in, we would have to ask the user to choose a uniqueness key. Even after this, if we have a conflict, we have to keep generating a key until we get a unique one:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/21.png" alt></p><h3 id="Generating-keys-offline"><a href="#Generating-keys-offline" class="headerlink" title="Generating keys offline"></a>Generating keys offline</h3><p>We can have a standalone <strong>Key Generation Service (KGS)</strong> that generates random six-letter strings beforehand and stores them in a database (let’s call it key-DB). Whenever we want to shorten a URL, we will take one of the already-generated keys and use it. This approach will make things quite simple and fast. Not only are we not encoding the URL, but we won’t have to worry about duplications or collisions. KGS will make sure all the keys inserted into key-DB are unique:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/22.png" alt></p><p><strong>Can concurrency cause problems</strong>? As soon as a key is used, it should be marked in the database to ensure that it is not used again. If there are multiple servers reading keys concurrently, we might get a scenario where two or more servers try to read the same key from the database. How can we solve this concurrency problem?<br>Servers can use KGS to read/mark keys in the database. KGS can use two tables to store keys: one for keys that are not used yet, and one for all the used keys. As soon as KGS gives keys to one of the servers, it can move them to the used keys table. KGS can always keep some keys in memory to quickly provide them whenever a server needs them.</p><p>For simplicity, as soon as KGS loads some keys in memory, it can move them to the used keys table. This ensures each server gets unique keys. If KGS dies before assigning all the loaded keys to some server, we will be wasting those keys–which could be acceptable, given the huge number of keys we have.<br>KGS also has to make sure not to give the same key to multiple servers. For that, it must synchronize (or get a lock on) the data structure holding the keys before removing keys from it and giving them to a server.</p><p><strong>What would be the key-DB size</strong>? With base64 encoding, we can generate 68.7B unique six letters keys. If we need one byte to store one alpha-numeric character, we can store all these keys in:</p><blockquote><p>6 (characters per key) * 68.7B (unique keys) ≈ 412 GB</p></blockquote><p><strong>Isn’t KGS a single point of failure</strong>? Yes, it is. To solve this, we can have a standby replica of KGS. Whenever the primary server dies, the standby server can take over to generate and provide keys.</p><p><strong>Can each app server cache some keys from key-DB</strong>? Yes, this can surely speed things up. Although, in this case, if the application server dies before consuming all the keys, we will end up losing those keys. This can be acceptable since we have 68.7B unique six-letter keys.</p><p><strong>How would we perform a key lookup</strong>? We can look up the key in our database to get the full URL. If it’s present in the DB, issue an “HTTP 302 Redirect” status back to the browser, passing the stored URL in the “Location” field of the request. If that key is not present in our system, issue an “HTTP 404 Not Found” status or redirect the user back to the homepage.</p><p><strong>Should we impose size limits on custom aliases</strong>? Our service supports custom aliases. Users can pick any “key” they like, but providing a custom alias is not mandatory. However, it is reasonable (and often desirable) to impose a size limit on a custom alias to ensure we have a consistent URL database. Let’s assume users can specify a maximum of 16 characters per customer key (as reflected in the above database schema).</p><h2 id="Data-Partitioning-and-Replication"><a href="#Data-Partitioning-and-Replication" class="headerlink" title="Data Partitioning and Replication"></a>Data Partitioning and Replication</h2><p>To scale out our DB, we need to partition it so that it can store information about billions of URLs. We need to develop a partitioning scheme that would divide and store our data into different DB servers:</p><ol><li><strong>Range-Based Partitioning</strong>: We can store URLs in separate partitions based on the hash key’s first letter. Hence we save all the URLs starting with the letter “A” (and “a”) in one partition, save those that start with the letter “B” in another partition, and so on. This approach is called range-based partitioning. We can even combine certain less frequently occurring letters into one database partition. We should come up with a static partitioning scheme to always store/find a URL in a predictable manner.<br>The main problem with this approach is that it can lead to unbalanced DB servers. For example, we decide to put all URLs starting with the letter “E” into a DB partition, but later we realize that we have too many URLs that start with the letter “E”;</li><li><strong>Hash-Based Partitioning</strong>: In this scheme, we take a hash of the object we are storing. We then calculate which partition to use based upon the hash. In our case, we can take the hash of the ‘key’ or the short link to determine the partition in which we store the data object.<br>Our hashing function will randomly distribute URLs into different partitions (e.g., our hashing function can always map any “key” to a number between [1, 256]). This number would represent the partition in which we store our object. This approach can still lead to overloaded partitions, which can be solved using Consistent Hashing;</li></ol><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>We can cache URLs that are frequently accessed. We can use some off-the-shelf solution like Memcached, which can store full URLs with their respective hashes. Before hitting backend storage, the application servers can quickly check if the cache has the desired URL.</p><p><strong>How much cache memory should we have</strong>? We can start with 20% of daily traffic and, based on clients’ usage patterns, we can adjust how many cache servers we need. As estimated above, we need 170GB memory to cache 20% of daily traffic. Since a modern-day server can have 256GB memory, we can easily fit all the cache into one machine. Alternatively, we can use a couple of smaller servers to store all these hot URLs.</p><p><strong>Which cache eviction policy would best fit our needs</strong>? When the cache is full, and we want to replace a link with a newer/hotter URL, how would we choose? Least Recently Used (LRU) can be a reasonable policy for our system. Under this policy, we discard the least recently used URL first. We can use a Linked Hash Map or a similar data structure to store our URLs and Hashes, which will also keep track of the URLs that have been accessed recently.</p><p>To further increase the efficiency, we can replicate our caching servers to distribute the load between them.<br><strong>How can each cache replica be updated</strong>? Whenever there is a cache miss, our servers would be hitting a backend database. Whenever this happens, we can update the cache and pass the new entry to all the cache replicas. Each replica can update its cache by adding the new entry. If a replica already has that entry, it can simply ignore it:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/23.png" alt></p><h2 id="Load-Balancer"><a href="#Load-Balancer" class="headerlink" title="Load Balancer"></a>Load Balancer</h2><p>We can add a Load balancing layer at three places in our system:</p><ol><li>Between Clients and Application Servers;</li><li>Between Application Servers and Database Servers;</li><li>Between Application Servers and Cache Servers;</li></ol><p>Initially, we could use a simple Round Robin approach that distributes incoming requests equally among backend servers. This LB is simple to implement and does not introduce any overhead. Another benefit of this approach is that if a server is dead, LB will take it out of the rotation and will stop sending any traffic to it.</p><p>A problem with Round Robin LB is that we don’t take the server load into consideration. If a server is overloaded or slow, the LB will not stop sending new requests to that server. To handle this, a more intelligent LB solution can be placed that periodically queries the backend server about its load and adjusts traffic based on that.</p><h2 id="Purging-or-DB-Cleanup"><a href="#Purging-or-DB-Cleanup" class="headerlink" title="Purging or DB Cleanup"></a>Purging or DB Cleanup</h2><p>Should entries stick around forever, or should they be purged? If a user-specified expiration time is reached, what should happen to the link?</p><p>If we chose to actively search for expired links to remove them, it would put a lot of pressure on our database. Instead, we can slowly remove expired links and do a lazy cleanup. Our service will ensure that only expired links will be deleted, although some expired links can live longer but will never be returned to users:</p><ul><li>Whenever a user tries to access an expired link, we can delete the link and return an error to the user;</li><li>A separate Cleanup Service can run periodically to remove expired links from our storage and cache. This service should be very lightweight and can be scheduled to run only when the user traffic is expected to be low;</li><li>We can have a default expiration time for each link (e.g., two years);</li><li>After removing an expired link, we can put the key back in the key-DB to be reused;</li><li>Should we remove links that haven’t been visited in some length of time, say six months? This could be tricky. Since storage is getting cheap, we can decide to keep links forever;</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/24.png" alt></p><h2 id="Telemetry"><a href="#Telemetry" class="headerlink" title="Telemetry"></a>Telemetry</h2><p>How many times a short URL has been used, what were user locations, etc.? How would we store these statistics? If it is part of a DB row that gets updated on each view, what will happen when a popular URL is slammed with a large number of concurrent requests?<br>Some statistics worth tracking: country of the visitor, date and time of access, web page that referred the click, browser, or platform from where the page was accessed.</p><h2 id="Security-and-Permissions"><a href="#Security-and-Permissions" class="headerlink" title="Security and Permissions"></a>Security and Permissions</h2><p>Can users create private URLs or allow a particular set of users to access a URL?<br>We can store the permission level (public/private) with each URL in the database. We can also create a separate table to store UserIDs that have permission to see a specific URL. If a user does not have permission and tries to access a URL, we can send an error (HTTP 401) back. Given that we are storing our data in a NoSQL wide-column database like Cassandra, the key for the table storing permissions would be the “Hash” (or the KGS generated “key”). The columns will store the UserIDs of those users that have permission to see the URL.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>A Step by Step Guide</title>
      <link href="2021/02/07/A-Step-by-Step-Guide/"/>
      <url>2021/02/07/A-Step-by-Step-Guide/</url>
      
        <content type="html"><![CDATA[<p>A lot of software engineers struggle with System Design Interviews (SDIs) primarily because of three reasons:</p><ol><li>The unstructured nature of SDIs, where the candidates are asked to work on an open-ended design problem that doesn’t have a standard answer;</li><li>Candidates lack experience in developing complex and large scale systems;</li><li>Candidates did not spend enough time to prepare for SDIs;</li></ol><p>Like coding interviews, candidates who haven’t put a deliberate effort to prepare for SDIs, mostly perform poorly, especially at top companies like Google, Facebook, Amazon, Microsoft, etc. In these companies, candidates who do not perform above average have a limited chance to get an offer. On the other hand, a good performance always results in a better offer (higher position and salary) since it shows the candidate’s ability to handle a complex system.</p><a id="more"></a><h2 id="Step-1-Requirements-Clarifications"><a href="#Step-1-Requirements-Clarifications" class="headerlink" title="Step 1: Requirements Clarifications"></a>Step 1: Requirements Clarifications</h2><p>It is always a good idea to ask questions about the exact scope of the problem we are trying to solve. Design questions are mostly open-ended, and they don’t have ONE correct answer. That’s why clarifying ambiguities early in the interview becomes critical. Candidates who spend enough time to define the end goals of the system always have a better chance to be successful in the interview. Also, since we only have 35~40 minutes to design a (supposedly) large system, we should clarify what parts of the system we will be focusing on.</p><p>Let’s expand this with an actual example of designing a Twitter-like service. Here are some questions for designing Twitter that should be answered before moving on to the next steps:</p><ul><li>Will users of our service be able to post tweets and follow other people?</li><li>Should we also design to create and display the user’s timeline?</li><li>Will tweets contain photos and videos?</li><li>Are we focusing on the backend only, or are we developing the frontend too?</li><li>Will users be able to search tweets?</li><li>Do we need to display hot trending topics?</li><li>Will there be any push notification for new (or important) tweets?</li></ul><p>All such questions will determine how our end design will look like.</p><h2 id="Step-2-Back-Of-The-Envelope-Estimation"><a href="#Step-2-Back-Of-The-Envelope-Estimation" class="headerlink" title="Step 2: Back-Of-The-Envelope Estimation"></a>Step 2: Back-Of-The-Envelope Estimation</h2><p>It is always a good idea to estimate the scale of the system we’re going to design. This will also help later when we focus on scaling, partitioning, load balancing, and caching:</p><ul><li>What scale is expected from the system (e.g., number of new tweets, number of tweet views, number of timeline generations per second., etc.)?</li><li>How much storage will we need? We will have different storage requirements if users can have photos and videos in their tweets;</li><li>What network bandwidth usage are we expecting? This will be crucial in deciding how we will manage traffic and balance load between servers;</li></ul><h2 id="Step-3-System-Interface-Definition"><a href="#Step-3-System-Interface-Definition" class="headerlink" title="Step 3: System Interface Definition"></a>Step 3: System Interface Definition</h2><p>Define what APIs are expected from the system. This will establish the exact contract expected from the system and ensure if we haven’t gotten any requirements wrong. Some examples of APIs for our Twitter-like service will be:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">postTweet(user_id, tweet_data, tweet_location, user_location, timestamp, ...)</span><br><span class="line">generateTimeline(user_id, current_time, user_location, ...)</span><br><span class="line">markTweetFavorite(user_id, tweet_id, timestamp, ...)</span><br></pre></td></tr></table></figure><h2 id="Step-4-Defining-Data-Model"><a href="#Step-4-Defining-Data-Model" class="headerlink" title="Step 4: Defining Data Model"></a>Step 4: Defining Data Model</h2><p>Defining the data model in the early part of the interview will clarify how data will flow between different system components. Later, it will guide for data partitioning and management. The candidate should identify various entities of the system, how they will interact with each other, and different aspects of data management like storage, transportation, encryption, etc. Here are some entities for our Twitter-like service:</p><ul><li><strong>User</strong>: UserID, Name, Email, DoB, CreationData, LastLogin, etc.;</li><li><strong>Tweet</strong>: TweetID, Content, TweetLocation, NumberOfLikes, TimeStamp, etc.;</li><li><strong>UserFollow</strong>: UserID1, UserID2;</li><li><strong>FavoriteTweets</strong>: UserID, TweetID, TimeStamp;</li></ul><p>Which database system should we use? Will NoSQL like Cassandra best fit our needs, or should we use a MySQL-like solution? What kind of block storage should we use to store photos and videos?</p><h2 id="Step-5-High-Level-Design"><a href="#Step-5-High-Level-Design" class="headerlink" title="Step 5: High-Level Design"></a>Step 5: High-Level Design</h2><p>Draw a block diagram with 5-6 boxes representing the core components of our system. We should identify enough components that are needed to solve the actual problem from end-to-end.</p><p>For Twitter, at a high level, we will need multiple application servers to serve all the read/write requests with load balancers in front of them for traffic distributions. If we’re assuming that we will have a lot more read traffic (compared to write), we can decide to have separate servers to handle these scenarios. On the backend, we need an efficient database that can store all the tweets and support a huge number of reads. We will also need a distributed file storage system for storing photos and videos:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/18.png" alt></p><h2 id="Step-6-Detailed-Design"><a href="#Step-6-Detailed-Design" class="headerlink" title="Step 6: Detailed Design"></a>Step 6: Detailed Design</h2><p>Dig deeper into two or three major components; the interviewer’s feedback should always guide us to what parts of the system need further discussion. We should present different approaches, their Pros and Cons, and explain why we will prefer one approach over the other. Remember, there is no single answer; the only important thing is to consider tradeoffs between different options while keeping system constraints in mind:</p><ul><li>Since we will be storing a massive amount of data, how should we partition our data to distribute it to multiple databases? Should we try to store all the data of a user on the same database? What issue could it cause?</li><li>How will we handle hot users who tweet a lot or follow lots of people?</li><li>Since users’ timeline will contain the most recent (and relevant) tweets, should we try to store our data so that it is optimized for scanning the latest tweets?</li><li>How much and at which layer should we introduce cache to speed things up?</li><li>What components need better load balancing?</li></ul><h2 id="Step-7-Identifying-and-Resolving-Bottlenecks"><a href="#Step-7-Identifying-and-Resolving-Bottlenecks" class="headerlink" title="Step 7: Identifying and Resolving Bottlenecks"></a>Step 7: Identifying and Resolving Bottlenecks</h2><p>Try to discuss as many bottlenecks as possible and different approaches to mitigate them:</p><ul><li>Is there any single point of failure in our system? What are we doing to mitigate it?</li><li>Do we have enough replicas of the data so that we can still serve our users if we lose a few servers?</li><li>Similarly, do we have enough copies of different services running such that a few failures will not cause a total system shutdown?</li><li>How are we monitoring the performance of our service? Do we get alerts whenever critical components fail or their performance degrades?</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Polling vs. WebSocket vs. Server-Sent Events</title>
      <link href="2021/02/07/Polling-vs-WebSocket-vs-Server-Sent-Events/"/>
      <url>2021/02/07/Polling-vs-WebSocket-vs-Server-Sent-Events/</url>
      
        <content type="html"><![CDATA[<p>Polling, WebSocket, and Server-Sent Events are popular communication protocols between a client like a web browser and a web server. First, let’s start with understanding what a standard HTTP web request looks like. Following are a sequence of events for regular HTTP request:</p><ol><li>The client opens a connection and requests data from the server;</li><li>The server calculates the response;</li><li>The server sends the response back to the client on the opened request;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/13.png" alt></p><h2 id="Ajax-Polling"><a href="#Ajax-Polling" class="headerlink" title="Ajax Polling"></a>Ajax Polling</h2><p>Polling is a standard technique used by the vast majority of Ajax applications. The basic idea is that the client repeatedly polls (or requests) a server for data. The client makes a request and waits for the server to respond with data. If no data is available, an empty response is returned:</p><ol><li>The client opens a connection and requests data from the server using regular HTTP;</li><li>The requested webpage sends requests to the server at regular intervals (e.g., 0.5 seconds);</li><li>The server calculates the response and sends it back, just like regular HTTP traffic;</li><li>The client repeats the above three steps periodically to get updates from the server;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/14.png" alt></p><p>The problem with Polling is that the client has to keep asking the server for any new data. As a result, a lot of responses are empty, creating HTTP overhead.</p><a id="more"></a><h2 id="HTTP-Long-Polling"><a href="#HTTP-Long-Polling" class="headerlink" title="HTTP Long-Polling"></a>HTTP Long-Polling</h2><p>This is a variation of the traditional polling technique that allows the server to push information to a client whenever the data is available. With Long-Polling, the client requests information from the server exactly as in normal polling, but with the expectation that the server may not respond immediately. That’s why this technique is sometimes referred to as a “Hanging GET”:</p><ul><li>If the server does not have any data available for the client, instead of sending an empty response, the server holds the request and waits until some data becomes available;</li><li>Once the data becomes available, a full response is sent to the client. The client then immediately re-request information from the server so that the server will almost always have an available waiting request that it can use to deliver data in response to an event;</li></ul><p>The basic life cycle of an application using HTTP Long-Polling is as follows:</p><ol><li>The client makes an initial request using regular HTTP and then waits for a response;</li><li>The server delays its response until an update is available or a timeout has occurred;</li><li>When an update is available, the server sends a full response to the client;</li><li>The client typically sends a new long-poll request, either immediately upon receiving a response or after a pause to allow an acceptable latency period;</li><li>Each Long-Poll request has a timeout. The client has to reconnect periodically after the connection is closed due to timeouts;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/15.png" alt></p><h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><p>WebSocket provides full-duplex communication channels over a single TCP connection. It provides a persistent connection between a client and a server that both parties can use to start sending data at any time. The client establishes a WebSocket connection through a process known as the WebSocket handshake. If the process succeeds, then the server and client can exchange data in both directions at any time. The WebSocket protocol enables communication between a client and a server with lower overheads, facilitating real-time data transfer from and to the server. This is made possible by providing a standardized way for the server to send content to the browser without being asked by the client and allowing for messages to be passed back and forth while keeping the connection open. In this way, a two-way (bi-directional) ongoing conversation can take place between a client and a server:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/16.png" alt></p><h2 id="Server-Sent-Events-SSE"><a href="#Server-Sent-Events-SSE" class="headerlink" title="Server-Sent Events (SSE)"></a>Server-Sent Events (SSE)</h2><p>Under SSE the client establishes a persistent and long-term connection with the server. The server uses this connection to send data to a client. If the client wants to send data to the server, it would require the use of another technology/protocol to do so:</p><ol><li>Client requests data from a server using regular HTTP;</li><li>The requested webpage opens a connection to the server;</li><li>The server sends the data to the client whenever there’s new information available;</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/17.png" alt></p><p>SSE is best when we need real-time traffic from the server to the client or if the server is generating data in a loop and will be sending multiple events to the client.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Consistent Hashing</title>
      <link href="2021/02/06/Consistent-Hashing/"/>
      <url>2021/02/06/Consistent-Hashing/</url>
      
        <content type="html"><![CDATA[<p><code>Distributed Hash Table</code> (DHT) is one of the fundamental components used in distributed scalable systems. Hash Tables need a key, a value, and a hash function where hash function maps the key to a location where the value is stored:</p><blockquote><p>index = hash_function(key)</p></blockquote><p>Suppose we are designing a distributed caching system. Given “n” cache servers, an intuitive hash function would be “key % n”. It is simple and commonly used. But it has two major drawbacks:</p><ol><li>It is NOT horizontally scalable. Whenever a new cache host is added to the system, all existing mappings are broken. It will be a pain point in maintenance if the caching system contains lots of data. Practically, it becomes difficult to schedule a downtime to update all caching mappings;</li><li>It may NOT be load balanced, especially for non-uniformly distributed data. In practice, it can be easily assumed that the data will not be distributed uniformly. For the caching system, it translates into some caches becoming hot and saturated while the others idle and are almost empty;</li></ol><p>In such situations, consistent hashing is a good way to improve the caching system.</p><h2 id="What-is-Consistent-Hashing"><a href="#What-is-Consistent-Hashing" class="headerlink" title="What is Consistent Hashing?"></a>What is Consistent Hashing?</h2><p>Consistent hashing is a very useful strategy for distributed caching systems and DHTs. It allows us to distribute data across a cluster in such a way that will minimize reorganization when nodes are added or removed. Hence, the caching system will be easier to scale up or scale down.</p><p>In Consistent Hashing, when the hash table is resized (e.g., a new cache host is added to the system), only “k/n” keys need to be remapped where “k” is the total number of keys and “n” is the total number of servers. Recall that in a caching system using the “mod” as the hash function, all keys need to be remapped.</p><p>In Consistent Hashing, objects are mapped to the same host if possible. When a host is removed from the system, the objects on that host are shared by other hosts; when a new host is added, it takes its share from a few hosts without touching other’s shares.</p><a id="more"></a><h2 id="How-does-It-Work"><a href="#How-does-It-Work" class="headerlink" title="How does It Work?"></a>How does It Work?</h2><p>As a typical hash function, consistent hashing maps a key to an integer. Suppose the output of the hash function is in the range of [0, 256]. Imagine that the integers in the range are placed on a ring such that the values are wrapped around.</p><p>Here’s how consistent hashing works:</p><ol><li>Given a list of cache servers, hash them to integers in the range;</li><li>To map a key to a server,<ul><li>Hash it to a single integer;</li><li>Move clockwise on the ring until finding the first cache it encounters;</li><li>That cache is the one that contains the key. See animation below as an example: key1 maps to cache A; key2 maps to cache C;</li></ul></li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/08.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/09.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/10.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/11.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/12.png" alt></p><p>To add a new server, say D, keys that were originally residing at C will be split. Some of them will be shifted to D, while other keys will not be touched.<br>To remove a cache or, if a cache fails, say A, all keys that were originally mapped to A will fall into B, and only those keys need to be moved to B; other keys will not be affected.</p><p>For load balancing, as we discussed in the beginning, the real data is essentially randomly distributed and thus may not be uniform. It may make the keys on caches unbalanced.<br>To handle this issue, we add “virtual replicas” for caches. Instead of mapping each cache to a single point on the ring, we map it to multiple points on the ring, i.e., replicas. This way, each cache is associated with multiple portions of the ring.<br>If the hash function “mixes well”, as the number of replicas increases, the keys will be more balanced.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CAP Theorem</title>
      <link href="2021/02/06/CAP-Theorem/"/>
      <url>2021/02/06/CAP-Theorem/</url>
      
        <content type="html"><![CDATA[<p>CAP theorem states that it is impossible for a distributed software system to simultaneously provide more than two out of three of the following guarantees (CAP): Consistency, Availability, and Partition tolerance. When we design a distributed system, trading off among CAP is almost the first thing we want to consider. CAP theorem says while designing a distributed system we can pick only two of the following three options:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/07.png" alt></p><a id="more"></a><ul><li><strong>Consistency</strong>: All nodes see the same data at the same time. Consistency is achieved by updating several nodes before allowing further reads;</li><li><strong>Availability</strong>: Every request gets a response on success/failure. Availability is achieved by replicating the data across different servers;</li><li><strong>Partition tolerance</strong>: The system continues to work despite message loss or partial failure. A system that is partition-tolerant can sustain any amount of network failure that doesn’t result in a failure of the entire network. Data is sufficiently replicated across combinations of nodes and networks to keep the system up through intermittent outages;</li></ul><p>We cannot build a general data store that is continually available, sequentially consistent, and tolerant to any partition failures. We can only build a system that has any two of these three properties. Because, to be consistent, all nodes should see the same set of updates in the same order. But if the network loses a partition, updates in one partition might not make it to the other partitions before a client reads from the out-of-date partition after having read from the up-to-date one. The only thing that can be done to cope with this possibility is to stop serving requests from the out-of-date partition, but then the service is no longer 100% available.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL vs. NoSQL</title>
      <link href="2021/02/06/SQL-vs-NoSQL/"/>
      <url>2021/02/06/SQL-vs-NoSQL/</url>
      
        <content type="html"><![CDATA[<p>In the world of databases, there are two main types of solutions: SQL and NoSQL (or relational databases and non-relational databases). Both of them differ in the way they were built, the kind of information they store, and the storage method they use.</p><p>Relational databases are structured and have predefined schemas like phone books that store phone numbers and addresses. Non-relational databases are unstructured, distributed, and have a dynamic schema like file folders that hold everything from a person’s address and phone number to their Facebook “likes” and online shopping preferences.</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>Relational databases store data in rows and columns. Each row contains all the information about one entity and each column contains all the separate data points. Some of the most popular relational databases are MySQL, Oracle, MS SQL Server, SQLite, PostgreSQL, and MariaDB.</p><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>Following are the most common types of NoSQL:</p><ul><li><strong>Key-Value Stores</strong>: Data is stored in an array of key-value pairs. The “key” is an attribute name which is linked to a “value”. Well-known key-value stores include Redis, Voldemort, and Dynamo;</li><li><strong>Document Databases</strong>: In these databases, data is stored in documents (instead of rows and columns in a table) and these documents are grouped together in collections. Each document can have an entirely different structure. Document databases include the CouchDB and MongoDB;</li><li><strong>Wide-Column Databases</strong>: Instead of “tables”, in columnar databases we have column families, which are containers for rows. Unlike relational databases, we don’t need to know all the columns up front and each row doesn’t have to have the same number of columns. Columnar databases are best suited for analyzing large datasets - big names include Cassandra and HBase;</li><li><strong>Graph Databases</strong>: These databases are used to store data whose relations are best represented in a graph. Data is saved in graph structures with nodes (entities), properties (information about the entities), and lines (connections between the entities). Examples of graph database include Neo4J and InfiniteGraph;</li></ul><a id="more"></a><h2 id="High-Level-Differences-between-SQL-and-NoSQL"><a href="#High-Level-Differences-between-SQL-and-NoSQL" class="headerlink" title="High-Level Differences between SQL and NoSQL"></a>High-Level Differences between SQL and NoSQL</h2><p><strong>Storage</strong>: SQL stores data in tables where each row represents an entity and each column represents a data point about that entity; for example, if we are storing a car entity in a table, different columns could be “Color”, “Make”, “Model”, and so on.<br>NoSQL databases have different data storage models. The main ones are key-value, document, graph, and columnar. We will discuss differences between these databases below.</p><p><strong>Schema</strong>: In SQL, each record conforms to a fixed schema, meaning the columns must be decided and chosen before data entry and each row must have data for each column. The schema can be altered later, but it involves modifying the whole database and going offline.<br>In NoSQL, schemas are dynamic. Columns can be added on the fly and each “row” (or equivalent) doesn’t have to contain data for each “column”.</p><p><strong>Querying</strong>: SQL databases use SQL for defining and manipulating the data, which is very powerful. In a NoSQL database, queries are focused on a collection of documents. Sometimes it is also called <code>UnQL</code> (Unstructured Query Language). Different databases have different syntax for using UnQL.</p><p><strong>Scalability</strong>: In most common situations, SQL databases are vertically scalable, i.e., by increasing the horsepower (higher Memory, CPU, etc.) of the hardware, which can get very expensive. It is possible to scale a relational database across multiple servers, but this is a challenging and time-consuming process.<br>On the other hand, NoSQL databases are horizontally scalable, meaning we can add more servers easily in our NoSQL database infrastructure to handle a lot of traffic. Any cheap commodity hardware or cloud instances can host NoSQL databases, thus making it a lot more cost-effective than vertical scaling. A lot of NoSQL technologies also distribute data across servers automatically.</p><p><strong>Reliability or ACID</strong>: The vast majority of relational databases are ACID compliant. So, when it comes to data reliability and safe guarantee of performing transactions, SQL databases are still the better bet.<br>Most of the NoSQL solutions sacrifice ACID compliance for performance and scalability.</p><h2 id="Which-One-to-Use"><a href="#Which-One-to-Use" class="headerlink" title="Which One to Use?"></a>Which One to Use?</h2><p>When it comes to database technology, there’s no one-size-fits-all solution. That’s why many businesses rely on both relational and non-relational databases for different needs. Even as NoSQL databases are gaining popularity for their speed and scalability, there are still situations where a highly structured SQL database may perform better; choosing the right technology hinges on the use case.</p><h3 id="Reasons-to-Use-SQL-Database"><a href="#Reasons-to-Use-SQL-Database" class="headerlink" title="Reasons to Use SQL Database"></a>Reasons to Use SQL Database</h3><p>Here are a few reasons to choose a SQL database:</p><ol><li>We need to ensure ACID compliance. ACID compliance reduces anomalies and protects the integrity of your database by prescribing exactly how transactions interact with the database. Generally, NoSQL databases sacrifice ACID compliance for scalability and processing speed, but for many e-commerce and financial applications, an ACID-compliant database remains the preferred option;</li><li>Your data is structured and unchanging. If your business is not experiencing massive growth that would require more servers and if you’re only working with data that is consistent, then there may be no reason to use a system designed to support a variety of data types and high traffic volume;</li></ol><h3 id="Reasons-to-Use-NoSQL-Database"><a href="#Reasons-to-Use-NoSQL-Database" class="headerlink" title="Reasons to Use NoSQL Database"></a>Reasons to Use NoSQL Database</h3><p>When all the other components of our application are fast and seamless, NoSQL databases prevent data from being the bottleneck. Big data is contributing to a large success for NoSQL databases, mainly because it handles data differently than the traditional relational databases. A few popular examples of NoSQL databases are MongoDB, CouchDB, Cassandra, and HBase:</p><ol><li>Storing large volumes of data that often have little to no structure. A NoSQL database sets no limits on the types of data we can store together and allows us to add new types as the need changes. With document-based databases, you can store data in one place without having to define what ‘types’ of data those are in advance;</li><li>Making the most of cloud computing and storage. Cloud-based storage is an excellent cost-saving solution but requires data to be easily spread across multiple servers to scale up. Using commodity (affordable, smaller) hardware on-site or in the cloud saves you the hassle of additional software and NoSQL databases like Cassandra are designed to be scaled across multiple data centers out of the box, without a lot of headaches;</li><li>Rapid development. NoSQL is extremely useful for rapid development as it doesn’t need to be prepped ahead of time. If you’re working on quick iterations of your system which require making frequent updates to the data structure without a lot of downtime between versions, a relational database will slow you down;</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redundancy &amp; Replication</title>
      <link href="2021/02/06/Redundancy-Replication/"/>
      <url>2021/02/06/Redundancy-Replication/</url>
      
        <content type="html"><![CDATA[<p><code>Redundancy</code> is the duplication of critical components or functions of a system with the intention of increasing the reliability of the system, usually in the form of a backup or fail-safe, or to improve actual system performance. For example, if there is only one copy of a file stored on a single server, then losing that server means losing the file. Since losing data is seldom a good thing, we can create duplicate or redundant copies of the file to solve this problem.</p><p>Redundancy plays a key role in removing the single points of failure in the system and provides backups if needed in a crisis. For example, if we have two instances of a service running in production and one fails, the system can failover to the other one:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/06.png" alt></p><a id="more"></a><p><code>Replication</code> means sharing information to ensure consistency between redundant resources, such as software or hardware components, to improve reliability, fault-tolerance, or accessibility.</p><p>Replication is widely used in many DBMS, usually with a primary/replica relationship between the original and the copies. The primary server gets all the updates, which then ripple through to the replica servers. Each replica outputs a message stating that it has received the update successfully, thus allowing the sending of subsequent updates.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxies</title>
      <link href="2021/02/04/Proxies/"/>
      <url>2021/02/04/Proxies/</url>
      
        <content type="html"><![CDATA[<p>A <code>Proxy Server</code> is an intermediate server between the client and the back-end server. Clients connect to proxy servers to make a request for a service like a web page, file, connection, etc. In short, a proxy server is a piece of software or hardware that acts as an intermediary for requests from clients seeking resources from other servers:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/05.png" alt></p><p>Typically, proxies are used to filter requests, log requests, or sometimes transform requests (by adding/removing headers, encrypting/decrypting, or compressing a resource). Another advantage of a proxy server is that its cache can serve a lot of requests. If multiple clients access a particular resource, the proxy server can cache it and serve it to all the clients without going to the remote server.</p><a id="more"></a><h2 id="Proxy-Server-Types"><a href="#Proxy-Server-Types" class="headerlink" title="Proxy Server Types"></a>Proxy Server Types</h2><p>Proxies can reside on the client’s local server or anywhere between the client and the remote servers. Here are a few famous types of proxy servers:</p><ul><li><strong>Open Proxy</strong>: An open proxy is a proxy server that is accessible by any Internet user. Generally, a proxy server only allows users within a network group (i.e., a closed proxy) to store and forward Internet services such as DNS or web pages to reduce and control the bandwidth used by the group. With an open proxy, however, any user on the Internet is able to use this forwarding service. There two famous open proxy types:<ol><li><strong>Anonymous Proxy</strong>: This proxy reveals іts identity аs а server but does not disclose the іnіtіаl IP address. Though this proxy server cаn be discovered easily іt cаn be beneficial for some users аs іt hides their IP address;</li><li><strong>Transparent Proxy</strong>: Thіs proxy server аgаіn іdentіfіes іtself, аnd wіth the support of HTTP heаders, the fіrst IP аddress cаn be vіewed. The mаіn benefіt of usіng thіs sort of server іs іts аbіlіty to cаche the websіtes;</li></ol></li><li><strong>Reverse Proxy</strong>: A reverse proxy retrieves resources on behalf of a client from one or more servers. These resources are then returned to the client, appearing as if they originated from the proxy server itself;</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Indexes</title>
      <link href="2021/02/03/Indexes/"/>
      <url>2021/02/03/Indexes/</url>
      
        <content type="html"><![CDATA[<p>Indexes are well known when it comes to databases. Sooner or later there comes a time when database performance is no longer satisfactory. One of the very first things you should turn to when that happens is database indexing.</p><p>The goal of creating an index on a particular table in a database is to make it faster to search through the table and find the row or rows that we want. Indexes can be created using one or more columns of a database table, providing the basis for both rapid random lookups and efficient access of ordered records.</p><h2 id="Example-A-Library-Catalog"><a href="#Example-A-Library-Catalog" class="headerlink" title="Example: A Library Catalog"></a>Example: A Library Catalog</h2><p>A library catalog is a register that contains the list of books found in a library. The catalog is organized like a database table generally with four columns: book title, writer, subject, and date of publication. There are usually two such catalogs: one sorted by the book title and one sorted by the writer name. That way, you can either think of a writer you want to read and then look through their books or look up a specific book title you know you want to read in case you don’t know the writer’s name. These catalogs are like indexes for the database of books. They provide a sorted list of data that is easily searchable by relevant information.</p><p>Simply saying, an index is a data structure that can be perceived as a table of contents that points us to the location where actual data lives. So when we create an index on a column of a table, we store that column and a pointer to the whole row in the index. Let’s assume a table containing a list of books, the following diagram shows how an index on the “Title” column looks like:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/04.png" alt></p><a id="more"></a><p>Just like a traditional relational data store, we can also apply this concept to larger datasets. The trick with indexes is that we must carefully consider how users will access the data. In the case of data sets that are many terabytes in size, but have very small payloads (e.g., 1 KB), indexes are a necessity for optimizing data access. Finding a small payload in such a large dataset can be a real challenge, since we can’t possibly iterate over that much data in any reasonable time. Furthermore, it is very likely that such a large data set is spread over several physical devices—this means we need some way to find the correct physical location of the desired data. Indexes are the best way to do this.</p><h2 id="How-do-Indexes-Decrease-Write-Performance"><a href="#How-do-Indexes-Decrease-Write-Performance" class="headerlink" title="How do Indexes Decrease Write Performance?"></a>How do Indexes Decrease Write Performance?</h2><p>An index can dramatically speed up data retrieval but may itself be large due to the additional keys, which slow down data insertion &amp; update.</p><p>When adding rows or making updates to existing rows for a table with an active index, we not only have to write the data but also have to update the index. This will decrease the write performance. This performance degradation applies to all insert, update, and delete operations for the table. For this reason, adding unnecessary indexes on tables should be avoided and indexes that are no longer used should be removed. To reiterate, adding indexes is about improving the performance of search queries. If the goal of the database is to provide a data store that is often written to and rarely read from, in that case, decreasing the performance of the more common operation, which is writing, is probably not worth the increase in performance we get from reading.</p><p>For more details, see <a href="https://en.wikipedia.org/wiki/Database_index" target="_blank" rel="noopener">Database Indexes</a>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Partitioning</title>
      <link href="2021/02/02/Data-Partitioning/"/>
      <url>2021/02/02/Data-Partitioning/</url>
      
        <content type="html"><![CDATA[<p>Data partitioning is a technique to break up a big database (DB) into many smaller parts. It is the process of splitting up a DB/table across multiple machines to improve the manageability, performance, availability, and load balancing of an application. The justification for data partitioning is that, after a certain scale point, it is cheaper and more feasible to scale horizontally by adding more machines than to grow it vertically by adding beefier servers.</p><h2 id="Partitioning-Methods"><a href="#Partitioning-Methods" class="headerlink" title="Partitioning Methods"></a>Partitioning Methods</h2><p>There are many different schemes one could use to decide how to break up an application database into multiple smaller DBs. Below are three of the most popular schemes used by various large scale applications:</p><ol><li><strong>Horizontal Partitioning</strong>: In this scheme, we put different rows into different tables. For example, if we are storing different places in a table, we can decide that locations with ZIP codes less than 10000 are stored in one table and places with ZIP Codes greater than 10000 are stored in a separate table. This is also called a range based partitioning as we are storing different ranges of data in separate tables. Horizontal partitioning is also called as Data Sharding.<br> The key problem with this approach is that if the value whose range is used for partitioning isn’t chosen carefully, then the partitioning scheme will lead to unbalanced servers. In the previous example, splitting location based on their Zip Codes assumes that places will be evenly distributed across the different Zip Codes. This assumption is not valid as there will be a lot of places in a thickly populated area like Manhattan as compared to its suburb cities;</li><li><strong>Vertical Partitioning</strong>: In this scheme, we divide our data to store tables related to a specific feature in their own server. For example, if we are building Instagram like application - where we need to store data related to users, photos they upload, and people they follow - we can decide to place user profile information on one DB server, friend lists on another, and photos on a third server.<br> Vertical partitioning is straightforward to implement and has a low impact on the application. The main problem with this approach is that if our application experiences additional growth, then it may be necessary to further partition a feature specific DB across various servers (e.g., it would not be possible for a single server to handle all the metadata queries for 10 billion photos by 140 million users);</li><li><strong>Directory Based Partitioning</strong>: A loosely coupled approach to work around issues mentioned in the above schemes is to create a lookup service which knows your current partitioning scheme and abstracts it away from the DB access code. So, to find out where a particular data entity resides, we query the directory server that holds the mapping between each tuple key to its DB server. This loosely coupled approach means we can perform tasks like adding servers to the DB pool or changing our partitioning scheme without having an impact on the application;</li></ol><a id="more"></a><h2 id="Partitioning-Criteria"><a href="#Partitioning-Criteria" class="headerlink" title="Partitioning Criteria"></a>Partitioning Criteria</h2><ul><li><strong>Key or Hash-based partitioning</strong>: Under this scheme, we apply a hash function to some key attributes of the entity we are storing; that yields the partition number. For example, if we have 100 DB servers and our ID is a numeric value that gets incremented by one each time a new record is inserted. In this example, the hash function could be “ID % 100”, which will give us the server number where we can store/read that record. This approach should ensure a uniform allocation of data among servers. The fundamental problem with this approach is that it effectively fixes the total number of DB servers, since adding new servers means changing the hash function which would require redistribution of data and downtime for the service. A workaround for this problem is to use Consistent Hashing;</li><li><strong>List partitioning</strong>: In this scheme, each partition is assigned a list of values, so whenever we want to insert a new record, we will see which partition contains our key and then store it there. For example, we can decide all users living in Iceland, Norway, Sweden, Finland, or Denmark will be stored in a partition for the Nordic countries;</li><li><strong>Round-robin partitioning</strong>: This is a very simple strategy that ensures uniform data distribution. With “n” partitions, the “i” tuple is assigned to partition (i mod n);</li><li><strong>Composite partitioning</strong>: Under this scheme, we combine any of the above partitioning schemes to devise a new scheme. For example, first applying a list partitioning scheme and then a hash based partitioning. Consistent hashing could be considered a composite of hash and list partitioning where the hash reduces the key space to a size that can be listed;</li></ul><h2 id="Common-Problems-of-Data-Partitioning"><a href="#Common-Problems-of-Data-Partitioning" class="headerlink" title="Common Problems of Data Partitioning"></a>Common Problems of Data Partitioning</h2><p>On a partitioned database, there are certain extra constraints on the different operations that can be performed. Most of these constraints are due to the fact that operations across multiple tables or multiple rows in the same table will no longer run on the same server. Below are some of the constraints and additional complexities introduced by partitioning:</p><ul><li><strong>Joins and Denormalization</strong>: Performing joins on a database which is running on one server is straightforward, but once a database is partitioned and spread across multiple machines it is often not feasible to perform joins that span database partitions. Such joins will not be performance efficient since data has to be compiled from multiple servers. A common workaround for this problem is to denormalize the database so that queries that previously required joins can be performed from a single table. Of course, the service now has to deal with all the perils of denormalization such as data inconsistency；</li><li><strong>Referential Integrity</strong>: As we saw that performing a cross-partition query on a partitioned database is not feasible, similarly, trying to enforce data integrity constraints such as foreign keys in a partitioned database can be extremely difficult.<br>Most of RDBMS do not support foreign keys constraints across databases on different database servers. Which means that applications that require referential integrity on partitioned databases often have to enforce it in application code. Often in such cases, applications have to run regular SQL jobs to clean up dangling references;</li><li><strong>Rebalancing</strong>: There could be many reasons we have to change our partitioning scheme:<ul><li>The data distribution is not uniform, e.g., there are a lot of places for a particular ZIP code that cannot fit into one database partition;</li><li>There is a lot of load on a partition, e.g., there are too many requests being handled by the DB partition dedicated to user photos;</li></ul></li></ul><p>In such cases, either we have to create more DB partitions or have to rebalance existing partitions, which means the partitioning scheme changed and all existing data moved to new locations. Doing this without incurring downtime is extremely difficult. Using a scheme like directory based partitioning does make rebalancing a more palatable experience at the cost of increasing the complexity of the system and creating a new single point of failure (i.e., the lookup service/database).</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Caching</title>
      <link href="2021/02/01/Caching/"/>
      <url>2021/02/01/Caching/</url>
      
        <content type="html"><![CDATA[<p>Load balancing helps you scale horizontally across an ever-increasing number of servers, but caching will enable you to make vastly better use of the resources you already have as well as making otherwise unattainable product requirements feasible. Caches take advantage of the locality of reference principle: recently requested data is likely to be requested again. They are used in almost every layer of computing: hardware, operating systems, web browsers, web applications, and more. A cache is like short-term memory: it has a limited amount of space, but is typically faster than the original data source and contains the most recently accessed items. Caches can exist at all levels in architecture, but are often found at the level nearest to the front end where they are implemented to return data quickly without taxing downstream levels.</p><h2 id="Application-Server-Cache"><a href="#Application-Server-Cache" class="headerlink" title="Application Server Cache"></a>Application Server Cache</h2><p>Placing a cache directly on a request layer node enables the local storage of response data. Each time a request is made to the service, the node will quickly return local cached data if it exists. If it is not in the cache, the requesting node will query the data from disk. The cache on one request layer node could also be located both in memory (which is very fast) and on the node’s local disk (faster than going to network storage).</p><p>What happens when you expand this to many nodes? If the request layer is expanded to multiple nodes, it’s still quite possible to have each node host its own cache. However, if your load balancer randomly distributes requests across the nodes, the same request will go to different nodes, thus increasing cache misses. Two choices for overcoming this hurdle are global caches and distributed caches.</p><a id="more"></a><h2 id="Content-Distribution-Network"><a href="#Content-Distribution-Network" class="headerlink" title="Content Distribution Network"></a>Content Distribution Network</h2><p>CDNs are a kind of cache that comes into play for sites serving large amounts of static media. In a typical CDN setup, a request will first ask the CDN for a piece of static media; the CDN will serve that content if it has it locally available. If it isn’t available, the CDN will query the back-end servers for the file, cache it locally, and serve it to the requesting user.</p><p>If the system we are building isn’t yet large enough to have its own CDN, we can ease a future transition by serving the static media off a separate subdomain (e.g., static.yourservice.com) using a lightweight HTTP server like Nginx, and cut-over the DNS from your servers to a CDN later.</p><h2 id="Cache-Invalidation"><a href="#Cache-Invalidation" class="headerlink" title="Cache Invalidation"></a>Cache Invalidation</h2><p>While caching is fantastic, it does require some maintenance for keeping cache coherent with the source of truth (e.g., database). If the data is modified in the database, it should be invalidated in the cache; if not, this can cause inconsistent application behavior.</p><p>Solving this problem is known as cache invalidation; there are three main schemes that are used:</p><ul><li><strong>Write-through cache</strong>: Under this scheme, data is written into the cache and the corresponding database at the same time. The cached data allows for fast retrieval and, since the same data gets written in the permanent storage, we will have complete data consistency between the cache and the storage. Also, this scheme ensures that nothing will get lost in case of a crash, power failure, or other system disruptions.<br>Although, write through minimizes the risk of data loss, since every write operation must be done twice before returning success to the client, this scheme has the disadvantage of higher latency for write operations;</li><li><strong>Write-around cache</strong>: This technique is similar to write through cache, but data is written directly to permanent storage, bypassing the cache. This can reduce the cache being flooded with write operations that will not subsequently be re-read, but has the disadvantage that a read request for recently written data will create a “cache miss” and must be read from slower back-end storage and experience higher latency;</li><li><strong>Write-back cache</strong>: Under this scheme, data is written to cache alone and completion is immediately confirmed to the client. The write to the permanent storage is done after specified intervals or under certain conditions. This results in low latency and high throughput for write-intensive applications, however, this speed comes with the risk of data loss in case of a crash or other adverse event because the only copy of the written data is in the cache;</li></ul><h2 id="Cache-Eviction-Policies"><a href="#Cache-Eviction-Policies" class="headerlink" title="Cache Eviction Policies"></a>Cache Eviction Policies</h2><p>Following are some of the most common cache eviction policies:</p><ol><li>First In First Out (FIFO): The cache evicts the first block accessed first without any regard to how often or how many times it was accessed before;</li><li>Last In First Out (LIFO): The cache evicts the block accessed most recently first without any regard to how often or how many times it was accessed before;</li><li>Least Recently Used (LRU): Discards the least recently used items first;</li><li>Most Recently Used (MRU): Discards, in contrast to LRU, the most recently used items first;</li><li>Least Frequently Used (LFU): Counts how often an item is needed. Those that are used least often are discarded first;</li><li>Random Replacement (RR): Randomly selects a candidate item and discards it to make space when necessary;</li></ol><p>Following links have some good discussion about caching:<br>[1] <a href="https://en.wikipedia.org/wiki/Cache_(computing)" target="_blank" rel="noopener">Cache</a><br>[2] <a href="https://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener">Introduction to architecting systems</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Topological Sort</title>
      <link href="2021/01/31/Topological-Sort/"/>
      <url>2021/01/31/Topological-Sort/</url>
      
        <content type="html"><![CDATA[<p>Topological Sort is used to find a linear ordering of elements that have dependencies on each other. For example, if event “B” is dependent on event “A”, “A” comes before “B” in topological ordering.</p><p>This pattern defines an easy way to understand the technique for performing topological sorting of a set of elements and then solves a few problems using it.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict, deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMinHeightTrees</span><span class="params">(self, n: int, edges: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    <span class="comment"># handle single vertex</span></span><br><span class="line">    <span class="keyword">if</span> n == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> [<span class="number">0</span>]</span><br><span class="line">    graph, degree = defaultdict(list), defaultdict(int)</span><br><span class="line">    <span class="comment"># initialize graph</span></span><br><span class="line">    <span class="keyword">for</span> u, v <span class="keyword">in</span> edges:</span><br><span class="line">        graph[u].append(v)</span><br><span class="line">        graph[v].append(u)</span><br><span class="line">        degree[u] += <span class="number">1</span></span><br><span class="line">        degree[v] += <span class="number">1</span></span><br><span class="line">    sources = deque()</span><br><span class="line">    <span class="comment"># obtain sources</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">if</span> degree[num] == <span class="number">1</span>:</span><br><span class="line">            sources.append(num)</span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">2</span>:</span><br><span class="line">        curr_len = len(sources)</span><br><span class="line">        n -= curr_len</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(curr_len):</span><br><span class="line">            u = sources.popleft()</span><br><span class="line">            <span class="keyword">for</span> v <span class="keyword">in</span> graph[u]:</span><br><span class="line">                degree[v] -= <span class="number">1</span></span><br><span class="line">                <span class="keyword">if</span> degree[v] == <span class="number">1</span>:</span><br><span class="line">                    sources.append(v)</span><br><span class="line">    <span class="keyword">return</span> sources</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/course-schedule/" target="_blank" rel="noopener">Course Schedule</a><br><a href="https://leetcode.com/problems/course-schedule-ii/" target="_blank" rel="noopener">Course Schedule II</a><br><a href="https://leetcode.com/problems/minimum-height-trees/" target="_blank" rel="noopener">Minimum Height Trees</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>K-Way Merge</title>
      <link href="2021/01/31/K-Way-Merge/"/>
      <url>2021/01/31/K-Way-Merge/</url>
      
        <content type="html"><![CDATA[<p>This pattern helps us solve problems that involve a list of sorted arrays.</p><p>Whenever we are given “K” sorted arrays, we can use a Heap to efficiently perform a sorted traversal of all the elements of all arrays. We can push the smallest (first) element of each sorted array in a <code>Min Heap</code> to get the overall minimum. While inserting elements to the Min Heap we keep track of which array the element came from. We can, then, remove the top element from the heap to get the smallest element and push the next element from the same array, to which this smallest element belonged, to the heap. We can repeat this process to make a sorted traversal of all elements.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">smallestRange</span><span class="params">(self, nums: List[List[int]])</span> -&gt; List[int]:</span></span><br><span class="line">    start, end = -sys.maxsize, sys.maxsize</span><br><span class="line">    max_num = -sys.maxsize</span><br><span class="line">    min_heap = []</span><br><span class="line">    <span class="comment"># initialize min heap</span></span><br><span class="line">    <span class="keyword">for</span> arr <span class="keyword">in</span> nums:</span><br><span class="line">        heappush(min_heap, (arr[<span class="number">0</span>], <span class="number">0</span>, arr))</span><br><span class="line">        max_num = max(max_num, arr[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">while</span> len(min_heap) == len(nums):</span><br><span class="line">        num, index, arr = heappop(min_heap)</span><br><span class="line">        <span class="keyword">if</span> max_num - num &lt; end - start:</span><br><span class="line">            start = num</span><br><span class="line">            end = max_num</span><br><span class="line">        <span class="keyword">if</span> index + <span class="number">1</span> &lt; len(arr):</span><br><span class="line">            heappush(min_heap, (arr[index+<span class="number">1</span>], index + <span class="number">1</span>, arr))</span><br><span class="line">            max_num = max(max_num, arr[index+<span class="number">1</span>])</span><br><span class="line">    <span class="keyword">return</span> [start, end]</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">Merge k Sorted Lists</a><br><a href="https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/" target="_blank" rel="noopener">Kth Smallest Element in a Sorted Matrix</a><br><a href="https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/" target="_blank" rel="noopener">Smallest Range Covering Elements from K Lists</a><br><a href="https://leetcode.com/problems/find-k-pairs-with-smallest-sums/" target="_blank" rel="noopener">Find K Pairs with Smallest Sums</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Top K Elements</title>
      <link href="2021/01/31/Top-K-Elements/"/>
      <url>2021/01/31/Top-K-Elements/</url>
      
        <content type="html"><![CDATA[<p>Any problem that asks us to find the top/smallest/frequent “K” elements among a given set falls under this pattern.</p><p>The best data structure that comes to mind to keep track of “K” elements is <code>Heap</code>. This pattern will make use of the Heap to solve multiple problems dealing with “K” elements at a time from a set of given elements.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reorganizeString</span><span class="params">(self, S: str)</span> -&gt; str:</span></span><br><span class="line">    freq = dict()</span><br><span class="line">    <span class="comment"># obtain frequency map</span></span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> S:</span><br><span class="line">        freq[char] = freq.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    max_heap = []</span><br><span class="line">    <span class="comment"># initialize max heap</span></span><br><span class="line">    <span class="keyword">for</span> char, count <span class="keyword">in</span> freq.items():</span><br><span class="line">        heappush(max_heap, (-count, char))</span><br><span class="line">    result = <span class="string">""</span></span><br><span class="line">    prev_char, prev_count = <span class="string">""</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> max_heap:</span><br><span class="line">        count, char = heappop(max_heap)</span><br><span class="line">        <span class="keyword">if</span> prev_count &gt; <span class="number">0</span>:</span><br><span class="line">            heappush(max_heap, (-prev_count, prev_char))</span><br><span class="line">        result += char</span><br><span class="line">        prev_char = char</span><br><span class="line">        prev_count = -count - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> result <span class="keyword">if</span> len(result) == len(S) <span class="keyword">else</span> <span class="string">""</span></span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/kth-largest-element-in-an-array/" target="_blank" rel="noopener">Kth Largest Element in an Array</a><br><a href="https://leetcode.com/problems/k-closest-points-to-origin/" target="_blank" rel="noopener">K Closest Points to Origin</a><br><a href="https://leetcode.com/problems/top-k-frequent-elements/" target="_blank" rel="noopener">Top K Frequent Elements</a><br><a href="https://leetcode.com/problems/sort-characters-by-frequency/" target="_blank" rel="noopener">Sort Characters By Frequency</a><br><a href="https://leetcode.com/problems/kth-largest-element-in-a-stream/" target="_blank" rel="noopener">Kth Largest Element in a Stream</a><br><a href="https://leetcode.com/problems/find-k-closest-elements/" target="_blank" rel="noopener">Find K Closest Elements</a><br><a href="https://leetcode.com/problems/reorganize-string/" target="_blank" rel="noopener">Reorganize String</a><br><a href="https://leetcode.com/problems/task-scheduler/" target="_blank" rel="noopener">Task Scheduler</a><br><a href="https://leetcode.com/problems/maximum-frequency-stack/" target="_blank" rel="noopener">Maximum Frequency Stack</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bitwise XOR</title>
      <link href="2021/01/31/Bitwise-XOR/"/>
      <url>2021/01/31/Bitwise-XOR/</url>
      
        <content type="html"><![CDATA[<p>XOR is a logical bitwise operator that returns 0 (false) if both bits are the same and returns 1 (true) otherwise. In other words, it only returns 1 if exactly one bit is set to 1 out of the two bits in comparison:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/educative/04.png" alt></p><p>It is surprising to know the approaches that the XOR operator enables us to solve certain problems. For example, let’s take a look at the following problem:</p><blockquote><p>Given an array of n-1 integers in the range from 1 to n, find the one number that is missing from the array.</p></blockquote><p>Example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: <span class="number">1</span>, <span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">4</span></span><br><span class="line">Answer: <span class="number">3</span></span><br></pre></td></tr></table></figure><p>A straight forward approach to solve this problem can be:</p><ol><li>Find the sum of all integers from 1 to n; let’s call it: s1;</li><li>Subtract all the numbers in the input array from s1; this will give us the missing number;</li></ol><a id="more"></a><p>This is what the algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_missing_number</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr) + <span class="number">1</span></span><br><span class="line">    s1 = <span class="number">0</span></span><br><span class="line">    <span class="comment"># find sum of all numbers from 1 to n</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range (<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        s1 += i</span><br><span class="line">    <span class="comment"># subtract all numbers in input from sum</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> arr:</span><br><span class="line">        s1 -= i</span><br><span class="line">    <span class="comment"># s1, now, is the missing number</span></span><br><span class="line">    <span class="keyword">return</span> s1</span><br></pre></td></tr></table></figure><p><strong>Time &amp; Space Complexity</strong>: The time complexity of the above algorithm is O(n) and the space complexity is O(1).</p><blockquote><p>While finding the sum of numbers from 1 to n, we can get integer overflow when n is large.</p></blockquote><p>Remember the important property of XOR that it returns 0 if both the bits in comparison are the same. In other words, XOR of a number with itself will always result in 0. This means that if we XOR all the numbers in the input array with all numbers from the range 1 to n then each number in the input is going to get zeroed out except the missing number. Following are the set of steps to find the missing number using XOR:</p><ol><li>XOR all the numbers from 1 to n, let’s call it: x1;</li><li>XOR all the numbers in the input array, let’s call it: x2;</li><li>The missing number can be found by x1 XOR x2;</li></ol><p>Here is what the algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_missing_number</span><span class="params">(arr)</span>:</span></span><br><span class="line">    n = len(arr) + <span class="number">1</span></span><br><span class="line">    x1 = <span class="number">1</span></span><br><span class="line">    <span class="comment"># x1 represents XOR of all values from 1 to n</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>, n + <span class="number">1</span>):</span><br><span class="line">        x1 = x1 ^ i</span><br><span class="line">    x2 = arr[<span class="number">0</span>]</span><br><span class="line">    <span class="comment"># x2 represents XOR of all values in arr</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n - <span class="number">1</span>):</span><br><span class="line">        x2 = x2 ^ arr[i]</span><br><span class="line">    <span class="comment"># missing number is the XOR of x1 and x2</span></span><br><span class="line">    <span class="keyword">return</span> x1 ^ x2</span><br></pre></td></tr></table></figure><p><strong>Time &amp; Space Complexity</strong>: The time complexity of the above algorithm is O(n) and the space complexity is O(1). The time and space complexities are the same as that of the previous solution but, in this algorithm, we will not have any integer overflow problem.</p><p>Following are some important properties of XOR to remember:</p><ul><li>Taking XOR of a number with itself returns 0, e.g.,<ul><li>1 ^ 1 = 0;</li><li>29 ^ 29 = 0;</li></ul></li><li>Taking XOR of a number with 0 returns the same number, e.g.,<ul><li>1 ^ 0 = 1;</li><li>31 ^ 0 = 31;</li></ul></li><li>XOR is Associative &amp; Commutative, which means:<ul><li>(a ^ b) ^ c = a ^ (b ^ c);</li><li>a ^ b = b ^ a;</li></ul></li></ul><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">singleNumber</span><span class="params">(self, nums: List[int])</span> -&gt; List[int]:</span></span><br><span class="line">    n1xn2 = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        n1xn2 = n1xn2 ^ num</span><br><span class="line">    last = <span class="number">1</span></span><br><span class="line">    <span class="comment"># obtain the last one</span></span><br><span class="line">    <span class="keyword">while</span> last &amp; n1xn2 == <span class="number">0</span>:</span><br><span class="line">        last = last &lt;&lt; <span class="number">1</span></span><br><span class="line">    num1, num2 = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    <span class="comment"># divide into two parts</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums:</span><br><span class="line">        <span class="keyword">if</span> last &amp; num == <span class="number">0</span>:</span><br><span class="line">            num1 = num1 ^ num</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            num2 = num2 ^ num</span><br><span class="line">    <span class="keyword">return</span> [num1, num2]</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Two's Complement</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findComplement</span><span class="params">(self, num: int)</span> -&gt; int:</span></span><br><span class="line">    bit_cnt, n = <span class="number">0</span>, num</span><br><span class="line">    <span class="comment"># obtain bit count</span></span><br><span class="line">    <span class="keyword">while</span> n &gt; <span class="number">0</span>:</span><br><span class="line">        bit_cnt += <span class="number">1</span></span><br><span class="line">        n = n &gt;&gt; <span class="number">1</span></span><br><span class="line">    all_sets = <span class="number">2</span> ** bit_cnt - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> num ^ all_sets</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/single-number/" target="_blank" rel="noopener">Single Number</a><br><a href="https://leetcode.com/problems/single-number-iii/" target="_blank" rel="noopener">Single Number III</a><br><a href="https://leetcode.com/problems/number-complement/" target="_blank" rel="noopener">Number Complement</a><br><a href="https://leetcode.com/problems/flipping-an-image/" target="_blank" rel="noopener">Flipping an Image</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Modified Binary Search</title>
      <link href="2021/01/31/Modified-Binary-Search/"/>
      <url>2021/01/31/Modified-Binary-Search/</url>
      
        <content type="html"><![CDATA[<p>As we know, whenever we are given a sorted <code>Array</code> or <code>LinkedList</code> or <code>Matrix</code>, and we are asked to find a certain element, the best algorithm we can use is the Binary Search.</p><p>This pattern describes an efficient way to handle all problems involving Binary Search. We will go through a set of problems that will help us build an understanding of this pattern so that we can apply this technique to other problems we might come across in the interviews.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self, nums: List[int], target: int)</span> -&gt; bool:</span></span><br><span class="line">    lo, hi = <span class="number">0</span>, len(nums) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> lo &lt;= hi:</span><br><span class="line">        mid = lo + (hi - lo) // <span class="number">2</span></span><br><span class="line">        <span class="keyword">if</span> nums[mid] == target:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># obtain sorted intervals</span></span><br><span class="line">        <span class="keyword">if</span> nums[lo] == nums[mid] == nums[hi]:</span><br><span class="line">            lo += <span class="number">1</span></span><br><span class="line">            hi -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">elif</span> nums[lo] &lt;= nums[mid]:</span><br><span class="line">            <span class="keyword">if</span> nums[lo] &lt;= target &lt;= nums[mid]:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> nums[mid+<span class="number">1</span>] &lt;= target &lt;= nums[hi]:</span><br><span class="line">                lo = mid + <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                hi = mid - <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/find-smallest-letter-greater-than-target/" target="_blank" rel="noopener">Find Smallest Letter Greater Than Target</a><br><a href="https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener">Find First and Last Position of Element in Sorted Array</a><br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array/" target="_blank" rel="noopener">Search in Rotated Sorted Array</a><br><a href="https://leetcode.com/problems/search-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">Search in Rotated Sorted Array II</a><br><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array</a><br><a href="https://leetcode.com/problems/find-minimum-in-rotated-sorted-array-ii/" target="_blank" rel="noopener">Find Minimum in Rotated Sorted Array II</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Subsets</title>
      <link href="2021/01/31/Subsets/"/>
      <url>2021/01/31/Subsets/</url>
      
        <content type="html"><![CDATA[<p>A huge number of coding interview problems involve dealing with <code>Permutations</code> and <code>Combinations</code> of a given set of elements. This pattern describes an efficient Breadth-First Search (BFS) approach to handle all these problems.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Iteration</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subsetsWithDup</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    subsets = [[]]</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        start = <span class="number">0</span></span><br><span class="line">        <span class="comment"># handle duplicates</span></span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">            start = end + <span class="number">1</span></span><br><span class="line">        end = len(subsets) - <span class="number">1</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(start, end + <span class="number">1</span>):</span><br><span class="line">            subsets.append(subsets[j] + [nums[i]])</span><br><span class="line">    <span class="keyword">return</span> subsets</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Recursion</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.map = dict()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numTrees</span><span class="params">(self, n: int)</span> -&gt; int:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt;= <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span> n <span class="keyword">in</span> self.map:</span><br><span class="line">        <span class="keyword">return</span> self.map[n]</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n + <span class="number">1</span>):</span><br><span class="line">        cnt_l = self.numTrees(i - <span class="number">1</span>)</span><br><span class="line">        cnt_r = self.numTrees(n - i)</span><br><span class="line">        count += cnt_l * cnt_r</span><br><span class="line">    <span class="comment"># memorization</span></span><br><span class="line">    self.map[n] = count</span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/subsets/" target="_blank" rel="noopener">Subsets</a><br><a href="https://leetcode.com/problems/subsets-ii/" target="_blank" rel="noopener">Subsets II</a><br><a href="https://leetcode.com/problems/permutations/" target="_blank" rel="noopener">Permutations</a><br><a href="https://leetcode.com/problems/letter-case-permutation/" target="_blank" rel="noopener">Letter Case Permutation</a><br><a href="https://leetcode.com/problems/generate-parentheses/" target="_blank" rel="noopener">Generate Parentheses</a><br><a href="https://leetcode.com/problems/different-ways-to-add-parentheses/" target="_blank" rel="noopener">Different Ways to Add Parentheses</a><br><a href="https://leetcode.com/problems/unique-binary-search-trees-ii/" target="_blank" rel="noopener">Unique Binary Search Trees II</a><br><a href="https://leetcode.com/problems/unique-binary-search-trees/" target="_blank" rel="noopener">Unique Binary Search Trees</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two Heaps</title>
      <link href="2021/01/30/Two-Heaps/"/>
      <url>2021/01/30/Two-Heaps/</url>
      
        <content type="html"><![CDATA[<p>In many problems, where we are given a set of elements such that we can divide them into two parts. To solve the problem, we are interested in knowing the smallest element in one part and the biggest element in the other part. This pattern is an efficient approach to solve such problems.</p><p>This pattern uses two Heaps to solve these problems; A <code>Min Heap</code> to find the smallest element and a <code>Max Heap</code> to find the biggest element.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> heapq <span class="keyword">import</span> heappush, heappop</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.max_heap = []</span><br><span class="line">    self.min_heap = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addNum</span><span class="params">(self, num: int)</span> -&gt; <span class="keyword">None</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.max_heap <span class="keyword">or</span> num &lt;= -self.max_heap[<span class="number">0</span>]:</span><br><span class="line">        heappush(self.max_heap, -num)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        heappush(self.min_heap, num)</span><br><span class="line">    <span class="comment"># balance</span></span><br><span class="line">    <span class="keyword">if</span> len(self.max_heap) &gt; len(self.min_heap) + <span class="number">1</span>:</span><br><span class="line">        heappush(self.min_heap, -heappop(self.max_heap))</span><br><span class="line">    <span class="keyword">elif</span> len(self.max_heap) &lt; len(self.min_heap):</span><br><span class="line">        heappush(self.max_heap, -heappop(self.min_heap))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">findMedian</span><span class="params">(self)</span> -&gt; float:</span></span><br><span class="line">    <span class="keyword">if</span> len(self.max_heap) == len(self.min_heap):</span><br><span class="line">        <span class="keyword">return</span> -self.max_heap[<span class="number">0</span>] / <span class="number">2.0</span> + self.min_heap[<span class="number">0</span>] / <span class="number">2.0</span></span><br><span class="line">    <span class="keyword">return</span> -self.max_heap[<span class="number">0</span>] / <span class="number">1.0</span></span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/find-median-from-data-stream/" target="_blank" rel="noopener">Find Median from Data Stream</a><br><a href="https://leetcode.com/problems/sliding-window-median/" target="_blank" rel="noopener">Sliding Window Median</a><br><a href="https://leetcode.com/problems/ipo/" target="_blank" rel="noopener">IPO</a><br><a href="https://leetcode.com/problems/find-right-interval/" target="_blank" rel="noopener">Find Right Interval</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree Depth-First Search</title>
      <link href="2021/01/30/Tree-Depth-First-Search/"/>
      <url>2021/01/30/Tree-Depth-First-Search/</url>
      
        <content type="html"><![CDATA[<p>This pattern is based on the Depth-First Search (DFS) technique to traverse a tree.</p><p>We will be using recursion (or we can also use a stack for the iterative approach) to keep track of all the previous (parent) nodes while traversing. This also means that the space complexity of the algorithm will be O(H), where “H” is the maximum height of the tree.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">One Direction</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.paths = []</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">obtain_path</span><span class="params">(self, root, targetSum, curr_path)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    curr_path.append(root.val)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root.left <span class="keyword">and</span> <span class="keyword">not</span> root.right <span class="keyword">and</span> root.val == targetSum:</span><br><span class="line">        self.paths.append(curr_path[:])</span><br><span class="line">    targetSum -= root.val</span><br><span class="line">    <span class="comment"># DFS</span></span><br><span class="line">    self.obtain_path(root.left, targetSum, curr_path)</span><br><span class="line">    self.obtain_path(root.right, targetSum, curr_path)</span><br><span class="line">    <span class="comment"># backtracking</span></span><br><span class="line">    curr_path.pop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">pathSum</span><span class="params">(self, root: TreeNode, targetSum: int)</span> -&gt; List[List[int]]:</span></span><br><span class="line">    self.obtain_path(root, targetSum, [])</span><br><span class="line">    <span class="keyword">return</span> self.paths</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Both Directions</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">    self.max_sum = -sys.maxsize</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc_max</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="comment"># DFS</span></span><br><span class="line">    l_max = max(<span class="number">0</span>, self.calc_max(root.left))</span><br><span class="line">    r_max = max(<span class="number">0</span>, self.calc_max(root.right))</span><br><span class="line">    curr_sum = l_max + r_max + root.val</span><br><span class="line">    self.max_sum = max(self.max_sum, curr_sum)</span><br><span class="line">    <span class="keyword">return</span> max(l_max, r_max) + root.val</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">maxPathSum</span><span class="params">(self, root: TreeNode)</span> -&gt; int:</span></span><br><span class="line">    self.calc_max(root)</span><br><span class="line">    <span class="keyword">return</span> self.max_sum</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">Path Sum</a><br><a href="https://leetcode.com/problems/path-sum-ii/" target="_blank" rel="noopener">Path Sum II</a><br><a href="https://leetcode.com/problems/binary-tree-paths/" target="_blank" rel="noopener">Binary Tree Paths</a><br><a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/" target="_blank" rel="noopener">Sum Root to Leaf Numbers</a><br><a href="https://leetcode.com/problems/path-sum-iii/" target="_blank" rel="noopener">Path Sum III</a><br><a href="https://leetcode.com/problems/diameter-of-binary-tree/" target="_blank" rel="noopener">Diameter of Binary Tree</a><br><a href="https://leetcode.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener">Binary Tree Maximum Path Sum</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tree Breadth-First Search</title>
      <link href="2021/01/30/Tree-Breadth-First-Search/"/>
      <url>2021/01/30/Tree-Breadth-First-Search/</url>
      
        <content type="html"><![CDATA[<p>This pattern is based on the Breadth-First Search (BFS) technique to traverse a tree.</p><p>Any problem involving the traversal of a tree in a level-by-level order can be efficiently solved using this approach. We will use a <code>Queue</code> to keep track of all the nodes of a level before we jump onto the next level. This also means that the space complexity of the algorithm will be O(W), where “W” is the maximum number of nodes on any level.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averageOfLevels</span><span class="params">(self, root: TreeNode)</span> -&gt; List[float]:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> root:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    queue = deque([root])</span><br><span class="line">    <span class="keyword">while</span> queue:</span><br><span class="line">        curr_sum, curr_len = <span class="number">0.0</span>, len(queue)</span><br><span class="line">        <span class="keyword">for</span> _ <span class="keyword">in</span> range(curr_len):</span><br><span class="line">            node = queue.popleft()</span><br><span class="line">            curr_sum += node.val</span><br><span class="line">            <span class="keyword">if</span> node.left:</span><br><span class="line">                queue.append(node.left)</span><br><span class="line">            <span class="keyword">if</span> node.right:</span><br><span class="line">                queue.append(node.right)</span><br><span class="line">        result.append(curr_sum / curr_len)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/binary-tree-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Level Order Traversal</a><br><a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/" target="_blank" rel="noopener">Binary Tree Level Order Traversal II</a><br><a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/" target="_blank" rel="noopener">Binary Tree Zigzag Level Order Traversal</a><br><a href="https://leetcode.com/problems/average-of-levels-in-binary-tree/" target="_blank" rel="noopener">Average of Levels in Binary Tree</a><br><a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/" target="_blank" rel="noopener">Minimum Depth of Binary Tree</a><br><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a><br><a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/" target="_blank" rel="noopener">Populating Next Right Pointers in Each Node II</a><br><a href="https://leetcode.com/problems/binary-tree-right-side-view/" target="_blank" rel="noopener">Binary Tree Right Side View</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>In-Place Reversal of a LinkedList</title>
      <link href="2021/01/30/In-Place-Reversal-of-a-LinkedList/"/>
      <url>2021/01/30/In-Place-Reversal-of-a-LinkedList/</url>
      
        <content type="html"><![CDATA[<p>In a lot of problems, we are asked to reverse the links between a set of nodes of a LinkedList. Often, the constraint is that we need to do this in-place, i.e., using the existing node objects and without using extra memory.</p><p>In-Place Reversal of a LinkedList pattern describes an efficient way to solve the above problem.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseBetween</span><span class="params">(self, head: ListNode, left: int, right: int)</span> -&gt; ListNode:</span></span><br><span class="line">    <span class="comment"># set sentinel</span></span><br><span class="line">    dummy, dummy.next = ListNode(), head</span><br><span class="line">    prev = dummy</span><br><span class="line">    <span class="comment"># obtain previous node</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(left - <span class="number">1</span>):</span><br><span class="line">        prev = prev.next</span><br><span class="line">    rev, curr = <span class="literal">None</span>, prev.next</span><br><span class="line">    <span class="comment"># reverse from left to right</span></span><br><span class="line">    <span class="keyword">for</span> _ <span class="keyword">in</span> range(right - left + <span class="number">1</span>):</span><br><span class="line">        temp = curr.next</span><br><span class="line">        curr.next = rev</span><br><span class="line">        rev = curr</span><br><span class="line">        curr = temp</span><br><span class="line">    <span class="comment"># merge three parts</span></span><br><span class="line">    prev.next.next = curr</span><br><span class="line">    prev.next = rev</span><br><span class="line">    <span class="keyword">return</span> dummy.next</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/reverse-linked-list/" target="_blank" rel="noopener">Reverse Linked List</a><br><a href="https://leetcode.com/problems/reverse-linked-list-ii/" target="_blank" rel="noopener">Reverse Linked List II</a><br><a href="https://leetcode.com/problems/reverse-nodes-in-k-group/" target="_blank" rel="noopener">Reverse Nodes in k-Group</a><br><a href="https://leetcode.com/problems/rotate-list/" target="_blank" rel="noopener">Rotate List</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Cyclic Sort</title>
      <link href="2021/01/30/Cyclic-Sort/"/>
      <url>2021/01/30/Cyclic-Sort/</url>
      
        <content type="html"><![CDATA[<p>This pattern describes an interesting approach to deal with problems involving arrays containing numbers in a given range. For example, take the following problem:</p><blockquote><p>You are given an unsorted array containing numbers taken from the range “1” to “n”. The array can have duplicates, which means that some numbers will be missing. Find all the missing numbers.</p></blockquote><p>To efficiently solve this problem, we can use the fact that the input array contains numbers in the range of “1” to “n”. For example, to efficiently sort the array, we can try placing each number in its correct place, i.e., placing “1” at index “0”, placing “2” at index “1”, and so on. Once we are done with the sorting, we can iterate the array to find all indices that are missing the correct numbers. These will be our required numbers.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">firstMissingPositive</span><span class="params">(self, nums: List[int])</span> -&gt; int:</span></span><br><span class="line">    max_value = len(nums) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># remove useless items</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> nums[i] &lt; <span class="number">1</span> <span class="keyword">or</span> nums[i] &gt; len(nums):</span><br><span class="line">            nums[i] = <span class="number">0</span></span><br><span class="line">    nums.append(<span class="number">0</span>)</span><br><span class="line">    <span class="comment"># record frequency</span></span><br><span class="line">    <span class="keyword">for</span> num <span class="keyword">in</span> nums[:<span class="number">-1</span>]:</span><br><span class="line">        nums[num % max_value] += max_value</span><br><span class="line">    <span class="comment"># obtain missing</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, max_value):</span><br><span class="line">        <span class="keyword">if</span> nums[i] // max_value == <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">return</span> i</span><br><span class="line">    <span class="keyword">return</span> max_value</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/missing-number/" target="_blank" rel="noopener">Missing Number</a><br><a href="https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/" target="_blank" rel="noopener">Find All Numbers Disappeared in an Array</a><br><a href="https://leetcode.com/problems/find-the-duplicate-number/" target="_blank" rel="noopener">Find the Duplicate Number</a><br><a href="https://leetcode.com/problems/find-all-duplicates-in-an-array/" target="_blank" rel="noopener">Find All Duplicates in an Array</a><br><a href="https://leetcode.com/problems/set-mismatch/" target="_blank" rel="noopener">Set Mismatch</a><br><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">First Missing Positive</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Merge Intervals</title>
      <link href="2021/01/30/Merge-Intervals/"/>
      <url>2021/01/30/Merge-Intervals/</url>
      
        <content type="html"><![CDATA[<p>This pattern describes an efficient technique to deal with overlapping intervals. In a lot of problems involving intervals, we either need to find overlapping intervals or merge intervals if they overlap.</p><p>Given two intervals (“a” and “b”), there will be six different ways the two intervals can relate to each other:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/educative/03.png" alt></p><p>Understanding the above six cases will help us in solving all intervals related problems.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert</span><span class="params">(self, intervals: List[List[int]], newInterval: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    merged, i = [], <span class="number">0</span></span><br><span class="line">    <span class="comment"># merge the left part</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(intervals) <span class="keyword">and</span> intervals[i][<span class="number">1</span>] &lt; newInterval[<span class="number">0</span>]:</span><br><span class="line">        merged.append(intervals[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="comment"># merge the middle part</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(intervals) <span class="keyword">and</span> intervals[i][<span class="number">0</span>] &lt;= newInterval[<span class="number">1</span>]:</span><br><span class="line">        newInterval[<span class="number">0</span>] = min(newInterval[<span class="number">0</span>], intervals[i][<span class="number">0</span>])</span><br><span class="line">        newInterval[<span class="number">1</span>] = max(newInterval[<span class="number">1</span>], intervals[i][<span class="number">1</span>])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    merged.append(newInterval)</span><br><span class="line">    <span class="comment"># merge the right part</span></span><br><span class="line">    <span class="keyword">while</span> i &lt; len(intervals):</span><br><span class="line">        merged.append(intervals[i])</span><br><span class="line">        i += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> merged</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/merge-intervals/" target="_blank" rel="noopener">Merge Intervals</a><br><a href="https://leetcode.com/problems/insert-interval/" target="_blank" rel="noopener">Insert Interval</a><br><a href="https://leetcode.com/problems/interval-list-intersections/" target="_blank" rel="noopener">Interval List Intersections</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fast &amp; Slow Pointers</title>
      <link href="2021/01/30/Fast-Slow-Pointers/"/>
      <url>2021/01/30/Fast-Slow-Pointers/</url>
      
        <content type="html"><![CDATA[<p>The Fast &amp; Slow pointer approach, also known as the <code>Tortoise &amp; Hare Algorithm</code>, is a pointer algorithm that uses two pointers which move through the array (or sequence/LinkedList) at different speeds. This approach is quite useful when dealing with cyclic LinkedLists or arrays.</p><p>By moving at different speeds (say, in a cyclic LinkedList), the algorithm proves that the two pointers are bound to meet. The fast pointer should catch the slow pointer once both the pointers are in a cyclic loop.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isPalindrome</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">    l = r = head</span><br><span class="line">    <span class="comment"># obtain the pointer of middle</span></span><br><span class="line">    <span class="keyword">while</span> r <span class="keyword">and</span> r.next:</span><br><span class="line">        l = l.next</span><br><span class="line">        r = r.next.next</span><br><span class="line">    stack = []</span><br><span class="line">    <span class="comment"># push the second half to stack</span></span><br><span class="line">    <span class="keyword">while</span> l:</span><br><span class="line">        stack.append(l.val)</span><br><span class="line">        l = l.next</span><br><span class="line">    curr = head</span><br><span class="line">    <span class="comment"># compare with the first half</span></span><br><span class="line">    <span class="keyword">while</span> stack:</span><br><span class="line">        <span class="keyword">if</span> stack.pop() != curr.val:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">        curr = curr.next</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">True</span></span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a><br><a href="https://leetcode.com/problems/linked-list-cycle-ii/" target="_blank" rel="noopener">Linked List Cycle II</a><br><a href="https://leetcode.com/problems/happy-number/" target="_blank" rel="noopener">Happy Number</a><br><a href="https://leetcode.com/problems/middle-of-the-linked-list/" target="_blank" rel="noopener">Middle of the Linked List</a><br><a href="https://leetcode.com/problems/palindrome-linked-list/" target="_blank" rel="noopener">Palindrome Linked List</a><br><a href="https://leetcode.com/problems/reorder-list/" target="_blank" rel="noopener">Reorder List</a><br><a href="https://leetcode.com/problems/circular-array-loop/" target="_blank" rel="noopener">Circular Array Loop</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Two Pointers</title>
      <link href="2021/01/30/Two-Pointers/"/>
      <url>2021/01/30/Two-Pointers/</url>
      
        <content type="html"><![CDATA[<p>In problems where we deal with sorted arrays (or LinkedLists) and need to find a set of elements that fulfill certain constraints, the Two Pointers approach becomes quite useful. The set of elements could be a pair, a triplet or even a subarray. For example, take a look at the following problem:</p><blockquote><p>Given an array of sorted numbers and a target sum, find a pair in the array whose sum is equal to the given target.</p></blockquote><p>To solve this problem, we can consider each element one by one (pointed out by the first pointer) and iterate through the remaining elements (pointed out by the second pointer) to find a pair with the given sum. The time complexity of this algorithm will be O(N^2) where “N” is the number of elements in the input array.</p><p>Given that the input array is sorted, an efficient way would be to start with one pointer in the beginning and another pointer at the end. At every step, we will see if the numbers pointed by the two pointers add up to the target sum. If they do not, we will do one of two things:</p><ol><li>If the sum of the two numbers pointed by the two pointers is greater than the target sum, this means that we need a pair with a smaller sum. So, to try more pairs, we can decrement the end-pointer;</li><li>If the sum of the two numbers pointed by the two pointers is smaller than the target sum, this means that we need a pair with a larger sum. So, to try more pairs, we can increment the start-pointer;</li></ol><a id="more"></a><p>Here is the visual representation of this algorithm:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/educative/02.png" alt></p><p>The time complexity of the above algorithm will be O(N).</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeSum</span><span class="params">(self, nums: List[int])</span> -&gt; List[List[int]]:</span></span><br><span class="line">    triplets = []</span><br><span class="line">    nums.sort()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(nums)):</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">0</span> <span class="keyword">and</span> nums[i] == nums[i<span class="number">-1</span>]:</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        l, r = i + <span class="number">1</span>, len(nums) - <span class="number">1</span></span><br><span class="line">        <span class="comment"># two pointers</span></span><br><span class="line">        <span class="keyword">while</span> l &lt; r:</span><br><span class="line">            curr_sum = nums[i] + nums[l] + nums[r]</span><br><span class="line">            <span class="keyword">if</span> curr_sum &lt; <span class="number">0</span>:</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">            <span class="keyword">elif</span> curr_sum &gt; <span class="number">0</span>:</span><br><span class="line">                r -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                triplets.append([nums[i], nums[l], nums[r]])</span><br><span class="line">                l += <span class="number">1</span></span><br><span class="line">                <span class="keyword">while</span> l &lt; r <span class="keyword">and</span> nums[l] == nums[l<span class="number">-1</span>]:</span><br><span class="line">                    l += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> triplets</span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/two-sum/" target="_blank" rel="noopener">Two Sum</a><br><a href="https://leetcode.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener">Remove Duplicates from Sorted Array</a><br><a href="https://leetcode.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener">Squares of a Sorted Array</a><br><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">3Sum</a><br><a href="https://leetcode.com/problems/3sum-closest/" target="_blank" rel="noopener">3Sum Closest</a><br><a href="https://leetcode.com/problems/subarray-product-less-than-k/" target="_blank" rel="noopener">Subarray Product Less Than K</a><br><a href="https://leetcode.com/problems/sort-colors/" target="_blank" rel="noopener">Sort Colors</a><br><a href="https://leetcode.com/problems/4sum/" target="_blank" rel="noopener">4Sum</a><br><a href="https://leetcode.com/problems/backspace-string-compare/" target="_blank" rel="noopener">Backspace String Compare</a><br><a href="https://leetcode.com/problems/shortest-unsorted-continuous-subarray/" target="_blank" rel="noopener">Shortest Unsorted Continuous Subarray</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Sliding Window</title>
      <link href="2021/01/30/Sliding-Window/"/>
      <url>2021/01/30/Sliding-Window/</url>
      
        <content type="html"><![CDATA[<p>In many problems dealing with an array (or a LinkedList), we are asked to find or calculate something among all the contiguous subarrays (or sublists) of a given size. For example, take a look at this problem:</p><blockquote><p>Given an array, find the average of all contiguous subarrays of size “K” in it.</p></blockquote><p>Let’s understand this problem with a real input:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Array: [<span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">-1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">8</span>, <span class="number">2</span>], K=<span class="number">5</span></span><br></pre></td></tr></table></figure><p>Here, we are asked to find the average of all contiguous subarrays of size “5” in the given array. Let’s solve this:</p><ol><li>For the first 5 numbers (subarray from index 0~4), the average is: (1+3+2+6-1)/5 = 2.2;</li><li>The average of next 5 numbers (subarray from index 1~5) is: (3+2+6-1+4)/5 = 2.8;</li><li>For the next 5 numbers (subarray from index 2~6), the average is: (2+6-1+4+1)/5 = 2.4;<br>…</li></ol><p>Here is the final output containing the averages of all contiguous subarrays of size 5:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Output: [<span class="number">2.2</span>, <span class="number">2.8</span>, <span class="number">2.4</span>, <span class="number">3.6</span>, <span class="number">2.8</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><p>A brute-force algorithm will calculate the sum of every 5-element contiguous subarray of the given array and divide the sum by “5” to find the average. This is what the algorithm will look like:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_averages_of_subarrays</span><span class="params">(k, arr)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(len(arr) - k + <span class="number">1</span>):</span><br><span class="line">        element_sum = <span class="number">0.0</span></span><br><span class="line">        <span class="comment"># find sum of next `K` elements</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i, i + k):</span><br><span class="line">            element_sum += arr[j]</span><br><span class="line">            result.append(element_sum / k) <span class="comment"># calculate average</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p><strong>Time Complexity</strong>: Since for every element of the input array, we are calculating the sum of its next “K” elements, the time complexity of the above algorithm will be O(N*K) where “N” is the number of elements in the input array.</p><p>The inefficiency is that for any two consecutive subarrays of size “5”, the overlapping part (which will contain four elements) will be evaluated twice. For example, take the above-mentioned input:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/educative/00.png" alt></p><p>As you can see, there are four overlapping elements between the subarray (indexed from 0~4) and the subarray (indexed from 1~5). Can we somehow reuse the sum we have calculated for the overlapping elements?</p><p>The efficient way to solve this problem would be to visualize each contiguous subarray as a sliding window of “5” elements. This means that we will slide the window by one element when we move on to the next subarray. To reuse the sum from the previous subarray, we will subtract the element going out of the window and add the element now being included in the sliding window. This will save us from going through the whole subarray to find the sum and, as a result, the algorithm complexity will reduce to O(N):<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/educative/01.png" alt></p><p>Here is the algorithm for the Sliding Window approach:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_averages_of_subarrays</span><span class="params">(k, arr)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    window_sum, start = <span class="number">0.0</span>, <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(len(arr)):</span><br><span class="line">        <span class="comment"># add the next element</span></span><br><span class="line">        window_sum += arr[end]</span><br><span class="line">        <span class="comment"># slide the window, we don't need to slide if we've not hit the required window size of `K`</span></span><br><span class="line">        <span class="keyword">if</span> end &gt;= k - <span class="number">1</span>:</span><br><span class="line">            result.append(window_sum / k) <span class="comment"># calculate the average</span></span><br><span class="line">            window_sum -= arr[start]      <span class="comment"># subtract the element going out</span></span><br><span class="line">            start += <span class="number">1</span>                    <span class="comment"># slide the window ahead</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>In some problems, the size of the sliding window is not fixed. We have to expand or shrink the window based on the problem constraints.</p><h2 id="Snippet"><a href="#Snippet" class="headerlink" title="Snippet"></a>Snippet</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkInclusion</span><span class="params">(self, s1: str, s2: str)</span> -&gt; bool:</span></span><br><span class="line">    matched, start = <span class="number">0</span>, <span class="number">0</span></span><br><span class="line">    freq = dict()</span><br><span class="line">    <span class="keyword">for</span> char <span class="keyword">in</span> s1:</span><br><span class="line">        freq[char] = freq.get(char, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="comment"># sliding window</span></span><br><span class="line">    <span class="keyword">for</span> end <span class="keyword">in</span> range(len(s2)):</span><br><span class="line">        <span class="keyword">if</span> s2[end] <span class="keyword">in</span> freq:</span><br><span class="line">            freq[s2[end]] -= <span class="number">1</span></span><br><span class="line">            <span class="keyword">if</span> freq[s2[end]] == <span class="number">0</span>:</span><br><span class="line">                matched += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> matched == len(s1):</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">        <span class="comment"># shrink</span></span><br><span class="line">        <span class="keyword">if</span> end - start + <span class="number">1</span> == len(s1):</span><br><span class="line">            <span class="keyword">if</span> s2[start] <span class="keyword">in</span> freq:</span><br><span class="line">                <span class="keyword">if</span> freq[s2[start]] == <span class="number">0</span>:</span><br><span class="line">                    matched -= <span class="number">1</span></span><br><span class="line">                freq[s2[start]] += <span class="number">1</span></span><br><span class="line">            start += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener">Minimum Size Subarray Sum</a><br><a href="https://leetcode.com/problems/fruit-into-baskets/" target="_blank" rel="noopener">Fruit Into Baskets</a><br><a href="https://leetcode.com/problems/longest-substring-without-repeating-characters/" target="_blank" rel="noopener">Longest Substring Without Repeating Characters</a><br><a href="https://leetcode.com/problems/longest-repeating-character-replacement/" target="_blank" rel="noopener">Longest Repeating Character Replacement</a><br><a href="https://leetcode.com/problems/max-consecutive-ones-iii/" target="_blank" rel="noopener">Max Consecutive Ones III</a><br><a href="https://leetcode.com/problems/permutation-in-string/" target="_blank" rel="noopener">Permutation in String</a><br><a href="https://leetcode.com/problems/find-all-anagrams-in-a-string/" target="_blank" rel="noopener">Find All Anagrams in a String</a><br><a href="https://leetcode.com/problems/minimum-window-substring/" target="_blank" rel="noopener">Minimum Window Substring</a><br><a href="https://leetcode.com/problems/substring-with-concatenation-of-all-words/" target="_blank" rel="noopener">Substring with Concatenation of All Words</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Load Balancing</title>
      <link href="2021/01/30/Load-Balancing/"/>
      <url>2021/01/30/Load-Balancing/</url>
      
        <content type="html"><![CDATA[<p>Load Balancer (LB) is another critical component of any distributed system. It helps to spread the traffic across a cluster of servers to improve responsiveness and availability of applications, websites or databases. LB also keeps track of the status of all the resources while distributing requests. If a server is not available to take new requests or is not responding or has elevated error rate, LB will stop sending traffic to such a server.</p><p>Typically a load balancer sits between the client and the server accepting incoming network and application traffic and distributing the traffic across multiple backend servers using various algorithms. By balancing application requests across multiple servers, a load balancer reduces individual server load and prevents any one application server from becoming a single point of failure, thus improving overall application availability and responsiveness:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/01.png" alt></p><a id="more"></a><p>To utilize full scalability and redundancy, we can try to balance the load at each layer of the system. We can add LBs at three places:</p><ul><li>Between the user and the web server;</li><li>Between web servers and an internal platform layer, like application servers or cache servers;</li><li>Between internal platform layer and database;</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/02.png" alt></p><h2 id="Benefits-of-Load-Balancing"><a href="#Benefits-of-Load-Balancing" class="headerlink" title="Benefits of Load Balancing"></a>Benefits of Load Balancing</h2><ul><li>Users experience faster, uninterrupted service. Users won’t have to wait for a single struggling server to finish its previous tasks. Instead, their requests are immediately passed on to a more readily available resource;</li><li>Service providers experience less downtime and higher throughput. Even a full server failure won’t affect the end user experience as the load balancer will simply route around it to a healthy server;</li><li>Load balancing makes it easier for system administrators to handle incoming requests while decreasing wait time for users;</li><li>Smart load balancers provide benefits like predictive analytics that determine traffic bottlenecks before they happen. As a result, the smart load balancer gives an organization actionable insights. These are key to automation and can help drive business decisions;</li><li>System administrators experience fewer failed or stressed components. Instead of a single device performing a lot of work, load balancing has several devices perform a little bit of work;</li></ul><h2 id="Load-Balancing-Algorithms"><a href="#Load-Balancing-Algorithms" class="headerlink" title="Load Balancing Algorithms"></a>Load Balancing Algorithms</h2><p><strong>How does the load balancer choose the backend server?</strong><br>Load balancers consider two factors before forwarding a request to a backend server. They will first ensure that the server they choose is actually responding appropriately to requests and then use a pre-configured algorithm to select one from the set of healthy servers. We will discuss these algorithms shortly.</p><p><strong>Health Checks</strong>: Load balancers should only forward traffic to “healthy” backend servers. To monitor the health of a backend server, “health checks” regularly attempt to connect to backend servers to ensure that servers are listening. If a server fails a health check, it is automatically removed from the pool, and traffic will not be forwarded to it until it responds to the health checks again.</p><p>There is a variety of load balancing methods, which use different algorithms for different needs:</p><ul><li><strong>Least Connection Method</strong>: This method directs traffic to the server with the fewest active connections. This approach is quite useful when there are a large number of persistent client connections which are unevenly distributed between the servers;</li><li><strong>Least Response Time Method</strong>: This algorithm directs traffic to the server with the fewest active connections and the lowest average response time;</li><li><strong>Least Bandwidth Method</strong>: This method selects the server that is currently serving the least amount of traffic measured in megabits per second (Mbps);</li><li><strong>Round Robin Method</strong>: This method cycles through a list of servers and sends each new request to the next server. When it reaches the end of the list, it starts over at the beginning. It is most useful when the servers are of equal specification and there are not many persistent connections;</li><li><strong>Weighted Round Robin Method</strong>: The weighted round-robin scheduling is designed to better handle servers with different processing capacities. Each server is assigned a weight (an integer value that indicates the processing capacity). Servers with higher weights receive new connections before those with less weights and servers with higher weights get more connections than those with less weights;</li><li><strong>IP Hash</strong>: Under this method, a hash of the IP address of the client is calculated to redirect the request to a server;</li></ul><h2 id="Redundant-Load-Balancers"><a href="#Redundant-Load-Balancers" class="headerlink" title="Redundant Load Balancers"></a>Redundant Load Balancers</h2><p>The load balancer can be a single point of failure; to overcome this, a second load balancer can be connected to the first to form a cluster. Each LB monitors the health of the other and, since both of them are equally capable of serving traffic and failure detection, in the event the main load balancer fails, the second load balancer takes over:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/03.png" alt></p><p>Following links have some good discussion about load balancers:<br>[1] <a href="https://avinetworks.com/what-is-load-balancing/" target="_blank" rel="noopener">What is load balancing</a><br>[2] <a href="https://lethain.com/introduction-to-architecting-systems-for-scale/" target="_blank" rel="noopener">Introduction to architecting systems</a><br>[3] <a href="https://en.wikipedia.org/wiki/Load_balancing_(computing)" target="_blank" rel="noopener">Load balancing</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>System Design Basics</title>
      <link href="2021/01/30/System%20Design%20Basics/"/>
      <url>2021/01/30/System%20Design%20Basics/</url>
      
        <content type="html"><![CDATA[<p>Whenever we are designing a large system, we need to consider a few things:</p><ol><li>What are the different architectural pieces that can be used?</li><li>How do these pieces work with each other?</li><li>How can we best utilize these pieces: what are the right tradeoffs?</li></ol><p>Investing in scaling before it is needed is generally not a smart business proposition; however, some forethought into the design can save valuable time and resources in the future. In the following chapters, we will try to define some of the core building blocks of scalable systems. Familiarizing these concepts would greatly benefit in understanding distributed system concepts. In the next section, we will go through Consistent Hashing, CAP Theorem, Load Balancing, Caching, Data Partitioning, Indexes, Proxies, Queues, Replication, and choosing between SQL vs. NoSQL.</p><p>Key characteristics of a distributed system include Scalability, Reliability, Availability, Efficiency, and Manageability.</p><a id="more"></a><h2 id="Scalability"><a href="#Scalability" class="headerlink" title="Scalability"></a>Scalability</h2><p>Scalability is the capability of a system, process, or a network to grow and manage increased demand. Any distributed system that can continuously evolve in order to support the growing amount of work is considered to be scalable.</p><p>A system may have to scale because of many reasons like increased data volume or increased amount of work, e.g., number of transactions. A scalable system would like to achieve this scaling without performance loss.</p><p>Generally, the performance of a system, although designed (or claimed) to be scalable, declines with the system size due to the management or environment cost. For instance, network speed may become slower because machines tend to be far apart from one another. More generally, some tasks may not be distributed, either because of their inherent atomic nature or because of some flaw in the system design. At some point, such tasks would limit the speed-up obtained by distribution. A scalable architecture avoids this situation and attempts to balance the load on all the participating nodes evenly.</p><p><strong>Horizontal vs. Vertical Scaling</strong>: Horizontal scaling means that you scale by adding more servers into your pool of resources whereas Vertical scaling means that you scale by adding more power (CPU, RAM, Storage, etc.) to an existing server:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/educative/00.png" alt></p><p>With horizontal-scaling it is often easier to scale dynamically by adding more machines into the existing pool; Vertical-scaling is usually limited to the capacity of a single server and scaling beyond that capacity often involves downtime and comes with an upper limit.</p><p>Good examples of horizontal scaling are <code>Cassandra</code> and <code>MongoDB</code> as they both provide an easy way to scale horizontally by adding more machines to meet growing needs. Similarly, a good example of vertical scaling is <code>MySQL</code> as it allows for an easy way to scale vertically by switching from smaller to bigger machines. However, this process often involves downtime.</p><h2 id="Reliability"><a href="#Reliability" class="headerlink" title="Reliability"></a>Reliability</h2><p>By definition, reliability is the probability a system will fail in a given period. In simple terms, a distributed system is considered reliable if it keeps delivering its services even when one or several of its software or hardware components fail. Reliability represents one of the main characteristics of any distributed system, since in such systems any failing machine can always be replaced by another healthy one, ensuring the completion of the requested task.</p><p>By definition, reliability is the probability a system will fail in a given period. In simple terms, a distributed system is considered reliable if it keeps delivering its services even when one or several of its software or hardware components fail. Reliability represents one of the main characteristics of any distributed system, since in such systems any failing machine can always be replaced by another healthy one, ensuring the completion of the requested task.</p><p>Take the example of a large electronic commerce store (like <code>Amazon</code>), where one of the primary requirement is that any user transaction should never be canceled due to a failure of the machine that is running that transaction. For instance, if a user has added an item to their shopping cart, the system is expected not to lose it. A reliable distributed system achieves this through redundancy of both the software components and data. If the server carrying the user’s shopping cart fails, another server that has the exact replica of the shopping cart should replace it.</p><p>Obviously, redundancy has a cost and a reliable system has to pay that to achieve such resilience for services by eliminating every single point of failure.</p><h2 id="Availability"><a href="#Availability" class="headerlink" title="Availability"></a>Availability</h2><p>By definition, availability is the time a system remains operational to perform its required function in a specific period. It is a simple measure of the percentage of time that a system, service, or a machine remains operational under normal conditions. An aircraft that can be flown for many hours a month without much downtime can be said to have a high availability. Availability takes into account maintainability, repair time, spares availability, and other logistics considerations. If an aircraft is down for maintenance, it is considered not available during that time.</p><p>Reliability is availability over time considering the full range of possible real-world conditions that can occur. An aircraft that can make it through any possible weather safely is more reliable than one that has vulnerabilities to possible conditions.</p><p><strong>Reliability vs. Availability</strong>: If a system is reliable, it is available. However, if it is available, it is not necessarily reliable. In other words, high reliability contributes to high availability, but it is possible to achieve a high availability even with an unreliable product by minimizing repair time and ensuring that spares are always available when they are needed. Let’s take the example of an online retail store that has 99.99% availability for the first two years after its launch. However, the system was launched without any information security testing. The customers are happy with the system, but they don’t realize that it isn’t very reliable as it is vulnerable to likely risks. In the third year, the system experiences a series of information security incidents that suddenly result in extremely low availability for extended periods of time. This results in reputational and financial damage to the customers.</p><h2 id="Efficiency"><a href="#Efficiency" class="headerlink" title="Efficiency"></a>Efficiency</h2><p>To understand how to measure the efficiency of a distributed system, let’s assume we have an operation that runs in a distributed manner and delivers a set of items as result. Two standard measures of its efficiency are the response time (or latency) that denotes the delay to obtain the first item and the throughput (or bandwidth) which denotes the number of items delivered in a given time unit (e.g., a second). The two measures correspond to the following unit costs:</p><ul><li>Number of messages globally sent by the nodes of the system regardless of the message size;</li><li>Size of messages representing the volume of data exchanges;</li></ul><p>The complexity of operations supported by distributed data structures (e.g., searching for a specific key in a distributed index) can be characterized as a function of one of these cost units. Generally speaking, the analysis of a distributed structure in terms of “number of messages” is over-simplistic. It ignores the impact of many aspects, including the network topology, the network load, and its variation, the possible heterogeneity of the software and hardware components involved in data processing and routing, etc. However, it is quite difficult to develop a precise cost model that would accurately take into account all these performance factors; therefore, we have to live with rough but robust estimates of the system behavior.</p><h2 id="Serviceability-or-Manageability"><a href="#Serviceability-or-Manageability" class="headerlink" title="Serviceability or Manageability"></a>Serviceability or Manageability</h2><p>Another important consideration while designing a distributed system is how easy it is to operate and maintain. Serviceability or manageability is the simplicity and speed with which a system can be repaired or maintained; if the time to fix a failed system increases, then availability will decrease. Things to consider for manageability are the ease of diagnosing and understanding problems when they occur, ease of making updates or modifications, and how simple the system is to operate (i.e., does it routinely operate without failure or exceptions?).</p><p>Early detection of faults can decrease or avoid system downtime. For example, some enterprise systems can automatically call a service center (without human intervention) when the system experiences a system fault.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何选择数据结构和算法</title>
      <link href="2021/01/29/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/29/%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>工程上的问题往往都比较开放，在选择数据结构和算法的时候，我们往往需要综合各种因素，比如编码难度、维护成本、数据特征、数据规模等，最终<strong>选择一个工程的最合适解，而非理论上的最优解</strong>。为了让你能做到活学活用，在实际的软件开发中，不生搬硬套数据结构和算法，今天，我们就聊一聊，在实际的软件开发中，如何权衡各种因素，合理地选择使用哪种数据结构和算法？关于这个问题，我总结了六条经验。</p><h2 id="时间、空间复杂度不能跟性能划等号"><a href="#时间、空间复杂度不能跟性能划等号" class="headerlink" title="时间、空间复杂度不能跟性能划等号"></a>时间、空间复杂度不能跟性能划等号</h2><p>我们在学习每种数据结构和算法的时候，都详细分析了算法的时间复杂度、空间复杂度，但是，在实际的软件开发中，复杂度不能与性能简单划等号，不能表示执行时间和内存消耗的确切数据量：</p><ul><li><strong>复杂度不是执行时间和内存消耗的精确值</strong>：<br>在用大 O 表示法表示复杂度的时候，我们会忽略掉低阶、常数、系数，只保留高阶，并且它的度量单位是语句的执行频度。每条语句的执行时间，并非是相同、确定的。所以，复杂度给出的只能是一个非精确量值的趋势；</li><li><strong>代码的执行时间有时不跟时间复杂度成正比</strong>：<br>我们常说，时间复杂度是 O(nlogn) 的算法，比时间复杂度是 O(n^2) 的算法，执行效率要高。这样说的一个前提是，算法处理的是大规模数据的情况。对于小规模数据的处理，算法的执行效率并不一定跟时间复杂度成正比，有时还会跟复杂度成反比；</li><li><strong>对于处理不同问题的不同算法，其复杂度大小没有可比性</strong>：<br>复杂度只能用来表征不同算法，在处理同样的问题，以及同样数据类型的情况下的性能表现。但是，对于不同的问题、不同的数据类型，不同算法之间的复杂度大小并没有可比性；</li></ul><a id="more"></a><h2 id="抛开数据规模谈数据结构和算法都是“耍流氓”"><a href="#抛开数据规模谈数据结构和算法都是“耍流氓”" class="headerlink" title="抛开数据规模谈数据结构和算法都是“耍流氓”"></a>抛开数据规模谈数据结构和算法都是“耍流氓”</h2><p>在平时的开发中，在数据规模很小的情况下，普通算法和高级算法之间的性能差距会非常小。如果代码执行频率不高、又不是核心代码，这个时候，我们选择数据结构和算法的主要依据是，其<strong>是否简单、容易维护、容易实现</strong>。大部分情况下，我们直接用最简单的存储结构和最暴力的算法就可以了。</p><p>比如，对于长度在一百以内的字符串匹配，我们直接使用朴素的字符串匹配算法就够了。如果用 KMP, BM 这些更加高效的字符串匹配算法，实际上就大材小用了。因为这对于处理时间是毫秒量级敏感的系统来说，性能的提升并不大。相反，这些高级算法会徒增编码的难度，还容易产生 bug。</p><h2 id="结合数据特征和访问方式来选择数据结构"><a href="#结合数据特征和访问方式来选择数据结构" class="headerlink" title="结合数据特征和访问方式来选择数据结构"></a>结合数据特征和访问方式来选择数据结构</h2><p>面对实际的软件开发场景，当我们掌握了基础数据结构和算法之后，最考验能力的并不是数据结构和算法本身，而是对问题需求的挖掘、抽象、建模。<strong>如何将一个背景复杂、开放的问题，通过细致的观察、调研、假设，理清楚要处理数据的特征与访问方式</strong>，这才是解决问题的重点。只有理清楚了这些东西，我们才能将问题转化成合理的数据结构模型，进而找到满足需求的算法。</p><p>比如我们前面讲过，Trie 树这种数据结构是一种非常高效的字符串匹配算法。但是，<strong>如果你要处理的数据，并没有太多的前缀重合，并且字符集很大，显然就不适合利用 Trie 树了</strong>。所以，在用 Trie 树之前，我们需要详细地分析数据的特点，甚至还要写些分析代码、测试代码，明确要处理的数据是否适合使用 Trie 树这种数据结构。</p><p>再比如，图的表示方式有很多种，邻接矩阵, 邻接表, 逆邻接表, 二元组等等。你面对的场景应该用哪种方式来表示，具体还要看你的数据特征和访问方式。<strong>如果每个数据之间联系很少，对应到图中，就是一个稀疏图，就比较适合用邻接表来存储</strong>。相反，如果是稠密图，那就比较适合采用邻接矩阵来存储。</p><h2 id="区别对待-IO-密集、内存密集和计算密集"><a href="#区别对待-IO-密集、内存密集和计算密集" class="headerlink" title="区别对待 IO 密集、内存密集和计算密集"></a>区别对待 IO 密集、内存密集和计算密集</h2><p>如果你要处理的数据存储在磁盘，比如数据库中。那代码的性能瓶颈有可能在磁盘 IO，而并非算法本身。这个时候，你需要合理地选择数据存储格式和存取方式，减少磁盘 IO 的次数。<strong>如果你的数据是存储在内存中，那我们还需要考虑，代码是内存密集型的还是 CPU 密集型的</strong>。</p><p>所谓 CPU 密集型，简单点理解就是，代码执行效率的瓶颈主要在 CPU 执行的效率。我们从内存中读取一次数据，到 CPU 缓存或者寄存器之后，会进行多次频繁的 CPU 计算（比如加减乘除），CPU 计算耗时占大部分。所以，在选择数据结构和算法的时候，要<strong>尽量减少逻辑计算的复杂度。比如，用位运算代替加减乘除运算等</strong>。</p><p>所谓内存密集型，简单点理解就是，代码执行效率的瓶颈在内存数据的存取。对于内存密集型的代码，计算操作都比较简单，比如，字符串比较操作，实际上就是内存密集型的。每次从内存中读取数据之后，我们只需要进行一次简单的比较操作。所以，内存数据的读取速度，是字符串比较操作的瓶颈。因此，在选择数据结构和算法的时候，需要<strong>考虑是否能减少数据的读取量，数据是否在内存中连续存储，是否能利用 CPU 缓存预读</strong>。</p><h2 id="善用语言提供的类，避免重复造轮子"><a href="#善用语言提供的类，避免重复造轮子" class="headerlink" title="善用语言提供的类，避免重复造轮子"></a>善用语言提供的类，避免重复造轮子</h2><p>实际上，对于大部分常用的数据结构和算法，编程语言都提供了现成的类和函数实现。比如，<strong>Java 中的 HashMap 就是散列表的实现，TreeMap 就是红黑树的实现等</strong>。在实际的软件开发中，除非有特殊的要求，我们都可以直接使用编程语言中提供的这些类或函数。</p><p>这些编程语言提供的类和函数，都是经过无数验证过的，不管是正确性、鲁棒性，都要超过你自己造的轮子。而且，你要知道，重复造轮子，并没有那么简单。你<strong>需要写大量的测试用例，并且考虑各种异常情况，还要团队能看懂、能维护</strong>，这显然是一个出力不讨好的事情。这也是很多高级的数据结构和算法，比如 Trie 树、跳表等，在工程中，并不经常被应用的原因。</p><h2 id="千万不要漫无目的地过度优化"><a href="#千万不要漫无目的地过度优化" class="headerlink" title="千万不要漫无目的地过度优化"></a>千万不要漫无目的地过度优化</h2><p>掌握了数据结构和算法这把锤子，不要看哪里都是钉子。比如，一段代码执行只需要 0.01 秒，你非得用一个非常复杂的算法或者数据结构，将其优化成 0.005 秒。即便你的算法再优秀，这种微小优化的意义也并不大。相反，对应的代码维护成本可能要高很多。还有，<strong>当你真的要优化代码的时候，一定要先做 Benchmark 基准测试</strong>。这样才能避免你想当然地换了一个更高效的算法，但真实情况下，性能反倒下降了。</p><p>不过度优化并不代表，我们在软件开发的时候，可以不加思考地随意选择数据结构和算法。我们要学会估算，<strong>估算能力实际上也是一个非常重要的能力</strong>。我们不仅要对普通情况下的数据规模和性能压力做估算，还需要对异常以及将来一段时间内，可能达到的数据规模和性能压力做估算。这样，我们才能做到未雨绸缪，写出来的代码才能经久可用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>并行算法</title>
      <link href="2021/01/29/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/29/%E5%B9%B6%E8%A1%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>时间复杂度是衡量算法执行效率的一种标准。但是，时间复杂度并不能跟性能划等号。在真实的软件开发中，<strong>即便在不降低时间复杂度的情况下，也可以通过一些优化手段，提升代码的执行效率</strong>。毕竟，对于实际的软件开发来说，即便是像 10%, 20% 这样微小的性能提升，也是非常可观的。算法的目的就是为了提高代码执行的效率，那当算法无法再继续优化的情况下，我们该如何来进一步提高执行效率呢？我们今天就讲一种非常简单但又非常好用的优化方法，那就是并行计算。</p><h2 id="并行排序"><a href="#并行排序" class="headerlink" title="并行排序"></a>并行排序</h2><p>假设我们要给大小为 8GB 的数据进行排序，并且，我们机器的内存可以一次性容纳这么多数据。<strong>对于排序来说，最常用的就是时间复杂度为 O(nlogn) 的三种排序算法：归并排序、快速排序、堆排序</strong>。从理论上讲，这个排序问题，已经很难再从算法层面优化了。而利用并行的处理思想，我们可以很轻松地将这个给 8GB 数据排序问题的执行效率提高很多倍。具体的实现思路有下面两种：</p><ol><li>对归并排序并行化处理：<br>我们可以<strong>将这 8GB 的数据划分成 16 个小的数据集合</strong>，每个集合包含 500MB 的数据。我们用 16 个线程，并行地对这 16 个 500MB 的数据集合进行排序。这 16 个小集合分别排序完成之后，我们再将这 16 个有序集合合并；</li><li>对快速排序并行化处理：<br>我们通过扫描一遍数据，找到数据所处的范围区间。我们<strong>把这个区间从小到大划分成 16 个小区间</strong>。我们将 8GB 的数据划分到对应的区间中。针对这 16 个小区间的数据，我们启动 16 个线程，并行地进行排序。等到 16 个线程都执行结束之后，得到的数据就是有序数据了；</li></ol><p>对比这两种处理思路，它们利用的都是分治的思想，对数据进行分片，然后并行处理。它们的区别在于，第一种处理思路是，先随意地对数据分片，排序之后再合并；第二种处理思路是，先对数据按照大小划分区间，然后再排序，排完序就不需要再处理了。这个跟归并和快排的区别如出一辙。</p><a id="more"></a><h2 id="并行查找"><a href="#并行查找" class="headerlink" title="并行查找"></a>并行查找</h2><p>我们知道，散列表是一种非常适合快速查找的数据结构。如果我们是给动态数据构建索引，在数据不断加入的时候，散列表的装载因子就会越来越大。为了保证散列表性能不下降，我们就需要对散列表进行动态扩容。<strong>对如此大的散列表进行动态扩容，一方面比较耗时，另一方面比较消耗内存</strong>。比如，我们给一个 2GB 大小的散列表进行扩容，扩展到原来的 1.5 倍，也就是 3GB 大小。这个时候，实际存储在散列表中的数据只有不到 2GB，所以内存的利用率只有 60%，有 1GB 的内存是空闲的。</p><p>实际上，我们可以将数据随机分割成 k 份（比如 16 份），每份中的数据只有原来的 1/k，然后我们针对这 k 个小数据集合分别构建散列表。这样，散列表的维护成本就变低了。<strong>当某个小散列表的装载因子过大的时候，我们可以单独对这个散列表进行扩容，而其他散列表不需要进行扩容</strong>。假设现在有 2GB 的数据，我们放到 16 个散列表中，每个散列表中的数据大约是 150MB。当某个散列表需要扩容的时候，我们只需要额外增加 150*0.5=75MB 的内存。无论从扩容的执行效率还是内存的利用率上，这种多个小散列表的处理方法，都要比大散列表高效。</p><p>当我们要查找某个数据的时候，我们只需要通过 16 个线程，并行地在这 16 个散列表中查找数据。这样的查找性能，比起一个大散列表的做法，也并不会下降，反倒有可能提高。当往散列表中添加数据的时候，我们可以<strong>选择将这个新数据放入装载因子最小的那个散列表中，这样也有助于减少散列冲突</strong>。</p><h2 id="并行字符串匹配"><a href="#并行字符串匹配" class="headerlink" title="并行字符串匹配"></a>并行字符串匹配</h2><p>我们之前学过的字符串匹配算法有 KMP, BM, RK, BF 等。当在一个不是很长的文本中查找关键词的时候，这些字符串匹配算法中的任何一个，都可以表现得非常高效。但是，如果我们处理的是超级大的文本，那处理的时间可能就会变得很长。我们可以<strong>把大的文本，分割成 k 个小文本</strong>。假设 k 是 16，我们就启动 16 个线程，并行地在这 16 个小文本中查找关键词，这样整个查找的性能就提高了 16 倍。16 倍效率的提升，从理论的角度来说并不多。但是，对于真实的软件开发来说，这显然是一个非常可观的优化。</p><p>不过，这里还有一个细节要处理，那就是<strong>原本包含在大文本中的关键词，被一分为二，分割到两个小文本中</strong>，这就会导致尽管大文本中包含这个关键词，但在这 16 个小文本中查找不到它。实际上，这个问题也不难解决，我们只需要针对这种特殊情况，做一些特殊处理就可以了。我们假设关键词的长度是 m。我们在每个小文本的结尾和开始各取 m 个字符串。前一个小文本的末尾 m 个字符和后一个小文本的开头 m 个字符，组成一个长度是 2m 的字符串。我们再拿关键词，在这个长度为 2m 的字符串中再重新查找一遍，就可以补上刚才的漏洞了。</p><h2 id="并行搜索"><a href="#并行搜索" class="headerlink" title="并行搜索"></a>并行搜索</h2><p>前面我们学习过好几种搜索算法，它们分别是广度优先搜索、深度优先搜索、Dijkstra 最短路径算法、A* 启发式搜索算法。对于广度优先搜索算法，我们也可以将其改造成并行算法。广度优先搜索是一种逐层搜索的搜索策略。<strong>基于当前这一层顶点，我们可以启动多个线程，并行地搜索下一层的顶点</strong>。在代码实现方面，原来广度优先搜索的代码实现，是通过一个队列来记录已经遍历到但还没有扩展的顶点。现在，经过改造之后的并行广度优先搜索算法，我们需要利用两个队列来完成扩展顶点的工作。</p><p>假设这两个队列分别是队列 A 和队列 B。<strong>多线程并行处理队列 A 中的顶点，并将扩展得到的顶点存储在队列 B 中</strong>。等队列 A 中的顶点都扩展完成之后，队列 A 被清空，我们再并行地扩展队列 B 中的顶点，并将扩展出来的顶点存储在队列 A。这样两个队列循环使用，就可以实现并行广度优先搜索算法。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>索引</title>
      <link href="2021/01/28/%E7%B4%A2%E5%BC%95/"/>
      <url>2021/01/28/%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<p>MySQL 底层依赖的是 B+ 树这种数据结构。那类似 Redis 这样的 Key-Value 数据库中的索引，又是怎么实现的呢？底层依赖的又是什么数据结构呢？今天，我就来讲一下<strong>索引这种常用的技术解决思路，底层往往会依赖哪些数据结构</strong>。</p><h2 id="为什么需要索引？"><a href="#为什么需要索引？" class="headerlink" title="为什么需要索引？"></a>为什么需要索引？</h2><p>在实际的软件开发中，业务纷繁复杂，功能千变万化，但是，万变不离其宗。<strong>如果抛开这些业务和功能的外壳，其实它们的本质都可以抽象为：对数据的存储和计算</strong>。对应到数据结构和算法中，那“存储”需要的就是数据结构，“计算”需要的就是算法。对于存储的需求，功能上无外乎增删改查，这其实并不复杂。但是，<strong>一旦存储的数据很多，那性能就成了这些系统要关注的重点</strong>，特别是在一些跟存储相关的基础系统（比如 MySQL 数据库、分布式文件系统等）、中间件（比如消息中间件 RocketMQ 等）中。</p><p>“如何节省存储空间、如何提高数据增删改查的执行效率”，这样的问题就成了设计的重点。而这些系统的实现，都离不开一个东西，那就是索引。不夸张地说，<strong>索引设计得好坏，直接决定了这些系统是否优秀</strong>。索引这个概念，非常好理解。你可以类比书籍的目录来理解。如果没有目录，我们想要查找某个知识点的时候，就要一页一页翻。通过目录，我们就可以快速定位相关知识点的页数，查找的速度也会有质的提高。</p><a id="more"></a><h2 id="索引的需求定义"><a href="#索引的需求定义" class="headerlink" title="索引的需求定义"></a>索引的需求定义</h2><p>对于系统设计需求，我们一般可以从<code>功能性需求</code>和<code>非功能性需求</code>两方面来分析。</p><h3 id="功能性需求"><a href="#功能性需求" class="headerlink" title="功能性需求"></a>功能性需求</h3><p>数据是格式化数据还是非格式化数据？要构建索引的原始数据，类型有很多。我把它分为两类，一类是结构化数据，比如，MySQL 中的数据；另一类是非结构化数据，比如搜索引擎中网页。<strong>对于非结构化数据，我们一般需要做预处理，提取出查询关键词，对关键词构建索引</strong>。</p><p>数据是静态数据还是动态数据？如果原始数据是一组静态数据，也就是说，不会有数据的增加、删除、更新操作，所以，我们<strong>在构建索引的时候，只需要考虑查询效率就可以了</strong>。这样，索引的构建就相对简单些。不过，大部分情况下，我们都是对动态数据构建索引，也就是说，我们不仅要考虑到索引的查询效率，在原始数据更新的同时，我们还需要动态地更新索引。支持动态数据集合的索引，设计起来相对也要更加复杂些。</p><p>索引存储在内存还是硬盘？如果索引存储在内存中，那查询的速度肯定要比存储在磁盘中的高。但是，如果原始数据量很大的情况下，对应的索引可能也会很大。这个时候，因为内存有限，我们可能就不得不将索引存储在磁盘中了。实际上，还有第三种情况，那就是<strong>一部分存储在内存，一部分存储在磁盘，这样就可以兼顾内存消耗和查询效率</strong>。</p><p>单值查找还是区间查找？所谓单值查找，也就是根据查询关键词等于某个值的数据。这种查询需求最常见。所谓<strong>区间查找，就是查找关键词处于某个区间值的所有数据</strong>。你可以类比 MySQL 数据库的查询需求，自己想象一下。实际上，不同的应用场景，查询的需求会多种多样。</p><p>单关键词查找还是多关键词组合查找？对于单关键词的查找，索引构建起来相对简单些。对于多关键词查询来说，要分多种情况。像 MySQL 这种结构化数据的查询需求，我们可以<strong>实现针对多个关键词的组合，建立索引</strong>；对于像搜索引擎这样的非结构数据的查询需求，我们可以针对单个关键词构建索引，然后通过集合操作，比如求并集、求交集等，计算出多个关键词组合的查询结果。</p><h3 id="非功能性需求"><a href="#非功能性需求" class="headerlink" title="非功能性需求"></a>非功能性需求</h3><p><strong>不管是存储在内存中还是磁盘中，索引对存储空间的消耗不能过大</strong>。如果存储在内存中，索引对占用存储空间的限制就会非常苛刻。毕竟内存空间非常有限，一个中间件启动后就占用几个 GB 的内存，开发者显然是无法接受的。如果存储在硬盘中，那索引对占用存储空间的限制，稍微会放宽一些。但是，我们也不能掉以轻心。因为，有时候，索引对存储空间的消耗会超过原始数据。</p><p><strong>在考虑索引查询效率的同时，我们还要考虑索引的维护成本</strong>。索引的目的是提高查询效率，但是，基于动态数据集合构建的索引，我们还要考虑到，索引的维护成本。因为在原始数据动态增删改的同时，我们也需要动态地更新索引。而索引的更新势必会影响到增删改操作的性能。</p><h2 id="构建索引常用的数据结构有哪些？"><a href="#构建索引常用的数据结构有哪些？" class="headerlink" title="构建索引常用的数据结构有哪些？"></a>构建索引常用的数据结构有哪些？</h2><p>实际上，常用来构建索引的数据结构，就是我们之前讲过的几种支持动态数据集合的数据结构。比如，散列表, 红黑树, 跳表, B+ 树。除此之外，<strong>位图、布隆过滤器可以作为辅助索引，有序数组可以用来对静态数据构建索引</strong>。</p><p>散列表增删改查操作的性能非常好，时间复杂度是 O(1)。<strong>一些键值数据库，比如 Redis, Memcache 就是使用散列表来构建索引的</strong>。这类索引，一般都构建在内存中。</p><p>红黑树作为一种常用的平衡二叉查找树，数据插入、删除、查找的时间复杂度是 O(logn)，也非常适合用来构建内存索引。<strong>ext 文件系统中，对磁盘块的索引，用的就是红黑树</strong>。</p><p>B+ 树比起红黑树来说，更加适合构建存储在磁盘中的索引。B+ 树是一个多叉树，所以，对相同个数的数据构建索引，B+ 树的高度要低于红黑树。当借助索引查询数据的时候，读取 B+ 树索引，需要的磁盘 IO 次数会更少。所以，<strong>大部分关系型数据库的索引，比如 MySQL, Oracle 都是用 B+ 树来实现的</strong>。</p><p>跳表也支持快速添加、删除、查找数据。而且，我们通过灵活调整索引结点个数和数据个数之间的比例，可以很好地平衡索引对内存的消耗及其查询效率。<strong>Redis 中的有序集合，就是用跳表来构建的</strong>。</p><p>布隆过滤器有一定的判错率。但是，我们可以规避它的短处，发挥它的长处。尽管对于判定存在的数据，有可能并不存在，但是对于判定不存在的数据，那肯定就不存在。而且，布隆过滤器还有一个更大的特点，那就是内存占用非常少。我们可以针对数据，构建一个布隆过滤器，并且存储在内存中。当要查询数据的时候，我们可以先通过布隆过滤器，判定是否存在。<strong>如果通过布隆过滤器判定数据不存在，那我们就没有必要读取磁盘中的索引了</strong>。对于数据不存在的情况，数据查询就更加快速了。</p><p>有序数组也可以被作为索引。如果数据是静态的，也就是不会有插入、删除、更新操作，那我们可以<strong>把数据的关键词（查询用的）抽取出来，组织成有序数组，然后利用二分查找算法来快速查找数据</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搜索</title>
      <link href="2021/01/25/%E6%90%9C%E7%B4%A2/"/>
      <url>2021/01/25/%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="如何用-A-搜索算法实现游戏中的寻路功能"><a href="#如何用-A-搜索算法实现游戏中的寻路功能" class="headerlink" title="如何用 A* 搜索算法实现游戏中的寻路功能"></a>如何用 A* 搜索算法实现游戏中的寻路功能</h2><p>魔兽世界、仙剑奇侠传这类 MMRPG 游戏，有一个非常重要的功能，那就是人物角色自动寻路。当人物处于游戏地图中的某个位置的时候，我们用鼠标点击另外一个相对较远的位置，人物就会自动地绕过障碍物走过去。玩过这么多游戏，不知你是否思考过，这个功能是怎么实现的呢？</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，这是一个非常典型的搜索问题。人物的起点就是他当下所在的位置，终点就是鼠标点击的位置。我们需要在地图中，找一条从起点到终点的路径。这条路径要绕过地图中所有障碍物，并且看起来要是一种非常聪明的走法。<strong>所谓“聪明”，笼统地解释就是，走的路不能太绕</strong>。理论上讲，最短路径显然是最聪明的走法，是这个问题的最优解。<strong>如果图非常大，那 Dijkstra 最短路径算法的执行耗时会很多</strong>。在真实的软件开发中，我们面对的是超级大的地图和海量的寻路请求，算法的执行效率太低，这显然是无法接受的。</p><p>实际上，像出行路线规划、游戏寻路，这些真实软件开发中的问题，一般情况下，我们都不需要非得求最优解（也就是最短路径）。在权衡路线规划质量和执行效率的情况下，我们只需要寻求一个次优解就足够了。这个快速的路径规划算法，就是我们今天要学习的 <code>A* 算法</code>。实际上，A* 算法是对 Dijkstra 算法的优化和改造。</p><a id="more"></a><p>Dijkstra 算法有点儿类似 BFS 算法，它每次找到跟起点最近的顶点，往外扩展。<strong>这种往外扩展的思路，其实有些盲目</strong>。下面这个图对应一个真实的地图，每个顶点在地图中的位置，我们用一个二维坐标（x, y）来表示，其中，x 表示横坐标，y 表示纵坐标：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/276.png" alt></p><p>在 Dijkstra 算法的实现思路中，我们用一个优先级队列，来记录已经遍历到的顶点以及这个顶点与起点的路径长度，<strong>顶点与起点路径长度越小，就越先被从优先级队列中取出来扩展</strong>。从图中举的例子可以看出，尽管我们找的是从 s 到 t 的路线，但是最先被搜索到的顶点依次是 1, 2, 3。通过肉眼来观察，这个搜索方向跟我们期望的路线方向（s 到 t 是从西向东）是反着的，路线搜索的方向明显“跑偏”了。</p><p>之所以会“跑偏”，那是因为我们是按照顶点与起点的路径长度的大小，来安排出队列顺序的。与起点越近的顶点，就会越早出队列。我们<strong>并没有考虑到这个顶点到终点的距离</strong>，所以，在地图中，尽管 1, 2, 3 三个顶点离起始顶点最近，但离终点却越来越远。当我们遍历到某个顶点的时候，从起点走到这个顶点的路径长度是确定的，我们记作 g(i)（i 表示顶点编号）。但是，从这个顶点到终点的路径长度，我们是未知的。虽然确切的值无法提前知道，但是我们可以用其他估计值来代替。</p><p>这里我们可以通过这个顶点跟终点之间的直线距离，也就是欧几里得距离，来近似地估计这个顶点跟终点的路径长度。我们把这个距离记作 h(i)（i 表示顶点编号），专业的叫法是<code>启发函数</code>（Heuristic Function）。因为欧几里得距离的计算公式，会涉及比较耗时的开根号计算，所以，我们一般通过另外一个更加简单的距离计算公式，那就是<code>曼哈顿距离</code>（Manhattan Distance）。曼哈顿距离是两点之间横纵坐标的距离之和。计算的过程只涉及加减法、符号位反转，所以比欧几里得距离更加高效：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hManhattan</span><span class="params">(Vertex v1, Vertex v2)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// Vertex 表示顶点</span></span><br><span class="line">    <span class="keyword">return</span> Math.abs(v1.x - v2.x) + Math.abs(v1.y - v2.y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原来只是单纯地通过顶点与起点之间的路径长度 g(i)，来判断谁先出队列，现在有了顶点到终点的路径长度估计值，我们通过两者之和 f(i)=g(i)+h(i)，来判断哪个顶点该最先出队列。综合两部分，我们就能有效避免刚刚讲的“跑偏”。这里 f(i) 的专业叫法是<code>估价函数</code>（Evaluation Function）。</p><p>从刚刚的描述，我们可以发现，A* 算法就是对 Dijkstra 算法的简单改造。实际上，代码实现方面，我们也只需要稍微改动几行代码，就能把 Dijkstra 算法的代码实现，改成 A* 算法的代码实现。在 A* 算法的代码实现中，<strong>顶点 Vertex 类的定义多了 x 和 y 的坐标，以及刚刚提到的 f(i) 值</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> id;   <span class="comment">// 顶点编号 ID</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> dist; <span class="comment">// 从起始顶点，到这个顶点的距离，也就是 g(i)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> f;    <span class="comment">// 新增：f(i)=g(i)+h(i)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> x, y; <span class="comment">// 新增：顶点在地图中的坐标 (x, y)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.f = Integer.MAX_VALUE;</span><br><span class="line">        <span class="keyword">this</span>.dist = Integer.MAX_VALUE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Graph 类的成员变量，在构造函数中初始化</span></span><br><span class="line">Vertex[] vertexes = <span class="keyword">new</span> Vertex[<span class="keyword">this</span>.v];</span><br><span class="line"><span class="comment">// 新增一个方法，添加顶点的坐标</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addVertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    vertexes[id] = <span class="keyword">new</span> Vertex(id, x, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>A* 算法的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aStar</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 从顶点 s 到顶点 t 的路径</span></span><br><span class="line">    <span class="keyword">int</span>[] predecessor = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.v]; <span class="comment">// 用来还原路径</span></span><br><span class="line">    <span class="comment">// 按照 vertex 的 f 值构建的小顶堆，而不是按照 dist</span></span><br><span class="line">    PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">this</span>.v);</span><br><span class="line">    <span class="keyword">boolean</span>[] inqueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.v]; <span class="comment">// 标记是否进入过队列</span></span><br><span class="line">    vertexes[s].dist = <span class="number">0</span>;</span><br><span class="line">    vertexes[s].f = <span class="number">0</span>;</span><br><span class="line">    queue.add(vertexes[s]);</span><br><span class="line">    inqueue[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) </span><br><span class="line">    &#123;</span><br><span class="line">        Vertex minVertex = queue.poll(); <span class="comment">// 取堆顶元素并删除</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[minVertex.id].size(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            Edge e = adj[minVertex.id].get(i);   <span class="comment">// 取出一条 minVertex 相连的边</span></span><br><span class="line">            Vertex nextVertex = vertexes[e.tid]; <span class="comment">// minVertex -&gt; nextVertex</span></span><br><span class="line">            <span class="keyword">if</span> (minVertex.dist + e.w &lt; nextVertex.dist) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 更新 next 的 dist, f</span></span><br><span class="line">                nextVertex.dist = minVertex.dist + e.w;</span><br><span class="line">                nextVertex.f = nextVertex.dist+hManhattan(nextVertex, vertexes[t]);</span><br><span class="line">                predecessor[nextVertex.id] = minVertex.id;</span><br><span class="line">                <span class="keyword">if</span> (inqueue[nextVertex.id] == <span class="keyword">true</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    queue.update(nextVertex);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    queue.add(nextVertex);</span><br><span class="line">                    inqueue[nextVertex.id] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nextVertex.id == t) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 只要到达 t 就可以结束 while 了</span></span><br><span class="line">                queue.clear(); <span class="comment">// 清空 queue，才能推出 while 循环</span></span><br><span class="line">                <span class="keyword">break</span>; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出路径</span></span><br><span class="line">    System.out.print(s);</span><br><span class="line">    print(s, t, predecessor); <span class="comment">// print 函数请参看 Dijkstra 算法的实现</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它跟 Dijkstra 算法的代码实现，主要有 3 点区别：</p><ul><li>优先级队列构建的方式不同。A* 算法是根据 f 值（f(i)=g(i)+h(i)）来构建优先级队列，而 Dijkstra 算法是根据 dist 值（g(i)）来构建优先级队列；</li><li>A* 算法在更新顶点 dist 值的时候，会同步更新 f 值；</li><li>循环结束的条件也不一样。Dijkstra 算法是在终点出队列的时候才结束，A* 算法是一旦遍历到终点就结束；</li></ul><p>尽管 A* 算法可以更加快速地找到从起点到终点的路线，但是它<strong>并不能像 Dijkstra 算法那样，找到最短路线</strong>。要找出起点 s 到终点 t 的最短路径，最简单的方法是，通过回溯穷举所有从 s 到达 t 的不同路径，然后对比找出最短的那个。不过很显然，回溯算法的执行效率非常低，是指数级的：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/276.png" alt></p><p>Dijkstra 算法在此基础之上，<strong>利用动态规划的思想，对回溯搜索进行了剪枝</strong>，只保留起点到某个顶点的最短路径，继续往外扩展搜索。动态规划相较于回溯搜索，只是换了一个实现思路，但它实际上也考察到了所有从起点到终点的路线，所以才能得到最优解：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/277.png" alt></p><p>A* 算法利用贪心算法的思路，每次都找 f 值最小的顶点出队列，一旦搜索到终点就不在继续考察其他顶点和路线了。所以，它<strong>并没有考察所有的路线，也就不可能找出最短路径了</strong>。</p><p>要利用 A* 算法解决这个问题，我们只需要把地图，抽象成图就可以了。我们把整个地图分割成一个一个的小方块。在某一个方块上的人物，只能往上下左右四个方向的方块上移动。我们可以把每个方块看作一个顶点。两个方块相邻，我们就在它们之间，连两条有向边，并且边的权值都是 1。所以，这个问题就转化成了，在一个有向有权图中，找某个顶点到另一个顶点的路径问题。<strong>将地图抽象成边权值为 1 的有向图</strong>之后，我们就可以套用 A* 算法，来实现游戏中人物的自动寻路功能了。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>A* 算法属于一种<code>启发式搜索算法</code>（Heuristically Search Algorithm）。实际上，启发式搜索算法并不仅仅只有 A* 算法，还有很多其他算法，比如 IDA* 算法、蚁群算法、遗传算法、模拟退火算法等。<strong>启发式搜索算法利用估价函数，避免“跑偏”，贪心地朝着最有可能到达终点的方向前进</strong>。这种算法找出的路线，并不是最短路线。但是，实际的软件开发中的路线规划问题，我们往往并不需要非得找最短路线。所以，<strong>鉴于启发式搜索算法能很好地平衡路线质量和执行效率，它在实际的软件开发中的应用更加广泛</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+ 树</title>
      <link href="2021/01/23/B-%E6%A0%91/"/>
      <url>2021/01/23/B-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL-数据库索引是如何实现的"><a href="#MySQL-数据库索引是如何实现的" class="headerlink" title="MySQL 数据库索引是如何实现的"></a>MySQL 数据库索引是如何实现的</h2><p>作为一个软件开发工程师，你对数据库肯定再熟悉不过了。作为主流的数据存储系统，它在我们的业务开发中，有着举足轻重的地位。在工作中，<strong>为了加速数据库中数据的查找速度，我们常用的处理思路是，对表中数据创建索引</strong>。那你是否思考过，数据库索引是如何实现的呢？底层使用的是什么数据结构和算法呢？</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>思考的过程比结论更重要。所以，今天的讲解，我会尽量还原这个解决方案的思考过程，让你知其然，并且知其所以然。</p><h3 id="解决问题的前提是定义清楚问题"><a href="#解决问题的前提是定义清楚问题" class="headerlink" title="解决问题的前提是定义清楚问题"></a>解决问题的前提是定义清楚问题</h3><p>除了对问题进行详细的调研，还有一个办法，那就是，<strong>通过对一些模糊的需求进行假设，来限定要解决的问题的范围</strong>。如果你对数据库的操作非常了解，针对我们现在这个问题，你就能把索引的需求定义得非常清楚。但是，对于大部分软件工程师来说，我们可能只了解一小部分常用的 SQL 语句，所以，这里我们假设要解决的问题，只包含这样两个常用的需求：</p><ul><li>根据某个值查找数据，比如 SELECT * FROM user WHERE id=1234；</li><li>根据区间值来查找某些数据，比如 SELECT * FROM user WHERE id&gt;1234 and id&lt;2345；</li></ul><p>除了这些功能性需求之外，这种问题往往还会涉及一些非功能性需求，我们着重考虑性能方面的需求。性能方面的需求，我们<strong>主要考察时间和空间两方面，也就是执行效率和存储空间</strong>。在执行效率方面，我们希望通过索引，查询数据的效率尽可能地高；在存储空间方面，我们希望索引不要消耗太多的内存空间。</p><a id="more"></a><h3 id="尝试用学过的数据结构解决这个问题"><a href="#尝试用学过的数据结构解决这个问题" class="headerlink" title="尝试用学过的数据结构解决这个问题"></a>尝试用学过的数据结构解决这个问题</h3><p>支持快速查询、插入等操作的动态数据结构，我们已经学习过散列表、平衡二叉查找树、跳表。</p><p>散列表的查询性能很好，时间复杂度是 O(1)。但是，<strong>散列表不能支持按照区间快速查找数据</strong>。所以，散列表不能满足我们的需求；尽管平衡二叉查找树查询的性能也很高，时间复杂度是 O(logn)。而且，对树进行中序遍历，我们还可以得到一个从小到大有序的数据序列，但这<strong>仍然不足以支持按照区间快速查找数据</strong>。</p><p>跳表是在链表之上加上多层索引构成的。它支持快速地插入、查找、删除数据，对应的时间复杂度是 O(logn)。并且，跳表也支持按照区间快速地查找数据。我们<strong>只需要定位到区间起点值对应在链表中的结点，然后从这个结点开始，顺序遍历链表，直到区间终点对应的结点为止</strong>，这期间遍历得到的数据就是满足区间值的数据：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/268.png" alt></p><p>实际上，数据库索引所用到的数据结构跟跳表非常相似，叫作 <code>B+ 树</code>。不过，它是通过二叉查找树演化过来的，而非跳表。</p><h3 id="改造二叉查找树来解决这个问题"><a href="#改造二叉查找树来解决这个问题" class="headerlink" title="改造二叉查找树来解决这个问题"></a>改造二叉查找树来解决这个问题</h3><p>为了让二叉查找树支持按照区间来查找数据，我们可以对它进行这样的改造：<strong>树中的节点并不存储数据本身，而是只是作为索引</strong>。除此之外，我们<strong>把每个叶子节点串在一条链表上，链表中的数据是从小到大有序的</strong>。经过改造之后的二叉树，就像图中这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/269.png" alt></p><p>改造之后，如果我们要求某个区间的数据。我们只需要拿区间的起始值，在树中进行查找，当查找到某个叶子节点之后，我们再顺着链表往后遍历，直到链表中的结点数据值大于区间的终止值为止。所有遍历到的数据，就是符合区间值的所有数据：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/270.png" alt></p><p>但是，我们要为几千万、上亿的数据构建索引，如果将索引存储在内存中，尽管内存访问的速度非常快，查询的效率非常高，但是，占用的内存会非常多。我们可以<strong>借助时间换空间的思路，把索引存储在硬盘中，而非内存中</strong>。我们都知道，硬盘是一个非常慢速的存储设备。通常内存的访问速度是纳秒级别的，而磁盘访问的速度是毫秒级别的。读取同样大小的数据，从磁盘中读取花费的时间，是从内存中读取所花费时间的上万倍，甚至几十万倍。</p><p>二叉查找树，经过改造之后，支持区间查找的功能就实现了。不过，为了节省内存，如果把树存储在硬盘中，那么每个节点的读取（或者访问），都对应一次磁盘 IO 操作。<strong>树的高度就等于每次查询数据时磁盘 IO 操作的次数</strong>，所以，我们优化的重点就是尽量减少磁盘 IO 操作，也就是，尽量降低树的高度。</p><p>如图所示，给 16 个数据构建二叉树索引，树的高度是 4，查找一个数据，就需要 4 个磁盘 IO 操作（假设根节点存储在内存中，其他节点存储在磁盘中）；<strong>如果对 16 个数据构建五叉树索引，那高度只有 2，查找一个数据，对应只需要 2 次磁盘操作</strong>。如果 m 叉树中的 m 是 100，那对一亿个数据构建索引，树的高度也只是 4，最多只要 4 次磁盘 IO 就能获取到数据。磁盘 IO 变少了，查找数据的效率也就提高了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/271.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/272.png" alt></p><p>我们将 m 叉树实现 B+ 树索引，用代码实现出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是 B+ 树非叶子节点的定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * 假设 keywords=[3, 5, 8, 10]</span></span><br><span class="line"><span class="comment"> * 4 个键值将数据分为 5 个区间: (-INF, 3), [3, 5), [5, 8), [8, 10), [10, INF)</span></span><br><span class="line"><span class="comment"> * 5 个区间分别对应：children[0]...children[4]</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * m 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span></span><br><span class="line"><span class="comment"> * PAGE_SIZE = (m-1) * 4[keywords 大小] + m * 8[children 大小]</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> m = <span class="number">5</span>; <span class="comment">// 五叉树</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[m-<span class="number">1</span>]; <span class="comment">// 键值，用来划分数据区间</span></span><br><span class="line">    <span class="keyword">public</span> BPlusTreeNode[] children = <span class="keyword">new</span> BPlusTreeNode[m]; <span class="comment">// 保存子节点指针</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是 B+ 树中叶子节点的定义</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * B+ 树中的叶子节点跟内部节点是不一样的</span></span><br><span class="line"><span class="comment"> * 叶子节点存储的是值，而非区间</span></span><br><span class="line"><span class="comment"> * 这个定义里，每个叶子节点存储 3 个数据行的键值及地址信息</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * k 值是事先计算得到的，计算的依据是让所有信息的大小正好等于页的大小：</span></span><br><span class="line"><span class="comment"> * PAGE_SIZE = k * 4[keywords 大小] + k * (8[dataAddress 大小] + 8[prevAddress 大小] + 8[nextAddress 大小])</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BPlusTreeLeafNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> k = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] keywords = <span class="keyword">new</span> <span class="keyword">int</span>[k];      <span class="comment">// 数据的键值</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span>[] dataAddress = <span class="keyword">new</span> <span class="keyword">long</span>[k]; <span class="comment">// 数据地址</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> BPlusTreeLeafNode prev; <span class="comment">// 这个结点在链表中的前驱结点</span></span><br><span class="line">    <span class="keyword">public</span> BPlusTreeLeafNode next; <span class="comment">// 这个结点在链表中的后继结点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于相同个数的数据构建 m 叉树索引，m 叉树中的 m 越大，那树的高度就越小。不管是内存中的数据，还是磁盘中的数据，操作系统都是按页（通常是 4KB）来读取的，一次会读一页的数据。如果要读取的数据量超过一页的大小，就会触发多次 IO 操作。所以，我们<strong>在选择 m 大小的时候，要尽量让每个节点的大小等于一个页的大小</strong>。读取一个节点，只需要一次磁盘 IO 操作：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/273.png" alt></p><p><strong>数据的写入过程，会涉及索引的更新，这是索引导致写入变慢的主要原因</strong>。对于一个 B+ 树来说，m 值是根据页的大小事先计算好的，也就是说，每个节点最多只能有 m 个子节点。在往数据库中写入数据的过程中，这样就有可能使索引中某些节点的子节点个数超过 m，这个节点的大小超过了一个页的大小，读取这样一个节点，就会导致多次磁盘 IO 操作。</p><p>实际上，解决方案并不复杂。我们<strong>只需要将这个节点分裂成两个节点</strong>。但是，节点分裂之后，其上层父节点的子节点个数就有可能超过 m 个。不过这也没关系，我们可以用同样的方法，将父节点也分裂成两个节点。这种级联反应会从下往上，一直影响到根节点。这个分裂过程，你可以结合着下面这个图一块看，会更容易理解：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/274.png" alt></p><p>正是因为<strong>要时刻保证 B+ 树索引是一个 m 叉树，所以，索引的存在会导致数据库写入的速度降低</strong>。实际上，不光写入数据会变慢，删除数据也会变慢。我们在删除某个数据的时候，也要对应地更新索引节点。这个处理思路有点类似跳表中删除数据的处理思路。<strong>频繁的数据删除，就会导致某些节点中，子节点的个数变得非常少</strong>，长此以往，如果每个节点的子节点都比较少，势必会影响索引的效率。</p><p>我们可以设置一个阈值。在 B+ 树中，这个阈值等于 m/2。<strong>如果某个节点的子节点个数小于 m/2，我们就将它跟相邻的兄弟节点合并</strong>。不过，合并之后节点的子节点个数有可能会超过 m。针对这种情况，我们可以借助插入数据时候的处理方法，再分裂节点。文字描述不是很直观，我举了一个删除操作的例子，你可以对比着看下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/275.png" alt></p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>我们讲解了数据库索引实现，依赖的底层数据结构，B+ 树。它通过存储在磁盘的多叉树结构，做到了时间、空间的平衡，既保证了执行效率，又节省了内存。为了方便你掌握和记忆，我这里再总结一下 B+ 树的特点：</p><ul><li>每个节点中子节点的个数不能超过 m，也不能小于 m/2；</li><li><strong>根节点的子节点个数可以不超过 m/2</strong>，这是一个例外；</li><li>m 叉树只存储索引，并不真正存储数据，这个有点儿类似跳表；</li><li>通过链表将叶子节点串联在一起，这样可以方便按区间查找；</li><li>一般情况，根节点会被存储在内存中，其他节点存储在磁盘中；</li></ul><p>B 树实际上是低级版的 B+ 树，或者说 B+ 树是 B 树的改进版。B 树跟 B+ 树的不同点主要集中在这几个地方：</p><ul><li>B+ 树中的节点不存储数据，只是索引，而 B 树中的节点存储数据；</li><li>B 树中的叶子节点并不需要链表来串联；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>向量空间</title>
      <link href="2021/01/23/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/"/>
      <url>2021/01/23/%E5%90%91%E9%87%8F%E7%A9%BA%E9%97%B4/</url>
      
        <content type="html"><![CDATA[<h2 id="如何实现一个简单的音乐推荐系统"><a href="#如何实现一个简单的音乐推荐系统" class="headerlink" title="如何实现一个简单的音乐推荐系统"></a>如何实现一个简单的音乐推荐系统</h2><p>很多人都喜爱听歌，以前我们用 MP3 听歌，现在直接通过音乐 App 在线就能听歌。而且，各种音乐 App 的功能越来越强大，不仅可以自己选歌听，还可以根据你听歌的口味偏好，给你推荐可能会喜爱的音乐，而且有时候，推荐的音乐还非常适合你的口味，甚至会惊艳到你！如此智能的一个功能，你知道它是怎么实现的吗？</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，要解决这个问题，并不需要特别高深的理论。解决思路的核心思想非常简单、直白，用两句话就能总结出来：</p><ul><li>找到跟你口味偏好相似的用户，把他们爱听的歌曲推荐给你；</li><li>找出跟你喜爱的歌曲特征相似的歌曲，把这些歌曲推荐给你；</li></ul><a id="more"></a><h3 id="基于相似用户做推荐"><a href="#基于相似用户做推荐" class="headerlink" title="基于相似用户做推荐"></a>基于相似用户做推荐</h3><p>我们把跟你听类似歌曲的人，看作口味相似的用户。你可以看我下面画的这个图。我<strong>用“1”表示“喜爱”，用“0”笼统地表示“不发表意见”</strong>。从图中我们可以看出，你跟小明共同喜爱的歌曲最多，有 5 首。于是，我们就可以说，小明跟你的口味非常相似：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/262.png" alt></p><p>我们只需要遍历所有的用户，对比每个用户跟你共同喜爱的歌曲个数，并且设置一个阈值，如果你和某个用户共同喜爱的歌曲个数超过这个阈值，我们就把这个用户看作跟你口味相似的用户，把这个用户喜爱但你还没听过的歌曲，推荐给你。实际上，我们可以<strong>通过用户的行为，来定义这个喜爱程度</strong>。我们给每个行为定义一个得分，得分越高表示喜爱程度越高：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/263.png" alt></p><p>我们如果把每个人对每首歌曲的喜爱程度表示出来，就是下面这个样子。图中，某个人对某首歌曲是否喜爱，我们不再用“1”或者“0”来表示，而是对应一个具体的分值：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/264.png" alt></p><p>显然，我们<strong>不能再像之前那样，采用简单的计数来统计两个用户之间的相似度</strong>。这里的相似度度量，我们可以使用另外一个距离，那就是<code>欧几里得距离</code>（Euclidean Distance）。欧几里得距离是用来计算两个向量之间的距离的。一维空间是一条线，我们用 1, 2, 3…这样单个的数，来表示一维空间中的某个位置；二维空间是一个面，我们用 (1, 3), (4, 2), (2, 2)…这样的两个数，来表示二维空间中的某个位置；三维空间是一个立体空间，我们用 (1, 3, 5), (3, 1, 7), (2, 4, 3)…这样的三个数，来表示三维空间中的某个位置。</p><p>类比一维, 二维, 三维的表示方法，K 维空间中的某个位置，我们可以写作 (X1​, X2​, X3​, …, XK​)。这种表示方法就是<code>向量</code>（Vector）。我们知道，二维, 三维空间中，两个位置之间有距离的概念，类比到高维空间，同样也有距离的概念，这就是我们说的两个向量之间的距离。通过类比，我们就可以得到两个向量之间距离的计算公式。这个计算公式就是欧几里得距离的计算公式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/265.png" alt></p><p>我们把每个用户对所有歌曲的喜爱程度，都用一个向量表示。我们<strong>计算出两个向量之间的欧几里得距离，作为两个用户的口味相似程度的度量</strong>。从图中的计算可以看出，小明与你的欧几里得距离距离最小，也就是说，你俩在高维空间中靠得最近，所以，我们就断定，小明跟你的口味最相似：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/266.png" alt></p><h3 id="基于相似歌曲做推荐"><a href="#基于相似歌曲做推荐" class="headerlink" title="基于相似歌曲做推荐"></a>基于相似歌曲做推荐</h3><p>但是，<strong>如果用户是一个新用户，我们还没有收集到足够多的行为数据</strong>，这个时候该如何推荐呢？我们现在再来看另外一种推荐方法，基于相似歌曲的推荐方法，也就是说，如果某首歌曲跟你喜爱的歌曲相似，我们就把它推荐给你。<strong>基于歌曲特征项计算相似度是不可行的</strong>，那我们就换一种思路。对于两首歌，<strong>如果喜欢听的人群都是差不多的，那侧面就可以反映出，这两首歌比较相似</strong>。如图所示，每个用户对歌曲有不同的喜爱程度，我们依旧通过上一个解决方案中定义得分的标准，来定义喜爱程度：<br><a href="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/267.png" target="_blank" rel="noopener"></a></p><p>这个图跟基于相似用户推荐中的图几乎一样。只不过这里把歌曲和用户主次颠倒了一下。<strong>基于相似用户的推荐方法中，针对每个用户，我们将对各个歌曲的喜爱程度作为向量；基于相似歌曲的推荐思路中，针对每个歌曲，我们将每个用户的打分作为向量</strong>。有了每个歌曲的向量表示，我们通过计算向量之间的欧几里得距离，来表示歌曲之间的相似度。欧几里得距离越小，表示两个歌曲越相似。然后，我们就在用户已经听过的歌曲中，找出他喜爱程度较高的歌曲。然后，我们找出跟这些歌曲相似度很高的其他歌曲，推荐给他。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>实际上，这个问题是<code>推荐系统</code>（Recommendation System）里最典型的一类问题。之所以讲这部分内容，主要还是想给你展示，算法的强大之处，利用简单的向量空间的欧几里得距离，就能解决如此复杂的问题。不过，今天，我只给你讲解了基本的理论，实践中遇到的问题还有很多，比如冷启动问题，产品初期积累的数据不多，不足以做推荐等等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>概率统计</title>
      <link href="2021/01/21/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/"/>
      <url>2021/01/21/%E6%A6%82%E7%8E%87%E7%BB%9F%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="如何利用朴素贝叶斯过滤垃圾短信"><a href="#如何利用朴素贝叶斯过滤垃圾短信" class="headerlink" title="如何利用朴素贝叶斯过滤垃圾短信"></a>如何利用朴素贝叶斯过滤垃圾短信</h2><p>垃圾短信和骚扰电话，我想每个人都收到过吧？买房、贷款、投资理财、开发票，各种垃圾短信和骚扰电话，不胜其扰。如果你是一名手机应用开发工程师，让你实现一个简单的垃圾短信过滤功能以及骚扰电话拦截功能，该用什么样的数据结构和算法实现呢？</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>实际上，解决这个问题并不会涉及很高深的算法。今天，我就带你一块看下，如何利用简单的数据结构和算法，解决这种看似非常复杂的问题。</p><h3 id="基于黑名单的过滤器"><a href="#基于黑名单的过滤器" class="headerlink" title="基于黑名单的过滤器"></a>基于黑名单的过滤器</h3><p>我们可以<strong>维护一个骚扰电话号码和垃圾短信发送号码的黑名单</strong>。如果黑名单中的电话号码不多的话，我们可以使用散列表、二叉树等动态数据结构来存储，对内存的消耗并不会很大。如果我们把每个号码看作一个字符串，并且假设平均长度是 16 个字节，那存储 50 万个电话号码，大约需要 10MB 的内存空间。即便是对于手机这样的内存有限的设备来说，这点内存的消耗也是可以接受的。</p><p>但是，如果黑名单中的电话号码很多呢？比如有 500 万个。这个时候，如果再用散列表存储，就需要大约 100MB 的存储空间。为了实现一个拦截功能，耗费用户如此多的手机内存，这显然有点儿不合理。如果我们<strong>要存储 500 万个手机号码，我们把位图大小设置为 10 倍数据大小</strong>，也就是 5000 万，那也只需要使用 5000 万个二进制位（5000 万 bits），换算成字节，也就是不到 7MB 的存储空间。比起散列表的解决方案，内存的消耗减少了很多。</p><p>我们<strong>还可以把黑名单存储在服务器端上，把过滤和拦截的核心工作，交给服务器端来做</strong>。手机端只负责将要检查的号码发送给服务器端，服务器端通过查黑名单，判断这个号码是否应该被拦截，并将结果返回给手机端。用这个解决思路完全不需要占用手机内存。不过，有利就有弊。我们知道，网络通信是比较慢的，所以，网络延迟就会导致处理速度降低。而且，这个方案还有个硬性要求，那就是只有在联网的情况下，才能正常工作。</p><a id="more"></a><h3 id="基于规则的过滤器"><a href="#基于规则的过滤器" class="headerlink" title="基于规则的过滤器"></a>基于规则的过滤器</h3><p>如果某个垃圾短信发送者的号码并不在黑名单中，那这种方法就没办法拦截了。对于垃圾短信来说，我们还可以<strong>通过短信的内容，来判断某条短信是否是垃圾短信</strong>。我们预先设定一些规则，如果某条短信符合这些规则，我们就可以判定它是垃圾短信。实际上，规则可以有很多，比如下面这几个：</p><ul><li>短信中包含特殊单词（或词语），比如一些非法、淫秽、反动词语等；</li><li>短信发送号码是群发号码，非我们正常的手机号码，比如 +60389585；</li><li>短信中包含回拨的联系方式，比如手机号码、微信、QQ、网页链接等；</li><li>短信格式花哨、内容很长，比如包含各种表情、图片、网页链接等；</li><li>符合已知垃圾短信的模板。垃圾短信一般都是重复群发，对于已经判定为垃圾短信的短信，我们可以抽象成模板，将获取到的短信与模板匹配，一旦匹配，我们就可以判定为垃圾短信；</li></ul><p>当然，<strong>如果短信只是满足其中一条规则，就判定为垃圾短信，那会存在比较大的误判的情况</strong>。我们可以综合多条规则进行判断。比如，满足 2 条以上才会被判定为垃圾短信；或者每条规则对应一个不同的得分，满足哪条规则，我们就累加对应的分数，某条短信的总得分超过某个阈值，才会被判定为垃圾短信。</p><p>如果我们只是自己拍脑袋想，哪些单词属于特殊单词，那势必有比较大的主观性，也很容易漏掉某些单词。实际上，我们可以基于概率统计的方法，借助计算机强大的计算能力，找出哪些单词最常出现在垃圾短信中，将这些最常出现的单词，作为特殊单词，用来过滤短信。不过<strong>这种方法的前提是，我们有大量的样本数据</strong>，也就是说，要有大量的短信（比如 1000 万条短信），并且我们还要求，每条短信都做好了标记，它是垃圾短信还是非垃圾短信。</p><p>我们对这 1000 万条短信，进行分词处理（借助中文或者英文分词算法），去掉“的, 和, 是”等没有意义的<code>停用词</code>（Stop Words），得到 n 个不同的单词。针对每个单词，我们统计有多少个垃圾短信出现了这个单词，有多少个非垃圾短信会出现这个单词，进而求出每个单词出现在垃圾短信中的概率，以及出现在非垃圾短信中的概率。<strong>如果某个单词出现在垃圾短信中的概率，远大于出现在非垃圾短信中的概率</strong>，那我们就把这个单词作为特殊单词，用来过滤垃圾短信。文字描述不好理解，我举个例子来解释一下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/255.png" alt></p><h3 id="基于概率统计的过滤器"><a href="#基于概率统计的过滤器" class="headerlink" title="基于概率统计的过滤器"></a>基于概率统计的过滤器</h3><p>基于规则的过滤器，看起来很直观，也很好理解，但是它也有一定的局限性：</p><ul><li>这些规则受人的思维方式局限，规则未免太过简单；</li><li>垃圾短信发送者可能会针对规则，精心设计短信，绕过这些规则的拦截；</li></ul><p>基于概率统计的过滤方式，基础理论是基于<code>朴素贝叶斯算法</code>（Naive Bayes Algorithm）。假设事件 A 是“小明不去上学”，事件 B 是“下雨了”。我们现在统计了一下过去 10 天的下雨情况和小明上学的情况，作为样本数据：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/256.png" alt></p><p>我们来分析一下，这组样本有什么规律。在这 10 天中，有 4 天下雨，所以下雨的概率 P(B)=4/10。10 天中有 3 天，小明没有去上学，所以小明不去上学的概率 P(A)=3/10。在 4 个下雨天中，小明有 2 天没去上学，所以下雨天不去上学的概率 P(A|B)=2/4。在小明没有去上学的 3 天中，有 2 天下雨了，所以小明不上学的日子里下雨的概率是 P(B|A)=2/3。实际上，<strong>这四个概率值之间，有一定的关系，这个关系就是朴素贝叶斯算法</strong>，我们用公式表示出来，就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/257.png" alt></p><p>基于概率统计的过滤器，是基于短信内容来判定是否是垃圾短信。而计算机没办法像人一样理解短信的含义。所以，我们需要<strong>把短信抽象成一组计算机可以理解并且方便计算的特征项，用这一组特征项代替短信本身</strong>，来做垃圾短信过滤。我们可以通过分词算法，把一个短信分割成 n 个单词。这 n 个单词就是一组特征项，全权代表这个短信。因此，判定一个短信是否是垃圾短信这样一个问题，就变成了，<strong>判定同时包含这几个单词的短信是否是垃圾短信</strong>。</p><p>不过，这里我们并不像基于规则的过滤器那样，非黑即白，一个短信要么被判定为垃圾短信、要么被判定为非垃圾短息。我们使用概率，来表征一个短信是垃圾短信的可信程度。如果我们用公式将这个概率表示出来，就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/258.png" alt></p><p>你可能会说，我只需要统计同时包含 W1​, W2​, W3​, …, Wn​ 这 n 个单词的短信有多少个（我们假设有 x 个），然后看这里面属于垃圾短信的有几个（我们假设有 y 个），那包含 W1​, W2​, W3​, …, Wn​ 这 n 个单词的短信是垃圾短信的概率就是 y/x。你忽视了非常重要的一点，那就是样本的数量再大，毕竟也是有限的，样本中不会有太多同时包含 W1​, W2​, W3​, …, Wn​ 的短信的。甚至<strong>很多时候，样本中根本不存在这样的短信，没有样本，也就无法计算概率</strong>。所以这样的推理方式虽然正确，但是实践中并不好用。</p><p>我们通过朴素贝叶斯公式，将这个概率的求解，分解为其他三个概率的求解：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/259.png" alt></p><p>基于<strong>独立事件发生的概率计算公式</strong>，我们可以把 P(W1, W2, W3, …, Wn 同时出现在一条短信中 | 短信是垃圾短信) 分解为下面这个公式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/260.png" alt></p><p>其中，P(Wi​ 出现在短信中 | 短信是垃圾短信) 表示垃圾短信中包含 Wi​ 这个单词的概率有多大。这个概率值通过统计样本很容易就能获得。我们假设垃圾短信有 y 个，其中包含 Wi​ 的有 x 个，那这个概率值就等于 x/y；P(短信是垃圾短信) 表示短信是垃圾短信的概率，这个很容易得到。我们把样本中垃圾短信的个数除以总样本短信个数，就是短信是垃圾短信的概率。</p><p>实际上，我们可以分别计算同时包含 W1​, W2​, W3​, …, Wn​ 这 n 个单词的短信，是垃圾短信和非垃圾短信的概率。假设它们分别是 p1 和 p2。我们并不需要单纯地基于 p1 值的大小来判断是否是垃圾短信，而是<strong>通过对比 p1 和 p2 值的大小，来判断一条短信是否是垃圾短信</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/261.png" alt></p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>实际上，我们可以结合三种不同的过滤方式的结果，对同一个短信处理，如果三者都表明这个短信是垃圾短信，我们才把它当作垃圾短信拦截过滤，这样就会更精准。当然，在实际的工程中，我们还需要结合具体的场景，以及大量的实验，不断去调整策略，权衡垃圾短信判定的<code>准确率</code>（是否会把不是垃圾的短信错判为垃圾短信）和<code>召回率</code>（是否能把所有的垃圾短信都找到），来实现我们的需求。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位图</title>
      <link href="2021/01/20/%E4%BD%8D%E5%9B%BE/"/>
      <url>2021/01/20/%E4%BD%8D%E5%9B%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="如何实现网页爬虫中的-URL-去重功能"><a href="#如何实现网页爬虫中的-URL-去重功能" class="headerlink" title="如何实现网页爬虫中的 URL 去重功能"></a>如何实现网页爬虫中的 URL 去重功能</h2><p>网页爬虫是搜索引擎中的非常重要的系统，负责爬取几十亿、上百亿的网页。爬虫的工作原理是，通过解析已经爬取页面中的网页链接，然后再爬取这些链接对应的网页。而<strong>同一个网页链接有可能被包含在多个页面中，这就会导致爬虫在爬取的过程中，重复爬取相同的网页</strong>。如果你是一名负责爬虫的工程师，你会如何避免这些重复的爬取呢？</p><p>最容易想到的方法就是，我们记录已经爬取的网页链接（也就是 URL），<strong>在爬取一个新的网页之前，我们拿它的链接，在已经爬取的网页链接列表中搜索</strong>。如果存在，那就说明这个网页已经被爬取过了；如果不存在，那就说明这个网页还没有被爬取过，可以继续去爬取。等爬取到这个网页之后，我们将这个网页的链接添加到已经爬取的网页链接列表了。</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>这个问题要处理的对象是网页链接，也就是 URL，需要支持的操作有两个，添加一个 URL 和查询一个 URL。除了这两个功能性的要求之外，在非功能性方面，我们还要求这两个操作的执行效率要尽可能高。除此之外，因为<strong>我们处理的是上亿的网页链接，内存消耗会非常大</strong>，所以在存储效率上，我们要尽可能地高效。</p><p>显然，散列表、红黑树、跳表这些动态数据结构，都能支持快速地插入、查找数据，但是在内存消耗方面，是否可以接受呢？我们拿散列表来举例，假设一个 URL 的平均长度是 64 字节，那单纯存储这 10 亿个 URL，需要大约 60GB 的内存空间。因为散列表必须维持较小的装载因子，才能保证不会出现过多的散列冲突，导致操作的性能下降。而且，<strong>用链表法解决冲突的散列表，还会存储链表指针</strong>。所以，如果将这 10 亿个 URL 构建成散列表，那需要的内存空间会远大于 60GB，有可能会超过 100GB。</p><a id="more"></a><p>当然，对于一个大型的搜索引擎来说，即便是 100GB 的内存要求，其实也不算太高，我们可以采用分治的思想，用多台机器（比如 20 台内存是 8GB 的机器）来存储这 10 亿网页链接。对于爬虫的 URL 去重这个问题，这种解决方案已经是可以实实在在工作的了。</p><p>如果我们用基于链表的方法解决冲突问题，散列表中存储的是 URL，那当查询的时候，通过哈希函数定位到某个链表之后，我们还需要依次比对每个链表中的 URL。这个操作是比较耗时的，主要有两点原因：</p><ul><li>链表中的结点在内存中不是连续存储的，所以<strong>不能一下子加载到 CPU 缓存中，没法很好地利用到 CPU 高速缓存</strong>，所以数据访问性能方面会打折扣；</li><li>链表中的每个数据都是 URL，而 URL 不是简单的数字，是平均长度为 64 字节的字符串。也就是说，我们要让待判重的 URL，跟链表中的每个 URL，做字符串匹配。显然，这样一个<strong>字符串匹配操作，比起单纯的数字比对，要慢很多</strong>；</li></ul><p>实际上，如果要想内存方面有明显的节省，那就得换一种解决方案，也就是我们今天要着重讲的这种存储结构，<code>布隆过滤器</code>（Bloom Filter）。布隆过滤器本身是基于<code>位图</code>（Bitmap）的，是对位图的一种改进。</p><p>我们有 1 千万个整数，整数的范围在 1 到 1 亿之间。如何快速查找某个整数是否在这 1 千万个整数中呢？我们<strong>申请一个大小为 1 亿、数据类型为布尔类型的数组</strong>。我们将这 1 千万个整数作为数组下标，将对应的数组值设置成 true。比如，整数 5 对应下标为 5 的数组值设置为 true，也就是 array[5]=true。</p><p>实际上，<strong>表示 true 和 false 两个值，我们只需要用一个二进制位（bit）就可以了</strong>。我们可以借助编程语言中提供的数据类型，比如 int, long, char 等类型，通过位运算，用其中的某个位表示某个数字。文字描述起来有点不好理解，我把位图的代码实现写了出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BitMap</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// Java 中 char 类型占 16bit，也即是 2 个字节</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] bytes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> nbits;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BitMap</span><span class="params">(<span class="keyword">int</span> nbits)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nbits = nbits;</span><br><span class="line">        <span class="keyword">this</span>.bytes = <span class="keyword">new</span> <span class="keyword">char</span>[nbits/<span class="number">16</span>+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nbits)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> byteIndex = k / <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIndex = k % <span class="number">16</span>;</span><br><span class="line">        bytes[byteIndex] |= (<span class="number">1</span> &lt;&lt; bitIndex);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k &gt; nbits) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> byteIndex = k / <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">int</span> bitIndex = k % <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (bytes[byteIndex] &amp; (<span class="number">1</span> &lt;&lt; bitIndex)) != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>位图通过数组下标来定位数据</strong>，所以，访问效率非常高。而且，<strong>每个数字用一个二进制位来表示</strong>，在数字范围不大的情况下，所需要的内存空间非常节省。比如刚刚那个例子，如果用散列表存储这 1 千万的数据，数据是 32 位的整型数，也就是需要 4 个字节的存储空间，那总共至少需要 40MB 的存储空间。如果我们通过位图的话，数字范围在 1 到 1 亿之间，只需要 1 亿个二进制位，也就是 12MB 左右的存储空间就够了。</p><p>这里我们有个假设，就是数字所在的范围不是很大。如果数字的范围很大，比如刚刚那个问题，数字范围不是 1 到 1 亿，而是 1 到 10 亿，那位图的大小就是 10 亿个二进制位，也就是 120MB 的大小，消耗的内存空间，不降反增。布隆过滤器的做法是，我们仍然使用一个 1 亿个二进制大小的位图，然后<strong>通过哈希函数，对数字进行处理，让它落在这 1 到 1 亿范围内</strong>。比如我们把哈希函数设计成 f(x)=x%n。其中，x 表示数字，n 表示位图的大小（1 亿），也就是，对数字跟位图的大小进行取模求余。</p><p>为了降低这种冲突概率，当然我们可以设计一个复杂点、随机点的哈希函数。除此之外，我们还可以使用 K 个哈希函数，对同一个数字进行求哈希值，那会得到 K 个不同的哈希值，我们分别记作 X1​, X2​, X3​, …, XK​。我们把这 K 个数字作为位图中的下标，将对应的 BitMap[X1​], BitMap[X2​], BitMap[X3​], …, BitMap[XK​] 都设置成 true，也就是说，我们<strong>用 K 个二进制位，来表示一个数字的存在</strong>。</p><p>当我们要查询某个数字是否存在的时候，我们用同样的 K 个哈希函数，对这个数字求哈希值，分别得到 Y1​, Y2​, Y3​, …, YK​。我们看这 K 个哈希值，对应位图中的数值是否都为 true，如果都是 true，则说明，这个数字存在，<strong>如果有其中任意一个不为 true，那就说明这个数字不存在</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/253.png" alt></p><p>对于两个不同的数字来说，经过一个哈希函数处理之后，可能会产生相同的哈希值。但是经过 K 个哈希函数处理之后，K 个哈希值都相同的概率就非常低了。尽管<strong>采用 K 个哈希函数之后，两个数字哈希冲突的概率降低了</strong>，但是，这种处理方式又带来了新的问题，那就是容易误判：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/254.png" alt></p><p>布隆过滤器的误判有一个特点，那就是，它只会对存在的情况有误判。如果某个数字经过布隆过滤器判断不存在，那说明这个数字真的不存在，不会发生误判；<strong>如果某个数字经过布隆过滤器判断存在，这个时候才会有可能误判</strong>，有可能并不存在。不过，只要我们调整哈希函数的个数、位图大小跟要存储数字的个数之间的比例，那就可以将这种误判的概率降到非常低。</p><p>尽管布隆过滤器会存在误判，但是，这并<strong>不影响它发挥大作用，很多场景对误判有一定的容忍度</strong>。比如我们今天要解决的爬虫判重这个问题，即便一个没有被爬取过的网页，被误判为已经被爬取，对于搜索引擎来说，也并不是什么大事情，是可以容忍的，毕竟网页太多了，搜索引擎也不可能 100% 都爬取到。</p><p>我们用布隆过滤器来记录已经爬取过的网页链接，<strong>假设需要判重的网页有 10 亿，那我们可以用一个 10 倍大小的位图来存储</strong>，也就是 100 亿个二进制位，换算成字节，那就是大约 1.2GB。之前我们用散列表判重，需要至少 100GB 的空间。相比来讲，布隆过滤器在存储空间的消耗上，降低了非常多。</p><p>布隆过滤器用多个哈希函数对同一个网页链接进行处理，CPU 只需要将网页链接从内存中读取一次，进行多次哈希计算，理论上讲这组操作是 CPU 密集型的；而在散列表的处理方式中，需要读取散列值相同（散列冲突）的多个网页链接，分别与待判重的网页链接进行字符串匹配，这个操作涉及很多内存数据的读取，所以是内存密集型的。我们知道 <strong>CPU 计算是要比内存访问更快速的</strong>，所以，理论上讲，布隆过滤器的判重方式，更加快速。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p><strong>布隆过滤器非常适合这种不需要 100% 准确的、允许存在小概率误判的大规模判重场景</strong>。除了爬虫网页去重这个例子，还有比如统计一个大型网站的每天的 UV 数，也就是每天有多少用户访问了网站，我们就可以使用布隆过滤器，对重复访问的用户进行去重。</p><p>我们前面讲到，布隆过滤器的误判率，主要跟哈希函数的个数、位图的大小有关。当我们往布隆过滤器中不停地加入数据之后，位图中不是 true 的位置就越来越少了，误判率就越来越高了。所以，<strong>对于无法事先知道要判重的数据个数的情况，我们需要支持自动扩容的功能</strong>。当布隆过滤器中，数据个数与位图大小的比例超过某个阈值的时候，我们就重新申请一个新的位图。后面来的新数据，会被放置到新的位图中。但是，<strong>如果我们要判断某个数据是否在布隆过滤器中已经存在，我们就需要查看多个位图</strong>，相应的执行效率就降低了一些。</p><p>位图、布隆过滤器应用如此广泛，很多编程语言都已经实现了。比如 Java 中的 BitSet 类就是一个位图，Redis 也提供了 BitMap 位图类，Google 的 Guava 工具包提供了 BloomFilter 布隆过滤器的实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路径</title>
      <link href="2021/01/19/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/"/>
      <url>2021/01/19/%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h2 id="地图软件是如何计算出最优出行路径的"><a href="#地图软件是如何计算出最优出行路径的" class="headerlink" title="地图软件是如何计算出最优出行路径的"></a>地图软件是如何计算出最优出行路径的</h2><p>像 Google 地图、百度地图、高德地图这样的地图软件，我想你应该经常使用吧？如果想从家开车到公司，你只需要输入起始、结束地址，地图就会给你规划一条最优出行路线。<strong>这里的最优，有很多种定义</strong>，比如最短路线、最少用时路线、最少红绿灯路线等等。作为一名软件开发工程师，你是否思考过，地图软件的最优路线是如何计算出来的吗？底层依赖了什么算法呢？</p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>解决软件开发中的实际问题，最重要的一点就是<code>建模</code>，也就是<strong>将复杂的场景抽象成具体的数据结构</strong>。我们把每个岔路口看作一个顶点，岔路口与岔路口之间的路看作一条边，路的长度就是边的权重。如果路是单行道，我们就在两个顶点之间画一条有向边；如果路是双行道，我们就在两个顶点之间画两条方向不同的边。这样，整个地图就被抽象成一个有向有权图。于是，我们要求解的问题就转化为，在一个有向有权图中，求两个顶点间的最短路径：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 有向有权图的邻接表表示</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Edge&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        <span class="keyword">this</span>.adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// 添加一条边</span></span><br><span class="line">        <span class="keyword">this</span>.adj[s].add(<span class="keyword">new</span> Edge(s, t, w));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Edge</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> sid; <span class="comment">// 边的起始顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> tid; <span class="comment">// 边的终止顶点编号</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> w;   <span class="comment">// 权重</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Edge</span><span class="params">(<span class="keyword">int</span> sid, <span class="keyword">int</span> tid, <span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sid = sid;</span><br><span class="line">            <span class="keyword">this</span>.tid = tid;</span><br><span class="line">            <span class="keyword">this</span>.w = w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面这个类是为了 Dijkstra 实现用的</span></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Vertex</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> id;   <span class="comment">// 顶点编号 ID</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">int</span> dist; <span class="comment">// 从起始顶点到这个顶点的距离</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Vertex</span><span class="params">(<span class="keyword">int</span> id, <span class="keyword">int</span> dist)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.id = id;</span><br><span class="line">            <span class="keyword">this</span>.dist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>想要解决这个问题，有一个非常经典的算法，<code>最短路径算法</code>（Shortest Path Algorithm），更加准确地说，是单源最短路径算法（一个顶点到一个顶点）。提到最短路径算法，最出名的莫过于 Dijkstra 算法了。所以，我们现在来看，Dijkstra 算法是怎么工作的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为 Java 提供的优先级队列，没有暴露更新数据的接口，所以我们需要重新实现一个</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityQueue</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 根据 vertex.dist 构建小顶堆</span></span><br><span class="line">    <span class="keyword">private</span> Vertex[] nodes;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> v)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.nodes = <span class="keyword">new</span> Vertex[v+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">this</span>.count = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Vertex <span class="title">poll</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Vertex vertex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 更新结点的值，并且从下往上堆化，重新符合堆的定义；时间复杂度 O(logn)</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Vertex vertex)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> ...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dijkstra</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 从顶点 s 到顶点 t 的最短路径</span></span><br><span class="line">    <span class="keyword">int</span>[] predecessor = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="keyword">this</span>.v]; <span class="comment">// 用来还原最短路径</span></span><br><span class="line">    Vertex[] vertexes = <span class="keyword">new</span> Vertex[<span class="keyword">this</span>.v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.v; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        vertexes[i] = <span class="keyword">new</span> Vertex(i, Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    PriorityQueue queue = <span class="keyword">new</span> PriorityQueue(<span class="keyword">this</span>.v); <span class="comment">// 小顶堆</span></span><br><span class="line">    <span class="keyword">boolean</span>[] inqueue = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="keyword">this</span>.v]; <span class="comment">// 标记是否进入过队列</span></span><br><span class="line">    vertexes[s].dist = <span class="number">0</span>;</span><br><span class="line">    queue.add(vertexes[s]);</span><br><span class="line">    inqueue[s] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) </span><br><span class="line">    &#123;</span><br><span class="line">        Vertex minVertex= queue.poll(); <span class="comment">// 取堆顶元素并删除</span></span><br><span class="line">        <span class="keyword">if</span> (minVertex.id == t)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 最短路径产生了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[minVertex.id].size(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            Edge e = adj[minVertex.id].get(i);   <span class="comment">// 取出一条 minVertex 相连的边</span></span><br><span class="line">            Vertex nextVertex = vertexes[e.tid]; <span class="comment">// minVertex-&gt;nextVertex</span></span><br><span class="line">            <span class="keyword">if</span> (minVertex.dist + e.w &lt; nextVertex.dist) </span><br><span class="line">            &#123; </span><br><span class="line">                <span class="comment">// 更新 next 的 dist</span></span><br><span class="line">                nextVertex.dist = minVertex.dist + e.w;</span><br><span class="line">                predecessor[nextVertex.id] = minVertex.id;</span><br><span class="line">                <span class="keyword">if</span> (inqueue[nextVertex.id] == <span class="keyword">true</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    queue.update(nextVertex); <span class="comment">// 更新队列中的 dist 值</span></span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    queue.add(nextVertex);</span><br><span class="line">                    inqueue[nextVertex.id] = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 输出最短路径</span></span><br><span class="line">    System.out.print(s);</span><br><span class="line">    print(s, t, predecessor);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t, <span class="keyword">int</span>[] predecessor)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    print(s, predecessor[t], predecessor);</span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span> + t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们用 vertexes 数组，记录从起始顶点到每个顶点的距离（dist）。起初，我们<strong>把所有顶点的 dist 都初始化为无穷大，把起始顶点的 dist 值初始化为 0</strong>，然后将其放到优先级队列中。</p><p>我们从优先级队列中取出 dist 最小的顶点 minVertex，然后考察这个顶点可达的所有顶点（代码中的 nextVertex）。如果 minVertex 的 dist 值加上 minVertex 与 nextVertex 之间边的权重 w 小于 nextVertex 当前的 dist 值，也就是说，存在另一条更短的路径，它经过 minVertex 到达 nextVertex。那我们就把 nextVertex 的 dist 更新为 minVertex 的 dist 值加上 w。然后，我们把 nextVertex 加入到优先级队列中。重复这个过程，直到找到终止顶点 t 或者队列为空。</p><p><strong>predecessor 数组的作用是为了还原最短路径</strong>，它记录每个顶点的前驱顶点。最后，我们通过递归的方式，将这个路径打印出来；<strong>inqueue 数组是为了避免将一个顶点多次添加到优先级队列中</strong>。我们更新了某个顶点的 dist 值之后，如果这个顶点已经在优先级队列中了，就不要再将它重复添加进去了。我举个例子，再给你解释一下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/249.png" alt></p><p>在刚刚的代码实现中，最复杂就是 while 循环嵌套 for 循环那部分代码了。while 循环最多会执行 V 次，而内部的 for 循环的执行次数不确定，跟每个顶点的相邻边的个数有关，我们分别记作 E0, E1, E2, …, E(V-1)。如果我们<strong>把这 V 个顶点的边都加起来，最大也不会超过图中所有边的个数 E</strong>。</p><p>for 循环内部的代码涉及从优先级队列取数据、往优先级队列中添加数据、更新优先级队列中的数据，这样三个主要的操作。我们知道，<strong>优先级队列是用堆来实现的，堆中的这几个操作，时间复杂度都是 O(logV)</strong>。所以，综合这两部分，再利用乘法原则，整个代码的时间复杂度就是 O(E*logV)。</p><p>前面讲最短路径的时候，每条边的权重是路的长度。在计算最少时间的时候，算法还是不变，我们<strong>只需要把边的权重，从路的长度变成经过这段路所需要的时间</strong>。不过，这个时间会根据拥堵情况时刻变化。</p><p>每经过一条边，就要经过一个红绿灯。关于最少红绿灯的出行方案，实际上，我们只需要把每条边的权值改为 1 即可，算法还是不变，可以继续使用前面讲的 Dijkstra 算法。不过，<strong>边的权值为 1，也就相当于无权图了，我们还可以使用之前讲过的广度优先搜索算法</strong>。因为我们前面讲过，广度优先搜索算法计算出来的两点之间的路径，就是两点的最短路径。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>我们有一个翻译系统，只能针对单个词来做翻译。如果要翻译一整个句子，我们需要将句子拆成一个一个的单词，再丢给翻译系统。针对每个单词，翻译系统会返回一组可选的翻译列表，并且针对每个翻译打一个分，表示这个翻译的可信程度：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/250.png" alt></p><p>针对每个单词，我们从可选列表中，选择其中一个翻译，组合起来就是整个句子的翻译。每个单词的翻译的得分之和，就是整个句子的翻译得分。随意搭配单词的翻译，会得到一个句子的不同翻译。针对整个句子，我们希望计算出得分最高的前 k 个翻译结果：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/251.png" alt></p><p>当然，<strong>最简单的办法还是借助回溯算法，穷举所有的排列组合情况</strong>，然后选出得分最高的前 k 个翻译结果。但是，这样做的时间复杂度会比较高，是 O(m^n)，其中，m 表示平均每个单词的可选翻译个数，n 表示一个句子中包含多少个单词。实际上，这个问题可以借助 Dijkstra 算法的核心思想，非常高效地解决。每个单词的可选翻译是按照分数从大到小排列的，所以 a0​b0​c0​ 肯定是得分最高组合结果。我们把 a0​b0​c0​ 及得分作为一个对象，放入到优先级队列中。</p><p>我们每次从优先级队列中取出一个得分最高的组合，并基于这个组合进行扩展。扩展的策略是每个单词的翻译分别替换成下一个单词的翻译。比如 a0​b0​c0​ 扩展后，会得到三个组合：a1​b0​c0​, a0​b1​c0​, a0​b0​c1​。我们把扩展之后的组合，加到优先级队列中。重复这个过程，直到获取到 k 个翻译组合或者队列为空：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/252.png" alt></p><p>假设句子包含 n 个单词，每个单词平均有 m 个可选的翻译，我们求得分最高的前 k 个组合结果。每次一个组合出队列，就对应着一个组合结果，我们希望得到 k 个，那就对应着 k 次出队操作。<strong>每次有一个组合出队列，就有 n 个组合入队列</strong>。优先级队列中出队和入队操作的时间复杂度都是 O(logX)，X 表示队列中的组合个数。所以，总的时间复杂度就是 O(k*n*logX)。</p><p>k 次出入队列，队列中的总数据不会超过 k*n，也就是说，出队、入队操作的时间复杂度是 O(log(k*n))。所以，总的时间复杂度就是 O(k*n*log(k*n))，比之前的指数级时间复杂度降低了很多。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>拓扑排序</title>
      <link href="2021/01/19/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/"/>
      <url>2021/01/19/%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="如何确定代码源文件的编译依赖关系"><a href="#如何确定代码源文件的编译依赖关系" class="headerlink" title="如何确定代码源文件的编译依赖关系"></a>如何确定代码源文件的编译依赖关系</h2><p>我们知道，一个完整的项目往往会包含很多代码源文件。编译器在编译整个项目的时候，需要按照依赖关系，依次编译每个源文件。比如，A.cpp 依赖 B.cpp，那在编译的时候，编译器需要先编译 B.cpp，才能编译 A.cpp。编译器通过分析源文件或者程序员事先写好的编译配置文件（比如 Makefile 文件），来获取这种局部的依赖关系。那编译器又该<strong>如何通过源文件两两之间的局部依赖关系，确定一个全局的编译顺序呢</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/247.png" alt></p><h2 id="算法解析"><a href="#算法解析" class="headerlink" title="算法解析"></a>算法解析</h2><p>我们在穿衣服的时候都有一定的顺序，我们可以把这种顺序想成，衣服与衣服之间有一定的依赖关系。比如说，你必须先穿袜子才能穿鞋，先穿内裤才能穿秋裤。假设我们现在有八件衣服要穿，它们之间的两两依赖关系我们已经很清楚了，那如何安排一个穿衣序列，能够满足所有的两两之间的依赖关系？这就是个<code>拓扑排序</code>（Topological Sorting）问题。从这个例子中，你应该能想到，<strong>在很多时候，拓扑排序的序列并不是唯一的</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/248.png" alt></p><a id="more"></a><p>我们可以<strong>把源文件与源文件之间的依赖关系，抽象成一个有向图</strong>。每个源文件对应图中的一个顶点，源文件之间的依赖关系就是顶点之间的边。如果 a 先于 b 执行，也就是说 b 依赖于 a，那么就在顶点 a 和顶点 b 之间，构建一条从 a 指向 b 的边。而且，这个图不仅要是有向图，还要是一个有向无环图，也就是不能存在像 a-&gt;b-&gt;c-&gt;a 这样的循环依赖关系。因为图中一旦出现环，拓扑排序就无法工作了。实际上，<strong>拓扑排序本身就是基于有向无环图的一个算法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v; <span class="comment">// 顶点的个数</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// s 先于 t，边 s-&gt;t</span></span><br><span class="line">        adj[s].add(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kahn-算法"><a href="#Kahn-算法" class="headerlink" title="Kahn 算法"></a>Kahn 算法</h3><p>Kahn 算法实际上用的是贪心算法思想，思路非常简单、好懂。定义数据结构的时候，如果 s 需要先于 t 执行，那就添加一条 s 指向 t 的边。所以，如果某个顶点入度为 0，也就表示，没有任何顶点必须先于这个顶点执行，那么这个顶点就可以执行了。我们<strong>先从图中，找出一个入度为 0 的顶点</strong>，将其输出到拓扑排序的结果序列中，并且<strong>把这个顶点从图中删除（也就是把这个顶点可达的顶点的入度都减 1）</strong>。我们循环执行上面的过程，直到所有的顶点都被输出。最后输出的序列，就是满足局部依赖关系的拓扑排序。</p><p>我把 Kahn 算法用代码实现了一下，你可以结合着文字描述一块看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByKahn</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] inDegree = <span class="keyword">new</span> <span class="keyword">int</span>[v]; <span class="comment">// 统计每个顶点的入度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = adj[i].get(j); <span class="comment">// i-&gt;w</span></span><br><span class="line">            inDegree[w]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    LinkedList&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> i = queue.remove();</span><br><span class="line">        System.out.print(<span class="string">"-&gt;"</span> + i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> k = adj[i].get(j);</span><br><span class="line">            inDegree[k]--;</span><br><span class="line">            <span class="keyword">if</span> (inDegree[k] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                queue.add(k);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DFS-算法"><a href="#DFS-算法" class="headerlink" title="DFS 算法"></a>DFS 算法</h3><p>实际上，拓扑排序也可以用深度优先搜索来实现。不过这里的名字要稍微改下，更加确切的说法应该是深度优先遍历，<strong>遍历图中的所有顶点，而非只是搜索一个顶点到另一个顶点的路径</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">topoSortByDFS</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 先构建逆邻接表，边 s-&gt;t 表示，s 依赖于 t，t 先于 s</span></span><br><span class="line">    LinkedList&lt;Integer&gt; inverseAdj[] = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 申请空间</span></span><br><span class="line">        inverseAdj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 通过邻接表生成逆邻接表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; adj[i].size(); ++j) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> w = adj[i].get(j); <span class="comment">// i-&gt;w</span></span><br><span class="line">            inverseAdj[w].add(i);  <span class="comment">// w-&gt;i</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 深度优先遍历图</span></span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="keyword">false</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            visited[i] = <span class="keyword">true</span>;</span><br><span class="line">            dfs(i, inverseAdj, visited);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> vertex, LinkedList&lt;Integer&gt; inverseAdj[], <span class="keyword">boolean</span>[] visited)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; inverseAdj[vertex].size(); ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w = inverseAdj[vertex].get(i);</span><br><span class="line">        <span class="keyword">if</span> (visited[w] == <span class="keyword">true</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[w] = <span class="keyword">true</span>;</span><br><span class="line">        dfs(w, inverseAdj, visited);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 先把 vertex 这个顶点可达的所有顶点都打印出来之后，再打印它自己</span></span><br><span class="line">    System.out.print(<span class="string">"-&gt;"</span> + vertex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个算法包含两个关键部分：</p><ol><li><strong>通过邻接表构造逆邻接表</strong>。邻接表中，边 s-&gt;t 表示 s 先于 t 执行，也就是 t 要依赖 s；在逆邻接表中，边 s-&gt;t 表示 s 依赖于 t，s 后于 t 执行；</li><li><strong>递归处理每个顶点</strong>。对于顶点 vertex 来说，我们先输出它可达的所有顶点，也就是说，先把它依赖的所有的顶点输出了，然后再输出自己；</li></ol><p>从 Kahn 代码中可以看出来，每个顶点被访问了一次，每个边也都被访问了一次，所以，Kahn 算法的时间复杂度就是 O(V+E)；DFS 算法的时间复杂度我们之前分析过。每个顶点被访问两次，每条边都被访问一次，所以时间复杂度也是 O(V+E)。注意，这里的图可能不是连通的，有可能是有好几个不连通的子图构成，所以，<strong>E 并不一定大于 V，两者的大小关系不确定</strong>。所以，在表示时间复杂度的时候，V, E 都要考虑在内。</p><h2 id="总结引申"><a href="#总结引申" class="headerlink" title="总结引申"></a>总结引申</h2><p>拓扑排序应用非常广泛，解决的问题的模型也非常一致。凡是需要通过局部顺序来推导全局顺序的，一般都能用拓扑排序来解决。除此之外，拓扑排序还能检测图中环的存在。对于 Kahn 算法来说，如果最后输出出来的顶点个数，少于图中顶点个数，<strong>图中还有入度不是 0 的顶点，那就说明，图中存在环</strong>。</p><p>在递归查找最终推荐人的时候，可能会因为脏数据，造成存在循环推荐，比如，用户 A 推荐了用户 B，用户 B 推荐了用户 C，用户 C 又推荐了用户 A。如何避免这种脏数据导致的无限递归？实际上，这就是环的检测问题。因为我们每次都只是查找一个用户的最终推荐人，所以，我们并不需要动用复杂的拓扑排序算法，而<strong>只需要记录已经访问过的用户 ID，当用户 ID 第二次被访问的时候，就说明存在环</strong>，也就说明存在脏数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">HashSet&lt;Integer&gt; hashTable = <span class="keyword">new</span> HashSet&lt;&gt;(); <span class="comment">// 保存已经访问过的 actorId</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hashTable.contains(actorId)) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 存在环</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    hashTable.add(actorId);</span><br><span class="line">    Long referrerId = select referrer_id from [table] where actor_id = actorId;</span><br><span class="line">    <span class="keyword">if</span> (referrerId == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> actorId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把这个问题改一下，我们想要知道，数据库中的所有用户之间的推荐关系了，有没有存在环的情况。这个问题，就需要用到拓扑排序算法了。我们<strong>把用户之间的推荐关系，从数据库中加载到内存中，然后构建成今天讲的这种有向图数据结构</strong>，再利用拓扑排序，就可以快速检测出是否存在环了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="2021/01/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>2021/01/17/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<h2 id="动态规划学习路线"><a href="#动态规划学习路线" class="headerlink" title="动态规划学习路线"></a>动态规划学习路线</h2><p><code>动态规划</code>（Dynamic Programming）比较适合用来求解最优问题，比如求最大值、最小值等等。它可以非常显著地降低时间复杂度，提高代码的执行效率。不过，它也是出了名的难学。它的主要学习难点跟递归类似，那就是，<strong>求解问题的过程不太符合人类常规的思维方式</strong>。对于新手来说，要想入门确实不容易。不过，等你掌握了之后，你会发现，实际上并没有想象中那么难。</p><h2 id="0-1-背包问题"><a href="#0-1-背包问题" class="headerlink" title="0-1 背包问题"></a>0-1 背包问题</h2><p>对于一组不同重量、不可分割的物品，我们需要选择一些装入背包，在满足背包最大重量限制的前提下，背包中物品总重量的最大值是多少呢。关于这个问题，回溯的解决方法就是穷举搜索所有可能的装法，然后找出满足条件的最大值。不过，<strong>回溯算法的复杂度比较高，是指数级别的</strong>。那有没有什么规律，可以有效降低时间复杂度呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 回溯算法实现。注意：我把输入的变量都定义成了成员变量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE;   <span class="comment">// 结果放到 maxW 中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] weight = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;; <span class="comment">// 物品重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>; <span class="comment">// 物品个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>; <span class="comment">// 背包承受的最大重量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 调用 f(0, 0)</span></span><br><span class="line">    <span class="keyword">if</span> (cw == w || i == n) &#123; </span><br><span class="line">        <span class="comment">// cw==w 表示装满了，i==n 表示物品都考察完了</span></span><br><span class="line">        <span class="keyword">if</span> (cw &gt; maxW) &#123;</span><br><span class="line">            maxW = cw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f(i+<span class="number">1</span>, cw); <span class="comment">// 选择不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw + weight[i] &lt;= w) &#123;</span><br><span class="line">        f(i+<span class="number">1</span>, cw + weight[i]); <span class="comment">// 选择装第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>我们假设背包的最大承载重量是 9。我们有 5 个不同的物品，每个物品的重量分别是 2, 2, 4, 6, 3。如果我们把这个例子的回溯求解过程，用递归树画出来，就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/233.png" alt></p><p>递归树中的<strong>每个节点表示一种状态</strong>，我们用 (i, cw) 来表示。其中，i 表示将要决策第几个物品是否装入背包，cw 表示当前背包中物品的总重量。比如，<strong>(2, 2) 表示我们将要决策第 2 个物品是否装入背包，在决策前，背包中物品的总重量是 2</strong>。从递归树中有些子问题的求解是重复的，比如图中 f(2, 2) 和 f(3, 4) 都被重复计算了两次。我们可以<strong>借助“备忘录”的解决方式，记录已经计算好的 f(i, cw)</strong>，当再次计算到重复的 f(i, cw) 的时候，可以直接从备忘录中取出来用，就不用再递归计算了，这样就可以避免冗余计算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE;    <span class="comment">// 结果放到 maxW 中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] weight = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;;  <span class="comment">// 物品重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>; <span class="comment">// 物品个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>; <span class="comment">// 背包承受的最大重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span>[][] mem = <span class="keyword">new</span> <span class="keyword">boolean</span>[<span class="number">5</span>][<span class="number">10</span>]; <span class="comment">// 备忘录，默认值 false</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 调用 f(0, 0)</span></span><br><span class="line">    <span class="keyword">if</span> (cw == w || i == n) &#123; </span><br><span class="line">        <span class="comment">// cw==w 表示装满了，i==n 表示物品都考察完了</span></span><br><span class="line">        <span class="keyword">if</span> (cw &gt; maxW) &#123;</span><br><span class="line">            maxW = cw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem[i][cw]) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 重复状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    mem[i][cw] = <span class="keyword">true</span>; <span class="comment">// 记录 (i, cw) 这个状态</span></span><br><span class="line">    f(i+<span class="number">1</span>, cw); <span class="comment">// 选择不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw + weight[i] &lt;= w) &#123;</span><br><span class="line">        f(i+<span class="number">1</span>, cw + weight[i]); <span class="comment">// 选择装第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们<strong>把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中</strong>。每个物品决策完之后，背包中的物品的重量会有多种情况，也就是说，会达到多种不同的状态，对应到递归树中，就是有很多不同的节点。我们<strong>把每一层重复的状态（节点）合并，只记录不同的状态，然后基于上一层的状态集合，来推导下一层的状态集合</strong>。我们可以通过合并每一层重复的状态，这样就保证每一层不同状态的个数都不会超过 w 个（w 表示背包的承载重量），也就是例子中的 9。于是，我们就成功避免了每层状态个数的指数级增长。</p><p>我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。第 0 个物品的重量是 2，要么装入背包，要么不装入背包，决策完之后，会对应背包的两种状态，背包中物品的总重量是 0 或者 2。我们用 states[0][0]=true 和 states[0][2]=true 来表示这两种状态。第 1 个物品的重量也是 2，基于之前的背包状态，在这个物品决策完之后，不同的状态有 3 个，背包中物品总重量分别是 0(0+0), 2(0+2 or 2+0), 4(2+2)。我们用 states[1][0]=true, states[1][2]=true, states[1][4]=true 来表示这三种状态。</p><p>以此类推，直到考察完所有的物品后，整个 states 状态数组就都计算好了。我把整个计算的过程画了出来，你可以看看。图中 0 表示 false，1 表示 true。我们只需要在最后一层，找一个值为 true 的最接近 w 的值，就是背包中物品总重量的最大值：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/234.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/235.png" alt></p><p>我把上面的过程，翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// weight：物品重量，n：物品个数，w：背包可承载重量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">knapsack</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][w+<span class="number">1</span>]; <span class="comment">// 默认值 false</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">    <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[<span class="number">0</span>][weight[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 动态规划状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">            <span class="comment">// 不把第 i 个物品放入背包</span></span><br><span class="line">            <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123;</span><br><span class="line">            <span class="comment">// 把第 i 个物品放入背包</span></span><br><span class="line">            <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                states[i][j+weight[i]] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123; </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (states[n-<span class="number">1</span>][i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这就是一种用动态规划解决问题的思路。我们把问题分解为多个阶段，每个阶段对应一个决策。我们记录每一个阶段可达的状态集合（去掉重复的），然后通过当前阶段的状态集合，来推导下一个阶段的状态集合，动态地往前推进。用回溯算法解决这个问题的时间复杂度 O(2^n)，是指数级的。这个代码的时间复杂度非常好分析，耗时最多的部分就是代码中的两层 for 循环，所以时间复杂度是 O(n*w)。n 表示物品个数，w 表示背包可以承载的总重量。从理论上讲，指数级的时间复杂度肯定要比 O(n*w) 高很多。</p><p>尽管动态规划的执行效率比较高，但是就刚刚的代码实现来说，我们需要额外申请一个 n 乘以 w+1 的二维数组，对空间的消耗比较多。所以，有时候，我们会说，<strong>动态规划是一种空间换时间的解决思路</strong>。实际上，我们只需要一个大小为 w+1 的一维数组就可以解决这个问题。动态规划状态转移的过程，都可以基于这个一维数组来操作。具体的代码实现我贴在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack2</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[w+<span class="number">1</span>]; <span class="comment">// 默认值 false</span></span><br><span class="line">    states[<span class="number">0</span>] = <span class="keyword">true</span>; <span class="comment">// 第一行的数据要特殊处理，可以利用哨兵优化</span></span><br><span class="line">    <span class="keyword">if</span> (items[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 避免 for 循环重复计算的问题</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = w-items[i]; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="comment">// 把第 i 个物品放入背包</span></span><br><span class="line">            <span class="keyword">if</span> (states[j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                states[j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = w; i &gt;= <span class="number">0</span>; --i) &#123; </span><br><span class="line">        <span class="comment">// 输出结果</span></span><br><span class="line">        <span class="keyword">if</span> (states[i] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="0-1-背包问题升级版"><a href="#0-1-背包问题升级版" class="headerlink" title="0-1 背包问题升级版"></a>0-1 背包问题升级版</h2><p>我们刚刚讲的背包问题，只涉及背包重量和物品重量。我们现在<strong>引入物品价值这一变量</strong>。对于一组不同重量、不同价值、不可分割的物品，我们选择将某些物品装入背包，在满足背包最大重量限制的前提下，背包中可装入物品的总价值最大是多少呢。这个问题依旧可以用回溯算法来解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> maxV = Integer.MIN_VALUE;  <span class="comment">// 结果放到 maxV 中</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] items = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">3</span>&#125;; <span class="comment">// 物品的重量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[] value = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">6</span>&#125;; <span class="comment">// 物品的价值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">5</span>; <span class="comment">// 物品个数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> w = <span class="number">9</span>; <span class="comment">// 背包承受的最大重量</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span> cv)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 调用 f(0, 0, 0)</span></span><br><span class="line">    <span class="keyword">if</span> (cw == w || i == n) &#123; </span><br><span class="line">        <span class="comment">// cw==w 表示装满了，i==n 表示物品都考察完了</span></span><br><span class="line">        <span class="keyword">if</span> (cv &gt; maxV) &#123;</span><br><span class="line">            maxV = cv;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f(i+<span class="number">1</span>, cw, cv); <span class="comment">// 选择不装第 i 个物品</span></span><br><span class="line">    <span class="keyword">if</span> (cw + weight[i] &lt;= w) &#123;</span><br><span class="line">        f(i+<span class="number">1</span>, cw+weight[i], cv+value[i]); <span class="comment">// 选择装第 i 个物品</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对上面的代码，我们还是照例画出递归树。在递归树中，每个节点表示一个状态。现在我们需要 3 个变量 (i, cw, cv) 来表示一个状态。其中，i 表示即将要决策第 i 个物品是否装入背包，cw 表示当前背包中物品的总重量，cv 表示当前背包中物品的总价值：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/236.png" alt></p><p>我们发现，在递归树中，有几个节点的 i 和 cw 是完全相同的，比如 f(2, 2, 4) 和 f(2, 2, 3)。在背包中物品总重量一样的情况下，f(2, 2, 4) 这种状态对应的物品总价值更大，我们可以舍弃 f(2, 2, 3) 这种状态，只需要沿着 f(2, 2, 4) 这条决策路线继续往下决策就可以。也就是说，对于 (i, cw) 相同的不同状态，那我们<strong>只需要保留 cv 值最大的那个，继续递归处理</strong>，其他状态不予考虑。</p><p><strong>如果用回溯算法，这个问题就没法再用“备忘录”解决了</strong>。我们还是把整个求解过程分为 n 个阶段，每个阶段会决策一个物品是否放到背包中。每个阶段决策完之后，背包中的物品的总重量以及总价值，会有多种情况，也就是会达到多种不同的状态。我们用一个二维数组 states[n][w+1]，来记录每层可以达到的不同状态。不过这里<strong>数组存储的值不再是 boolean 类型的了，而是当前状态对应的最大总价值</strong>。我们把每一层中 (i, cw) 重复的状态（节点）合并，只记录 cv 值最大的那个状态，然后基于这些状态来推导下一层的状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">knapsack3</span><span class="params">(<span class="keyword">int</span>[] weight, <span class="keyword">int</span>[] value, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][w+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 初始化 states</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; w+<span class="number">1</span>; ++j) &#123;</span><br><span class="line">            states[i][j] = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (weight[<span class="number">0</span>] &lt;= w) &#123;</span><br><span class="line">        states[<span class="number">0</span>][weight[<span class="number">0</span>]] = value[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 动态规划，状态转移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123; </span><br><span class="line">            <span class="comment">// 不选择第 i 个物品</span></span><br><span class="line">            <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123; </span><br><span class="line">                states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w-weight[i]; ++j) &#123; </span><br><span class="line">            <span class="comment">// 选择第 i 个物品</span></span><br><span class="line">            <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> v = states[i-<span class="number">1</span>][j] + value[i];</span><br><span class="line">                <span class="keyword">if</span> (v &gt; states[i][j+weight[i]]) &#123;</span><br><span class="line">                    states[i][j+weight[i]] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找出最大值</span></span><br><span class="line">    <span class="keyword">int</span> maxvalue = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w; ++j) &#123;</span><br><span class="line">        <span class="keyword">if</span> (states[n-<span class="number">1</span>][j] &gt; maxvalue) &#123;</span><br><span class="line">            maxvalue = states[n-<span class="number">1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxvalue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何解决购物时的凑单问题"><a href="#如何解决购物时的凑单问题" class="headerlink" title="如何解决购物时的凑单问题"></a>如何解决购物时的凑单问题</h2><p>假设你女朋友的购物车中有 n 个（n&gt;100）想买的商品，她希望从里面选几个，在凑够满减条件的前提下，让选出来的商品价格总和最大程度地接近满减条件（200 元），这样就可以极大限度地“薅羊毛”。对于这个问题，你当然可以利用回溯算法，穷举所有的排列组合，看大于等于 200 并且最接近 200 的组合是哪一个。但是，这样效率太低了点，时间复杂度非常高，是指数级的。</p><p>实际上，它<strong>跟第一个例子中讲的 0-1 背包问题很像，只不过是把“重量”换成了“价格”而已</strong>。购物车中有 n 个商品。我们针对每个商品都决策是否购买。每次决策之后，对应不同的状态集合。我们还是用一个二维数组 states[n][x]，来记录每次决策之后所有可达的状态。0-1 背包问题中，我们找的是小于等于 w 的最大值，x 就是背包的最大承载重量 w+1。对于这个问题来说，我们要找的是大于等于 200（满减条件）的值中最小的，所以就不能设置为 200 加 1 了。所以，我们可以限定 x 值为 601。</p><p>不过，这个问题不仅要求大于等于 200 的总价格中的最小的，我们还要找出这个最小总价格对应都要购买哪些商品。实际上，我们<strong>可以利用 states 数组，倒推出这个被选择的商品序列</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// items 商品价格，n 商品个数, w 表示满减条件，比如 200</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">double11advance</span><span class="params">(<span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span>[][] states = <span class="keyword">new</span> <span class="keyword">boolean</span>[n][<span class="number">3</span>*w+<span class="number">1</span>]; <span class="comment">// 超过 3 倍就没有薅羊毛的价值了</span></span><br><span class="line">    states[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">true</span>;  <span class="comment">// 第一行的数据要特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (items[<span class="number">0</span>] &lt;= <span class="number">3</span>*w) &#123;</span><br><span class="line">        states[<span class="number">0</span>][items[<span class="number">0</span>]] = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 动态规划</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>*w; ++j) &#123;</span><br><span class="line">            <span class="comment">// 不购买第 i 个商品</span></span><br><span class="line">            <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                states[i][j] = states[i-<span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= <span class="number">3</span>*w-items[i]; ++j) &#123;</span><br><span class="line">            <span class="comment">// 购买第 i 个商品</span></span><br><span class="line">            <span class="keyword">if</span> (states[i-<span class="number">1</span>][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">                states[i][j+items[i]] = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (j = w; j &lt; <span class="number">3</span>*w+<span class="number">1</span>; ++j) &#123; </span><br><span class="line">        <span class="keyword">if</span> (states[n-<span class="number">1</span>][j] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>; <span class="comment">// 输出结果大于等于 w 的最小值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j == <span class="number">3</span>*w+<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 没有可行解</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n-<span class="number">1</span>; i &gt;= <span class="number">1</span>; --i) &#123; </span><br><span class="line">        <span class="comment">// i 表示二维数组中的行，j 表示列</span></span><br><span class="line">        <span class="keyword">if</span> (j-items[i] &gt;= <span class="number">0</span> &amp;&amp; states[i-<span class="number">1</span>][j-items[i]] == <span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.print(items[i] + <span class="string">" "</span>); <span class="comment">// 购买这个商品</span></span><br><span class="line">            j = j - items[i];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">// else 没有购买这个商品，j 不变</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">        System.out.print(items[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>状态 (i, j) 只有可能从 (i-1, j) 或者 (i-1, j-value[i]) 两个状态推导过来。所以，我们就检查这两个状态是否是可达的，也就是 states[i-1][j] 或者 states[i-1][j-value[i]] 是否是 true。<strong>如果 states[i-1][j] 可达，就说明我们没有选择购买第 i 个商品，如果 states[i-1][j-value[i]] 可达，那就说明我们选择了购买第 i 个商品</strong>。我们从中选择一个可达的状态（如果两个都可达，就随意选择一个），然后，继续迭代地考察其他商品是否有选择购买。</p><h2 id="“一个模型三个特征”理论讲解"><a href="#“一个模型三个特征”理论讲解" class="headerlink" title="“一个模型三个特征”理论讲解"></a>“一个模型三个特征”理论讲解</h2><p>首先，我们来看，什么是“一个模型”？它指的是动态规划适合解决的问题的模型，我把这个模型定义为<strong>多阶段决策最优解模型</strong>。我们一般是用动态规划来解决最优问题，而解决问题的过程，需要经历多个决策阶段，每个决策阶段都对应着一组状态。然后我们寻找一组决策序列，经过这组决策序列，能够产生最终期望求解的最优值。</p><p>现在，我们再来看，什么是“三个特征”：</p><ol><li>最优子结构：<br>最优子结构指的是，问题的最优解包含子问题的最优解。反过来说就是，我们可以通过子问题的最优解，推导出问题的最优解。如果我们把最优子结构，对应到我们前面定义的动态规划问题模型上，那我们也可以理解为，<strong>后面阶段的状态可以通过前面阶段的状态推导出来</strong>；</li><li>无后效性：<br>无后效性有两层含义，第一层含义是，在推导后面阶段的状态的时候，我们只关心前面阶段的状态值，不关心这个状态是怎么一步一步推导出来的。第二层含义是，<strong>某阶段状态一旦确定，就不受之后阶段的决策影响</strong>。无后效性是一个非常“宽松”的要求。只要满足前面提到的动态规划问题模型，其实基本上都会满足无后效性；</li><li>重复子问题：<br>如果用一句话概括一下，那就是：<strong>不同的决策序列，到达某个相同的阶段时，可能会产生重复的状态</strong>；</li></ol><h2 id="“一个模型三个特征”实例剖析"><a href="#“一个模型三个特征”实例剖析" class="headerlink" title="“一个模型三个特征”实例剖析"></a>“一个模型三个特征”实例剖析</h2><p>假设我们有一个 n 乘以 n 的矩阵 w[n][n]。矩阵存储的都是正整数。棋子起始位置在左上角，终止位置在右下角。我们将棋子从左上角移动到右下角。每次只能向右或者向下移动一位。从左上角到右下角，会有很多不同的路径可以走。我们把每条路径经过的数字加起来看作路径的长度。那从左上角移动到右下角的最短路径长度是多少呢：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/237.png" alt></p><p>从 (0, 0) 走到 (n-1, n-1)，<strong>总共要走 2*(n-1) 步，也就对应着 2*(n-1) 个阶段</strong>。每个阶段都有向右走或者向下走两种决策，并且每个阶段都会对应一个状态集合。我们把状态定义为 min_dist(i, j)，其中 i 表示行，j 表示列。min_dist 表达式的值表示从 (0, 0) 到达 (i, j) 的最短路径长度。所以，这个问题是一个多阶段决策最优解问题，符合动态规划的模型：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/238.png" alt></p><p>我们可以用回溯算法来解决这个问题。如果你自己写一下代码，画一下递归树，就会发现，递归树中有重复的节点。<strong>重复的节点表示，从左上角到节点对应的位置，有多种路线</strong>，这也能说明这个问题中存在重复子问题：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/239.png" alt></p><p>如果我们走到 (i, j) 这个位置，我们只能通过 (i-1, j)，(i, j-1) 这两个位置移动过来，也就是说，我们想要计算 (i, j) 位置对应的状态，只需要关心 (i-1, j)，(i, j-1) 两个位置对应的状态，并不关心棋子是通过什么样的路线到达这两个位置的。而且，我们仅仅允许往下和往右移动，不允许后退，所以，<strong>前面阶段的状态确定之后，不会被后面阶段的决策所改变</strong>，所以，这个问题符合“无后效性”这一特征。</p><p>刚刚定义状态的时候，我们把从起始位置 (0, 0) 到 (i, j) 的最小路径，记作 min_dist(i, j)。因为我们只能往右或往下移动，所以，我们只有可能从 (i, j-1) 或者 (i-1, j) 两个位置到达 (i, j)。也就是说，到达 (i, j) 的最短路径要么经过 (i, j-1)，要么经过 (i-1, j)，而且到达 (i, j) 的最短路径肯定包含到达这两个位置的最短路径之一。换句话说就是，<strong>min_dist(i, j) 可以通过 min_dist(i, j-1) 和 min_dist(i-1, j) 两个状态推导出来</strong>。这就说明，这个问题符合“最优子结构”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">min_dist(i, j) = w[i][j] + min(min_dist(i, j-<span class="number">1</span>), min_dist(i-<span class="number">1</span>, j))</span><br></pre></td></tr></table></figure><h2 id="两种动态规划解题思路总结"><a href="#两种动态规划解题思路总结" class="headerlink" title="两种动态规划解题思路总结"></a>两种动态规划解题思路总结</h2><p>解决动态规划问题，一般有两种思路。我把它们分别叫作，状态转移表法和状态转移方程法。</p><h3 id="状态转移表法"><a href="#状态转移表法" class="headerlink" title="状态转移表法"></a>状态转移表法</h3><p>一般能用动态规划解决的问题，都可以使用回溯算法的暴力搜索解决。所以，当我们拿到问题的时候，我们可以先用简单的回溯算法解决，然后定义状态，每个状态表示一个节点，然后对应画出递归树。<strong>从递归树中，我们很容易可以看出来，是否存在重复子问题，以及重复子问题是如何产生的</strong>。以此来寻找规律，看是否能用动态规划解决。</p><p>找到重复子问题之后，接下来，我们有两种处理思路：</p><ol><li>直接用回溯加“备忘录”的方法，来避免重复子问题。从执行效率上来讲，这跟动态规划的解决思路没有差别；</li><li>使用动态规划的解决方法 – 状态转移表法；</li></ol><p>我们先画出一个状态表。状态表一般都是二维的，所以你可以把它想象成二维数组。其中，<strong>每个状态包含三个变量，行、列、数组值</strong>。我们根据决策的先后过程，从前往后，根据递推关系，分阶段填充状态表中的每个状态。最后，我们<strong>将这个递推填表的过程，翻译成代码，就是动态规划代码了</strong>。</p><p>尽管大部分状态表都是二维的，但是如果问题的状态比较复杂，需要很多变量来表示，那对应的状态表可能就是高维的，比如三维、四维。那这个时候，我们就不适合用状态转移表法来解决了。一方面是因为高维状态转移表不好画图表示，另一方面是因为<strong>人脑确实很不擅长思考高维的东西</strong>。</p><p>从起点到终点，我们有很多种不同的走法。我们可以穷举所有走法，然后对比找出一个最短走法。我们可以用回溯算法这个比较有规律的穷举算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"><span class="comment">// 调用方式：minDistBT(0, 0, 0, w, n)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">minDistBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> dist, <span class="keyword">int</span>[][] w, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 到达了 (n-1, n-1) 这个位置了，这里看着有点奇怪哈，你自己举个例子看下</span></span><br><span class="line">    <span class="keyword">if</span> (i == n &amp;&amp; j == n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dist &lt; minDist) &#123;</span><br><span class="line">            minDist = dist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i &lt; n) &#123; </span><br><span class="line">        <span class="comment">// 往下走，更新 i=i+1</span></span><br><span class="line">        minDistBT(i + <span class="number">1</span>, j, dist+w[i][j], w, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (j &lt; n) &#123; </span><br><span class="line">        <span class="comment">// 往右走，更新 j=j+1</span></span><br><span class="line">        minDistBT(i, j+<span class="number">1</span>, dist+w[i][j], w, n);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有了回溯代码之后，接下来，我们要画出递归树，以此来寻找重复子问题。在递归树中，一个状态（也就是一个节点）包含三个变量 (i, j, dist)。从图中，我们看出，尽管 (i, j, dist) 不存在重复的，但是 (i, j) 重复的有很多。<strong>对于 (i, j) 重复的节点，我们只需要选择 dist 最小的节点</strong>，继续递归求解，其他节点就可以舍弃了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/240.png" alt></p><p>我们画出一个二维状态表，表中的行、列表示棋子所在的位置，表中的数值表示从起点到这个位置的最短路径。我们<strong>按照决策过程，通过不断状态递推演进，将状态表填好</strong>。为了方便代码实现，我们按行来进行依次填充：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/241.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/242.png" alt></p><p>弄懂了填表的过程，代码实现就简单多了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDistDP</span><span class="params">(<span class="keyword">int</span>[][] matrix, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] states = <span class="keyword">new</span> <span class="keyword">int</span>[n][n];</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123; </span><br><span class="line">        <span class="comment">// 初始化 states 的第一行数据</span></span><br><span class="line">        sum += matrix[<span class="number">0</span>][j];</span><br><span class="line">        states[<span class="number">0</span>][j] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 初始化 states 的第一列数据</span></span><br><span class="line">        sum += matrix[i][<span class="number">0</span>];</span><br><span class="line">        states[i][<span class="number">0</span>] = sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">            states[i][j] = matrix[i][j] + Math.min(states[i][j-<span class="number">1</span>], states[i-<span class="number">1</span>][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> states[n-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="状态转移方程法"><a href="#状态转移方程法" class="headerlink" title="状态转移方程法"></a>状态转移方程法</h3><p>状态转移方程法有点类似递归的解题思路。我们需要分析，<strong>某个问题如何通过子问题来递归求解，也就是所谓的最优子结构</strong>。根据最优子结构，写出递归公式，也就是所谓的状态转移方程。有了状态转移方程，代码实现就非常简单了。一般情况下，我们有两种代码实现方法：</p><ol><li>递归加“备忘录”；</li><li>迭代递推；</li></ol><p>这里我强调一下，状态转移方程是解决动态规划的关键。如果我们能写出状态转移方程，那动态规划问题基本上就解决一大半了，而翻译成代码非常简单。但是很多动态规划问题的状态本身就不好定义，状态转移方程也就更不好想到。下面我用递归加“备忘录”的方式，将状态转移方程翻译成代码；对于另一种实现方式，跟状态转移表法的代码实现是一样的，只是思路不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] matrix = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">9</span>&#125;, &#123;<span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>&#125;, &#123;<span class="number">5</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>&#125;, &#123;<span class="number">6</span>, <span class="number">8</span>, <span class="number">4</span>, <span class="number">3</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">4</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span>[][] mem = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">minDist</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; </span><br><span class="line">    <span class="comment">// 调用 minDist(n-1, n-1)</span></span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mem[i][j] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mem[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minLeft = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (j-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        minLeft = minDist(i, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minUp = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">if</span> (i-<span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        minUp = minDist(i-<span class="number">1</span>, j);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> currMinDist = matrix[i][j] + Math.min(minLeft, minUp);</span><br><span class="line">    mem[i][j] = currMinDist;</span><br><span class="line">    <span class="keyword">return</span> currMinDist;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="四种算法思想比较分析"><a href="#四种算法思想比较分析" class="headerlink" title="四种算法思想比较分析"></a>四种算法思想比较分析</h2><p>如果我们将这四种算法思想分一下类，那贪心、回溯、动态规划可以归为一类，而分治单独可以作为一类，因为它跟其他三个都不大一样。<strong>前三个算法解决问题的模型，都可以抽象成我们今天讲的那个多阶段决策最优解模型</strong>，而分治算法解决的问题尽管大部分也是最优解问题，但是，大部分都不能抽象成多阶段决策模型。</p><p>回溯算法是个“万金油”。<strong>基本上能用的动态规划、贪心解决的问题，我们都可以用回溯算法解决</strong>。回溯算法相当于穷举搜索。穷举所有的情况，然后对比得到最优解。不过，回溯算法的时间复杂度非常高，是指数级别的，只能用来解决小规模数据的问题。对于大规模数据的问题，用回溯算法解决的执行效率就很低了。</p><p>尽管动态规划比回溯算法高效，但是，并不是所有问题，都可以用动态规划来解决。<strong>能用动态规划解决的问题，需要满足三个特征</strong>，最优子结构、无后效性和重复子问题。在重复子问题这一点上，动态规划和分治算法的区分非常明显。<strong>分治算法要求分割成的子问题，不能有重复子问题</strong>，而动态规划正好相反，动态规划之所以高效，就是因为回溯算法实现中存在大量的重复子问题。</p><p><strong>贪心算法实际上是动态规划算法的一种特殊情况</strong>。它解决问题起来更加高效，代码实现也更加简洁。不过，它可以解决的问题也更加有限。它能解决的问题需要满足三个条件，最优子结构、无后效性和<strong>贪心选择性</strong>。“贪心选择性”的意思是：<strong>通过局部最优的选择，能产生全局的最优选择</strong>。每一个阶段，我们都选择当前看起来最优的决策，所有阶段的决策完成之后，最终由这些局部最优解构成全局最优解。</p><h2 id="如何量化两个字符串的相似度？"><a href="#如何量化两个字符串的相似度？" class="headerlink" title="如何量化两个字符串的相似度？"></a>如何量化两个字符串的相似度？</h2><p>有一个非常著名的量化方法，那就是<code>编辑距离</code>（Edit Distance）。根据所包含的编辑操作种类的不同，编辑距离有多种不同的计算方式，比较著名的有<code>莱文斯坦距离</code>（Levenshtein Distance）和<code>最长公共子串长度</code>（Longest Common Substring Length）。其中，莱文斯坦距离允许增加、删除、替换字符这三个编辑操作，最长公共子串长度只允许增加、删除字符这两个编辑操作。</p><p>而且，莱文斯坦距离和最长公共子串长度，从两个截然相反的角度，分析字符串的相似程度。<strong>莱文斯坦距离的大小，表示两个字符串差异的大小；而最长公共子串的大小，表示两个字符串相似程度的大小</strong>。我举个例子给你说明一下。这里面，两个字符串 mitcmu 和 mtacnu 的莱文斯坦距离是 3，最长公共子串长度是 4：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/243.png" alt></p><h2 id="如何编程计算莱文斯坦距离？"><a href="#如何编程计算莱文斯坦距离？" class="headerlink" title="如何编程计算莱文斯坦距离？"></a>如何编程计算莱文斯坦距离？</h2><p>这个问题是求把一个字符串变成另一个字符串，需要的最少编辑次数。整个求解过程，涉及多个决策阶段，我们需要依次考察一个字符串中的每个字符，跟另一个字符串中的字符是否匹配，匹配的话如何处理，不匹配的话又如何处理。所以，这个问题符合多阶段决策最优解模型。回溯是一个递归处理的过程。如果 a[i] 与 b[j] 匹配，我们递归考察 a[i+1] 和 b[j+1]。<strong>如果 a[i] 与 b[j] 不匹配，那我们有多种处理方式可选</strong>：</p><ul><li>可以删除 a[i]，然后递归考察 a[i+1] 和 b[j]；</li><li>可以删除 b[j]，然后递归考察 a[i] 和 b[j+1]；</li><li>可以在 a[i] 前面添加一个跟 b[j] 相同的字符，然后递归考察 a[i] 和 b[j+1]；</li><li>可以在 b[j] 前面添加一个跟 a[i] 相同的字符，然后递归考察 a[i+1] 和 b[j]；</li><li>可以将 a[i] 替换成 b[j]，或者将 b[j] 替换成 a[i]，然后递归考察 a[i+1] 和 b[j+1]；</li></ul><p>我们将上面的回溯算法的处理思路，翻译成代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] a = <span class="string">"mitcmu"</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">char</span>[] b = <span class="string">"mtacnu"</span>.toCharArray();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> m = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> minDist = Integer.MAX_VALUE; <span class="comment">// 存储结果</span></span><br><span class="line"><span class="comment">// 调用方式：lwstBT(0, 0, 0)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">lwstBT</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> edist)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i == n || j == m) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; n) &#123;</span><br><span class="line">            edist += n - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m) &#123;</span><br><span class="line">            edist += m - j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (edist &lt; minDist) &#123;</span><br><span class="line">            minDist = edist;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (a[i] == b[j]) &#123; </span><br><span class="line">        <span class="comment">// 两个字符匹配</span></span><br><span class="line">        lwstBT(i + <span class="number">1</span>, j + <span class="number">1</span>, edist);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="comment">// 两个字符不匹配</span></span><br><span class="line">        lwstBT(i + <span class="number">1</span>, j, edist + <span class="number">1</span>);     <span class="comment">// 删除 a[i] 或者 b[j] 前添加一个字符</span></span><br><span class="line">        lwstBT(i, j + <span class="number">1</span>, edist + <span class="number">1</span>);     <span class="comment">// 删除 b[j] 或者 a[i] 前添加一个字符</span></span><br><span class="line">        lwstBT(i + <span class="number">1</span>, j + <span class="number">1</span>, edist + <span class="number">1</span>); <span class="comment">// 将 a[i] 和 b[j] 替换为相同字符</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据回溯算法的代码实现，我们可以画出递归树，看是否存在重复子问题。如果存在重复子问题，那我们就可以考虑能否用动态规划来解决；<strong>如果不存在重复子问题，那回溯就是最好的解决方法</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/244.png" alt></p><p>在递归树中，每个节点代表一个状态，状态包含三个变量 (i, j, edist)，其中，edist 表示处理到 a[i] 和 b[j] 时，已经执行的编辑操作的次数。在递归树中，(i, j) 两个变量重复的节点很多，比如 (3, 2) 和 (2, 3)。对于 (i, j) 相同的节点，我们只需要保留 edist 最小的，继续递归处理就可以了，剩下的节点都可以舍弃。所以，状态就从 (i, j, edist) 变成了 (i, j, min_edist)，其中 min_edist 表示处理到 a[i] 和 b[j]，已经执行的最少编辑次数。</p><p>不过，这个问题的状态转移方式要复杂很多。状态 (i, j) 可能从 (i-1, j), (i, j-1), (i-1, j-1) 三个状态中的任意一个转移过来：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/245.png" alt></p><p>基于刚刚的分析，我们可以尝试着将把状态转移的过程，用公式写出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果：a[i]!=b[j]，那么：min_edist(i, j) 就等于：</span></span><br><span class="line">min(min_edist(i-<span class="number">1</span>, j) + <span class="number">1</span>, min_edist(i, j-<span class="number">1</span>) + <span class="number">1</span>, min_edist(i-<span class="number">1</span>, j-<span class="number">1</span>) + <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果：a[i]==b[j]，那么：min_edist(i, j) 就等于：</span></span><br><span class="line">min(min_edist(i-<span class="number">1</span>, j) + <span class="number">1</span>, min_edist(i, j-<span class="number">1</span>) + <span class="number">1</span>，min_edist(i-<span class="number">1</span>, j-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>了解了状态与状态之间的递推关系，我们画出一个二维的状态表，按行依次来填充状态表中的每个值：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/246.png" alt></p><p>我们现在既有状态转移方程，又理清了完整的填表过程，代码实现就非常简单了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lwstDP</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] minDist = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123; </span><br><span class="line">        <span class="comment">// 初始化第 0 行： a[0] 与 b[0...j] 的编辑距离</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[j]) &#123; </span><br><span class="line">            minDist[<span class="number">0</span>][j] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">            minDist[<span class="number">0</span>][j] = minDist[<span class="number">0</span>][j-<span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            minDist[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 初始化第 0 列：a[0...i] 与 b[0] 的编辑距离</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            minDist[i][<span class="number">0</span>] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            minDist[i][<span class="number">0</span>] = minDist[i-<span class="number">1</span>][<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; </span><br><span class="line">            minDist[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 按行填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                minDist[i][j] = min(minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                minDist[i][j] = min(minDist[i-<span class="number">1</span>][j]+<span class="number">1</span>, minDist[i][j-<span class="number">1</span>]+<span class="number">1</span>, minDist[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDist[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们拿到一个问题的时候，我们可以先不思考，计算机会如何实现这个问题，而是单纯考虑“人脑”会如何去解决这个问题。人脑比较倾向于思考具象化的、摸得着看得见的东西，不适合思考过于抽象的问题。所以，我们需要<strong>把抽象问题具象化，实例化几个测试数据，通过人脑去分析具体实例的解，然后总结规律</strong>，再尝试套用学过的算法，看是否能够解决。</p><h2 id="如何编程计算最长公共子串长度？"><a href="#如何编程计算最长公共子串长度？" class="headerlink" title="如何编程计算最长公共子串长度？"></a>如何编程计算最长公共子串长度？</h2><p>这个问题的解决思路，跟莱文斯坦距离的解决思路非常相似，也可以用动态规划解决。我刚刚已经详细讲解了莱文斯坦距离的动态规划解决思路，所以，针对这个问题，我直接定义状态，然后写状态转移方程。每个状态还是包括三个变量 (i, j, max_lcs)，max_lcs 表示 a[0…i] 和 b[0…j] 的最长公共子串长度。</p><p>我们先来看回溯的处理思路。我们从 a[0] 和 b[0] 开始，依次考察两个字符串中的字符是否匹配：</p><ul><li>如果 a[i] 与 b[j] 互相匹配，我们将最大公共子串长度加一，并且继续考察 a[i+1] 和 b[j+1]；</li><li>如果 a[i] 与 b[j] 不匹配，最长公共子串长度不变，这个时候，有两个不同的决策路线：<ul><li>删除 a[i]，或者在 b[j] 前面加上一个字符 a[i]，然后继续考察 a[i+1] 和 b[j]；</li><li>删除 b[j]，或者在 a[i] 前面加上一个字符 b[j]，然后继续考察 a[i] 和 b[j+1]；</li></ul></li></ul><p>反过来也就是说，如果我们要求 a[0…i] 和 b[0…j] 的最长公共长度 max_lcs(i, j)，我们只有可能通过这三个状态转移过来：(i-1, j-1, max_lcs), (i-1, j, max_lcs), (i, j-1, max_lcs)。</p><p>如果我们把这个转移过程，用状态转移方程写出来，就是下面这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果：a[i]==b[j]，那么：max_lcs(i, j) 就等于：</span></span><br><span class="line">max(max_lcs(i-<span class="number">1</span>, j-<span class="number">1</span>) + <span class="number">1</span>, max_lcs(i-<span class="number">1</span>, j), max_lcs(i, j-<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果：a[i]!=b[j]，那么：max_lcs(i, j) 就等于：</span></span><br><span class="line">max(max_lcs(i-<span class="number">1</span>, j-<span class="number">1</span>), max_lcs(i-<span class="number">1</span>, j), max_lcs(i, j-<span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>有了状态转移方程，代码实现就简单多了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lcs</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[][] maxLcs = <span class="keyword">new</span> <span class="keyword">int</span>[n][m];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; ++j) &#123;</span><br><span class="line">        <span class="comment">// 初始化第 0 行：a[0] 与 b[0...j] 的 maxLcs</span></span><br><span class="line">        <span class="keyword">if</span> (a[<span class="number">0</span>] == b[j]) &#123;</span><br><span class="line">            maxLcs[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (j != <span class="number">0</span>) &#123;</span><br><span class="line">            maxLcs[<span class="number">0</span>][j] = maxLcs[<span class="number">0</span>][j-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            maxLcs[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 初始化第 0 列：a[0...i] 与 b[0] 的 maxLcs</span></span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[<span class="number">0</span>]) &#123;</span><br><span class="line">            maxLcs[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i != <span class="number">0</span>) &#123;</span><br><span class="line">            maxLcs[i][<span class="number">0</span>] = maxLcs[i-<span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            maxLcs[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123; </span><br><span class="line">        <span class="comment">// 填表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; m; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">                maxLcs[i][j] = max(maxLcs[i-<span class="number">1</span>][j], maxLcs[i][j-<span class="number">1</span>], maxLcs[i-<span class="number">1</span>][j-<span class="number">1</span>]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                maxLcs[i][j] = max(maxLcs[i-<span class="number">1</span>][j], maxLcs[i][j-<span class="number">1</span>], maxLcs[i-<span class="number">1</span>][j-<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxLcs[n-<span class="number">1</span>][m-<span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现搜索引擎中的拼写纠错功能"><a href="#如何实现搜索引擎中的拼写纠错功能" class="headerlink" title="如何实现搜索引擎中的拼写纠错功能"></a>如何实现搜索引擎中的拼写纠错功能</h2><p>当用户在搜索框内，输入一个拼写错误的单词时，我们就<strong>拿这个单词跟词库中的单词一一进行比较，计算编辑距离，将编辑距离最小的单词，作为纠正之后的单词，提示给用户</strong>。这就是拼写纠错最基本的原理。不过，真正用于商用的搜索引擎，拼写纠错功能显然不会就这么简单。一方面，单纯利用编辑距离来纠错，效果并不一定好；另一方面，词库中的数据量可能很大，搜索引擎每天要支持海量的搜索，所以对纠错的性能要求很高。针对纠错效果不好的问题，我们有很多种优化思路，我这里介绍几种：</p><ul><li>我们并不仅仅取出编辑距离最小的那个单词，而是取出编辑距离最小的 Top 10，然后根据其他参数，决策选择哪个单词作为拼写纠错单词。比如使用搜索热门程度来决定哪个单词作为拼写纠错单词；</li><li>我们还可以用多种编辑距离计算方法，比如今天讲到的两种，然后分别编辑距离最小的 Top 10，然后求交集，用交集的结果，再继续优化处理；</li><li>我们还可以通过统计用户的搜索日志，得到最常被拼错的单词列表，以及对应的拼写正确的单词。搜索引擎在拼写纠错的时候，首先在这个最常被拼错单词列表中查找。如果一旦找到，直接返回对应的正确的单词。这样纠错的效果非常好；</li><li>我们还有更加高级一点的做法，引入个性化因素。针对每个用户，维护这个用户特有的搜索喜好，也就是常用的搜索关键词。当用户输入错误的单词的时候，我们首先在这个用户常用的搜索关键词中，计算编辑距离，查找编辑距离最小的单词；</li></ul><p>针对纠错性能方面，我们也有相应的优化方式。我讲两种分治的优化思路：</p><ul><li>如果纠错功能的 TPS 不高，我们可以部署多台机器，每台机器运行一个独立的纠错功能。当有一个纠错请求的时候，我们通过负载均衡，分配到其中一台机器，来计算编辑距离，得到纠错单词；</li><li>如果纠错系统的响应时间太长，也就是，每个纠错请求处理时间过长，我们可以将纠错的词库，分割到很多台机器。当有一个纠错请求的时候，我们就将这个拼写错误的单词，同时发送到这多台机器，让多台机器并行处理，分别得到编辑距离最小的单词，然后再比对合并，最终决定出一个最优的纠错单词；</li></ul><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/regular-expression-matching/" target="_blank" rel="noopener">Regular Expression Matching</a><br><a href="https://leetcode.com/problems/minimum-path-sum/" target="_blank" rel="noopener">Minimum Path Sum</a><br><a href="https://leetcode.com/problems/coin-change/" target="_blank" rel="noopener">Coin Change</a><br><a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock/" target="_blank" rel="noopener">Best Time to Buy and Sell Stock</a><br><a href="https://leetcode.com/problems/maximum-product-subarray/" target="_blank" rel="noopener">Maximum Product Subarray</a><br><a href="https://leetcode.com/problems/triangle/" target="_blank" rel="noopener">Triangle</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法</title>
      <link href="2021/01/16/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/16/%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解“回溯算法”？"><a href="#如何理解“回溯算法”？" class="headerlink" title="如何理解“回溯算法”？"></a>如何理解“回溯算法”？</h2><p>笼统地讲，<code>回溯算法</code>（Backtracking Algorithm）很多时候都应用在“搜索”这类问题上。不过这里说的搜索，并不是狭义的指我们前面讲过的图的搜索算法，而是<strong>在一组可能的解中，搜索满足期望的解</strong>。回溯的处理思想，有点类似枚举搜索。我们枚举所有的解，找到满足期望的解。为了有规律地枚举所有可能的解，避免遗漏和重复，我们<strong>把问题求解的过程分为多个阶段</strong>。每个阶段，我们都会面对一个岔路口，我们先随意选一条路走，当发现这条路走不通的时候（不符合期望的解），就回退到上一个岔路口，另选一种走法继续走。</p><p>我们有一个 8x8 的棋盘，希望往里放 8 个棋子（皇后），每个棋子所在的行、列、对角线都不能有另一个棋子。你可以看我画的图，第一幅图是满足条件的一种方法，第二幅图是不满足条件的。八皇后问题就是期望找到所有满足这种要求的放棋子方式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/232.png" alt></p><p>我们<strong>把这个问题划分成 8 个阶段</strong>，依次将 8 个棋子放到第一行, 第二行, 第三行, …, 第八行。在放置的过程中，我们不停地检查当前放法，是否满足要求。如果满足，则跳到下一行继续放置棋子；如果不满足，那就再换一种放法，继续尝试。<strong>回溯算法非常适合用递归代码实现</strong>：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">8</span>]; <span class="comment">// 全局或成员变量，下标表示行，值表示 queen 存储在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cal8queens</span><span class="params">(<span class="keyword">int</span> row)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 调用方式：cal8queens(0);</span></span><br><span class="line">    <span class="keyword">if</span> (row == <span class="number">8</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 8 个棋子都放置好了，打印结果</span></span><br><span class="line">        printQueens(result);</span><br><span class="line">        <span class="keyword">return</span>; <span class="comment">// 8 行棋子都放好了，已经没法再往下递归了，所以就 return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 每一行都有 8 种放法</span></span><br><span class="line">        <span class="keyword">if</span> (isOk(row, column)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 有些放法不满足要求</span></span><br><span class="line">            result[row] = column; <span class="comment">// 第 row 行的棋子放到了 column 列</span></span><br><span class="line">            cal8queens(row+<span class="number">1</span>);    <span class="comment">// 考察下一行</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isOk</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> column)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 判断 row 行 column 列放置是否合适</span></span><br><span class="line">    <span class="keyword">int</span> leftup = column - <span class="number">1</span>, rightup = column + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = row-<span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 逐行往上考察每一行</span></span><br><span class="line">        <span class="keyword">if</span> (result[i] == column)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 第 i 行的 column 列有棋子吗</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (leftup &gt;= <span class="number">0</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 考察左上对角线：第 i 行 leftup 列有棋子吗</span></span><br><span class="line">            <span class="keyword">if</span> (result[i] == leftup) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rightup &lt; <span class="number">8</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 考察右上对角线：第 i 行 rightup 列有棋子吗</span></span><br><span class="line">            <span class="keyword">if</span> (result[i] == rightup)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        --leftup; ++rightup;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">printQueens</span><span class="params">(<span class="keyword">int</span>[] result)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 打印出一个二维矩阵</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> row = <span class="number">0</span>; row &lt; <span class="number">8</span>; ++row) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> column = <span class="number">0</span>; column &lt; <span class="number">8</span>; ++column) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (result[row] == column) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">"Q "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                System.out.print(<span class="string">"* "</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.println();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="两个回溯算法的经典应用"><a href="#两个回溯算法的经典应用" class="headerlink" title="两个回溯算法的经典应用"></a>两个回溯算法的经典应用</h2><p>回溯算法的理论知识很容易弄懂。不过，对于新手来说，比较难的是用递归来实现。</p><h3 id="0-1-背包"><a href="#0-1-背包" class="headerlink" title="0-1 背包"></a>0-1 背包</h3><p>0-1 背包是非常经典的算法问题，很多场景都可以抽象成这个问题模型。这个问题的经典解法是动态规划，不过还有<strong>一种简单但没有那么高效的解法</strong>，那就是回溯算法。0-1 背包问题有很多变体，我这里介绍一种比较基础的。我们有一个背包，背包总的承载重量是 Wkg。现在我们有 n 个物品，每个物品的重量不等，并且不可分割。我们现在期望选择几件物品，装载到背包中。在不超过背包所能装载重量的前提下，如何让背包中物品的总重量最大。由于物品是不可分割的，要么装要么不装，所以叫 0-1 背包问题。</p><p>对于每个物品来说，都有两种选择，装进背包或者不装进背包。对于 n 个物品来说，总的装法就有 2^n 种，去掉总重量超过 Wkg 的，从剩下的装法中选择总重量最接近 Wkg 的。这里就可以用回溯的方法。我们可以<strong>把物品依次排列，整个问题就分解为了 n 个阶段</strong>，每个阶段对应一个物品怎么选择。先对第一个物品进行处理，选择装进去或者不装进去，然后再递归地处理剩下的物品。这里还<strong>稍微用到了一点搜索剪枝的技巧</strong>，就是当发现已经选择的物品的重量超过 Wkg 之后，我们就停止继续探测剩下的物品：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> maxW = Integer.MIN_VALUE; <span class="comment">// 存储背包中物品总重量的最大值</span></span><br><span class="line"><span class="comment">// cw 表示当前已经装进去的物品的重量和；i 表示考察到哪个物品了</span></span><br><span class="line"><span class="comment">// w 背包重量；items 表示每个物品的重量；n 表示物品个数</span></span><br><span class="line"><span class="comment">// 假设背包可承受重量 100，物品个数 10，物品重量存储在数组 a 中，那可以这样调用函数：</span></span><br><span class="line"><span class="comment">// f(0, 0, a, 10, 100)</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> cw, <span class="keyword">int</span>[] items, <span class="keyword">int</span> n, <span class="keyword">int</span> w)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cw == w || i == n) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// cw==w 表示装满了；i==n 表示已经考察完所有的物品</span></span><br><span class="line">        <span class="keyword">if</span> (cw &gt; maxW)</span><br><span class="line">        &#123; </span><br><span class="line">            maxW = cw;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    f(i+<span class="number">1</span>, cw, items, n, w); <span class="comment">// 当前物品不装进背包</span></span><br><span class="line">    <span class="keyword">if</span> (cw + items[i] &lt;= w) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 已经超过可以背包承受的重量的时候，就不要再装了</span></span><br><span class="line">        f(i+<span class="number">1</span>, cw + items[i], items, n, w); <span class="comment">// 当前物品装进背包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><p>正则表达式中，最重要的就是通配符，通配符结合在一起，可以表达非常丰富的语义。为了方便讲解，我假设正则表达式中只包含“*”和“?”这两种通配符，并且对这两个通配符的语义稍微做些改变，其中，“*”匹配任意多个任意字符，“?”匹配零个或者一个任意字符。</p><p>我们依次考察正则表达式中的每个字符，<strong>当是非通配符时，我们就直接跟文本的字符进行匹配</strong>，如果相同，则继续往下处理；如果不同，则回溯。如果遇到特殊字符的时候，我们就有多种处理方式了，也就是所谓的岔路口，比如“*”有多种匹配方案，可以匹配任意个文本串中的字符，我们就先随意的选择一种匹配方案，然后继续考察剩下的字符。如果中途发现无法继续匹配下去了，我们就回到这个岔路口，重新选择一种匹配方案，然后再继续匹配剩下的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Pattern</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> matched = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span>[] pattern; <span class="comment">// 正则表达式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> plen;       <span class="comment">// 正则表达式长度</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Pattern</span><span class="params">(<span class="keyword">char</span>[] pattern, <span class="keyword">int</span> plen)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.pattern = pattern;</span><br><span class="line">        <span class="keyword">this</span>.plen = plen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// 文本串及长度</span></span><br><span class="line">        matched = <span class="keyword">false</span>;</span><br><span class="line">        rmatch(<span class="number">0</span>, <span class="number">0</span>, text, tlen);</span><br><span class="line">        <span class="keyword">return</span> matched;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rmatch</span><span class="params">(<span class="keyword">int</span> ti, <span class="keyword">int</span> pj, <span class="keyword">char</span>[] text, <span class="keyword">int</span> tlen)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matched)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>; <span class="comment">// 如果已经匹配了，就不要继续递归了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pj == plen) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 正则表达式到结尾了</span></span><br><span class="line">            <span class="keyword">if</span> (ti == tlen)</span><br><span class="line">            &#123;</span><br><span class="line">                matched = <span class="keyword">true</span>; <span class="comment">// 文本串也到结尾了</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pattern[pj] == <span class="string">'*'</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// * 匹配任意个字符</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= tlen-ti; ++k) </span><br><span class="line">            &#123;</span><br><span class="line">                rmatch(ti+k, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pattern[pj] == <span class="string">'?'</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// ? 匹配 0 个或者 1 个字符</span></span><br><span class="line">            rmatch(ti, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">            rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (ti &lt; tlen &amp;&amp; pattern[pj] == text[ti]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 纯字符匹配才行</span></span><br><span class="line">            rmatch(ti+<span class="number">1</span>, pj+<span class="number">1</span>, text, tlen);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分治算法</title>
      <link href="2021/01/15/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/15/%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<p>MapReduce 是 Google 大数据处理的三驾马车之一，另外两个是 <code>GFS</code> 和 <code>Bigtable</code>。它在倒排索引、PageRank 计算、网页分析等搜索引擎相关的技术中都有大量的应用。</p><h2 id="如何理解分治算法？"><a href="#如何理解分治算法？" class="headerlink" title="如何理解分治算法？"></a>如何理解分治算法？</h2><p><code>分治算法</code>（Divide-and-Conquer Algorithm）的核心思想其实就是四个字，分而治之 ，也就是将原问题划分成 n 个规模较小，并且结构与原问题相似的子问题，递归地解决这些子问题，然后再合并其结果，就得到原问题的解。<strong>分治算法是一种处理问题的思想，递归是一种编程技巧</strong>。实际上，分治算法一般都比较适合用递归来实现。分治算法的递归实现中，每一层递归都会涉及这样三个操作：</p><ul><li><strong>分解</strong>：将原问题分解成一系列子问题；</li><li><strong>解决</strong>：递归地求解各个子问题，若子问题足够小，则直接求解；</li><li><strong>合并</strong>：将子问题的结果合并成原问题；</li></ul><p>分治算法能解决的问题，一般需要满足下面这几个条件：</p><ul><li>原问题与分解成的小问题具有相同的模式；</li><li>原问题分解成的子问题可以独立求解，<strong>子问题之间没有相关性</strong>，这一点是分治算法跟动态规划的明显区别；</li><li>具有分解终止条件，也就是说，当问题足够小时，可以直接求解；</li><li>可以将子问题合并成原问题，而这个<strong>合并操作的复杂度不能太高</strong>，否则就起不到减小算法总体复杂度的效果了；</li></ul><a id="more"></a><h2 id="分治算法应用举例分析"><a href="#分治算法应用举例分析" class="headerlink" title="分治算法应用举例分析"></a>分治算法应用举例分析</h2><p>假设我们有 n 个数据，我们期望数据从小到大排列，那完全有序的数据的有序度就是 n(n-1)/2，逆序度等于 0；相反，倒序排列的数据的有序度就是 0，逆序度是 n(n-1)/2。除了这两种极端情况外，我们通过计算有序对或者逆序对的个数，来表示数据的有序度或逆序度：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/230.png" alt></p><p>最笨的方法是，拿每个数字跟它后面的数字比较，看有几个比它小的。我们把比它小的数字个数记作 k，通过这样的方式，把每个数字都考察一遍之后，然后对每个数字对应的 k 值求和，最后得到的总和就是逆序对个数。不过，这样操作的时间复杂度是 O(n^2)。我们套用分治的思想来求数组 A 的逆序对个数。我们可以将数组分成前后两半 A1 和 A2，分别计算 A1 和 A2 的逆序对个数 K1 和 K2，然后<strong>再计算 A1 与 A2 之间的逆序对个数 K3</strong>。那数组 A 的逆序对个数就等于 K1+K2+K3。</p><p>归并排序中有一个非常关键的操作，就是将两个有序的小数组，合并成一个有序的数组。实际上，<strong>在这个合并的过程中，我们就可以计算这两个小数组的逆序对个数了</strong>。每次合并操作，我们都计算逆序对个数，把这些计算出来的逆序对个数求和，就是这个数组的逆序对个数了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/231.png" alt></p><p>对于工程师来说，看代码肯定更好理解一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> num = <span class="number">0</span>; <span class="comment">// 全局变量或者成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">count</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    num = <span class="number">0</span>;</span><br><span class="line">    mergeSortCounting(a, <span class="number">0</span>, n-<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mergeSortCounting</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p &gt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> q = (p+r)/<span class="number">2</span>;</span><br><span class="line">    mergeSortCounting(a, p, q);</span><br><span class="line">    mergeSortCounting(a, q+<span class="number">1</span>, r);</span><br><span class="line">    merge(a, p, q, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> p, <span class="keyword">int</span> q, <span class="keyword">int</span> r)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = p, j = q+<span class="number">1</span>, k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>[] tmp = <span class="keyword">new</span> <span class="keyword">int</span>[r-p+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (i&lt;=q &amp;&amp; j&lt;=r) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] &lt;= a[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            tmp[k++] = a[i++];</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            num += (q-i+<span class="number">1</span>); <span class="comment">// 统计 p-q 之间，比 a[j] 大的元素个数</span></span><br><span class="line">            tmp[k++] = a[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (i &lt;= q) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 处理剩下的</span></span><br><span class="line">        tmp[k++] = a[i++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (j &lt;= r) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 处理剩下的</span></span><br><span class="line">        tmp[k++] = a[j++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt;= r-p; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 从 tmp 拷贝回 a</span></span><br><span class="line">        a[p+i] = tmp[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="分治思想在海量数据处理中的应用"><a href="#分治思想在海量数据处理中的应用" class="headerlink" title="分治思想在海量数据处理中的应用"></a>分治思想在海量数据处理中的应用</h2><p>分治算法思想的应用是非常广泛的，并<strong>不仅限于指导编程和算法设计，它还经常用在海量数据处理的场景中</strong>。我们前面讲的数据结构和算法，大部分都是基于内存存储和单机处理。但是，如果要处理的数据量非常大，没法一次性放到内存中，这个时候，这些数据结构和算法就无法工作了。比如，给 10GB 的订单文件按照金额排序这样一个需求，看似是一个简单的排序问题，但是因为数据量大，有 10GB，而我们的机器的内存可能只有 2, 3GB 这样子，无法一次性加载到内存，也就无法通过单纯地使用快排、归并等基础算法来解决了。</p><p><strong>要解决这种数据量大到内存装不下的问题，我们就可以利用分治的思想</strong>。我们可以将海量的数据集合根据某种方法，划分为几个小的数据集合，每个小的数据集合单独加载到内存来解决，然后再将小数据集合合并成大数据集合。实际上，利用这种分治的处理思路，不仅仅能克服内存的限制，还能利用多线程或者多机处理，加快处理的速度。</p><p>比如刚刚举的那个例子，给 10GB 的订单排序，我们就可以<strong>先扫描一遍订单，根据订单的金额，将 10GB 的文件划分为几个金额区间</strong>。比如订单金额为 1 到 100 元的放到一个小文件，101 到 200 之间的放到另一个文件，以此类推。这样每个小文件都可以单独加载到内存排序，最后将这些有序的小文件合并，就是最终有序的 10GB 订单数据了。</p><p>如果订单数据存储在类似 GFS 这样的分布式系统上，当 10GB 的订单被划分成多个小文件的时候，每个文件可以并行加载到多台机器上处理，最后再将结果合并在一起，这样并行处理的速度也加快了很多。不过，这里有一个点要注意，就是<strong>数据的存储与计算所在的机器是同一个或者在网络中靠得很近，否则就会因为数据访问的速度</strong>，导致整个处理过程不但不会变快，反而有可能变慢。</p><h2 id="MapReduce-中的分治思想"><a href="#MapReduce-中的分治思想" class="headerlink" title="MapReduce 中的分治思想"></a>MapReduce 中的分治思想</h2><p>我们刚刚举的订单的例子，数据有 10GB 大小，可能给你的感受还不强烈。那如果我们要处理的数据是 1T、10T、100T 这样子的，那一台机器处理的效率肯定是非常低的。而对于谷歌搜索引擎来说，网页爬取、清洗、分析、分词、计算权重、倒排索引等等各个环节中，都会面对如此海量的数据。所以，我们可以利用 MapReduce 提供的<strong>高可靠、高性能、高容错的并行计算框架</strong>，并行地处理这几十亿、上百亿的网页。</p><p>一台机器过于低效，那我们就把任务拆分到多台机器上来处理。如果拆分之后的小任务之间互不干扰，独立计算，最后再将结果合并。实际上，<strong>MapReduce 框架只是一个任务调度器，底层依赖 GFS 来存储数据，依赖 Borg 管理机器</strong>。它从 GFS 中拿数据，交给 Borg 中的机器执行，并且时刻监控机器执行的进度，一旦出现机器宕机、进度卡壳等，就重新从 Borg 中调度一台机器执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贪心算法</title>
      <link href="2021/01/14/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/14/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解“贪心算法”？"><a href="#如何理解“贪心算法”？" class="headerlink" title="如何理解“贪心算法”？"></a>如何理解“贪心算法”？</h2><p>假设我们有一个可以容纳 100kg 物品的背包，可以装各种物品。我们有以下 5 种豆子，每种豆子的总量和总价值都各不相同。为了让背包中所装物品的总价值最大，我们如何选择在背包中装哪些豆子？每种豆子又该装多少呢：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/222.png" alt></p><p>实际上，这个问题很简单，我们只要先算一算每个物品的单价，按照单价由高到低依次来装就好了。单价从高到低排列，依次是：黑豆、绿豆、红豆、青豆、黄豆，所以，我们可以往背包里装 20kg 黑豆、30kg 绿豆、50kg 红豆。这个问题的解决思路显而易见，它本质上借助的就是贪心算法。</p><p><code>贪心算法</code>（Greedy Algorithm）解决问题的步骤：</p><ol><li>针对一组数据，我们定义了<code>限制值</code>和<code>期望值</code>，希望<strong>从中选出几个数据，在满足限制值的情况下，期望值最大</strong>。类比到刚刚的例子，限制值就是重量不能超过 100kg，期望值就是物品的总价值。这组数据就是 5 种豆子。我们从中选出一部分，满足重量不超过 100kg，并且总价值最大；</li><li><strong>每次选择当前情况下，对限制值同等贡献量，并对期望值贡献最大的数据</strong>。类比到刚刚的例子，我们每次都从剩下的豆子里面，选择单价最高的，也就是重量相同的情况下，对价值贡献最大的豆子；</li><li>严格地证明贪心算法的正确性，是非常复杂的，需要涉及比较多的数学推理。大部分情况下，举几个例子验证一下就可以了；</li></ol><a id="more"></a><p>实际上，用贪心算法解决问题的思路，并不总能给出最优解。在一个有权图中，我们从顶点 S 开始，找一条到顶点 T 的最短路径。贪心算法的解决思路是，每次都选择一条跟当前顶点相连的权最小的边，直到找到顶点 T。按照这种思路，我们求出的最短路径是 S-&gt;A-&gt;E-&gt;T，路径长度是 1+4+4=9：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/223.png" alt></p><p>但是，这种贪心的选择方式，最终求的路径并不是最短路径，因为路径 S-&gt;B-&gt;D-&gt;T 才是最短路径，因为这条路径的长度是 2+2+2=6。在这个问题上，贪心算法不工作的主要原因是，<strong>前面的选择，会影响后面的选择</strong>。如果我们第一步从顶点 S 走到顶点 A，那接下来面对的顶点和边，跟第一步从顶点 S 走到顶点 B，是完全不同的。所以，即便我们第一步选择最优的走法（边最短），但有可能因为这一步选择，导致后面每一步的选择都很糟糕，最终也就无缘全局最优解了。</p><h2 id="贪心算法实战分析"><a href="#贪心算法实战分析" class="headerlink" title="贪心算法实战分析"></a>贪心算法实战分析</h2><p>如果死抠理论的话，确实很难理解透彻。掌握贪心算法的关键是多练习。只要多练习几道题，自然就有感觉了。</p><h3 id="分糖果"><a href="#分糖果" class="headerlink" title="分糖果"></a>分糖果</h3><p>我们有 m 个糖果和 n 个孩子。我们现在要把糖果分给这些孩子吃，但是糖果少，孩子多（m&lt;\n)，所以糖果只能分配给一部分孩子。每个糖果的大小不等，这 m 个糖果的大小分别是 s1, s2, s3, …, sm。除此之外，每个孩子对糖果大小的需求也是不一样的，只有糖果的大小大于等于孩子的对糖果大小的需求的时候，孩子才得到满足。假设这 n 个孩子对糖果大小的需求分别是 g1, g2, g3, …, gn。如何分配糖果，能尽可能满足最多数量的孩子？</p><p>我们可以把这个问题抽象成：从 n 个孩子中，抽取一部分孩子分配糖果，<strong>让满足的孩子的个数（期望值）是最大的，这个问题的限制值就是糖果个数 m</strong>。</p><p>我们现在来看看如何用贪心算法来解决。对于一个孩子来说，如果小的糖果可以满足，我们就没必要用更大的糖果，这样更大的就可以留给其他对糖果大小需求更大的孩子。另一方面，对糖果大小需求小的孩子更容易被满足，所以，我们可以从需求小的孩子开始分配糖果。因为满足一个需求大的孩子跟满足一个需求小的孩子，对我们期望值的贡献是一样的。我们每次从剩下的孩子中，找出对糖果大小需求最小的，然后发给他剩下的糖果中能满足他的最小的糖果，这样得到的分配方案，也就是满足的孩子个数最多的方案。</p><h3 id="钱币找零"><a href="#钱币找零" class="headerlink" title="钱币找零"></a>钱币找零</h3><p>假设我们有 1 元, 2 元, 5 元, 10 元, 20 元, 50 元, 100 元这些面额的纸币，它们的张数分别是 c1, c2, c5, c10, c20, c50, c100。我们现在要用这些钱来支付 K 元，最少要用多少张纸币呢？在生活中，我们肯定是先用面值最大的来支付，如果不够，就继续用更小一点面值的，以此类推，最后剩下的用 1 元来补齐。</p><p><strong>在贡献相同期望值（纸币数目）的情况下，我们希望多贡献点金额，这样就可以让纸币数更少</strong>，这就是一种贪心算法的解决思路。直觉告诉我们，这种处理方法就是最好的。</p><h3 id="区间覆盖"><a href="#区间覆盖" class="headerlink" title="区间覆盖"></a>区间覆盖</h3><p>假设我们有 n 个区间，区间的起始端点和结束端点分别是 [l1, r1], [l2, r2], [l3, r3], …, [ln, rn]。我们从这 n 个区间中选出一部分区间，这部分区间满足两两不相交，最多能选出多少个区间呢：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/224.png" alt></p><p>这个问题的解决思路是这样的：我们假设这 n 个区间中最左端点是 lmin，最右端点是 rmax。这个问题就相当于，我们选择几个不相交的区间，从左到右将 [lmin, rmax] 覆盖上。我们按照起始端点从小到大的顺序对这 n 个区间排序。我们每次选择，<strong>左端点跟前面的已经覆盖的区间不重合的，右端点又尽量小的区间</strong>，这样可以让剩下的未覆盖区间尽可能的大，就可以放置更多的区间。这实际上就是一种贪心的选择方法：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/225.png" alt></p><h2 id="如何用贪心算法实现霍夫曼编码"><a href="#如何用贪心算法实现霍夫曼编码" class="headerlink" title="如何用贪心算法实现霍夫曼编码"></a>如何用贪心算法实现霍夫曼编码</h2><p>假设我有一个包含 1000 个字符的文件，每个字符占 1 个 byte（1byte=8bits），存储这 1000 个字符就一共需要 8000bits。假设我们通过统计分析发现，这 1000 个字符中只包含 6 种不同字符，假设它们分别是 a, b, c, d, e, f。而 3 个二进制位（bit）就可以表示 8 个不同的字符，所以，为了尽量减少存储空间，每个字符我们用 3 个二进制位来表示。那存储这 1000 个字符只需要 3000bits 就可以了，比原来的存储方式节省了很多空间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a(<span class="number">000</span>), b(<span class="number">001</span>), c(<span class="number">010</span>), d(<span class="number">011</span>), e(<span class="number">100</span>), f(<span class="number">101</span>)</span><br></pre></td></tr></table></figure><p>霍夫曼编码是一种十分有效的编码方法，广泛用于数据压缩中，其压缩率通常在 20%~90% 之间。霍夫曼编码不仅会考察文本中有多少个不同字符，还会考察每个字符出现的频率，根据频率的不同，选择不同长度的编码。霍夫曼编码试图用这种不等长的编码方法，来进一步增加压缩的效率。根据贪心的思想，我们可以<strong>把出现频率比较多的字符，用稍微短一些的编码；出现频率比较少的字符，用稍微长一些的编码</strong>。</p><p>霍夫曼编码是不等长的，每次应该读取 1 位还是 2 位, 3 位等等来解压缩呢？这个问题就导致霍夫曼编码解压缩起来比较复杂。为了避免解压缩过程中的歧义，霍夫曼编码<strong>要求各个字符的编码之间，不会出现某个编码是另一个编码前缀的情况</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/226.png" alt></p><p>假设这 6 个字符出现的频率从高到低依次是 a, b, c, d, e, f。我们把它们编码下面这个样子，任何一个字符的编码都不是另一个的前缀，在解压缩的时候，我们<strong>每次会读取尽可能长的可解压的二进制串，所以在解压缩的时候也不会歧义</strong>。经过这种编码压缩之后，这 1000 个字符只需要 2100bits 就可以了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/227.png" alt></p><p>我们把每个字符看作一个节点，并且附带着把频率放到优先级队列中。我们从队列中取出频率最小的两个节点 A, B，然后新建一个节点 C，把频率设置为两个节点的频率之和，并把这个新节点 C 作为节点 A, B 的父节点。最后<strong>再把 C 节点放入到优先级队列中，重复这个过程，直到队列中没有数据</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/228.png" alt></p><p>现在，我们给每一条边加上画一个权值，<strong>指向左子节点的边我们统统标记为 0，指向右子节点的边，我们统统标记为 1</strong>，那从根节点到叶节点的路径就是叶节点对应字符的霍夫曼编码：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/229.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AC 自动机</title>
      <link href="2021/01/12/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/"/>
      <url>2021/01/12/AC-%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="基于单模式串和-Trie-树实现的敏感词过滤"><a href="#基于单模式串和-Trie-树实现的敏感词过滤" class="headerlink" title="基于单模式串和 Trie 树实现的敏感词过滤"></a>基于单模式串和 Trie 树实现的敏感词过滤</h2><p>单模式串匹配算法，是在一个模式串和一个主串之间进行匹配，也就是说，在一个主串中查找一个模式串。多模式串匹配算法，就是在多个模式串和一个主串之间做匹配，也就是说，在一个主串中查找多个模式串。尽管，单模式串匹配算法也能完成多模式串的匹配工作。但是，这样做的话，<strong>每个匹配过程都需要扫描一遍用户输入的内容，整个过程下来就要扫描很多遍用户输入的内容</strong>。如果敏感词很多，比如几千个，并且用户输入的内容很长，假如有上千个字符，那我们就需要扫描几千遍这样的输入内容。很显然，这种处理思路比较低效。</p><p>与单模式匹配算法相比，多模式匹配算法在这个问题的处理上就很高效了。它只需要扫描一遍主串，就能在主串中一次性查找多个模式串是否存在，从而大大提高匹配效率。我们可以<strong>对敏感词字典进行预处理，构建成 Trie 树结构</strong>。这个预处理的操作只需要做一次，如果敏感词字典动态更新了，比如删除、添加了一个敏感词，那我们只需要动态更新一下 Trie 树就可以了。</p><p>当用户输入一个文本内容后，我们把用户输入的内容作为主串，从第一个字符（假设是字符 C）开始，在 Trie 树中匹配。<strong>当匹配到 Trie 树的叶子节点，或者中途遇到不匹配字符的时候，我们将主串的开始匹配位置后移一位</strong>，也就是从字符 C 的下一个字符开始，重新在 Trie 树中匹配。基于 Trie 树的这种处理方法，有点类似单模式串匹配的 BF 算法。</p><a id="more"></a><h2 id="经典的多模式串匹配算法：AC-自动机"><a href="#经典的多模式串匹配算法：AC-自动机" class="headerlink" title="经典的多模式串匹配算法：AC 自动机"></a>经典的多模式串匹配算法：AC 自动机</h2><p>AC 自动机算法，全称是 Aho-Corasick 算法。其实，<strong>Trie 树跟 AC 自动机之间的关系，就像单串匹配中朴素的串匹配算法，跟 KMP 算法之间的关系一样</strong>，只不过前者针对的是多模式串而已。所以，AC 自动机实际上就是在 Trie 树之上，加了类似 KMP 的 next 数组，只不过此处的 next 数组是构建在树上罢了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AcNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">char</span> data; </span><br><span class="line">    <span class="keyword">public</span> AcNode[] children = <span class="keyword">new</span> AcNode[<span class="number">26</span>]; <span class="comment">// 字符集只包含 a~z 这 26 个字符</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;       <span class="comment">// 结尾字符为 true</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> length = -<span class="number">1</span>;                    <span class="comment">// 当 isEndingChar=true 时，记录模式串长度</span></span><br><span class="line">    <span class="keyword">public</span> AcNode fail;                        <span class="comment">// 失败指针</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AcNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.data = data;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，AC 自动机的构建，包含两个操作：</p><ol><li>将多个模式串构建成 Trie 树；</li><li>在 Trie 树上构建失败指针（相当于 KMP 中的失效函数 next 数组）；</li></ol><p>构建好 Trie 树之后，如何在它之上构建失败指针？这里有 4 个模式串，分别是 c, bc, bcd, abcd；主串是 abcd：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/216.png" alt></p><p>假设我们沿 Trie 树走到 p 节点，也就是下图中的紫色节点，那 p 的失败指针就是从 root 走到紫色节点形成的字符串 abc，跟所有模式串前缀匹配的<strong>最长可匹配后缀子串</strong>，就是箭头指的 bc 模式串。我们将 p 节点的失败指针指向那个最长匹配后缀子串对应的模式串的前缀的最后一个节点，就是下图中箭头指向的节点：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/217.png" alt></p><p>其实，如果我们把树中相同深度的节点放到同一层，那么某个节点的失败指针只有可能出现在它所在层的上一层。我们可以像 KMP 算法那样，当我们要求某个节点的失败指针的时候，我们通过已经求得的、深度更小的那些节点的失败指针来推导。也就是说，我们可以逐层依次来求解每个节点的失败指针。所以，<strong>失败指针的构建过程，是一个按层遍历树的过程</strong>。</p><p>我们假设节点 p 的失败指针指向节点 q，我们看节点 p 的子节点 pc 对应的字符，是否也可以在节点 q 的子节点中找到。如果找到了节点 q 的一个子节点 qc，对应的字符跟节点 pc 对应的字符相同，则将节点 pc 的失败指针指向节点 qc：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/218.png" alt></p><p>如果节点 q 中没有子节点的字符等于节点 pc 包含的字符，则<strong>令 q=q-&gt;fail，继续上面的查找，直到 q 是 root 为止</strong>，如果还没有找到相同字符的子节点，就让节点 pc 的失败指针指向 root：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/219.png" alt></p><p>我将构建失败指针的代码贴在这里，你可以对照着讲解一块看下，应该更容易理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildFailurePointer</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue&lt;AcNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    root.fail = <span class="keyword">null</span>;</span><br><span class="line">    queue.add(root);</span><br><span class="line">    <span class="keyword">while</span> (!queue.isEmpty()) </span><br><span class="line">    &#123;</span><br><span class="line">        AcNode p = queue.remove();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            AcNode pc = p.children[i];</span><br><span class="line">            <span class="keyword">if</span> (pc == <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (p == root) </span><br><span class="line">            &#123;</span><br><span class="line">                pc.fail = root;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                AcNode q = p.fail;</span><br><span class="line">                <span class="keyword">while</span> (q != <span class="keyword">null</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    AcNode qc = q.children[pc.data - <span class="string">'a'</span>];</span><br><span class="line">                    <span class="keyword">if</span> (qc != <span class="keyword">null</span>) </span><br><span class="line">                    &#123;</span><br><span class="line">                        pc.fail = qc;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    q = q.fail;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (q == <span class="keyword">null</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    pc.fail = root;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            queue.add(pc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过按层来计算每个节点的子节点的失效指针，刚刚举的那个例子，最后构建完成之后的 AC 自动机就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/220.png" alt></p><p>在匹配过程中，主串从 i=0 开始，AC 自动机从指针 p=root 开始，假设模式串是 b，主串是 a：</p><ul><li>如果 p 指向的节点有一个等于 b[i]的子节点 x，我们就更新 p 指向 x，这个时候我们需要通过失败指针，检测一系列失败指针为结尾的路径是否是模式串。这一句不好理解，你可以结合代码看。处理完之后 i+1，继续这两个过程；</li><li>如果 p 指向的节点没有等于 b[i]的子节点，那失败指针就派上用场了，我们让 p=p-&gt;fail，然后继续这两个过程；</li></ul><p>关于匹配的这部分，文字描述不如代码看得清楚，所以我把代码贴了出来，非常简短。<strong>这段代码输出的就是，在主串中每个可以匹配的模式串出现的位置</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// text 是主串</span></span><br><span class="line">    <span class="keyword">int</span> n = text.length;</span><br><span class="line">    AcNode p = root;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> idx = text[i] - <span class="string">'a'</span>;</span><br><span class="line">        <span class="keyword">while</span> (p.children[idx] == <span class="keyword">null</span> &amp;&amp; p != root) </span><br><span class="line">        &#123;</span><br><span class="line">            p = p.fail; <span class="comment">// 失败指针发挥作用的地方</span></span><br><span class="line">        &#125;</span><br><span class="line">        p = p.children[idx];</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            p = root; <span class="comment">// 如果没有匹配的，从 root 开始重新匹配</span></span><br><span class="line">        &#125;</span><br><span class="line">        AcNode tmp = p;</span><br><span class="line">        <span class="keyword">while</span> (tmp != root) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 打印出可以匹配的模式串</span></span><br><span class="line">            <span class="keyword">if</span> (tmp.isEndingChar == <span class="keyword">true</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> pos = i - tmp.length + <span class="number">1</span>;</span><br><span class="line">                System.out.println(<span class="string">"匹配起始下标："</span> + pos + <span class="string">"; 长度："</span> + tmp.length);</span><br><span class="line">            &#125;</span><br><span class="line">            tmp = tmp.fail;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现高性能的敏感词过滤功能"><a href="#如何实现高性能的敏感词过滤功能" class="headerlink" title="如何实现高性能的敏感词过滤功能"></a>如何实现高性能的敏感词过滤功能</h2><p>实际上，我上面贴出来的代码，已经是一个敏感词过滤的原型代码了。它可以找到所有敏感词出现的位置（在用户输入的文本中的起始下标）。你只需要稍加改造，<strong>再遍历一遍文本内容（主串），就可以将文本中的所有敏感词替换成“***”</strong>。</p><p>AC 自动机实现的敏感词过滤系统，是否比单模式串匹配方法更高效：</p><ol><li>将多个模式串构建成 AC 自动机：<br>AC 自动机的构建过程都是预先处理好的，构建好之后，并不会频繁地更新，所以不会影响到敏感词过滤的运行效率。<ol><li>将模式串构建成 Trie 树：</li></ol> <strong>Trie 树构建的时间复杂度是 O(m*len)</strong>，其中 len 表示敏感词的平均长度，m 表示敏感词的个数；<ol start="2"><li>在 Trie 树上构建失败指针：<br>假设 Trie 树中总的节点个数是 k，每个节点构建失败指针的时候，最耗时的环节是 while 循环中的 q=q-&gt;fail，<strong>每运行一次这个语句，q 指向节点的深度都会减少 1，而树的高度最高也不会超过 len</strong>，所以每个节点构建失败指针的时间复杂度是 O(len)。整个失败指针的构建过程就是 O(k*len)；</li></ol></li><li>在 AC 自动机中匹配主串：<br>跟刚刚构建失败指针的分析类似，for 循环依次遍历主串中的每个字符，for 循环内部最耗时的部分也是 while 循环，而这一部分的时间复杂度也是 O(len)，所以总的匹配的时间复杂度就是 O(n*len)。因为敏感词并不会很长，而且这个时间复杂度只是一个非常宽泛的上限，<strong>实际情况下，可能近似于 O(n)，所以 AC 自动机做敏感词过滤，性能非常高</strong>；</li></ol><p>实际上，因为失效指针可能大部分情况下都指向 root 节点，所以<strong>绝大部分情况下，在 AC 自动机上做匹配的效率要远高于刚刚计算出的比较宽泛的时间复杂度</strong>。只有在极端情况下，如图所示，AC 自动机的性能才会退化的跟 Trie 树一样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/221.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Trie 树</title>
      <link href="2021/01/12/Trie-%E6%A0%91/"/>
      <url>2021/01/12/Trie-%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是“Trie-树”？"><a href="#什么是“Trie-树”？" class="headerlink" title="什么是“Trie 树”？"></a>什么是“Trie 树”？</h2><p>Trie 树，也叫“字典树”。顾名思义，它是一个树形结构。它是一种专门处理字符串匹配的数据结构，用来<strong>解决在一组字符串集合中快速查找某个字符串的问题</strong>。我举个简单的例子来说明一下。我们有 6 个字符串，它们分别是：how, hi, her, hello, so, see。我们希望在里面多次查找某个字符串是否存在。如果每次查找，都是拿要查找的字符串跟这 6 个字符串依次进行字符串匹配，那效率就比较低。</p><p>这个时候，我们就可以先对这 6 个字符串做一下预处理，组织成 Trie 树的结构，之后每次查找，都是在 Trie 树中进行匹配查找。Trie 树的本质，就是<strong>利用字符串之间的公共前缀，将重复的前缀合并在一起</strong>。最后构造出来的就是下面这个图中的样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/208.png" alt></p><a id="more"></a><p>其中，根节点不包含任何信息。每个节点表示一个字符串中的字符，从根节点到红色节点的一条路径表示一个字符串（注意：<strong>红色节点并不都是叶子节点</strong>）。为了让你更容易理解 Trie 树是怎么构造出来的，我画了一个 Trie 树构造的分解过程。<strong>构造过程的每一步，都相当于往 Trie 树中插入一个字符串</strong>。当所有字符串都插入完成之后，Trie 树就构造好了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/209.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/210.png" alt></p><p>当我们在 Trie 树中查找一个字符串的时候，比如查找字符串“her”，那我们将要查找的字符串分割成单个的字符 h, e, r，然后从 Trie 树的根节点开始匹配。如图所示，绿色的路径就是在 Trie 树中匹配的路径：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/211.png" alt></p><p>如果我们要查找的是字符串“he”呢？我们还用上面同样的方法，从根节点开始，沿着某条路径来匹配，如图所示，绿色的路径，是字符串“he”匹配的路径。但是，路径的最后一个节点“e”并不是红色的。也就是说，<strong>“he”是某个字符串的前缀子串，但并不能完全匹配任何字符串</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/212.png" alt></p><h2 id="如何实现一棵-Trie-树？"><a href="#如何实现一棵-Trie-树？" class="headerlink" title="如何实现一棵 Trie 树？"></a>如何实现一棵 Trie 树？</h2><p>Trie 树主要有两个操作：</p><ol><li>将字符串集合构造成 Trie 树。这个过程分解开来的话，就是一个将字符串插入到 Trie 树的过程；</li><li>在 Trie 树中查询一个字符串；</li></ol><p>借助散列表的思想，我们通过一个下标与字符一一映射的数组，来存储子节点的指针。这句话稍微有点抽象，不怎么好懂，我画了一张图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/213.png" alt></p><p>假设我们的字符串中只有从 a 到 z 这 26 个小写字母，我们在数组中下标为 0 的位置，存储指向子节点 a 的指针，下标为 1 的位置存储指向子节点 b 的指针，以此类推，下标为 25 的位置，存储的是指向的子节点 z 的指针。如果某个字符的子节点不存在，我们就在对应的下标的位置存储 null：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> data;</span><br><span class="line">    TrieNode children[<span class="number">26</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们在 Trie 树中查找字符串的时候，我们就可以<strong>通过字符的 ASCII 码减去“a”的 ASCII 码，迅速找到匹配的子节点的指针</strong>。比如，d 的 ASCII 码减去 a 的 ASCII 码就是 3，那子节点 d 的指针就存储在数组中下标为 3 的位置中。我把上面的描述翻译成了代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> TrieNode root = <span class="keyword">new</span> TrieNode(<span class="string">'/'</span>); <span class="comment">// 存储无意义字符</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往 Trie 树中插入一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">char</span>[] text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; text.length; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = text[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                TrieNode newNode = <span class="keyword">new</span> TrieNode(text[i]);</span><br><span class="line">                p.children[index] = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        p.isEndingChar = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在 Trie 树中查找一个字符串</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>[] pattern)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pattern.length; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = pattern[i] - <span class="string">'a'</span>;</span><br><span class="line">            <span class="keyword">if</span> (p.children[index] == <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不存在 pattern</span></span><br><span class="line">            &#125;</span><br><span class="line">            p = p.children[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.isEndingChar == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 不能完全匹配，只是前缀</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;  <span class="comment">// 找到 pattern</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrieNode</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">char</span> data;</span><br><span class="line">        <span class="keyword">public</span> TrieNode[] children = <span class="keyword">new</span> TrieNode[<span class="number">26</span>];</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">boolean</span> isEndingChar = <span class="keyword">false</span>;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">TrieNode</span><span class="params">(<span class="keyword">char</span> data)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果要在一组字符串中，频繁地查询某些字符串，用 Trie 树会非常高效。构建 Trie 树的过程，需要扫描所有的字符串，<strong>时间复杂度是 O(n)（n 表示所有字符串的长度和）</strong>。但是<strong>一旦构建成功之后，后续的查询操作会非常高效</strong>。每次查询时，如果要查询的字符串长度是 k，那我们只需要比对大约 k 个节点，就能完成查询操作。跟原本那组字符串的长度和个数没有任何关系。所以说，构建好 Trie 树后，在其中<strong>查找字符串的时间复杂度是 O(k)</strong>，k 表示要查找的字符串的长度。</p><h2 id="Trie-树真的很耗内存吗？"><a href="#Trie-树真的很耗内存吗？" class="headerlink" title="Trie 树真的很耗内存吗？"></a>Trie 树真的很耗内存吗？</h2><p>Trie 树是一种非常独特的、高效的字符串匹配方法。但是，关于 Trie 树，你有没有听过这样一种说法：“Trie 树是非常耗内存的，用的是一种空间换时间的思路”。Trie 树的本质是避免重复存储一组字符串的相同前缀子串，但是现在<strong>每个字符（对应一个节点）的存储远远大于 1 个字节</strong>。按照我们上面举的例子，数组长度为 26，每个元素是 8 字节，那每个节点就会额外需要 26*8=208 个字节。而且这还是只包含 26 个字符的情况。</p><p>如果字符串中不仅包含小写字母，还包含大写字母、数字、甚至是中文，那需要的存储空间就更多了。所以，也就是说，在某些情况下，Trie 树不一定会节省存储空间。<strong>在重复的前缀并不多的情况下，Trie 树不但不能节省内存，还有可能会浪费更多的内存</strong>。我们可以稍微牺牲一点查询的效率，将每个节点中的数组换成其他数据结构，来存储一个节点的子节点指针。用哪种数据结构呢？我们的选择其实有很多，比如有序数组、跳表、散列表、红黑树等。</p><p>假设我们用有序数组，数组中的指针按照所指向的子节点中的字符的大小顺序排列。查询的时候，我们可以通过二分查找的方法，快速查找到某个字符应该匹配的子节点的指针。但是，在往 Trie 树中插入一个字符串的时候，我们<strong>为了维护数组中数据的有序性，就会稍微慢了点</strong>。实际上，Trie 树的变体有很多，都可以在一定程度上解决内存消耗的问题。比如，<code>缩点优化</code>，就是<strong>对只有一个子节点的节点，而且此节点不是一个串的结束节点，可以将此节点与子节点合并</strong>。这样可以节省空间，但却增加了编码难度：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/214.png" alt></p><h2 id="Trie-树与散列表、红黑树的比较"><a href="#Trie-树与散列表、红黑树的比较" class="headerlink" title="Trie 树与散列表、红黑树的比较"></a>Trie 树与散列表、红黑树的比较</h2><p>在一组字符串中查找字符串，Trie 树实际上表现得并不好。它对要处理的字符串有及其严苛的要求：</p><ul><li>字符串中包含的字符集不能太大。我们前面讲到，如果字符集太大，那存储空间可能就会浪费很多。即便可以优化，但也要付出牺牲查询、插入效率的代价；</li><li>要求字符串的前缀重合比较多，不然空间消耗会变大很多；</li><li>如果要用 Trie 树解决问题，那我们就要自己从零开始实现一个 Trie 树，还要保证没有 bug，这个在工程上是将简单问题复杂化，除非必须，一般不建议这样做；</li><li>我们知道，通过指针串起来的数据块是不连续的，而 Trie 树中用到了指针，所以，对缓存并不友好，性能上会打个折扣；</li></ul><p>综合这几点，针对在一组字符串中查找字符串的问题，我们在工程中，更倾向于用散列表或者红黑树。因为这两种数据结构，我们都不需要自己去实现，直接利用编程语言中提供的现成类库就行了。实际上，Trie 树只是不适合精确匹配查找，这种问题更适合用散列表或者红黑树来解决；<strong>Trie 树比较适合的是查找前缀匹配的字符串</strong>。</p><h2 id="如何实现搜索关键词的提示功能"><a href="#如何实现搜索关键词的提示功能" class="headerlink" title="如何实现搜索关键词的提示功能"></a>如何实现搜索关键词的提示功能</h2><p>我们假设关键词库由用户的热门搜索关键词组成。我们将这个词库构建成一个 Trie 树。当用户输入其中某个单词的时候，把这个词作为一个前缀子串在 Trie 树中匹配。为了讲解方便，我们假设词库里只有 hello, her, hi, how, so, see 这 6 个关键词。当用户输入了字母 h 的时候，我们就把以 h 为前缀的 hello, her, hi, how 展示在搜索提示框内。当用户继续键入字母 e 的时候，我们就把以 he 为前缀的 hello, her 展示在搜索提示框内。这就是<strong>搜索关键词提示的最基本的算法原理</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/215.png" alt></p><p>实际上，搜索引擎的搜索关键词提示功能远非我讲的这么简单。如果再稍微深入一点，你就会想到，上面的解决办法遇到下面几个问题：</p><ul><li>我刚讲的思路是针对英文的搜索关键词提示，对于更加复杂的中文来说，词库中的数据又该如何构建成 Trie 树呢；</li><li>如果词库中有很多关键词，在搜索提示的时候，用户输入关键词，作为前缀在 Trie 树中可以匹配的关键词也有很多，如何选择展示哪些内容呢；</li><li>像 Google 这样的搜索引擎，用户单词拼写错误的情况下，Google 还是可以使用正确的拼写来做关键词提示，这个又是怎么做到的呢；</li></ul><p>实际上，<strong>Trie 树的这个应用可以扩展到更加广泛的一个应用上，就是自动输入补全</strong>，比如输入法自动补全功能、IDE 代码编辑器自动补全功能、浏览器网址输入的自动补全功能等等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>字符串匹配基础</title>
      <link href="2021/01/10/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80/"/>
      <url>2021/01/10/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="BF-算法"><a href="#BF-算法" class="headerlink" title="BF 算法"></a>BF 算法</h2><p>BF（Brute Force）算法，中文叫作暴力匹配算法，也叫朴素匹配算法。从名字可以看出，这种算法的字符串匹配方式很“暴力”，当然也就会比较简单、好懂，但相应的性能也不高。我们在字符串 A 中查找字符串 B，那字符串 A 就是<code>主串</code>，字符串 B 就是<code>模式串</code>。我们把主串的长度记作 n，模式串的长度记作 m。因为我们是在主串中查找模式串，所以 n&gt;m。</p><p>作为最简单、最暴力的字符串匹配算法，BF 算法的思想可以用一句话来概括，那就是，我们<strong>在主串中，检查起始位置分别是 0, 1, 2, n-m 且长度为 m 的 n-m+1 个子串，看有没有跟模式串匹配的</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/170.png" alt></p><p>从上面的算法思想和例子，我们可以看出，在极端情况下，比如主串是“aaaaa…aaaaaa”，模式串是“aaaaab”。我们每次都比对 m 个字符，要比对 n-m+1 次，所以，这种算法的<strong>最坏情况时间复杂度是 O(n*m)</strong>。尽管理论上，BF 算法的时间复杂度很高，是 O(n*m)，但在实际的开发中，它却是一个比较常用的字符串匹配算法。原因有两点：</p><ol><li>实际的软件开发中，大部分情况下，模式串和主串的长度都不会太长。而且每次模式串与主串中的子串匹配的时候，当<strong>中途遇到不能匹配的字符的时候，就可以就停止了</strong>，不需要把 m 个字符都比对一下。所以，尽管理论上的最坏情况时间复杂度是 O(n*m)，但是，统计意义上，大部分情况下，算法执行效率要比这个高很多；</li><li>朴素字符串匹配算法思想简单，代码实现也非常简单。简单意味着不容易出错，如果有 bug 也容易暴露和修复。在工程中，<strong>在满足性能要求的前提下，简单是首选</strong>；</li></ol><a id="more"></a><h2 id="RK-算法"><a href="#RK-算法" class="headerlink" title="RK 算法"></a>RK 算法</h2><p>RK（Rabin-Karp）算法是由它的两位发明者 Rabin 和 Karp 的名字来命名的。我个人觉得，它其实就是刚刚讲的 BF 算法的升级版。我们对朴素的字符串匹配算法稍加改造，<strong>引入哈希算法，时间复杂度立刻就会降低</strong>。RK 算法的思路是这样的：我们通过哈希算法对主串中的 n-m+1 个子串分别求哈希值，然后逐个与模式串的哈希值比较大小。如果某个子串的哈希值与模式串相等，那就说明对应的子串和模式串匹配了。因为哈希值是一个数字，数字之间比较是否相等是非常快速的，所以模式串和子串比较的效率就提高了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/171.png" alt></p><p>不过，通过哈希算法计算子串的哈希值的时候，我们需要遍历子串中的每个字符。<strong>尽管模式串与子串比较的效率提高了，但是，算法整体的效率并没有提高</strong>。这就需要哈希算法设计的非常有技巧了。我们假设要匹配的字符串的字符集中只包含 K 个字符，我们可以用一个 K 进制数来表示一个子串，这个 K 进制数转化成十进制数，作为子串的哈希值。</p><p>在十进制的表示法中，一个数字的值是通过下面的方式计算出来的。对应到二十六进制，一个包含 a 到 z 这 26 个字符的字符串，计算哈希的时候，我们只需要把进位从 10 改成 26 就可以：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/172.png" alt></p><p>这种哈希算法有一个特点，<strong>在主串中，相邻两个子串的哈希值的计算公式有一定关系</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/173.png" alt></p><p>从这里例子中，我们很容易就能得出这样的规律：相邻两个子串 s[i-1]和 s[i]，对应的哈希值计算公式有交集，也就是说，我们可以使用 s[i-1]的哈希值很快的计算出 s[i]的哈希值。如果用公式表示的话，就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/174.png" alt></p><p>不过，这里有一个小细节需要注意，那就是 26^(m-1) 这部分的计算，我们<strong>可以通过查表的方法来提高效率</strong>。我们事先计算好 26^0, 26^1, 26^2, …, 26^(m-1)，并且存储在一个长度为 m 的数组中，公式中的“次方”就对应数组的下标。当我们需要计算 26 的 x 次方的时候，就可以从数组的下标为 x 的位置取值，直接使用，省去了计算的时间：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/175.png" alt></p><p><strong>整个 RK 算法包含两部分，计算子串哈希值和模式串哈希值与子串哈希值之间的比较</strong>。第一部分，我们前面也分析了，可以通过设计特殊的哈希算法，只需要扫描一遍主串就能计算出所有子串的哈希值了，所以这部分的时间复杂度是 O(n)。模式串哈希值与每个子串哈希值之间的比较的时间复杂度是 O(1)，总共需要比较 n-m+1 个子串的哈希值，所以，这部分的时间复杂度也是 O(n)。所以，RK 算法整体的时间复杂度就是 O(n)。</p><p>这里还有一个问题就是，模式串很长，相应的主串中的子串也会很长，通过上面的哈希算法计算得到的哈希值就可能很大，可能会超过了计算机中整型数据可以表示的范围。刚刚我们设计的哈希算法是没有散列冲突的，也就是说，一个字符串与一个二十六进制数一一对应，不同的字符串的哈希值肯定不一样。实际上，我们<strong>为了能将哈希值落在整型数据范围内，可以牺牲一下，允许哈希冲突</strong>。</p><p>假设字符串中只包含 a~z 这 26 个英文字母，那我们每个字母对应一个数字，比如 a 对应 1，b 对应 2，以此类推，z 对应 26。我们可以把字符串中每个字母对应的数字相加，最后得到的和作为哈希值。这种哈希算法产生的哈希值的数据范围就相对要小很多了。不过，你也应该发现，这种哈希算法的哈希冲突概率也是挺高的。当然，我只是举了一个最简单的设计方法，还有很多更加优化的方法，比如<strong>将每一个字母从小到大对应一个素数，而不是 1, 2, 3, …这样的自然数</strong>，这样冲突的概率就会降低一些。</p><p>但是，当存在哈希冲突的时候，有可能存在这样的情况，子串和模式串的哈希值虽然是相同的，但是两者本身并不匹配。实际上，解决方法很简单。<strong>当我们发现一个子串的哈希值跟模式串的哈希值相等的时候，我们只需要再对比一下子串和模式串本身就好了</strong>。当然，如果子串的哈希值与模式串的哈希值不相等，那对应的子串和模式串肯定也是不匹配的，就不需要比对子串和模式串本身了。</p><p>所以，哈希算法的冲突概率要相对控制得低一些，如果存在大量冲突，就会导致 RK 算法的时间复杂度退化，效率下降。极端情况下，<strong>如果存在大量的冲突，每次都要再对比子串和模式串本身，那时间复杂度就会退化成 O(n*m)</strong>。但也不要太悲观，一般情况下，冲突不会很多，RK 算法的效率还是比 BF 算法高的。</p><h2 id="BM-算法的核心思想"><a href="#BM-算法的核心思想" class="headerlink" title="BM 算法的核心思想"></a>BM 算法的核心思想</h2><p>我们把模式串和主串的匹配过程，看作模式串在主串中不停地往后滑动。当遇到不匹配的字符时，<strong>BF 算法和 RK 算法的做法是，模式串往后滑动一位</strong>，然后从模式串的第一个字符开始重新匹配：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/176.png" alt></p><p>在这个例子里，主串中的 c，在模式串中是不存在的，所以，模式串向后滑动的时候，只要 c 与模式串有重合，肯定无法匹配。所以，我们可以一次性把模式串往后多滑动几位，把模式串移动到 c 的后面：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/177.png" alt></p><p>BM（Boyer-Moore）算法本质上其实就是在寻找这种规律。借助这种规律，在模式串与主串匹配的过程中，当模式串和主串某个字符不匹配的时候，<strong>能够跳过一些肯定不会匹配的情况，将模式串往后多滑动几位</strong>。</p><h2 id="BM-算法原理分析"><a href="#BM-算法原理分析" class="headerlink" title="BM 算法原理分析"></a>BM 算法原理分析</h2><p>BM 算法包含两部分，分别是<code>坏字符规则</code>（Bad Character Rule）和<code>好后缀规则</code>（Good Suffix Rule）。我们下面依次来看，这两个规则分别都是怎么工作的。</p><h3 id="坏字符规则"><a href="#坏字符规则" class="headerlink" title="坏字符规则"></a>坏字符规则</h3><p>BM 算法的匹配顺序比较特别，它是按照模式串下标从大到小的顺序，倒着匹配的：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/178.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/179.png" alt></p><p>我们从模式串的末尾往前倒着匹配，当我们发现某个字符没法匹配的时候。我们把这个没有匹配的字符叫作<code>坏字符</code>（主串中的字符）：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/180.png" alt></p><p>我们拿坏字符 c 在模式串中查找，发现模式串中并不存在这个字符，也就是说，<strong>字符 c 与模式串中的任何字符都不可能匹配</strong>。这个时候，我们可以将模式串直接往后滑动三位，<strong>将模式串滑动到 c 后面的位置</strong>，再从模式串的末尾字符开始比较：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/181.png" alt></p><p>这个时候，我们发现，模式串中最后一个字符 d，还是无法跟主串中的 a 匹配，这个时候，还能将模式串往后滑动三位吗？答案是不行的。因为这个时候，<strong>坏字符 a 在模式串中是存在的</strong>，模式串中下标是 0 的位置也是字符 a。这种情况下，我们可以<strong>将模式串往后滑动两位，让两个 a 上下对齐</strong>，然后再从模式串的末尾字符开始，重新匹配：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/182.png" alt></p><p>当发生不匹配的时候，我们把坏字符对应的模式串中的字符下标记作 si。如果坏字符在模式串中存在，我们把这个坏字符在模式串中的下标记作 xi；<strong>如果不存在，我们把 xi 记作 -1</strong>。那模式串往后移动的位数就等于 si-xi（注意，这里说的下标，都是字符在模式串的下标）：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/183.png" alt></p><p>这里我要特别说明一点，如果坏字符在模式串里多处出现，那我们在计算 xi 的时候，<strong>选择最靠后的那个，因为这样不会让模式串滑动过多</strong>，导致本来可能匹配的情况被滑动略过。利用坏字符规则，<strong>BM 算法在最好情况下的时间复杂度非常低，是 O(n/m)</strong>。比如，主串是 aaabaaabaaabaaab，模式串是 aaaa。每次比对，模式串都可以直接后移四位，所以，匹配具有类似特点的模式串和主串的时候，BM 算法非常高效。</p><p>不过，单纯使用坏字符规则还是不够的。因为<strong>根据 si-xi 计算出来的移动位数，有可能是负数</strong>，比如主串是 aaaaaaaaaaaaaaaa，模式串是 baaa。不但不会向后滑动模式串，还有可能倒退。</p><h3 id="好后缀规则"><a href="#好后缀规则" class="headerlink" title="好后缀规则"></a>好后缀规则</h3><p>好后缀规则实际上跟坏字符规则的思路很类似。你看我下面这幅图。当模式串滑动到图中的位置的时候，模式串和主串有 2 个字符是匹配的，倒数第 3 个字符发生了不匹配的情况：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/184.png" alt></p><p>我们把已经匹配的 bc 叫作好后缀，记作 {u}。我们拿它在模式串中查找，如果找到了另一个跟 {u} 相匹配的子串 {u*}，那我们就<strong>将模式串滑动到子串 {u*} 与主串中 {u} 对齐的位置</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/185.png" alt></p><p>如果在模式串中找不到另一个等于 {u} 的子串，我们就<strong>直接将模式串滑动到主串中 {u} 的后面</strong>，因为之前的任何一次往后滑动，都没有匹配主串中 {u} 的情况：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/186.png" alt></p><p>不过，当模式串中不存在等于 {u} 的子串时，我们直接将模式串滑动到主串 {u} 的后面。这样做是否有点太过头呢？我们来看下面这个例子。这里面 bc 是好后缀，尽管在模式串中没有另外一个相匹配的子串 {u*}，但是如果我们将模式串移动到好后缀的后面，如图所示，那就会错过模式串和主串可以匹配的情况：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/187.png" alt></p><p><strong>当模式串滑动到前缀与主串中 {u} 的后缀有部分重合的时候</strong>，并且重合的部分相等的时候，就有可能会存在完全匹配的情况：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/188.png" alt></p><p>所以，针对这种情况，我们不仅要看好后缀在模式串中，是否有另一个匹配的子串，我们<strong>还要考察好后缀的后缀子串，是否存在跟模式串的前缀子串匹配的</strong>。我们从好后缀的后缀子串中，找一个最长的并且能跟模式串的前缀子串匹配的，假设是 {v}，然后将模式串滑动到如图所示的位置：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/189.png" alt></p><p>我们可以<strong>分别计算好后缀和坏字符往后滑动的位数，然后取两个数中最大的</strong>，作为模式串往后滑动的位数。这种处理方法还可以避免我们前面提到的，根据坏字符规则，计算得到的往后滑动的位数，有可能是负数的情况。</p><h2 id="BM-算法代码实现"><a href="#BM-算法代码实现" class="headerlink" title="BM 算法代码实现"></a>BM 算法代码实现</h2><p>如果我们拿坏字符，在模式串中顺序遍历查找，这样就会比较低效，势必影响这个算法的性能。我们<strong>可以将模式串中的每个字符及其下标都存到散列表中，这样就可以快速找到坏字符在模式串的位置下标了</strong>。关于这个散列表，我们只实现一种最简单的情况，假设字符串的字符集不是很大，每个字符长度是 1 字节，我们用大小为 256 的数组，来记录每个字符在模式串中出现的位置。数组的下标对应字符的 ASCII 码值，数组中存储这个字符在模式串中出现的位置：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/190.png" alt></p><p>如果将上面的过程翻译成代码，就是下面这个样子。其中，变量 b 是模式串，m 是模式串的长度，bc 表示刚刚讲的散列表：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">256</span>; <span class="comment">// 全局变量或成员变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateBC</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] bc)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; SIZE; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        bc[i] = -<span class="number">1</span>; <span class="comment">// 初始化 bc</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ascii = (<span class="keyword">int</span>)b[i]; <span class="comment">// 计算 b[i] 的 ASCII 值</span></span><br><span class="line">        bc[ascii] = i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>掌握了坏字符规则之后，我们先把 BM 算法代码的大框架写好，先不考虑好后缀规则，仅用坏字符规则，并且不考虑 si-xi 计算得到的移动位数可能会出现负数的情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    generateBC(b, m, bc);     <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;                <span class="comment">// i 表示主串与模式串对齐的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">            <span class="keyword">if</span> (a[i+j] != b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是 j</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这里等同于将模式串往后滑动 j-bc[(int)a[i+j]] 位</span></span><br><span class="line">        i = i + (j - bc[(<span class="keyword">int</span>)a[i+j]]); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我画了一张图，将其中的一些关键变量标注在上面了，结合着图，代码应该更好理解：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/191.png" alt></p><p>好后缀的处理规则中最核心的内容：</p><ul><li>在模式串中，查找跟好后缀匹配的另一个子串；</li><li>在好后缀的后缀子串中，查找最长的、能跟模式串前缀子串匹配的后缀子串；</li></ul><p>因为好后缀也是模式串本身的后缀子串，所以，我们可以在模式串和主串正式匹配之前，通过<strong>预处理模式串，预先计算好模式串的每个后缀子串，对应的另一个可匹配子串的位置</strong>。因为后缀子串的最后一个字符的位置是固定的，下标为 m-1，我们只需要记录长度就可以了。通过长度，我们可以确定一个唯一的后缀子串：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/192.png" alt></p><p>suffix 数组的下标 k，表示后缀子串的长度。下标对应的数组值存储的是，<strong>在模式串中跟好后缀 {u} 相匹配的子串 {u*} 的起始下标值</strong>。这句话不好理解，我举一个例子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/193.png" alt></p><p>如果我们只记录刚刚定义的 suffix，实际上，只能处理规则的前半部分，也就是，在模式串中，查找跟好后缀匹配的另一个子串。所以，除了 suffix 数组之外，我们还需要另外一个 boolean 类型的 prefix 数组，来<strong>记录模式串的后缀子串是否能匹配模式串的前缀子串</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/194.png" alt></p><p>我们拿下标从 0 到 i 的子串（i 可以是 0 到 m-2）与整个模式串，求公共后缀子串。如果公共后缀子串的长度是 k，那我们就记录 suffix[k]=j。<strong>如果 j 等于 0，也就是说，公共后缀子串也是模式串的前缀子串</strong>，我们就记录 prefix[k]=true：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/195.png" alt></p><p>我们把 suffix 数组和 prefix 数组的计算过程，用代码实现出来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b 表示模式串，m 表示长度，suffix、prefix 数组事先申请好了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateGS</span><span class="params">(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 初始化</span></span><br><span class="line">        suffix[i] = -<span class="number">1</span>;</span><br><span class="line">        prefix[i] = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m - <span class="number">1</span>; ++i) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// b[0, i]</span></span><br><span class="line">        <span class="keyword">int</span> j = i;</span><br><span class="line">        <span class="keyword">int</span> k = <span class="number">0</span>; <span class="comment">// 公共后缀子串长度</span></span><br><span class="line">        <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; b[j] == b[m-<span class="number">1</span>-k]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 与 b[0, m-1] 求公共后缀子串</span></span><br><span class="line">            --j;</span><br><span class="line">            ++k;</span><br><span class="line">            suffix[k] = j+<span class="number">1</span>; <span class="comment">// j+1 表示公共后缀子串在 b[0, i] 中的起始下标</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == -<span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            prefix[k] = <span class="keyword">true</span>; <span class="comment">// 如果公共后缀子串也是模式串的前缀子串</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设好后缀的长度是 k。我们先拿好后缀，在 suffix 数组中查找其匹配的子串。如果 suffix[k]不等于 -1，那我们就将模式串往后移动 j-suffix[k]+1 位：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/196.png" alt></p><p>好后缀的后缀子串 b[r, m-1] 的长度 k=m-r，如果 prefix[k]等于 true，表示长度为 k 的后缀子串，有可匹配的前缀子串，这样我们可以把模式串后移 r 位：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/197.png" alt></p><p>如果两条规则都没有找到可以匹配好后缀及其后缀子串的子串，我们就将整个模式串后移 m 位：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/198.png" alt></p><p>我们把好后缀规则加到前面的代码框架里，就可以得到 BM 算法的完整版代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b 表示主串和模式串；n, m 表示主串和模式串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bm</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] bc = <span class="keyword">new</span> <span class="keyword">int</span>[SIZE]; <span class="comment">// 记录模式串中每个字符最后出现的位置</span></span><br><span class="line">    generateBC(b, m, bc);     <span class="comment">// 构建坏字符哈希表</span></span><br><span class="line">    <span class="keyword">int</span>[] suffix = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    <span class="keyword">boolean</span>[] prefix = <span class="keyword">new</span> <span class="keyword">boolean</span>[m];</span><br><span class="line">    generateGS(b, m, suffix, prefix);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>; <span class="comment">// j 表示主串与模式串匹配的第一个字符</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt;= n - m) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="keyword">for</span> (j = m - <span class="number">1</span>; j &gt;= <span class="number">0</span>; --j) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 模式串从后往前匹配</span></span><br><span class="line">            <span class="keyword">if</span> (a[i+j] != b[j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>; <span class="comment">// 坏字符对应模式串中的下标是 j</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i; <span class="comment">// 匹配成功，返回主串与模式串第一个匹配的字符的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> x = j - bc[(<span class="keyword">int</span>)a[i+j]];</span><br><span class="line">        <span class="keyword">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (j &lt; m-<span class="number">1</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 如果有好后缀的话</span></span><br><span class="line">            y = moveByGS(j, m, suffix, prefix);</span><br><span class="line">        &#125;</span><br><span class="line">        i = i + Math.max(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// j 表示坏字符对应的模式串中的字符下标；m 表示模式串长度</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">moveByGS</span><span class="params">(<span class="keyword">int</span> j, <span class="keyword">int</span> m, <span class="keyword">int</span>[] suffix, <span class="keyword">boolean</span>[] prefix)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> k = m - <span class="number">1</span> - j; <span class="comment">// 好后缀长度</span></span><br><span class="line">    <span class="keyword">if</span> (suffix[k] != -<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> j - suffix[k] +<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> r = j+<span class="number">2</span>; r &lt;= m-<span class="number">1</span>; ++r) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (prefix[m-r] == <span class="keyword">true</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="BM-算法的性能分析及优化"><a href="#BM-算法的性能分析及优化" class="headerlink" title="BM 算法的性能分析及优化"></a>BM 算法的性能分析及优化</h2><p>整个算法用到了额外的 3 个数组，其中 bc 数组的大小跟字符集大小有关，suffix 数组和 prefix 数组的大小跟模式串长度 m 有关。如果我们处理字符集很大的字符串匹配问题，bc 数组对内存的消耗就会比较多。因为好后缀和坏字符规则是独立的，如果我们运行的环境对内存要求苛刻，可以<strong>只使用好后缀规则，不使用坏字符规则，这样就可以避免 bc 数组过多的内存消耗</strong>。不过，单纯使用好后缀规则的 BM 算法效率就会下降一些了。</p><p>基于我目前这个初级版本，在极端情况下，预处理计算 suffix 数组、prefix 数组的性能会比较差。比如<strong>模式串是 aaaaaaa 这种包含很多重复的字符的模式串，预处理的时间复杂度就是 O(m^2)</strong>。当然，大部分情况下，时间复杂度不会这么差。</p><h2 id="KMP-算法基本原理"><a href="#KMP-算法基本原理" class="headerlink" title="KMP 算法基本原理"></a>KMP 算法基本原理</h2><p>KMP 算法是根据三位作者（D.E.Knuth, J.H.Morris, V.R.Pratt）的名字来命名的，它的核心思想和 BM 算法非常相近。我们假设主串是 a，模式串是 b。在模式串与主串匹配的过程中，<strong>当遇到不可匹配的字符的时候，我们希望找到一些规律，可以将模式串往后多滑动几位，跳过那些肯定不会匹配的情况</strong>。在模式串和主串匹配的过程中，把不能匹配的那个字符仍然叫作<code>坏字符</code>，把已经匹配的那段字符串叫作<code>好前缀</code>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/199.png" alt></p><p>当遇到坏字符的时候，我们就要把模式串往后滑动，在滑动的过程中，只要模式串和好前缀有上下重合，前面几个字符的比较，就<strong>相当于拿好前缀的后缀子串，跟模式串的前缀子串在比较</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/200.png" alt></p><p>我们<strong>只需要拿好前缀本身，在它的后缀子串中，查找最长的那个可以跟好前缀的前缀子串匹配的</strong>。假设最长的可匹配的那部分前缀子串是 {v}，长度是 k。我们把模式串一次性往后滑动 j-k 位，相当于，每次遇到坏字符的时候，我们就把 j 更新为 k；i 不变，然后继续比较：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/201.png" alt></p><p>为了表述起来方便，我把好前缀的所有后缀子串中，最长的可匹配前缀子串的那个后缀子串，叫作<strong>最长可匹配后缀子串</strong>；对应的前缀子串，叫作<strong>最长可匹配前缀子串</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/202.png" alt></p><p>KMP 算法也可以提前构建一个数组，用来存储模式串中每个前缀（这些前缀都有可能是好前缀）的最长可匹配前缀子串的结尾字符下标。我们把这个数组定义为 <code>next 数组</code>。<strong>数组的下标是每个前缀结尾字符下标，数组的值是这个前缀的最长可以匹配前缀子串的结尾字符下标</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/203.png" alt></p><p>有了 next 数组，我们很容易就可以实现 KMP 算法了，先给出 KMP 算法的框架代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a, b 分别是主串和模式串；n, m 分别是主串和模式串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = getNexts(b, m);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 一直找到 a[i] 和 b[j]</span></span><br><span class="line">            j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="失效函数计算方法"><a href="#失效函数计算方法" class="headerlink" title="失效函数计算方法"></a>失效函数计算方法</h2><p>当然，我们可以用非常笨的方法，比如要计算下面这个模式串 b 的 next[4]，我们就<strong>把 b[0, 4]的所有后缀子串，从长到短找出来，依次看看，是否能跟模式串的前缀子串匹配</strong>。很显然，这个方法也可以计算得到 next 数组，但是效率非常低：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/204.png" alt></p><p>如果 next[i-1]=k-1，也就是说，子串 b[0, k-1] 是 b[0, i-1] 的最长可匹配前缀子串。如果子串 b[0, k-1] 的下一个字符 b[k]，与 b[0, i-1] 的下一个字符 b[i] 匹配，那子串 b[0, k] 就是 b[0, i] 的最长可匹配前缀子串。所以，next[i] 等于 k：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/205.png" alt></p><p>我们假设 b[0, i] 的最长可匹配后缀子串是 b[r, i]。如果我们把最后一个字符去掉，那 b[r, i-1] 肯定是 b[0, i-1] 的可匹配后缀子串，但不一定是最长可匹配后缀子串。所以，既然 b[0, i-1] 最长可匹配后缀子串对应的模式串的前缀子串的下一个字符并不等于 b[i]，那么我们就可以考察 b[0, i-1] 的次长可匹配后缀子串 b[x, i-1] 对应的可匹配前缀子串 b[0, i-1-x] 的下一个字符 b[i-x] 是否等于 b[i]。如果等于，那 b[x, i] 就是 b[0, i] 的最长可匹配后缀子串：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/206.png" alt></p><p>次长可匹配后缀子串肯定被包含在最长可匹配后缀子串中，而最长可匹配后缀子串又对应最长可匹配前缀子串 b[0, y]。于是，查找 b[0, i-1] 的次长可匹配后缀子串，这个问题就变成，查找 b[0, y] 的最长匹配后缀子串的问题了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/207.png" alt></p><p>按照这个思路，我们可以考察完所有的 b[0, i-1] 的可匹配后缀子串 b[y, i-1]，直到找到一个可匹配的后缀子串，它对应的前缀子串的下一个字符等于 b[i]，那这个 b[y, i] 就是 b[0, i] 的最长可匹配后缀子串。失效函数的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// b 表示模式串，m 表示模式串的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNexts(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k != -<span class="number">1</span> &amp;&amp; b[k + <span class="number">1</span>] != b[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b[k + <span class="number">1</span>] == b[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="KMP-算法复杂度分析"><a href="#KMP-算法复杂度分析" class="headerlink" title="KMP 算法复杂度分析"></a>KMP 算法复杂度分析</h2><p>KMP 算法包含两部分：</p><ol><li>构建 next 数组：<br>我们可以找一些参照变量，i 和 k。i 从 1 开始一直增加到 m，而 k 并不是每次 for 循环都会增加，所以，k 累积增加的值肯定小于 m。而 while 循环里 k=next[k]，实际上是在减小 k 的值，k 累积都没有增加超过 m，所以 while 循环里面 k=next[k] 总的执行次数也不可能超过 m。因此，next 数组计算的时间复杂度是 O(m)；</li><li>借助 next 数组匹配：<br>i 从 0 循环增长到 n-1，j 的增长量不可能超过 i，所以肯定小于 n。而 while 循环中的那条语句 j=next[j-1]+1，不会让 j 增长的，那有没有可能让 j 不变呢？也没有可能。因为 next[j-1] 的值肯定小于 j-1，所以 while 循环中的这条语句实际上也是在让 j 的值减少。而 j 总共增长的量都不会超过 n，那减少的量也不可能超过 n，所以 while 循环中的这条语句总的执行次数也不会超过 n，所以这部分的时间复杂度是 O(n)；</li></ol><p>所以，综合两部分的时间复杂度，<strong>KMP 算法的时间复杂度就是 O(m+n)</strong>。空间复杂度很容易分析，KMP 算法只需要一个额外的 next 数组，数组的大小跟模式串相同。所以<strong>空间复杂度是 O(m)</strong>，m 表示模式串的长度。</p><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/reverse-string/" target="_blank" rel="noopener">Reverse String</a><br><a href="https://leetcode.com/problems/reverse-words-in-a-string/" target="_blank" rel="noopener">Reverse Words in a String</a><br><a href="https://leetcode.com/problems/string-to-integer-atoi/" target="_blank" rel="noopener">String to Integer (atoi)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>广度和深度优先搜索</title>
      <link href="2021/01/09/%E5%B9%BF%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"/>
      <url>2021/01/09/%E5%B9%BF%E5%BA%A6%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是“搜索”算法？"><a href="#什么是“搜索”算法？" class="headerlink" title="什么是“搜索”算法？"></a>什么是“搜索”算法？</h2><p>我们知道，算法是作用于具体数据结构之上的，广度优先搜索算法和深度优先搜索算法都是基于“图”这种数据结构的。这是因为，<strong>图这种数据结构的表达能力很强，大部分涉及搜索的场景都可以抽象成图</strong>。图上的搜索算法，最直接的理解就是，在图中找出从一个顶点出发，到另一个顶点的路径。具体方法有很多，比如下面的两种最简单、最“暴力”的广度优先、深度优先搜索，还有 A*、IDA* 等启发式搜索算法。</p><p>我这里先给出图的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Graph</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 无向图</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> v;                     <span class="comment">// 顶点的个数</span></span><br><span class="line">    <span class="keyword">private</span> LinkedList&lt;Integer&gt; adj[]; <span class="comment">// 邻接表</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Graph</span><span class="params">(<span class="keyword">int</span> v)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.v = v;</span><br><span class="line">        adj = <span class="keyword">new</span> LinkedList[v];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;v; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            adj[i] = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addEdge</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// 无向图一条边存两次</span></span><br><span class="line">        adj[s].add(t);</span><br><span class="line">        adj[t].add(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h2><p>广度优先搜索（Breadth-First Search），我们平常都简称 BFS。直观地讲，它其实就是一种“地毯式”层层推进的搜索策略，即先查找离起始顶点最近的，然后是次近的，依次往外搜索。理解起来并不难，所以我画了一张示意图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/165.png" alt></p><p>尽管广度优先搜索的原理挺简单，但代码实现还是稍微有点复杂度。这里面，bfs() 函数就是基于之前定义的，图的广度优先搜索的代码实现。其中 s 表示起始顶点，t 表示终止顶点，我们搜索一条从 s 到 t 的路径。实际上，<strong>这样求得的路径就是从 s 到 t 的最短路径</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    visited[s] = <span class="keyword">true</span>;</span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    queue.add(s);</span><br><span class="line">    <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        prev[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (queue.size() != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w = queue.poll();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">            <span class="keyword">if</span> (!visited[q]) </span><br><span class="line">            &#123;</span><br><span class="line">                prev[q] = w;</span><br><span class="line">                <span class="keyword">if</span> (q == t) </span><br><span class="line">                &#123;</span><br><span class="line">                    print(prev, s, t);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                visited[q] = <span class="keyword">true</span>;</span><br><span class="line">                queue.add(q);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">int</span>[] prev, <span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 递归打印 s-&gt;t 的路径</span></span><br><span class="line">    <span class="keyword">if</span> (prev[t] != -<span class="number">1</span> &amp;&amp; t != s) </span><br><span class="line">    &#123;</span><br><span class="line">        print(prev, s, prev[t]);</span><br><span class="line">    &#125;</span><br><span class="line">    System.out.print(t + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码不是很好理解，里面有三个重要的辅助变量 visited、queue、prev：</p><ul><li><strong>visited</strong>：用来记录已经被访问的顶点，<strong>避免顶点被重复访问</strong>。如果顶点 q 被访问，那相应的 visited[q]会被设置为 true；</li><li><strong>queue</strong>：用来<strong>存储已经被访问、但相连的顶点还没有被访问的顶点</strong>。因为广度优先搜索是逐层访问的，也就是说，我们只有把第 k 层的顶点都访问完成之后，才能访问第 k+1 层的顶点。当我们访问到第 k 层的顶点的时候，我们需要把第 k 层的顶点记录下来，稍后才能通过第 k 层的顶点来找第 k+1 层的顶点。所以，我们用这个队列来实现记录的功能；</li><li><strong>prev</strong>：用来记录搜索路径。当我们从顶点 s 开始，广度优先搜索到顶点 t 后，prev 数组中存储的就是搜索的路径。不过，这个<strong>路径是反向存储的</strong>。prev[w]存储的是，顶点 w 是从哪个前驱顶点遍历过来的。比如，我们通过顶点 2 的邻接表访问到顶点 3，那 prev[3]就等于 2；</li></ul><p>为了方便你理解，我画了一个广度优先搜索的分解图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/166.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/167.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/168.png" alt></p><p>最坏情况下，终止顶点 t 离起始顶点 s 很远，需要遍历完整个图才能找到。这个时候，每个顶点都要进出一遍队列，每个边也都会被访问一次，所以，广度优先搜索的时间复杂度是 O(V+E)，其中，V 表示顶点的个数，E 表示边的个数。当然，对于一个连通图来说，也就是说一个图中的所有顶点都是连通的，E 肯定要大于等于 V-1，所以，<strong>广度优先搜索的时间复杂度也可以简写为 O(E)</strong>。广度优先搜索的空间消耗主要在几个辅助变量 visited 数组、queue 队列、prev 数组上。这<strong>三个存储空间的大小都不会超过顶点的个数，所以空间复杂度是 O(V)</strong>。</p><h2 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h2><p>深度优先搜索（Depth-First Search），简称 DFS。最直观的例子就是“走迷宫”。假设你站在迷宫的某个岔路口，然后想找到出口。你随意选择一个岔路口来走，走着走着发现走不通的时候，你就回退到上一个岔路口，重新选择一条路继续走，直到最终找到出口。这种走法就是一种深度优先搜索策略。</p><p>你可以看我画的这幅图。搜索的起始顶点是 s，终止顶点是 t，我们希望在图中寻找一条从顶点 s 到顶点 t 的路径。如果映射到迷宫那个例子，s 就是你起始所在的位置，t 就是出口。我用深度递归算法，把整个搜索的路径标记出来了。这里面实线箭头表示遍历，虚线箭头表示回退。从图中我们可以看出，<strong>深度优先搜索找出来的路径，并不是顶点 s 到顶点 t 的最短路径</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/169.png" alt></p><p>实际上，深度优先搜索用的是一种比较著名的算法思想，回溯思想。这种思想解决问题的过程，非常适合用递归来实现。深度优先搜索代码实现里，有个比较特殊的变量 found，它的作用是，<strong>当我们已经找到终止顶点 t 之后，我们就不再递归地继续查找了</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> found = <span class="keyword">false</span>; <span class="comment">// 全局变量或者类成员变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> s, <span class="keyword">int</span> t)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    found = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span>[] visited = <span class="keyword">new</span> <span class="keyword">boolean</span>[v];</span><br><span class="line">    <span class="keyword">int</span>[] prev = <span class="keyword">new</span> <span class="keyword">int</span>[v];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        prev[i] = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    recurDfs(s, t, visited, prev);</span><br><span class="line">    print(prev, s, t);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">recurDfs</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> t, <span class="keyword">boolean</span>[] visited, <span class="keyword">int</span>[] prev)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (found == <span class="keyword">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[w] = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (w == t) </span><br><span class="line">    &#123;</span><br><span class="line">        found = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adj[w].size(); ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> q = adj[w].get(i);</span><br><span class="line">        <span class="keyword">if</span> (!visited[q]) </span><br><span class="line">        &#123;</span><br><span class="line">            prev[q] = w;</span><br><span class="line">            recurDfs(q, t, visited, prev);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从我前面画的图可以看出，每条边最多会被访问两次，一次是遍历，一次是回退。所以，图上的<strong>深度优先搜索算法的时间复杂度是 O(E)</strong>，E 表示边的个数。深度优先搜索算法的消耗内存主要是 visited、prev 数组和递归调用栈。visited、prev 数组的大小跟顶点的个数 V 成正比，<strong>递归调用栈的最大深度不会超过顶点的个数，所以总的空间复杂度就是 O(V)</strong>。</p><h2 id="如何找出社交网络中的三度好友关系"><a href="#如何找出社交网络中的三度好友关系" class="headerlink" title="如何找出社交网络中的三度好友关系"></a>如何找出社交网络中的三度好友关系</h2><p>这个问题就非常适合用图的广度优先搜索算法来解决，因为广度优先搜索是层层往外推进的。首先，遍历与起始顶点最近的一层顶点，也就是用户的一度好友，然后再遍历与用户距离的边数为 2 的顶点，也就是二度好友关系，以及与用户距离的边数为 3 的顶点，也就是三度好友关系。我们只需要稍加改造一下广度优先搜索代码，<strong>用一个数组来记录每个顶点与起始顶点的距离，非常容易就可以找出三度好友关系</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图的表示</title>
      <link href="2021/01/09/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA/"/>
      <url>2021/01/09/%E5%9B%BE%E7%9A%84%E8%A1%A8%E7%A4%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解“图”？"><a href="#如何理解“图”？" class="headerlink" title="如何理解“图”？"></a>如何理解“图”？</h2><p><code>图</code>（Graph）和树比起来，这是一种更加复杂的非线性表结构。我们知道，树中的元素我们称为节点，图中的元素我们就叫做<code>顶点</code>（Vertex）。从我画的图中可以看出来，图中的一个顶点可以与任意其他顶点建立连接关系。我们把这种建立的关系叫做<code>边</code>（Edge）：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/157.png" alt></p><p>我们生活中就有很多符合图这种结构的例子。比如，社交网络就是一个非常典型的图结构。我们就拿微信举例子吧。我们可以把每个用户看作一个顶点。如果两个用户之间互加好友，那就在两者之间建立一条边。所以，整个微信的好友关系就可以用一张图来表示。其中，每个用户有多少个好友，对应到图中，就叫做顶点的<code>度</code>（Degree），就是跟顶点相连接的边的条数。</p><p>实际上，微博的社交关系跟微信还有点不一样，或者说更加复杂一点。微博允许单向关注，如果用户 A 关注了用户 B，我们就在图中画一条从 A 到 B 的带箭头的边，来表示边的方向。如果用户 A 和用户 B 互相关注了，那我们就画一条从 A 指向 B 的边，再画一条从 B 指向 A 的边。我们把这种边有方向的图叫做<code>有向图</code>。以此类推，我们把边没有方向的图就叫做<code>无向图</code>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/158.png" alt></p><p>无向图中有“度”这个概念，表示一个顶点有多少条边。在有向图中，我们把度分为<code>入度</code>（In-degree）和<code>出度</code>（Out-degree）。顶点的入度，表示有多少条边指向这个顶点；顶点的出度，表示有多少条边是以这个顶点为起点指向其他顶点。对应到微博的例子，入度就表示有多少粉丝，出度就表示关注了多少人。</p><a id="more"></a><p>QQ 中的社交关系要更复杂一点。不知道你有没有留意过 QQ 亲密度这样一个功能。QQ 不仅记录了用户之间的好友关系，还记录了两个用户之间的亲密度，如果两个用户经常往来，那亲密度就比较高；如果不经常往来，亲密度就比较低。这里就要用到另一种图，<code>带权图</code>（Weighted Graph）。在带权图中，每条边都有一个<code>权重</code>（Weight），我们可以通过这个权重来表示 QQ 好友间的亲密度：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/159.png" alt></p><h2 id="邻接矩阵存储方法"><a href="#邻接矩阵存储方法" class="headerlink" title="邻接矩阵存储方法"></a>邻接矩阵存储方法</h2><p><code>邻接矩阵</code>（Adjacency Matrix）的底层依赖一个二维数组。对于无向图来说，如果顶点 i 与顶点 j 之间有边，我们就将 A[i][j]和 A[j][i]标记为 1；对于有向图来说，如果顶点 i 到顶点 j 之间，有一条箭头从顶点 i 指向顶点 j 的边，那我们就将 A[i][j]标记为 1。同理，如果有一条箭头从顶点 j 指向顶点 i 的边，我们就将 A[j][i]标记为 1。<strong>对于带权图，数组中就存储相应的权重</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/160.png" alt></p><p>对于无向图来说，如果 A[i][j]等于 1，那 A[j][i]也肯定等于 1。实际上，我们只需要存储一个就可以了。也就是说，无向图的二维数组中，如果我们将其用对角线划分为上下两部分，那我们<strong>只需要利用上面或者下面这样一半的空间就足够了，另外一半白白浪费掉了</strong>。还有，如果我们存储的是<code>稀疏图</code>（Sparse Matrix），也就是说，顶点很多，但每个顶点的边并不多，那<strong>邻接矩阵的存储方法就更加浪费空间</strong>了。</p><p>但这也并不是说，邻接矩阵的存储方法就完全没有优点。首先，邻接矩阵的存储方式简单、直接，因为基于数组，所以<strong>在获取两个顶点的关系时，就非常高效</strong>。其次，用邻接矩阵存储图的另外一个好处是方便计算。这是因为，用邻接矩阵的方式存储图，<strong>可以将很多图的运算转换成矩阵之间的运算</strong>。</p><h2 id="邻接表存储方法"><a href="#邻接表存储方法" class="headerlink" title="邻接表存储方法"></a>邻接表存储方法</h2><p>我画了一张<code>邻接表</code>（Adjacency List）的图，<strong>每个顶点对应一条链表，链表中存储的是与这个顶点相连接的其他顶点</strong>。另外我需要说明一下，图中画的是一个有向图的邻接表存储方式，每个顶点对应的链表里面，存储的是指向的顶点：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/161.png" alt></p><p>邻接矩阵存储起来比较浪费空间，但是使用起来比较节省时间。相反，邻接表存储起来比较节省空间，但是使用起来就比较耗时间。如果我们要确定，是否存在一条从顶点 2 到顶点 4 的边，那我们就要遍历顶点 2 对应的那条链表，看链表中是否存在顶点 4。而且，<strong>链表的存储方式对缓存不友好</strong>。所以，比起邻接矩阵的存储方式，在邻接表中查询两个顶点之间的关系就没那么高效了。</p><p>我们<strong>可以将邻接表中的链表改成平衡二叉查找树</strong>。实际开发中，我们可以选择用红黑树。这样，我们就可以更加快速地查找两个顶点之间是否存在边了。当然，这里的二叉查找树可以换成其他动态数据结构，比如跳表、散列表等。除此之外，我们<strong>还可以将链表改成有序动态数组</strong>，通过二分查找的方法来快速定位两个顶点之间否是存在边。</p><h2 id="如何存储社交网络中的好友关系"><a href="#如何存储社交网络中的好友关系" class="headerlink" title="如何存储社交网络中的好友关系"></a>如何存储社交网络中的好友关系</h2><p>数据结构是为算法服务的，所以<strong>具体选择哪种存储方法，与期望支持的操作有关系</strong>。针对微博用户关系，假设我们需要支持下面这样几个操作：</p><ul><li>判断用户 A 是否关注了用户 B；</li><li>判断用户 A 是否是用户 B 的粉丝；</li><li>用户 A 关注用户 B；</li><li>用户 A 取消关注用户 B；</li><li>根据用户名称的首字母排序，分页获取用户的粉丝列表；</li><li>根据用户名称的首字母排序，分页获取用户的关注列表；</li></ul><p>因为社交网络是一张稀疏图，使用邻接矩阵存储比较浪费存储空间。所以，这里我们采用邻接表来存储。不过，用一个邻接表来存储这种有向图是不够的。我们去查找某个用户关注了哪些用户非常容易，但是如果要想知道某个用户都被哪些用户关注了，也就是用户的粉丝列表，是非常困难的。基于此，我们需要一个逆邻接表。<strong>邻接表中存储了用户的关注关系，逆邻接表中存储的是用户的被关注关系</strong>。</p><p>对应到图上，邻接表中，每个顶点的链表中，存储的就是这个顶点指向的顶点，逆邻接表中，每个顶点的链表中，存储的是指向这个顶点的顶点。如果要查找某个用户关注了哪些用户，我们可以在邻接表中查找；如果要查找某个用户被哪些用户关注了，我们从逆邻接表中查找：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/162.png" alt></p><p>基础的邻接表不适合快速判断两个用户之间是否是关注与被关注的关系，所以我们选择改进版本，<strong>将邻接表中的链表改为支持快速查找的动态数据结构</strong>。因为我们需要按照用户名称的首字母排序，分页来获取用户的粉丝列表或者关注列表，用跳表这种结构再合适不过了。这是因为，跳表插入、删除、查找都非常高效，时间复杂度是 O(logn)，空间复杂度上稍高，是 O(n)。最重要的一点，<strong>跳表中存储的数据本来就是有序的了，分页获取粉丝列表或关注列表，就非常高效</strong>。</p><p>如果对于小规模的数据，比如社交网络中只有几万、几十万个用户，我们可以将整个社交关系存储在内存中，上面的解决思路是没有问题的。但是如果像微博那样有上亿的用户，数据规模太大，我们就无法全部存储在内存中了。我们可以<strong>通过哈希算法等数据分片方式，将邻接表存储在不同的机器上</strong>。你可以看下面这幅图，我们在机器 1 上存储顶点 1, 2, 3 的邻接表，在机器 2 上，存储顶点 4, 5 的邻接表。逆邻接表的处理方式也一样。当要查询顶点与顶点关系的时候，我们就利用同样的哈希算法，先定位顶点所在的机器，然后再在相应的机器上查找：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/163.png" alt></p><p>除此之外，我们还有另外一种解决思路，就是利用外部存储（比如硬盘），因为<strong>外部存储的存储空间要比内存会宽裕很多</strong>。数据库是我们经常用来持久化存储关系数据的，我用下面这张表来存储这样一个图。<strong>为了高效地支持前面定义的操作，我们可以在表上建立多个索引</strong>，比如第一列、第二列，给这两列都建立索引：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/164.png" alt></p><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/number-of-islands/description/" target="_blank" rel="noopener">Number of Islands</a><br><a href="https://leetcode.com/problems/valid-sudoku/" target="_blank" rel="noopener">Valid Sudoku</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆的应用</title>
      <link href="2021/01/07/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/"/>
      <url>2021/01/07/%E5%A0%86%E7%9A%84%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="堆的应用一：优先级队列"><a href="#堆的应用一：优先级队列" class="headerlink" title="堆的应用一：优先级队列"></a>堆的应用一：优先级队列</h2><p>优先级队列，顾名思义，它首先应该是一个队列。不过，在优先级队列中，数据的出队顺序不是先进先出，而是按照优先级来，<strong>优先级最高的，最先出队</strong>。一个堆就可以看作一个优先级队列，很多时候，它们只是概念上的区分而已。往优先级队列中插入一个元素，就相当于往堆中插入一个元素；从优先级队列中取出优先级最高的元素，就相当于取出堆顶元素。</p><p>优先级队列的应用场景非常多。比如，赫夫曼编码、图的最短路径、最小生成树算法等等。不仅如此，很多语言中，都提供了优先级队列的实现，比如，Java 的 PriorityQueue，C++ 的 priority_queue 等。只讲这些应用场景比较空泛，现在，我举两个具体的例子：</p><ol><li>合并有序小文件：<br>假设我们有 100 个小文件，每个文件的大小是 100MB，每个文件中存储的都是有序的字符串。我们希望将这些 100 个小文件合并成一个有序的大文件。我们用数组这种数据结构，来存储从小文件中取出来的字符串。<strong>每次从数组中取最小字符串，都需要循环遍历整个数组</strong>，显然，这不是很高效。<br>这里就可以用到优先级队列，也可以说是堆。我们将从小文件中取出来的字符串放入到小顶堆中，那堆顶的元素，也就是优先级队列队首的元素，就是最小的字符串。我们将这个字符串放入到大文件中，并将其从堆中删除。然后再从小文件中取出下一个字符串，放入到堆中。循环这个过程，就可以将 100 个小文件中的数据依次放入到大文件中。我们知道，删除堆顶数据和往堆中插入数据的时间复杂度都是 O(logn)，n 表示堆中的数据个数，这里就是 100，比原来数组存储的方式高效了很多；</li></ol><a id="more"></a><ol start="2"><li>高性能定时器：<br>假设我们有一个定时器，定时器中维护了很多定时任务，每个任务都设定了一个要触发执行的时间点。定时器每过一个很小的单位时间（比如 1 秒），就扫描一遍任务，看是否有任务到达设定的执行时间。如果到达了，就拿出来执行：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/153.png" alt><br>但是，这样每过 1 秒就扫描一遍任务列表的做法比较低效，主要原因有两点：第一，任务的约定执行时间离当前时间可能还有很久，这样前面很多次扫描其实都是徒劳的；第二，每次都要扫描整个任务列表，如果任务列表很大的话，势必会比较耗时。<br>针对这些问题，我们就可以用优先级队列来解决。我们按照任务设定的执行时间，将这些任务存储在优先级队列中，队列首部（也就是小顶堆的堆顶）存储的是最先执行的任务。这样，定时器就不需要每隔 1 秒就扫描一遍任务列表了。它拿队首任务的执行时间点，与当前时间点相减，得到一个时间间隔 T。这个时间间隔 T 就是，从当前时间开始，需要等待多久，才会有第一个任务需要被执行。这样，定时器就可以设定在 T 秒之后，再来执行任务。从当前时间点到 T-1 秒这段时间里，定时器都不需要做任何事情。<br>当 T 秒时间过去之后，定时器取优先级队列中队首的任务执行。然后再计算新的队首任务的执行时间点与当前时间点的差值，把这个值作为定时器执行下一个任务需要等待的时间。这样，定时器<strong>既不用间隔 1 秒就轮询一次，也不用遍历整个任务列表</strong>，性能也就提高了；</li></ol><h2 id="堆的应用二：利用堆求-Top-K"><a href="#堆的应用二：利用堆求-Top-K" class="headerlink" title="堆的应用二：利用堆求 Top K"></a>堆的应用二：利用堆求 Top K</h2><p>我们可以<strong>维护一个大小为 K 的小顶堆</strong>，顺序遍历数组，从数组中取出数据与堆顶元素比较。如果比堆顶元素大，我们就把堆顶元素删除，并且将这个元素插入到堆中；如果比堆顶元素小，则不做处理，继续遍历数组。这样等数组中的数据都遍历完之后，堆中的数据就是前 K 大数据了；并且，无论任何时候需要查询当前的前 K 大数据，我们都可以立刻返回。</p><p>遍历数组需要 O(n) 的时间复杂度，一次堆化操作需要 O(logK) 的时间复杂度，所以<strong>最坏情况下，n 个元素都入堆一次，时间复杂度就是 O(nlogK)</strong>。</p><h2 id="堆的应用三：利用堆求中位数"><a href="#堆的应用三：利用堆求中位数" class="headerlink" title="堆的应用三：利用堆求中位数"></a>堆的应用三：利用堆求中位数</h2><p>中位数，顾名思义，就是处在中间位置的那个数。如果数据的个数是奇数，把数据从小到大排列，那第 n/2​+1 个数据就是中位数；如果数据的个数是偶数的话，那处于中间位置的数据有两个，第 n/2​ 个和第 n/2​+1 个数据，这个时候，我们可以<strong>随意取一个作为中位数，比如取两个数中靠前的那个</strong>，就是第 n/2​ 个数据：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/154.png" alt></p><p>对于一组<code>静态数据</code>，中位数是固定的，我们可以先排序，第 n/2​ 个数据就是中位数。每次询问中位数的时候，我们直接返回这个固定的值就好了。所以，<strong>尽管排序的代价比较大，但是边际成本会很小</strong>。但是，如果我们面对的是<code>动态数据</code>集合，中位数在不停地变动，如果再用先排序的方法，每次询问中位数的时候，都要先进行排序，那效率就不高了。</p><p>我们需要维护两个堆，一个大顶堆，一个小顶堆。大顶堆中存储前半部分数据，小顶堆中存储后半部分数据，且<strong>小顶堆中的数据都大于大顶堆中的数据</strong>。也就是说，如果有 n 个数据，n 是偶数，我们从小到大排序，那前 n/2​ 个数据存储在大顶堆中，后 n/2​ 个数据存储在小顶堆中。这样，大顶堆中的堆顶元素就是我们要找的中位数。如果 n 是奇数，情况是类似的，大顶堆就存储 n/2​+1 个数据，小顶堆中就存储 n/2​ 个数据：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/155.png" alt></p><p><strong>如果新加入的数据小于等于大顶堆的堆顶元素，我们就将这个新数据插入到大顶堆</strong>；否则，我们就将这个新数据插入到小顶堆。这个时候就有可能出现，两个堆中的数据个数不符合前面约定的情况，我们可以从一个堆中不停地将堆顶元素移动到另一个堆，通过这样的调整，来让两个堆中的数据满足上面的约定：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/156.png" alt></p><p>插入数据因为需要涉及堆化，所以时间复杂度变成了 O(logn)，但是求中位数我们只需要返回大顶堆的堆顶元素就可以了，所以时间复杂度就是 O(1)。实际上，利用两个堆不仅可以快速求出中位数，还可以快速求其他百分位的数据，比如：快速求接口的 99% 响应时间。</p><p>我们维护两个堆，一个大顶堆，一个小顶堆。假设当前总数据的个数是 n，大顶堆中保存 n*99% 个数据，小顶堆中保存 n*1% 个数据。<strong>大顶堆堆顶的数据就是我们要找的 99% 响应时间</strong>。为了保持大顶堆中的数据占 99%，小顶堆中的数据占 1%，在每次新插入数据之后，我们都要重新计算，这个时候大顶堆和小顶堆中的数据个数，是否还符合 99:1 这个比例。如果不符合，我们就将一个堆中的数据移动到另一个堆，直到满足这个比例。</p><p>通过这样的方法，<strong>每次插入数据，可能会涉及几个数据的堆化操作，所以时间复杂度是 O(logn)</strong>。每次求 99% 响应时间的时候，直接返回大顶堆中的堆顶数据即可，时间复杂度是 O(1)。</p><h2 id="如何快速获取到-Top-10-最热门的搜索关键词"><a href="#如何快速获取到-Top-10-最热门的搜索关键词" class="headerlink" title="如何快速获取到 Top 10 最热门的搜索关键词"></a>如何快速获取到 Top 10 最热门的搜索关键词</h2><p>搜索引擎每天会接收大量的用户搜索请求，它会把这些用户输入的搜索关键词记录下来，然后再离线地统计分析，得到最热门的 Top 10 搜索关键词。假设现在我们有一个包含 10 亿个搜索关键词的日志文件。处理这个问题，有很多高级的解决方法，比如使用 MapReduce 等。但是，如果我们<strong>将处理的场景限定为单机，可以使用的内存为 1GB</strong>。那这个问题该如何解决呢？</p><p>因为用户搜索的关键词，有很多可能都是重复的，所以我们首先要统计每个搜索关键词出现的频率。我们可以<strong>通过散列表、平衡二叉查找树或者其他一些支持快速查找、插入的数据结构，来记录关键词及其出现的次数</strong>。假设我们选用散列表。我们就顺序扫描这 10 亿个搜索关键词。当扫描到某个关键词时，我们去散列表中查询。如果存在，我们就将对应的次数加一；如果不存在，我们就将它插入到散列表，并记录次数为 1。以此类推，等遍历完这 10 亿个搜索关键词之后，散列表中就存储了不重复的搜索关键词以及出现的次数。</p><p>然后，我们再根据前面讲的用堆求 Top K 的方法，<strong>建立一个大小为 10 的小顶堆</strong>，遍历散列表，依次取出每个搜索关键词及对应出现的次数，然后与堆顶的搜索关键词对比。如果出现次数比堆顶搜索关键词的次数多，那就删除堆顶的关键词，将这个出现次数更多的关键词加入到堆中。以此类推，当遍历完整个散列表中的搜索关键词之后，堆中的搜索关键词就是出现次数最多的 Top 10 搜索关键词了。</p><p>上面的解决思路其实存在漏洞。10 亿的关键词还是很多的。我们假设 10 亿条搜索关键词中不重复的有 1 亿条，如果每个搜索关键词的平均长度是 50 个字节，那存储 1 亿个关键词起码需要 5GB 的内存空间，而散列表因为要避免频繁冲突，不会选择太大的装载因子，所以消耗的内存空间就更多了。而我们的机器只有 1GB 的可用内存空间，所以我们<strong>无法一次性将所有的搜索关键词加入到内存中</strong>。</p><p>相同数据经过哈希算法得到的哈希值是一样的，我们将 10 亿条搜索关键词先通过哈希算法分片到 10 个文件中。具体可以这样做：我们创建 10 个空文件 00, 01, 02, …, 09。我们遍历这 10 亿个关键词，并且<strong>通过某个哈希算法对其求哈希值，然后哈希值同 10 取模</strong>，得到的结果就是这个搜索关键词应该被分到的文件编号。对这 10 亿个关键词分片之后，总的大小大约是 500MB。1GB 的内存完全可以放得下。</p><p>我们针对每个包含 1 亿条搜索关键词的文件，利用散列表和堆，分别求出 Top 10，然后把这个 10 个 Top 10 放在一块，然后<strong>取这 100 个关键词中，出现次数最多的 10 个关键词</strong>，这就是这 10 亿数据中的 Top 10 最频繁的搜索关键词了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆和堆排序</title>
      <link href="2021/01/05/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/"/>
      <url>2021/01/05/%E5%A0%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解“堆”？"><a href="#如何理解“堆”？" class="headerlink" title="如何理解“堆”？"></a>如何理解“堆”？</h2><p><strong>堆是一种特殊的树</strong>。我罗列了两点要求，只要满足这两点，它就是一个堆：</p><ul><li>堆是一个完全二叉树；</li><li>堆中每一个节点的值都必须大于等于（或小于等于）其子树中每个节点的值；</li></ul><p>对于每个节点的值都大于等于子树中每个节点值的堆，我们叫做<code>大顶堆</code>。对于每个节点的值都小于等于子树中每个节点值的堆，我们叫做<code>小顶堆</code>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/138.png" alt></p><p>其中第 1 个和第 2 个是大顶堆，第 3 个是小顶堆，第 4 个不是堆。除此之外，从图中还可以看出来，<strong>对于同一组数据，我们可以构建多种不同形态的堆</strong>。</p><a id="more"></a><h2 id="如何实现一个堆？"><a href="#如何实现一个堆？" class="headerlink" title="如何实现一个堆？"></a>如何实现一个堆？</h2><p><strong>完全二叉树比较适合用数组来存储</strong>。用数组来存储完全二叉树是非常节省存储空间的。因为我们不需要存储左右子节点的指针，单纯地通过数组的下标，就可以找到一个节点的左右子节点和父节点。我画了一个用数组存储堆的例子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/139.png" alt></p><p>从图中我们可以看到，数组中下标为 i 的节点的左子节点，就是下标为 i*2 的节点，右子节点就是下标为 i*2+1 的节点，父节点就是下标为 i/2​ 的节点。</p><h3 id="往堆中插入一个元素"><a href="#往堆中插入一个元素" class="headerlink" title="往堆中插入一个元素"></a>往堆中插入一个元素</h3><p>往堆中插入一个元素后，我们需要继续满足堆的两个特性。如果我们把新插入的元素放到堆的最后，此时的树便不符合堆的特性了。于是，我们就需要<strong>进行调整，让其重新满足堆的特性</strong>，这个过程我们起了一个名字，就叫做<code>堆化</code>（heapify）。堆化非常简单，就是顺着节点所在的路径，向上或者向下，对比，然后交换：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/140.png" alt></p><p>我这里画了一张堆化的过程分解图，我们可以让新插入的节点与父节点对比大小。如果不满足子节点小于等于父节点的大小关系，我们就互换两个节点。一直重复这个过程，直到父子节点之间满足刚说的那种大小关系：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/141.png" alt></p><p>我将上面讲的往堆中插入数据的过程，翻译成了代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Heap</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] a;   <span class="comment">// 数组，从下标 1 开始存储数据</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;     <span class="comment">// 堆可以存储的最大数据个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count; <span class="comment">// 堆中已经存储的数据个数</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Heap</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        a = <span class="keyword">new</span> <span class="keyword">int</span>[capacity + <span class="number">1</span>];</span><br><span class="line">        n = capacity;</span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= n)</span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 堆满了</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ++count;</span><br><span class="line">        a[count] = data;</span><br><span class="line">        <span class="keyword">int</span> i = count;</span><br><span class="line">        <span class="keyword">while</span> (i/<span class="number">2</span> &gt; <span class="number">0</span> &amp;&amp; a[i] &gt; a[i/<span class="number">2</span>]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 自下往上堆化</span></span><br><span class="line">            swap(a, i, i/<span class="number">2</span>); <span class="comment">// swap() 函数作用：交换下标为 i 和 i/2 的两个元素</span></span><br><span class="line">            i = i/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h3><p>从堆的定义的第二条中，任何节点的值都大于等于（或小于等于）子树节点的值，我们可以发现，堆顶元素存储的就是堆中数据的最大值或者最小值。假设我们构造的是大顶堆，堆顶元素就是最大的元素。当我们<strong>删除堆顶元素之后，就需要把第二大的元素放到堆顶</strong>，那第二大元素肯定会出现在左右子节点中。然后我们再迭代地删除第二大节点，以此类推，直到叶子节点被删除。不过这种方法有点问题，就是最后堆化出来的堆并不满足完全二叉树的特性：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/142.png" alt></p><p>实际上，我们稍微改变一下思路，就可以解决这个问题。你看我画的下面这幅图。我们<strong>把最后一个节点放到堆顶，然后利用同样的父子节点对比方法</strong>。对于不满足父子节点大小关系的，互换两个节点，并且重复进行这个过程，直到父子节点之间满足大小关系为止。因为我们移除的是数组中的最后一个元素，而在堆化的过程中，都是交换操作，不会出现数组中的“空洞”，所以这种方法堆化之后的结果，肯定满足完全二叉树的特性：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/143.png" alt></p><p>我把上面的删除过程同样也翻译成了代码，贴在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeMax</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 堆中没有数据</span></span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    a[<span class="number">1</span>] = a[count];</span><br><span class="line">    --count;</span><br><span class="line">    heapify(a, count, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="comment">// 自上往下堆化</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = i;</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            maxPos = i*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxPos == i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, maxPos);</span><br><span class="line">        i = maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，一个包含 n 个节点的完全二叉树，树的高度不会超过 log2​n。堆化的过程是顺着节点所在路径比较交换的，所以<strong>堆化的时间复杂度跟树的高度成正比，也就是 O(logn)</strong>。插入数据和删除堆顶元素的主要逻辑就是堆化，所以，往堆中插入一个元素和删除堆顶元素的时间复杂度都是 O(logn)。</p><h2 id="如何基于堆实现排序？"><a href="#如何基于堆实现排序？" class="headerlink" title="如何基于堆实现排序？"></a>如何基于堆实现排序？</h2><p>借助于堆这种数据结构实现的排序算法，就叫做堆排序。这种排序方法的时间复杂度非常稳定，是 O(nlogn)，并且它还是<strong>原地排序算法</strong>。我们可以把堆排序的过程大致分解成两个大的步骤：建堆和排序。</p><h3 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h3><p>我们首先将数组原地建成一个堆。建堆的过程，有两种思路：</p><ol><li>尽管数组中包含 n 个数据，但是<strong>我们可以假设，起初堆中只包含一个数据</strong>，就是下标为 1 的数据。然后，我们调用前面讲的插入操作，将下标从 2 到 n 的数据依次插入到堆中。这样我们就将包含 n 个数据的数组，组织成了堆；</li><li>第一种建堆思路的处理过程是从前往后处理数组数据，并且每个数据插入堆中时，都是从下往上堆化。而第二种实现思路，是<strong>从后往前处理数组，并且每个数据都是从上往下堆化</strong>；</li></ol><p>我举了一个例子，并且画了一个第二种实现思路的建堆分解步骤图，你可以看下。因为叶子节点往下堆化只能自己跟自己比较，所以我们<strong>直接从最后一个非叶子节点开始，依次堆化</strong>就行了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/144.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/145.png" alt></p><p>对于程序员来说，看代码可能更好理解一些：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildHeap</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n/<span class="number">2</span>; i &gt;= <span class="number">1</span>; --i) </span><br><span class="line">    &#123;</span><br><span class="line">        heapify(a, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> maxPos = i;</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span> &lt;= n &amp;&amp; a[i] &lt; a[i*<span class="number">2</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            maxPos = i*<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i*<span class="number">2</span>+<span class="number">1</span> &lt;= n &amp;&amp; a[maxPos] &lt; a[i*<span class="number">2</span>+<span class="number">1</span>]) </span><br><span class="line">        &#123;</span><br><span class="line">            maxPos = i*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxPos == i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(a, i, maxPos);</span><br><span class="line">        i = maxPos;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们对下标从 n/2​ 开始到 1 的数据进行堆化，下标是 n/2​+1 到 n 的节点不需要堆化。实际上，<strong>对于完全二叉树来说，下标从 n/2​+1 到 n 的节点都是叶子节点</strong>。</p><p>因为叶子节点不需要堆化，所以需要堆化的节点从倒数第二层开始。<strong>每个节点堆化的过程中，需要比较和交换的节点个数，跟这个节点的高度成正比</strong>。我把每一层的节点个数和对应的高度画了出来，你可以看看。我们只需要将每个节点的高度求和，得出的就是建堆的时间复杂度：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/146.png" alt></p><p>我们将每个非叶子节点的高度求和，就是下面这个公式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/147.png" alt></p><p>这个公式的求解稍微有点技巧：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/148.png" alt></p><p>S 的中间部分是一个等比数列，所以最后可以用等比数列的求和公式来计算：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/149.png" alt></p><p>因为 h=log2​n，代入公式 S，就能得到 S=O(n)，所以，<strong>建堆的时间复杂度就是 O(n)</strong>。</p><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>建堆结束之后，<strong>数组中的数据已经是按照大顶堆的特性来组织的</strong>。数组中的第一个元素就是堆顶，也就是最大的元素。我们把它跟最后一个元素交换，那最大元素就放到了下标为 n 的位置。当堆顶元素移除之后，我们把下标为 n 的元素放到堆顶，然后再通过堆化的方法，将剩下的 n−1 个元素重新构建成堆。堆化完成之后，我们再取堆顶的元素，放到下标是 n−1 的位置，一直重复这个过程，直到最后堆中只剩下标为 1 的一个元素，排序工作就完成了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/150.png" alt></p><p>堆排序的过程，我也翻译成了代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数据的个数，数组 a 中的数据从下标 1 到 n 的位置</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    buildHeap(a, n);</span><br><span class="line">    <span class="keyword">int</span> k = n;</span><br><span class="line">    <span class="keyword">while</span> (k &gt; <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        swap(a, <span class="number">1</span>, k);</span><br><span class="line">        --k;</span><br><span class="line">        heapify(a, k, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个堆排序的过程，都只需要极个别临时存储空间，所以堆排序是原地排序算法。堆排序包括建堆和排序两个操作，<strong>建堆过程的时间复杂度是 O(n)，排序过程的时间复杂度是 O(nlogn)</strong>，所以，堆排序整体的时间复杂度是 O(nlogn)。堆排序不是稳定的排序算法，因为在排序的过程，存在将堆的最后一个节点跟堆顶节点互换的操作，所以就有可能改变值相同数据的原始相对顺序。</p><p>如果从 0 开始存储，实际上处理思路是没有任何变化的，唯一变化的，可能就是，代码实现的时候，<strong>计算子节点和父节点的下标的公式改变了</strong>。如果节点的下标是 i，那左子节点的下标就是 2*i+1，右子节点的下标就是 2*i+2，父节点的下标就是 (i-1)/2​。</p><h2 id="为什么快速排序要比堆排序性能好"><a href="#为什么快速排序要比堆排序性能好" class="headerlink" title="为什么快速排序要比堆排序性能好"></a>为什么快速排序要比堆排序性能好</h2><ol><li>对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1, 2, 4, 8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样<strong>对 CPU 缓存是不友好的</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/151.png" alt></li><li>对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。但是堆排序的第一步是建堆，<strong>建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低</strong>。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/152.png" alt></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归树</title>
      <link href="2021/01/05/%E9%80%92%E5%BD%92%E6%A0%91/"/>
      <url>2021/01/05/%E9%80%92%E5%BD%92%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="递归树与时间复杂度分析"><a href="#递归树与时间复杂度分析" class="headerlink" title="递归树与时间复杂度分析"></a>递归树与时间复杂度分析</h2><p>递归的思想就是，将大问题分解为小问题来求解，然后再将小问题分解为小小问题。这样一层一层地分解，直到问题的数据规模被分解得足够小，不用继续递归分解为止。如果我们<strong>把这个一层一层的分解过程画成图，它其实就是一棵树</strong>。我们给这棵树起一个名字，叫作<code>递归树</code>（Recursion Tree）。归并排序每次会将数据规模一分为二，我们把归并排序画成递归树，就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/131.png" alt></p><p>因为每次分解都是一分为二，所以代价很低，我们把时间上的消耗记作常量 1。归并算法中比较耗时的是归并操作，也就是把两个子数组合并为大数组。从图中我们可以看出，<strong>每一层归并操作消耗的时间总和是一样的，跟要排序的数据规模有关</strong>。我们把每一层归并操作消耗的时间记作 n。现在，我们只需要知道这棵树的高度 h，用高度 h 乘以每一层的时间消耗 n，就可以得到总的时间复杂度 O(n*h)。</p><p>从归并排序的原理和递归树，可以看出来，归并排序递归树是一棵满二叉树。满二叉树的高度大约是 log2​n，所以，归并排序递归实现的时间复杂度就是 O(nlogn)。我这里的时间复杂度都是估算的，对树的高度的计算也没有那么精确，但是这并不影响复杂度的计算结果。</p><a id="more"></a><h2 id="实战一：分析快速排序的时间复杂度"><a href="#实战一：分析快速排序的时间复杂度" class="headerlink" title="实战一：分析快速排序的时间复杂度"></a>实战一：分析快速排序的时间复杂度</h2><p>快速排序在最好情况下，每次分区都能一分为二，这个时候用递推公式 T(n)=2T(n/2​)+n，很容易就能推导出时间复杂度是 O(nlogn)。但是，我们并不可能每次分区都这么幸运，正好一分为二。我们假设平均情况下，每次分区之后，两个分区的大小比例为 1:k。当 k=9 时，如果用递推公式的方法来求解时间复杂度的话，递推公式就写成 T(n)=T(n/10​)+T(9n/10​)+n。<strong>这个公式可以推导出时间复杂度，但是推导过程非常复杂</strong>。</p><p>我们还是取 k 等于 9，也就是说，每次分区都很不平均，一个分区是另一个分区的 9 倍。如果我们把递归分解的过程画成递归树，就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/132.png" alt></p><p>快速排序的过程中，每次分区都要遍历待分区区间的所有数据，所以，每一层分区操作所遍历的数据的个数之和就是 n。我们现在只要求出递归树的高度 h，这个快排过程遍历的数据个数就是 h*n ，也就是说，时间复杂度就是 O(h*n)。我们知道，快速排序结束的条件就是待排序的小区间，大小为 1，也就是说叶子节点里的数据规模是 1。从根节点 n 到叶子节点 1，<strong>递归树中最短的一个路径每次都乘以 1/10​，最长的一个路径每次都乘以 9/10</strong>。通过计算，我们可以得到，从根节点到叶子节点的最短路径是 log10​n，最长的路径是 log10/9​​n：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/133.png" alt></p><p>所以，遍历数据的个数总和就介于 nlog10​n 和 nlog10/9​​n 之间。根据复杂度的大 O 表示法，对数复杂度的底数不管是多少，我们统一写成 logn，所以，当分区大小比例是 1:9 时，快速排序的时间复杂度仍然是 O(nlogn)。</p><h2 id="实战二：分析斐波那契数列的时间复杂度"><a href="#实战二：分析斐波那契数列的时间复杂度" class="headerlink" title="实战二：分析斐波那契数列的时间复杂度"></a>实战二：分析斐波那契数列的时间复杂度</h2><p>我们先把斐波那契数列的递归代码画成递归树，就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/134.png" alt></p><p>f(n) 分解为 f(n−1) 和 f(n−2)，每次数据规模都是 −1 或者 −2，叶子节点的数据规模是 1 或者 2。所以，从根节点走到叶子节点，每条路径是长短不一的。<strong>如果每次都是 −1，那最长路径大约就是 n；如果每次都是 −2，那最短路径大约就是 n/2</strong>。每次分解之后的合并操作只需要一次加法运算，我们把这次加法运算的时间消耗记作 1。所以，从上往下，第一层的总时间消耗是 1，第二层的总时间消耗是 2，第三层的总时间消耗就是 2^2。依次类推，第 k 层的时间消耗就是 2^(k−1)，那整个算法的总的时间消耗就是每一层时间消耗之和：</p><ul><li>如果路径长度都为 n，那这个总和就是 2^n−1：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/135.png" alt></li><li>如果路径长度都是 n/2​ ，那整个算法的总的时间消耗就是 2^(n/2)​−1：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/136.png" alt></li></ul><p>所以，这个算法的时间复杂度就介于 O(2^(n/2)) 和 O(2^n​) 之间。虽然这样得到的结果还不够精确，只是一个范围，但是我们也基本上知道了<strong>上面算法的时间复杂度是指数级的，非常高</strong>。</p><h2 id="实战三：分析全排列的时间复杂度"><a href="#实战三：分析全排列的时间复杂度" class="headerlink" title="实战三：分析全排列的时间复杂度"></a>实战三：分析全排列的时间复杂度</h2><p>我们在高中的时候都学过排列组合。“如何把 n 个数据的所有排列都找出来”，这就是全排列的问题。我来举个例子。比如，1, 2, 3 这样 3 个数据，有下面这几种不同的排列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="number">1</span>, <span class="number">3</span>, <span class="number">2</span></span><br><span class="line"><span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span></span><br><span class="line"><span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span></span><br><span class="line"><span class="number">3</span>, <span class="number">1</span>, <span class="number">2</span></span><br><span class="line"><span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span></span><br></pre></td></tr></table></figure><p>如果我们确定了最后一位数据，那就变成了求解剩下 n−1 个数据的排列问题。而最后一位数据可以是 n 个数据中的任意一个，因此它的取值就有 n 种情况。所以，<strong>“n 个数据的排列”问题，就可以分解成 n 个“n−1 个数据的排列”的子问题</strong>。如果我们把它写成递推公式，就是下面这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 假设数组中存储的是 1, 2, 3, ..., n</span></span><br><span class="line">        </span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>, ..., n) = &#123;最后一位是 <span class="number">1</span>, f(n-<span class="number">1</span>)&#125; + &#123;最后一位是 <span class="number">2</span>, f(n-<span class="number">1</span>)&#125; + ... + &#123;最后一位是 n, f(n-<span class="number">1</span>)&#125;</span><br></pre></td></tr></table></figure><p>如果我们把递推公式改写成代码，就是下面这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 调用方式：</span></span><br><span class="line"><span class="comment">// int[]a = a=&#123;1, 2, 3, 4&#125;; printPermutations(a, 4, 4);</span></span><br><span class="line"><span class="comment">// k 表示要处理的子数组的数据个数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printPermutations</span><span class="params">(<span class="keyword">int</span>[] data, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.print(data[i] + <span class="string">" "</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = data[i];</span><br><span class="line">        data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">        data[k-<span class="number">1</span>] = tmp;</span><br><span class="line"></span><br><span class="line">        printPermutations(data, n, k - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        tmp = data[i];</span><br><span class="line">        data[i] = data[k-<span class="number">1</span>];</span><br><span class="line">        data[k-<span class="number">1</span>] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，我们还是画出递归树。不过，现在的递归树已经不是标准的二叉树了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/137.png" alt></p><p>第一层分解有 n 次交换操作，第二层有 n 个节点，每个节点分解需要 n−1 次交换，所以第二层总的交换次数是 n*(n−1)。第三层有 n*(n−1) 个节点，每个节点分解需要 n−2 次交换，所以第三层总的交换次数是 n*(n−1)*(n−2)。以此类推，第 k 层总的交换次数就是 n*(n−1)*(n−2)*…*(n−k+1)。最后一层的交换次数就是 n*(n−1)*(n−2)*…*2*1。每一层的交换次数之和就是总的交换次数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">n + n*(n-<span class="number">1</span>) + n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>) +... + n*(n-<span class="number">1</span>)*(n-<span class="number">2</span>)*...*<span class="number">2</span>*<span class="number">1</span></span><br></pre></td></tr></table></figure><p>这个公式的求和比较复杂，我们看最后一个数，n*(n−1)*(n−2)*…*2*1 等于 n!，而前面的 n−1 个数都小于最后一个数，所以，总和肯定小于 n*n!，也就是说，<strong>全排列的递归算法的时间复杂度大于 O(n!)，小于 O(n*n!)</strong>，虽然我们没法知道非常精确的时间复杂度，但是这样一个范围已经让我们知道，全排列的时间复杂度是非常高的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>红黑树</title>
      <link href="2021/01/04/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
      <url>2021/01/04/%E7%BA%A2%E9%BB%91%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是“平衡二叉查找树”？"><a href="#什么是“平衡二叉查找树”？" class="headerlink" title="什么是“平衡二叉查找树”？"></a>什么是“平衡二叉查找树”？</h2><p>平衡二叉树的严格定义是这样的：<strong>二叉树中任意一个节点的左右子树的高度相差不能大于 1</strong>。从这个定义来看，上一节我们讲的完全二叉树、满二叉树其实都是平衡二叉树，但是非完全二叉树也有可能是平衡二叉树：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/114.png" alt></p><p>平衡二叉查找树不仅满足上面平衡二叉树的定义，还满足二叉查找树的特点。最先被发明的平衡二叉查找树是 <code>AVL 树</code>，它严格符合我刚讲到的平衡二叉查找树的定义，即任何节点的左右子树高度相差不超过 1，是一种高度平衡的二叉查找树。发明平衡二叉查找树这类数据结构的初衷是，<strong>解决普通二叉查找树在频繁的插入、删除等动态更新的情况下，出现时间复杂度退化的问题</strong>。</p><p>平衡二叉查找树中“平衡”的意思，其实就是让整棵树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。这样就能让整棵树的高度相对来说低一些，相应的插入、删除、查找等操作的效率高一些。所以，如果我们现在设计一个新的平衡二叉查找树，<strong>只要树的高度不比 log2n 大很多（比如树的高度仍然是对数量级的）</strong>，尽管它不符合我们前面讲的严格的平衡二叉查找树的定义，但我们仍然可以说，这是一个合格的平衡二叉查找树。</p><a id="more"></a><h2 id="如何定义一棵“红黑树”？"><a href="#如何定义一棵“红黑树”？" class="headerlink" title="如何定义一棵“红黑树”？"></a>如何定义一棵“红黑树”？</h2><p>平衡二叉查找树其实有很多，比如，<code>Splay Tree</code>（伸展树）、<code>Treap</code>（树堆）等，但是我们提到平衡二叉查找树，听到的基本都是红黑树。红黑树的英文是“Red-Black Tree”，简称 R-B Tree。它是一种不严格的平衡二叉查找树。顾名思义，红黑树中的节点，一类被标记为黑色，一类被标记为红色。除此之外，一棵红黑树还需要满足这样几个要求：</p><ul><li>根节点是黑色的；</li><li>每个叶子节点都是黑色的空节点（NIL），也就是说，叶子节点不存储数据；</li><li>任何相邻的节点都不能同时为红色，也就是说，红色节点是被黑色节点隔开的；</li><li>每个节点，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点；</li></ul><p>这里的第二点要求“叶子节点都是黑色的空节点”，稍微有些奇怪，它主要是<strong>为了简化红黑树的代码实现而设置的</strong>。所以，在画图和讲解的时候，我将黑色的、空的叶子节点都省略掉了。为了让你更好地理解上面的定义，我画了两个红黑树的图例：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/115.png" alt></p><h2 id="为什么说红黑树是“近似平衡”的？"><a href="#为什么说红黑树是“近似平衡”的？" class="headerlink" title="为什么说红黑树是“近似平衡”的？"></a>为什么说红黑树是“近似平衡”的？</h2><p>平衡二叉查找树的初衷，是为了解决二叉查找树因为动态更新导致的性能退化问题。所以，平衡的意思可以等价为性能不退化，<strong>近似平衡就等价为性能不会退化得太严重</strong>。</p><p>首先，如果我们将红色节点从红黑树中去掉，那<strong>单纯包含黑色节点的红黑树的高度是多少</strong>呢？红色节点删除之后，有些节点就没有父节点了，它们会直接拿这些节点的祖父节点（父节点的父节点）作为父节点。所以，之前的二叉树就变成了四叉树：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/116.png" alt></p><p>前面红黑树的定义里有这么一条：从任意节点到可达的叶子节点的每个路径包含相同数目的黑色节点。我们从四叉树中取出某些节点，放到叶节点位置，四叉树就变成了完全二叉树。所以，<strong>仅包含黑色节点的四叉树的高度，比包含相同节点个数的完全二叉树的高度还要小</strong>，所以去掉红色节点的“黑树”的高度也不会超过 log2n。</p><p>从上面我画的红黑树的例子和定义看，在红黑树中，红色节点不能相邻，也就是说，有一个红色节点就要至少有一个黑色节点，将它跟其他红色节点隔开。红黑树中包含最多黑色节点的路径不会超过 log2n，所以加入红色节点之后，最长路径不会超过 2log2n，也就是说，<strong>红黑树的高度近似 2*log2n</strong>。红黑树的高度只比高度平衡的 AVL 树的高度（log2n）仅仅大了一倍，在性能上，下降得并不多。这样推导出来的结果不够精确，实际上红黑树的性能更好。</p><h2 id="为什么在工程中都喜欢用红黑树"><a href="#为什么在工程中都喜欢用红黑树" class="headerlink" title="为什么在工程中都喜欢用红黑树"></a>为什么在工程中都喜欢用红黑树</h2><p>我们前面提到 Treap、Splay Tree，绝大部分情况下，它们操作的效率都很高，但是也<strong>无法避免极端情况下时间复杂度的退化</strong>。尽管这种情况出现的概率不大，但是对于单次操作时间非常敏感的场景来说，它们并不适用。AVL 树是一种高度平衡的二叉树，所以查找的效率非常高，但是，有利就有弊，<strong>AVL 树为了维持这种高度的平衡，就要付出更多的代价</strong>。每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用 AVL 树的代价就有点高了。</p><p>红黑树只是做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比 AVL 树要低。所以，<strong>红黑树的插入、删除、查找各种操作性能都比较稳定</strong>。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，我们更倾向于这种性能稳定的平衡二叉查找树。</p><h2 id="实现红黑树的基本思想"><a href="#实现红黑树的基本思想" class="headerlink" title="实现红黑树的基本思想"></a>实现红黑树的基本思想</h2><p>红黑树的平衡过程跟魔方复原非常神似，大致过程就是：<strong>遇到什么样的节点排布，我们就对应怎么去调整</strong>。只要按照这些固定的调整规则来操作，就能将一个非平衡的红黑树调整成平衡的。我先介绍两个非常重要的操作，<code>左旋</code>（rotate left）、<code>右旋</code>（rotate right）。左旋全称其实是叫<strong>围绕某个节点的左旋</strong>，那右旋的全称就叫围绕某个节点的右旋。我们下面的平衡调整中，会一直用到这两个操作，所以我这里画了个示意图，帮助你彻底理解这两个操作。图中的 a, b, r 表示子树，可以为空：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/117.png" alt></p><h2 id="插入操作的平衡调整"><a href="#插入操作的平衡调整" class="headerlink" title="插入操作的平衡调整"></a>插入操作的平衡调整</h2><p>红黑树规定，<strong>插入的节点必须是红色的</strong>。而且，<strong>二叉查找树中新插入的节点都是放在叶子节点上</strong>。所以，关于插入操作的平衡调整，有这样两种特殊情况：</p><ul><li>如果插入节点的父节点是黑色的，那我们什么都不用做，它仍然满足红黑树的定义；</li><li>如果插入的节点是根节点，那我们直接改变它的颜色，把它变成黑色就可以了；</li></ul><p>除此之外，其他情况都会违背红黑树的定义，于是我们就需要进行调整，<strong>调整的过程包含两种基础的操作：左右旋转和改变颜色</strong>。红黑树的平衡调整过程是一个迭代的过程。我们把正在处理的节点叫做<code>关注节点</code>。<strong>关注节点会随着不停地迭代处理，而不断发生变化</strong>。最开始的关注节点就是新插入的节点。新节点插入之后，如果红黑树的平衡被打破，那一般会有下面三种情况：</p><ol><li>如果<strong>关注节点是 a，它的叔叔节点 d 是红色</strong>，我们就依次执行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/118.png" alt><ul><li>将关注节点 a 的父节点 b、叔叔节点 d 的颜色都设置成黑色；</li><li>将关注节点 a 的祖父节点 c 的颜色设置成红色；</li><li>关注节点变成 a 的祖父节点 c；</li><li>跳到 2 或者 3；</li></ul></li><li>如果<strong>关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的右子节点</strong>，我们就依次执行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/119.png" alt><ul><li>关注节点变成节点 a 的父节点 b；</li><li>围绕新的关注节点b 左旋；</li><li>跳到 3；</li></ul></li><li>如果<strong>关注节点是 a，它的叔叔节点 d 是黑色，关注节点 a 是其父节点 b 的左子节点</strong>，我们就依次执行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/120.png" alt><ul><li>围绕关注节点 a 的祖父节点 c 右旋；</li><li>将关注节点 a 的父节点 b、兄弟节点 c 的颜色互换；</li><li>调整结束；</li></ul></li></ol><h2 id="删除操作的平衡调整"><a href="#删除操作的平衡调整" class="headerlink" title="删除操作的平衡调整"></a>删除操作的平衡调整</h2><p>删除操作的平衡调整分为两步，第一步是针对删除节点初步调整。初步调整只是保证整棵红黑树在一个节点删除之后，<strong>每个节点仍然满足，从该节点到达其可达叶子节点的所有路径，都包含相同数目的黑色节点</strong>；第二步是针对关注节点进行二次调整，<strong>仍然不存在相邻的两个红色节点</strong>。</p><h3 id="针对删除节点初步调整"><a href="#针对删除节点初步调整" class="headerlink" title="针对删除节点初步调整"></a>针对删除节点初步调整</h3><p>这里需要注意一下，红黑树的定义中“只包含红色节点和黑色节点”，经过初步调整之后，为了保证满足红黑树定义的最后一条要求，有些节点会被标记成两种颜色，“红-黑”或者“黑-黑”。如果一个节点被标记为了“黑-黑”，那在计算黑色节点个数的时候，要算成两个黑色节点：</p><ol><li>如果<strong>要删除的节点是 a，它只有一个子节点 b</strong>，那我们就依次进行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/121.png" alt><ul><li>删除节点 a，并且把节点 b 替换到节点 a 的位置，这一部分操作跟普通的二叉查找树的删除操作一样；</li><li>节点 a 只能是黑色，节点 b 也只能是红色，其他情况均不符合红黑树的定义。这种情况下，我们把节点 b 改为黑色；</li><li>调整结束，不需要进行二次调整；</li></ul></li><li>如果<strong>要删除的节点 a 有两个非空子节点，并且它的后继节点就是节点 a 的右子节点 c</strong>。我们就依次进行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/122.png" alt><ul><li>如果节点 a 的后继节点就是右子节点 c，那右子节点 c 肯定没有左子树。我们把节点 a 删除，并且将节点 c 替换到节点 a 的位置。这一部分操作跟普通的二叉查找树的删除操作无异；</li><li>然后把节点 c 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 c 是黑色，为了不违反红黑树的最后一条定义，我们给节点 c 的右子节点 d 多加一个黑色，这个时候节点 d 就成了“红-黑”或者“黑-黑”；</li><li>这个时候，关注节点变成了节点 d，第二步的调整操作就会针对关注节点来做；</li></ul></li><li>如果<strong>要删除的是节点 a，它有两个非空子节点，并且节点 a 的后继节点不是右子节点</strong>，我们就依次进行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/123.png" alt><ul><li>找到后继节点 d，并将它删除，删除后继节点 d 的过程参照 1；</li><li>将节点 a 替换成后继节点 d；</li><li>把节点 d 的颜色设置为跟节点 a 相同的颜色；</li><li>如果节点 d 是黑色，为了不违反红黑树的最后一条定义，我们给节点 d 的右子节点 c 多加一个黑色，这个时候节点 c 就成了“红-黑”或者“黑-黑”；</li><li>这个时候，关注节点变成了节点 c，第二步的调整操作就会针对关注节点来做；</li></ul></li></ol><h3 id="针对关注节点进行二次调整"><a href="#针对关注节点进行二次调整" class="headerlink" title="针对关注节点进行二次调整"></a>针对关注节点进行二次调整</h3><p>经过初步调整之后，关注节点变成了“红-黑”或者“黑-黑”节点。针对这个关注节点，我们再分四种情况来进行二次调整。二次调整是为了让红黑树中不存在相邻的红色节点：</p><ol><li>如果<strong>关注节点是 a，它的兄弟节点 c 是红色的</strong>，我们就依次进行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/124.png" alt><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>关注节点 a 的父节点 b 和祖父节点 c 交换颜色；</li><li>关注节点不变；</li><li>继续从四种情况中选择适合的规则来调整；</li></ul></li><li>如果<strong>关注节点是 a，它的兄弟节点 c 是黑色的，并且节点 c 的左右子节点 d、e 都是黑色的</strong>，我们就依次进行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/125.png" alt><ul><li>将关注节点 a 的兄弟节点 c 的颜色变成红色；</li><li>从关注节点 a 中去掉一个黑色，这个时候节点 a 就是单纯的红色或者黑色；</li><li>给关注节点 a 的父节点 b 添加一个黑色，这个时候节点 b 就变成了“红-黑”或者“黑-黑”；</li><li>关注节点从 a 变成其父节点 b；</li><li>继续从四种情况中选择符合的规则来调整；</li></ul></li><li>如果<strong>关注节点是 a，它的兄弟节点 c 是黑色，c 的左子节点 d 是红色，c 的右子节点 e 是黑色</strong>，我们就依次进行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/126.png" alt><ul><li>围绕关注节点 a 的兄弟节点 c 右旋；</li><li>节点 c 和节点 d 交换颜色；</li><li>关注节点不变；</li><li>跳转到 4，继续调整；</li></ul></li><li>如果<strong>关注节点 a 的兄弟节点 c 是黑色的，并且 c 的右子节点是红色的</strong>，我们就依次进行下面的操作：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/127.png" alt><ul><li>围绕关注节点 a 的父节点 b 左旋；</li><li>将关注节点 a 的兄弟节点 c 的颜色，跟关注节点 a 的父节点 b 设置成相同的颜色；</li><li>将关注节点 a 的父节点 b 的颜色设置为黑色；</li><li>从关注节点 a 中去掉一个黑色，节点 a 就变成了单纯的红色或者黑色；</li><li>将关注节点 a 的叔叔节点 e 设置为黑色；</li><li>调整结束；</li></ul></li></ol><h2 id="为什么叶子节点是黑色的空节点"><a href="#为什么叶子节点是黑色的空节点" class="headerlink" title="为什么叶子节点是黑色的空节点"></a>为什么叶子节点是黑色的空节点</h2><p>假设红黑树的定义中不包含刚刚提到的那一条“叶子节点必须是黑色的空节点”，我们往一棵红黑树中插入一个数据，新插入节点的父节点也是红色的，两个红色的节点相邻，这个时候，红黑树的定义就被破坏了。你会发现，这个时候，我们前面在讲插入时，<strong>三种情况下的平衡调整规则，没有一种是适用的</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/128.png" alt></p><p>但是，<strong>如果我们把黑色的空节点都给它加上，你会发现，它满足 2 了</strong>，变成下面这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/129.png" alt></p><p>虽然我们在讲解或者画图的时候，每个黑色的、空的叶子节点都是独立画出来的。实际上，<strong>在具体实现的时候，共用一个黑色的、空的叶子节点就行了</strong>，像下面这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/130.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树基础</title>
      <link href="2021/01/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/"/>
      <url>2021/01/03/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<h2 id="树（Tree）"><a href="#树（Tree）" class="headerlink" title="树（Tree）"></a>树（Tree）</h2><p>我们首先来看，什么是<code>树</code>？我在图中画了几棵树：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/96.png" alt></p><p>树这种数据结构真的很像我们现实生活中的树，这里面每个元素我们叫做“节点”；用来连接相邻节点之间的关系，我们叫做“父子关系”。比如下面这幅图，A 节点就是 B 节点的<code>父节点</code>，B 节点是 A 节点的<code>子节点</code>。B、C、D 这三个节点的父节点是同一个节点，所以它们之间互称为<code>兄弟节点</code>。我们把没有父节点的节点叫做<code>根节点</code>，也就是图中的节点 E。我们把没有子节点的节点叫做<code>叶子节点</code>，比如图中的 G、H、I、J、K、L 都是叶子节点：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/97.png" alt></p><a id="more"></a><p>除此之外，关于树，还有三个比较相似的概念：<code>高度</code>（Height）、<code>深度</code>（Depth）、<code>层</code>（Level）。它们的定义是这样的：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/98.png" alt></p><p>这三个概念的定义比较容易混淆，描述起来也比较空洞。我举个例子说明一下，你一看应该就能明白：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/99.png" alt></p><h2 id="二叉树（Binary-Tree）"><a href="#二叉树（Binary-Tree）" class="headerlink" title="二叉树（Binary Tree）"></a>二叉树（Binary Tree）</h2><p>二叉树，顾名思义，每个节点最多有两个“叉”，也就是两个子节点，分别是<code>左子节点</code>和<code>右子节点</code>。不过，二叉树并不要求每个节点都有两个子节点，有的节点只有左子节点，有的节点只有右子节点。我画的这几个都是二叉树。以此类推，你可以想象一下四叉树、八叉树长什么样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/100.png" alt></p><p>其中，编号 2 的二叉树中，叶子节点全都在最底层，除了叶子节点之外，每个节点都有左右两个子节点，这种二叉树就叫做<code>满二叉树</code>；编号 3 的二叉树中，叶子节点都在最底下两层，最后一层的叶子节点都靠左排列，并且除了最后一层，其他层的节点个数都要达到最大，这种二叉树叫做<code>完全二叉树</code>。</p><p>满二叉树很好理解，也很好识别，但是完全二叉树，有的人可能就分不清了。我画了几个完全二叉树和非完全二叉树的例子，你可以对比着看看：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/101.png" alt></p><p>想要存储一棵二叉树，我们有两种方法，<strong>一种是基于指针或者引用的二叉链式存储法，一种是基于数组的顺序存储法</strong>。我们先来看比较简单、直观的<code>链式存储法</code>。从图中你应该可以很清楚地看到，每个节点有三个字段，其中一个存储数据，另外两个是指向左右子节点的指针。我们只要拎住根节点，就可以通过左右子节点的指针，把整棵树都串起来。这种存储方式我们比较常用。大部分二叉树代码都是通过这种结构来实现的：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/102.png" alt></p><p>我们再来看，基于数组的<code>顺序存储法</code>。我们把根节点存储在下标 i=1 的位置，那左子节点存储在下标 2*i=2 的位置，右子节点存储在 2*i+1=3 的位置。以此类推，B 节点的左子节点存储在 2*i=2*2=4 的位置，右子节点存储在 2*i+1=2*2+1=5 的位置：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/103.png" alt></p><p>我来总结一下，如果节点 X 存储在数组中下标为 i 的位置，下标为 2*i 的位置存储的就是左子节点，下标为 2*i+1 的位置存储的就是右子节点。反过来，<strong>下标为 i/2 的位置存储就是它的父节点</strong>。通过这种方式，我们只要知道根节点存储的位置（一般情况下，<strong>为了方便计算子节点，根节点会存储在下标为 1 的位置</strong>），这样就可以通过下标计算，把整棵树都串起来。</p><p>不过，我刚刚举的例子是一棵完全二叉树，所以仅仅浪费了一个下标为 0 的存储位置。如果是<strong>非完全二叉树，其实会浪费比较多的数组存储空间</strong>。你可以看我举的下面这个例子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/104.png" alt></p><h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><p>经典的方法有三种，<code>前序遍历</code>、<code>中序遍历</code>和<code>后序遍历</code>。其中，前、中、后序，表示的是<strong>节点与它的左右子树节点遍历打印的先后顺序</strong>：</p><ul><li>前序遍历是指，对于树中的任意节点来说，先打印这个节点，然后再打印它的左子树，最后打印它的右子树；</li><li>中序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它本身，最后打印它的右子树；</li><li>后序遍历是指，对于树中的任意节点来说，先打印它的左子树，然后再打印它的右子树，最后打印这个节点本身；</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/105.png" alt></p><p>实际上，<strong>二叉树的前、中、后序遍历就是一个递归的过程</strong>。比如，前序遍历，其实就是先打印根节点，然后再递归地打印左子树，最后递归地打印右子树。写递归代码的关键，就是看能不能写出递推公式，而写递推公式的关键就是，<strong>如果要解决问题 A，就假设子问题 B、C 已经解决</strong>，然后再来看如何利用 B、C 来解决 A。所以，我们可以把前、中、后序遍历的递推公式都写出来：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 前序遍历的递推公式</span></span><br><span class="line">preOrder(r) = print r-&gt;preOrder(r-&gt;left)-&gt;preOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 中序遍历的递推公式</span></span><br><span class="line">inOrder(r) = inOrder(r-&gt;left)-&gt;print r-&gt;inOrder(r-&gt;right)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后序遍历的递推公式</span></span><br><span class="line">postOrder(r) = postOrder(r-&gt;left)-&gt;postOrder(r-&gt;right)-&gt;print r</span><br></pre></td></tr></table></figure><p>有了递推公式，代码写起来就简单多了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(Node* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">    preOrder(root-&gt;left);</span><br><span class="line">    preOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">inOrder</span><span class="params">(Node* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    inOrder(root-&gt;left);</span><br><span class="line">    print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">    inOrder(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postOrder</span><span class="params">(Node* root)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == null)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    postOrder(root-&gt;left);</span><br><span class="line">    postOrder(root-&gt;right);</span><br><span class="line">    print root <span class="comment">// 此处为伪代码，表示打印 root 节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从我前面画的前、中、后序遍历的顺序图，可以看出来，每个节点最多会被访问两次，所以<strong>遍历操作的时间复杂度，跟节点的个数 n 成正比</strong>，也就是说二叉树遍历的时间复杂度是 O(n)。</p><h2 id="二叉查找树（Binary-Search-Tree）"><a href="#二叉查找树（Binary-Search-Tree）" class="headerlink" title="二叉查找树（Binary Search Tree）"></a>二叉查找树（Binary Search Tree）</h2><p>二叉查找树是二叉树中最常用的一种类型，也叫二叉搜索树。顾名思义，二叉查找树是为了实现快速查找而生的。不过，它不仅仅支持快速查找一个数据，<strong>还支持快速插入、删除一个数据</strong>。这些都依赖于二叉查找树的特殊结构。二叉查找树要求，在树中的任意一个节点，其<strong>左子树中的每个节点的值，都要小于这个节点的值，而右子树节点的值都大于这个节点的值</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/106.png" alt></p><h3 id="二叉查找树的查找操作"><a href="#二叉查找树的查找操作" class="headerlink" title="二叉查找树的查找操作"></a>二叉查找树的查找操作</h3><p>首先，我们看如何在二叉查找树中查找一个节点。我们先取根节点，如果它等于我们要查找的数据，那就返回。如果要查找的数据比根节点的值小，那就在左子树中递归查找；如果要查找的数据比根节点的值大，那就在右子树中递归查找：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/107.png" alt></p><p>这里我把查找的代码实现了一下，贴在下面了，结合代码，理解起来会更加容易：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearchTree</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Node tree;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Node <span class="title">find</span><span class="params">(<span class="keyword">int</span> data)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Node p = tree;</span><br><span class="line">        <span class="keyword">while</span> (p != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (data &lt; p.data)</span><br><span class="line">            &#123;</span><br><span class="line">                p = p.left;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (data &gt; p.data) </span><br><span class="line">            &#123;</span><br><span class="line">                p = p.right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> data;</span><br><span class="line">        <span class="keyword">private</span> Node left;</span><br><span class="line">        <span class="keyword">private</span> Node right;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(<span class="keyword">int</span> data)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.data = data;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树的插入操作"><a href="#二叉查找树的插入操作" class="headerlink" title="二叉查找树的插入操作"></a>二叉查找树的插入操作</h3><p>二叉查找树的插入过程有点类似查找操作。<strong>如果要插入的数据比节点的数据大，并且节点的右子树为空，就将新数据直接插到右子节点的位置</strong>；如果不为空，就再递归遍历右子树，查找插入位置。同理，如果要插入的数据比节点数值小，并且节点的左子树为空，就将新数据插入到左子节点的位置；如果不为空，就再递归遍历左子树，查找插入位置：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/108.png" alt></p><p>同样，插入的代码我也实现了一下，贴在下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> data)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tree == <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        tree = <span class="keyword">new</span> Node(data);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node p = tree;</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p.data) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (p.right == <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                p.right = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// data &lt; p.data</span></span><br><span class="line">            <span class="keyword">if</span> (p.left == <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                p.left = <span class="keyword">new</span> Node(data);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉查找树的删除操作"><a href="#二叉查找树的删除操作" class="headerlink" title="二叉查找树的删除操作"></a>二叉查找树的删除操作</h3><p>二叉查找树的查找、插入操作都比较简单易懂，但是它的删除操作就比较复杂了。针对要删除节点的子节点个数的不同，我们需要分三种情况来处理：</p><ol><li>如果要删除的节点没有子节点，我们只需要直接将父节点中，指向要删除节点的指针置为 null。比如图中的删除节点 55；</li><li>如果要删除的节点只有一个子节点（只有左子节点或者右子节点），我们只需要更新父节点中，指向要删除节点的指针，让它指向要删除节点的子节点就可以了。比如图中的删除节点 13；</li><li>如果要删除的节点有两个子节点，这就比较复杂了。我们需要<strong>找到这个节点的右子树中的最小节点，把它替换到要删除的节点上</strong>。然后再删除掉这个最小节点，因为最小节点肯定没有左子节点（如果有左子结点，那就不是最小节点了），所以，我们可以<strong>应用上面两条规则来删除这个最小节点</strong>。比如图中的删除节点 18；</li></ol><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/109.png" alt></p><p>老规矩，我还是把删除的代码贴在这里：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">(<span class="keyword">int</span> data)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node p = tree;  <span class="comment">// p 指向要删除的节点，初始化指向根节点</span></span><br><span class="line">    Node pp = <span class="keyword">null</span>; <span class="comment">// pp 记录的是 p 的父节点</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span> &amp;&amp; p.data != data) </span><br><span class="line">    &#123;</span><br><span class="line">        pp = p;</span><br><span class="line">        <span class="keyword">if</span> (data &gt; p.data)</span><br><span class="line">        &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123; </span><br><span class="line">            p = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (p == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 没有找到</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 要删除的节点有两个子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) </span><br><span class="line">    &#123; </span><br><span class="line">        <span class="comment">// 查找右子树中最小节点</span></span><br><span class="line">        Node minP = p.right;</span><br><span class="line">        Node minPP = p; <span class="comment">// minPP 表示 minP 的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (minP.left != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            minPP = minP;</span><br><span class="line">            minP = minP.left;</span><br><span class="line">        &#125;</span><br><span class="line">        p.data = minP.data; <span class="comment">// 将 minP 的数据替换到 p 中，下面就变成了删除 minP 了</span></span><br><span class="line">        p = minP;</span><br><span class="line">        pp = minPP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 删除节点是叶子节点或者仅有一个子节点</span></span><br><span class="line">    Node child; <span class="comment">// p 的子节点</span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        child = p.left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (p.right != <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        child = p.right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        child = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pp == <span class="keyword">null</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 删除的是根节点</span></span><br><span class="line">        tree = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pp.left == p)</span><br><span class="line">    &#123;</span><br><span class="line">        pp.left = child;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pp.right = child;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，关于二叉查找树的删除操作，还有个非常简单、取巧的方法，就是<strong>单纯将要删除的节点标记为“已删除”，但是并不真正从树中将这个节点去掉</strong>。这样原本删除的节点还需要存储在内存中，比较浪费内存空间，但是删除操作就变得简单了很多。而且，这种处理方法也并没有增加插入、查找操作代码实现的难度。</p><h3 id="二叉查找树的其他操作"><a href="#二叉查找树的其他操作" class="headerlink" title="二叉查找树的其他操作"></a>二叉查找树的其他操作</h3><p>除了插入、删除、查找操作之外，二叉查找树中还可以支持<strong>快速地查找最大节点和最小节点、前驱节点和后继节点</strong>。二叉查找树除了支持上面几个操作之外，还有一个重要的特性，就是<strong>中序遍历二叉查找树，可以输出有序的数据序列，时间复杂度是 O(n)</strong>，非常高效。因此，二叉查找树也叫作二叉排序树。</p><h2 id="支持重复数据的二叉查找树"><a href="#支持重复数据的二叉查找树" class="headerlink" title="支持重复数据的二叉查找树"></a>支持重复数据的二叉查找树</h2><p>前面讲二叉查找树的时候，我们默认树中节点存储的都是数字。很多时候，<strong>在实际的软件开发中，我们在二叉查找树中存储的，是一个包含很多字段的对象</strong>。我们利用对象的某个字段作为键值（key）来构建二叉查找树。我们把对象中的其他字段叫作<code>卫星数据</code>。</p><p>如果存储的两个对象键值相同，我这里有两种解决方法：</p><ol><li>二叉查找树中每一个节点不仅会存储一个数据，因此我们<strong>通过链表和支持动态扩容的数组等数据结构</strong>，把值相同的数据都存储在同一个节点上；</li><li>比较不好理解，不过更加优雅。每个节点仍然只存储一个数据。在查找插入位置的过程中，如果碰到一个节点的值，与要插入数据的值相同，我们就将这个要插入的数据放到这个节点的右子树，也就是说，<strong>把这个新插入的数据当作大于这个节点的值来处理</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/110.png" alt><br> 当要查找数据的时候，遇到值相同的节点，我们并不停止查找操作，而是<strong>继续在右子树中查找，直到遇到叶子节点，才停止</strong>。这样就可以把键值等于要查找值的所有节点都找出来：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/111.png" alt><br> 对于删除操作，我们也需要先查找到每个要删除的节点，然后再<strong>按前面讲的删除操作的方法，依次删除</strong>：<br> <img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/112.png" alt></li></ol><h2 id="二叉查找树的时间复杂度分析"><a href="#二叉查找树的时间复杂度分析" class="headerlink" title="二叉查找树的时间复杂度分析"></a>二叉查找树的时间复杂度分析</h2><p>实际上，二叉查找树的形态各式各样。比如这个图中，对于同一组数据，我们构造了三种二叉查找树。它们的查找、插入、删除操作的执行效率都是不一样的。图中第一种二叉查找树，<strong>根节点的左右子树极度不平衡，已经退化成了链表</strong>，所以查找的时间复杂度就变成了 O(n)：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/113.png" alt></p><p>我刚刚其实分析了一种最糟糕的情况，我们现在来分析一个最理想的情况，二叉查找树是一棵完全二叉树（或满二叉树）。不管操作是插入、删除还是查找，<strong>时间复杂度其实都跟树的高度成正比，也就是 O(height)</strong>。对于完全二叉树来说，它包含的节点个数在 1 个到 2^(L-1) 个之间（我们假设最大层数是 L）。如果我们把每一层的节点个数加起来就是总的节点个数 n。也就是说，如果节点的个数是 n，那么 n 满足这样一个关系：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n &gt;= <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">8</span>+...+<span class="number">2</span>^(L-<span class="number">2</span>)+<span class="number">1</span></span><br><span class="line">n &lt;= <span class="number">1</span>+<span class="number">2</span>+<span class="number">4</span>+<span class="number">8</span>+...+<span class="number">2</span>^(L-<span class="number">2</span>)+<span class="number">2</span>^(L-<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>借助等比数列的求和公式，我们可以计算出，L 的范围是[log2(n+1), log2n + 1]。完全二叉树的层数小于等于 log2n + 1，也就是说，完全二叉树的高度小于等于 log2n。</p><h2 id="相对于散列表的优势"><a href="#相对于散列表的优势" class="headerlink" title="相对于散列表的优势"></a>相对于散列表的优势</h2><p>我们在散列表那节中讲过，散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1)，非常高效。而二叉查找树在比较平衡的情况下，插入、删除、查找操作时间复杂度才是 O(logn)，相对散列表，好像并没有什么优势，那我们为什么还要用二叉查找树呢：</p><ul><li>散列表中的数据是无序存储的，如果要<strong>输出有序的数据，需要先进行排序</strong>。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列；</li><li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的<strong>平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)</strong>；</li><li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但<strong>因为哈希冲突的存在，这个常量不一定比 logn 小</strong>，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高；</li><li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。<strong>平衡二叉查找树只需要考虑平衡性这一个问题</strong>，而且这个问题的解决方案比较成熟、固定；</li><li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会<strong>浪费一定的存储空间</strong>；</li></ul><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/invert-binary-tree/" target="_blank" rel="noopener">Invert Binary Tree</a><br><a href="https://leetcode.com/problems/maximum-depth-of-binary-tree/" target="_blank" rel="noopener">Maximum Depth of Binary Tree</a><br><a href="https://leetcode.com/problems/validate-binary-search-tree/" target="_blank" rel="noopener">Validate Binary Search Tree</a><br><a href="https://leetcode.com/problems/path-sum/" target="_blank" rel="noopener">Path Sum</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>哈希算法</title>
      <link href="2021/01/03/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/"/>
      <url>2021/01/03/%E5%93%88%E5%B8%8C%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是哈希算法？"><a href="#什么是哈希算法？" class="headerlink" title="什么是哈希算法？"></a>什么是哈希算法？</h2><p><strong>将任意长度的二进制值串映射为固定长度的二进制值串，这个映射的规则就是哈希算法</strong>，而通过原始数据映射之后得到的二进制值串就是<code>哈希值</code>。但是，要想设计一个优秀的哈希算法并不容易，根据我的经验，我总结了需要满足的几点要求：</p><ul><li>从哈希值不能反向推导出原始数据（所以哈希算法也叫单向哈希算法）；</li><li>对输入数据非常敏感，哪怕原始数据只修改了一个 bit，最后得到的哈希值也大不相同；</li><li>散列冲突的概率要很小，对于不同的原始数据，哈希值相同的概率非常小；</li><li>哈希算法的执行效率要尽量高效，针对较长的文本，也能快速地计算出哈希值；</li></ul><p>我们分别对“今天我来讲哈希算法”和“jiajia”这两个文本，计算 MD5 哈希值，得到两串看起来毫无规律的字符串（MD5 的哈希值是 128 位的 bit 长度，为了方便表示，我把它们转化成了 16 进制编码）。可以看出来，无论要哈希的文本有多长、多短，通过 MD5 哈希之后，得到的哈希值的长度都是相同的，而且得到的哈希值看起来像一堆随机数，完全没有规律：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(<span class="string">"今天我来讲哈希算法"</span>) = bb4767201ad42c74e650c1b6c03d78fa</span><br><span class="line">MD5(<span class="string">"jiajia"</span>) = cd611a31ea969b908932d44d126d195b</span><br></pre></td></tr></table></figure><p>我们再来看两个非常相似的文本，“我今天讲哈希算法！”和“我今天讲哈希算法”。这两个文本只有一个感叹号的区别。如果用 MD5 哈希算法分别计算它们的哈希值，你会发现，尽管只有一字之差，得到的哈希值也是完全不同的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MD5(<span class="string">"我今天讲哈希算法！"</span>) = <span class="number">425f</span>0d5a917188d2c3c3dc85b5e4f2cb</span><br><span class="line">MD5(<span class="string">"我今天讲哈希算法"</span>) = a1fb91ac128e6aa37fe42c663971ac3d</span><br></pre></td></tr></table></figure><p>通过哈希算法得到的哈希值，很难反向推导出原始数据。比如上面的例子中，我们就很难通过哈希值“a1fb91ac128e6aa37fe42c663971ac3d”反推出对应的文本“我今天讲哈希算法”。哈希算法要处理的文本可能是各种各样的。比如，对于非常长的文本，<strong>如果哈希算法的计算时间很长，那就只能停留在理论研究的层面，很难应用到实际的软件开发中</strong>。比如，我们把今天这篇包含 4000 多个汉字的文章，用 MD5 计算哈希值，用不了 1ms 的时间。</p><p>哈希算法的应用非常非常多，我选了最常见的七个，分别是：安全加密、唯一标识、数据校验、散列函数、负载均衡、数据分片、分布式存储。</p><a id="more"></a><h2 id="应用一：安全加密"><a href="#应用一：安全加密" class="headerlink" title="应用一：安全加密"></a>应用一：安全加密</h2><p>说到哈希算法的应用，最先想到的应该就是安全加密。最常用于加密的哈希算法是 <code>MD5</code>（MD5 Message-Digest Algorithm，MD5 消息摘要算法）和 <code>SHA</code>（Secure Hash Algorithm，安全散列算法）。除了这两个之外，当然还有很多其他加密算法，比如 <code>DES</code>（Data Encryption Standard，数据加密标准）、<code>AES</code>（Advanced Encryption Standard，高级加密标准）。</p><p>对用于加密的哈希算法来说，有两点格外重要。第一点是很难根据哈希值反向推导出原始数据，第二点是散列冲突的概率要很小。第一点很好理解，加密的目的就是防止原始数据泄露，所以很难通过哈希值反向推导原始数据，这是一个最基本的要求。所以我着重讲一下第二点。实际上，不管是什么哈希算法，我们<strong>只能尽量减少碰撞冲突的概率，理论上是没办法做到完全不冲突的</strong>。</p><p>我们知道，哈希算法产生的哈希值的长度是固定且有限的。比如前面举的 MD5 的例子，哈希值是固定的 128 位二进制串，能表示的数据是有限的，最多能表示 2^128 个数据，而我们要哈希的数据是无穷的。基于<code>鸽巢原理</code>，如果我们对 2^128+1 个数据求哈希值，就必然会存在哈希值相同的情况。这里你应该能想到，一般情况下，哈希值越长的哈希算法，散列冲突的概率越低：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2</span>^<span class="number">128</span>=<span class="number">340282366920938463463374607431768211456</span></span><br></pre></td></tr></table></figure><p>不过，即便哈希算法存在散列冲突的情况，但是因为哈希值的范围很大，冲突的概率极低，所以相对来说还是很难破解的。像 MD5，有 2^128 个不同的哈希值，这个数据已经是一个天文数字了，所以散列冲突的概率要小于 1/2^128。除此之外，没有绝对安全的加密。越复杂、越难破解的加密算法，需要的计算时间也越长。比如 SHA-256 比 SHA-1 要更复杂、更安全，相应的计算时间就会比较长。密码学界也一直致力于找到一种快速并且很难被破解的哈希算法。我们在实际的开发过程中，也<strong>需要权衡破解难度和计算时间，来决定究竟使用哪种加密算法</strong>。</p><h2 id="应用二：唯一标识"><a href="#应用二：唯一标识" class="headerlink" title="应用二：唯一标识"></a>应用二：唯一标识</h2><p>如果要在海量的图库中，搜索一张图是否存在，我们不能单纯地用图片的元信息（比如图片名称）来比对，因为有可能存在名称相同但图片内容不同，或者名称不同图片内容相同的情况。我们知道，任何文件在计算中都可以表示成二进制码串，所以，比较笨的办法就是，拿要查找的图片的二进制码串与图库中所有图片的二进制码串一一比对。如果相同，则说明图片在图库中存在。但是，<strong>每个图片小则几十 KB、大则几 MB，转化成二进制是一个非常长的串，比对起来非常耗时</strong>。</p><p>我们可以<strong>给每一个图片取一个唯一标识，或者说信息摘要</strong>。比如，我们可以从图片的二进制码串开头取 100 个字节，从中间取 100 个字节，从最后再取 100 个字节，然后将这 300 个字节放到一块，通过哈希算法（比如 MD5），得到一个哈希字符串，用它作为图片的唯一标识。通过这个唯一标识来判定图片是否在图库中，这样就可以减少很多工作量。</p><p>如果还想继续提高效率，我们可以<strong>把每个图片的唯一标识，和相应的图片文件在图库中的路径信息，都存储在散列表中</strong>。当要查看某个图片是不是在图库中的时候，我们先通过哈希算法对这个图片取唯一标识，然后在散列表中查找是否存在这个唯一标识。如果不存在，那就说明这个图片不在图库中；如果存在，我们再通过散列表中存储的文件路径，获取到这个已经存在的图片，跟现在要插入的图片做全量的比对，看是否完全一样。如果一样，就说明已经存在；如果不一样，说明两张图片尽管唯一标识相同，但是并不是相同的图片。</p><h2 id="应用三：数据校验"><a href="#应用三：数据校验" class="headerlink" title="应用三：数据校验"></a>应用三：数据校验</h2><p>BT 下载的原理是基于 P2P 协议的。我们从多个机器上并行下载一个 2GB 的电影，这个电影文件可能会被分割成很多文件块（比如可以分成 100 块，每块大约 20MB）。等所有的文件块都下载完成之后，再组装成一个完整的电影文件就行了。我们知道，<strong>网络传输是不安全的</strong>，下载的文件块有可能是被宿主机器恶意修改过的，又或者下载过程中出现了错误，所以下载的文件块可能不是完整的。如果我们没有能力检测这种恶意修改或者文件下载出错，就会导致最终合并后的电影无法观看，甚至导致电脑中毒。</p><p>我们通过哈希算法，对 100 个文件块分别取哈希值，并且保存在种子文件中。我们在前面讲过，哈希算法有一个特点，对数据很敏感。只要文件块的内容有一丁点儿的改变，最后计算出的哈希值就会完全不同。所以，当文件块下载完成之后，我们可以通过相同的哈希算法，<strong>对下载好的文件块逐一求哈希值，然后跟种子文件中保存的哈希值比对</strong>。如果不同，说明这个文件块不完整或者被篡改了，需要再重新从其他宿主机器上下载这个文件块。</p><h2 id="应用四：散列函数"><a href="#应用四：散列函数" class="headerlink" title="应用四：散列函数"></a>应用四：散列函数</h2><p>散列函数是设计一个散列表的关键。它直接决定了散列冲突的概率和散列表的性能。不过，相对哈希算法的其他应用，<strong>散列函数对于散列算法冲突的要求要低很多</strong>。即便出现个别散列冲突，只要不是过于严重，我们都可以通过开放寻址法或者链表法解决。不仅如此，散列函数对于散列算法计算得到的值，是否能反向解密也并不关心。散列函数中用到的散列算法，<strong>更加关注散列后的值是否能平均分布</strong>，也就是，一组数据是否能均匀地散列在各个槽中。除此之外，散列函数执行的快慢，也会影响散列表的性能，所以，<strong>散列函数用的散列算法一般都比较简单，比较追求效率</strong>。</p><h2 id="应用五：负载均衡"><a href="#应用五：负载均衡" class="headerlink" title="应用五：负载均衡"></a>应用五：负载均衡</h2><p>负载均衡算法有很多，比如轮询、随机、加权轮询等。那如何才能实现一个<code>会话粘滞</code>（Session Sticky）的负载均衡算法呢？也就是说，我们需要在同一个客户端上，在一次会话中的所有请求都路由到同一个服务器上。最直接的方法就是，维护一张映射关系表，这张表的内容是客户端 IP 地址或者会话 ID 与服务器编号的映射关系。客户端发出的每次请求，都要先在映射表中查找应该路由到的服务器编号，然后再请求编号对应的服务器。这种方法简单直观，但也有几个弊端：</p><ul><li>如果客户端很多，映射表可能会很大，比较浪费内存空间；</li><li>客户端下线、上线，服务器扩容、缩容都会导致映射失效，这样维护映射表的成本就会很大；</li></ul><p>如果借助哈希算法，这些问题都可以非常完美地解决。我们可以通过哈希算法，<strong>对客户端 IP 地址或者会话 ID 计算哈希值，将取得的哈希值与服务器列表的大小进行取模运算</strong>，最终得到的值就是应该被路由到的服务器编号。 这样，我们就可以把同一个 IP 过来的所有请求，都路由到同一个后端服务器上。</p><h2 id="应用六：数据分片"><a href="#应用六：数据分片" class="headerlink" title="应用六：数据分片"></a>应用六：数据分片</h2><p>哈希算法还可以用于数据的分片。我这里有两个例子：</p><ol><li>如何统计“搜索关键词”出现的次数？<br>假如我们有 1T 的日志文件，这里面记录了用户的搜索关键词，我们想要快速统计出每个关键词被搜索的次数。这个问题有两个难点，第一个是搜索日志很大，没办法放到一台机器的内存中。第二个难点是，如果只用一台机器来处理这么巨大的数据，处理时间会很长。<br> 针对这两个难点，我们可以<strong>先对数据进行分片，然后采用多台机器处理的方法，来提高处理速度</strong>。具体的思路是这样的：为了提高处理的速度，我们用 n 台机器并行处理。我们从搜索记录的日志文件中，依次读出每个搜索关键词，并且通过哈希函数计算哈希值，然后再跟 n 取模，最终得到的值，就是应该被分配到的机器编号。<br> 这样，哈希值相同的搜索关键词就被分配到了同一个机器上。也就是说，同一个搜索关键词会被分配到同一个机器上。每个机器会分别计算关键词出现的次数，最后合并起来就是最终的结果。实际上，这里的处理过程也是 MapReduce 的基本设计思想；</li><li>如何快速判断图片是否在图库中？<br>假设现在我们的图库中有 1 亿张图片，很显然，在单台机器上构建散列表是行不通的。因为单台机器的内存有限，而 1 亿张图片构建散列表显然远远超过了单台机器的内存上限。我们同样可以对数据进行分片，然后采用多机处理。我们准备 n 台机器，让<strong>每台机器只维护某一部分图片对应的散列表</strong>。我们每次从图库中读取一个图片，计算唯一标识，然后与机器个数 n 求余取模，得到的值就对应要分配的机器编号，然后将这个图片的唯一标识和图片路径发往对应的机器构建散列表。<br> 当我们要判断一个图片是否在图库中的时候，我们通过同样的哈希算法，计算这个图片的唯一标识，然后与机器个数 n 求余取模。假设得到的值是 k，那就去编号 k 的机器构建的散列表中查找。散列表中每个数据单元包含两个信息，哈希值和图片文件的路径。假设我们通过 MD5 来计算哈希值，那长度就是 128 比特，也就是 16 字节。文件路径长度的上限是 256 字节，我们可以假设平均长度是 128 字节。如果我们用链表法来解决冲突，那还需要存储指针，指针只占用 8 字节。所以，散列表中每个数据单元就占用 152 字节。<br> 假设一台机器的内存大小为 2GB，散列表的装载因子为 0.75，那一台机器可以给大约 1000 万（2GB*0.75/152）张图片构建散列表。所以，如果要对 1 亿张图片构建索引，需要大约十几台机器。在工程中，<strong>这种估算还是很重要的，能让我们事先对需要投入的资源、资金有个大概的了解</strong>，能更好地评估解决方案的可行性。实际上，针对这种海量数据的处理问题，我们都可以采用多机分布式处理。<strong>借助这种分片的思路，可以突破单机内存、CPU 等资源的限制</strong>；</li></ol><h2 id="应用七：分布式存储"><a href="#应用七：分布式存储" class="headerlink" title="应用七：分布式存储"></a>应用七：分布式存储</h2><p>现在互联网面对的都是海量的数据、海量的用户。我们为了提高数据的读取、写入能力，一般都采用分布式的方式来存储数据，比如分布式缓存。我们有海量的数据需要缓存，所以一个缓存机器肯定是不够的。于是，我们就需要将数据分布在多台机器上。我们可以借用前面数据分片的思想，即<strong>通过哈希算法对数据取哈希值，然后对机器个数取模，这个最终值就是应该存储的缓存机器编号</strong>。</p><p>但是，如果数据增多，原来的 10 个机器已经无法承受了，我们就需要扩容了，比如扩到 11 个机器，这时候麻烦就来了。因为，这里并不是简单地加个机器就可以了。原来的数据是通过与 10 来取模的。比如 13 这个数据，存储在编号为 3 这台机器上。但是新加了一台机器中，我们对数据按照 11 取模，原来 13 这个数据就被分配到 2 号这台机器上了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/95.png" alt></p><p>因此，所有的数据都要重新计算哈希值，然后重新搬移到正确的机器上。这样就相当于，缓存中的数据一下子就都失效了。所有的数据请求都会穿透缓存，直接去请求数据库。这样就可能发生<code>雪崩效应</code>，压垮数据库。所以，我们需要一种方法，使得在新加入一个机器后，并不需要做大量的数据搬移。这时候，<code>一致性哈希算法</code>就要登场了。</p><p>假设我们有 k 个机器，数据的哈希值的范围是 [0, MAX]。我们将整个范围划分成 m 个小区间（m 远大于 k），每个机器负责 m/k 个小区间。当有新机器加入的时候，我们就<strong>将某几个小区间的数据，从原来的机器中搬移到新的机器中</strong>。这样，既不用全部重新哈希、搬移数据，也保持了各个机器上数据数量的均衡。除了我们上面讲到的分布式缓存，实际上，一致性哈希算法的应用非常广泛，<strong>在很多分布式存储系统中，都可以见到一致性哈希算法的影子</strong>。</p><h2 id="如何防止数据库中的用户信息被脱库"><a href="#如何防止数据库中的用户信息被脱库" class="headerlink" title="如何防止数据库中的用户信息被脱库"></a>如何防止数据库中的用户信息被脱库</h2><p>如果用户信息被“脱库”，黑客虽然拿到是加密之后的密文，但可以通过“猜”的方式来破解密码，这是因为，有些用户的密码太简单。比如很多人习惯用 00000、123456 这样的简单数字组合做密码，很容易就被猜中。我们<strong>维护一个常用密码的字典表</strong>，把字典中的每个密码用哈希算法计算哈希值，然后拿哈希值跟脱库后的密文比对。如果相同，基本上就可以认为，这个加密之后的密码对应的明文就是字典中的这个密码。</p><p>针对字典攻击，我们可以引入一个<code>盐</code>（Salt），跟用户的密码组合在一起，增加密码的复杂度。我们拿组合之后的字符串来做哈希算法加密，将它存储到数据库中，进一步增加破解的难度。不过我这里想多说一句，我认为安全和攻击是一种博弈关系，不存在绝对的安全。<strong>所有的安全措施，只是增加攻击的成本而已</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>散列表</title>
      <link href="2021/01/02/%E6%95%A3%E5%88%97%E8%A1%A8/"/>
      <url>2021/01/02/%E6%95%A3%E5%88%97%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="散列思想"><a href="#散列思想" class="headerlink" title="散列思想"></a>散列思想</h2><p>散列表的英文叫“Hash Table”，我们平时也叫它“哈希表”或者“Hash 表”。散列表用的是数组支持按照下标随机访问数据的特性，所以<strong>散列表其实就是数组的一种扩展</strong>，由数组演化而来。可以说，如果没有数组，就没有散列表。</p><p>假设校长说，参赛编号不能设置得这么简单，要加上年级、班级这些更详细的信息，所以我们把编号的规则稍微修改了一下，用 6 位数字来表示。比如 051167，其中，前两位 05 表示年级，中间两位 11 表示班级，最后两位还是原来的编号 1 到 89。尽管我们不能直接把编号作为数组下标，但我们可以截取参赛编号的后两位作为数组下标，来存取选手信息数据。当通过参赛编号查询选手信息的时候，我们用同样的方法，取参赛编号的后两位，作为数组下标，来读取数组中的数据。</p><p>这就是典型的散列思想。其中，参赛选手的编号我们叫做<code>键值</code>。我们用它来标识一个选手。我们把参赛编号转化为数组下标的映射方法就叫作<code>散列函数</code>，而散列函数计算得到的值就叫作<code>散列值</code>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/83.png" alt></p><p>通过这个例子，我们可以总结出这样的规律：<strong>散列表用的就是数组支持按照下标随机访问的时候，时间复杂度是 O(1) 的特性</strong>。我们通过散列函数把元素的键值映射为下标，然后将数据存储在数组中对应下标的位置。当我们按照键值查询元素时，我们用同样的散列函数，将键值转化数组下标，从对应的数组下标的位置取数据。</p><a id="more"></a><h2 id="散列函数"><a href="#散列函数" class="headerlink" title="散列函数"></a>散列函数</h2><p>散列函数，顾名思义，它是一个函数。我们可以把它定义成 <strong>hash(key)</strong>，其中 key 表示元素的键值，hash(key) 的值表示经过散列函数计算得到的散列值。上面例子的散列函数稍微有点复杂：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获取后两位字符</span></span><br><span class="line">    <span class="built_in">string</span> lastTwoChars = key.substr(length<span class="number">-2</span>, length);</span><br><span class="line">    <span class="comment">// 将后两位字符转换为整数</span></span><br><span class="line">    <span class="keyword">int</span> hashValue = convert lastTwoChars to <span class="keyword">int</span>-type;</span><br><span class="line">    <span class="keyword">return</span> hashValue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果参赛选手的编号是随机生成的 6 位数字，又或者用的是 a 到 z 之间的字符串，该如何构造散列函数呢？我总结了三点散列函数设计的基本要求：</p><ol><li>散列函数计算得到的散列值是一个非负整数；</li><li>如果 key1 = key2，那 hash(key1) = hash(key2)；</li><li>如果 key1 ≠ key2，那 hash(key1) ≠ hash(key2)；</li></ol><p>其中，第一点理解起来应该没有任何问题。因为<strong>数组下标是从 0 开始的，所以散列函数生成的散列值也要是非负整数</strong>。第二点也很好理解。相同的 key，经过散列函数得到的散列值也应该是相同的。第三点理解起来可能会有问题，我着重说一下。这个要求看起来合情合理，但是在真实的情况下，要想找到一个不同的 key 对应的散列值都不一样的散列函数，几乎是不可能的。即便像业界著名的 MD5、SHA、CRC 等哈希算法，也无法完全避免这种<code>散列冲突</code>。而且，因为<strong>数组的存储空间有限，也会加大散列冲突的概率</strong>。</p><h2 id="散列冲突"><a href="#散列冲突" class="headerlink" title="散列冲突"></a>散列冲突</h2><p>我们几乎无法找到一个完美的无冲突的散列函数，即便能找到，付出的时间成本、计算成本也是很大的。我们常用的散列冲突解决方法有两类，开放寻址法（Open Addressing）和链表法（Chaining）。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法的核心思想是，<strong>如果出现了散列冲突，我们就重新探测一个空闲位置，将其插入</strong>。我先讲一个比较简单的探测方法，<code>线性探测</code>（Linear Probing）。当我们往散列表中插入数据时，如果某个数据经过散列函数散列之后，存储位置已经被占用了，我们就从当前位置开始，依次往后查找，看是否有空闲位置，直到找到为止。我说的可能比较抽象，我举一个例子具体给你说明一下。这里面黄色的色块表示空闲位置，橙色的色块表示已经存储了数据：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/84.png" alt></p><p>从图中可以看出，散列表的大小为 10，在元素 x 插入散列表之前，已经 6 个元素插入到散列表中。x 经过 Hash 算法之后，被散列到位置下标为 7 的位置，但是这个位置已经有数据了，所以就产生了冲突。于是我们就顺序地往后一个一个找，看有没有空闲的位置，<strong>遍历到尾部都没有找到空闲的位置，于是我们再从表头开始找</strong>，直到找到空闲位置 2，于是将其插入到这个位置。</p><p>在散列表中查找元素的过程有点儿类似插入过程。我们通过散列函数求出要查找元素的键值对应的散列值，然后比较数组中下标为散列值的元素和要查找的元素。如果相等，则说明就是我们要找的元素；否则就顺序往后依次查找。如果<strong>遍历到数组中的空闲位置，还没有找到，就说明要查找的元素并没有在散列表中</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/85.png" alt></p><p>散列表跟数组一样，不仅支持插入、查找操作，还支持删除操作。在查找的时候，一旦我们通过线性探测方法，找到一个空闲位置，我们就可以认定散列表中不存在这个数据。但是，如果这个空闲位置是我们后来删除的，就会导致原来的查找算法失效。本来存在的数据，会被认定为不存在。我们可以<strong>将删除的元素，特殊标记为 deleted</strong>。当线性探测查找的时候，遇到标记为 deleted 的空间，并不是停下来，而是继续往下探测：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/86.png" alt></p><p>当散列表中插入的数据越来越多时，散列冲突发生的可能性就会越来越大，空闲位置会越来越少，线性探测的时间就会越来越久。<strong>极端情况下，我们可能需要探测整个散列表</strong>，所以最坏情况下的时间复杂度为 O(n)。同理，在删除和查找时，也有可能会线性探测整张散列表，才能找到要查找或者删除的数据。</p><p>对于开放寻址冲突解决方法，除了线性探测方法之外，还有另外两种比较经典的探测方法，<code>二次探测</code>（Quadratic Probing）和<code>双重散列</code>（Double Hashing）。所谓二次探测，跟线性探测很像，线性探测每次探测的步长是 1，那它探测的下标序列就是 hash(key)+0, hash(key)+1, hash(key)+2, …；而二次探测探测的步长就变成了原来的“二次方”，也就是说，它探测的下标序列就是 hash(key)+0, hash(key)+1^2, hash(key)+2^2, …；</p><p>所谓双重散列，意思就是不仅要使用一个散列函数。我们使用一组散列函数 hash1(key), hash2(key), hash3(key), …；我们先用第一个散列函数，如果计算得到的存储位置已经被占用，再用第二个散列函数，依次类推，直到找到空闲的存储位置。</p><p>不管采用哪种探测方法，当散列表中空闲位置不多的时候，散列冲突的概率就会大大提高。为了尽可能保证散列表的操作效率，一般情况下，我们会尽可能保证散列表中有一定比例的空闲槽位。我们用<code>装载因子</code>（Load Factor）来表示空位的多少。装载因子的计算公式是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的装载因子 = 填入表中的元素个数 / 散列表的长度</span><br></pre></td></tr></table></figure><p>装载因子越大，说明空闲位置越少，冲突越多，散列表的性能会下降。</p><h3 id="链表法"><a href="#链表法" class="headerlink" title="链表法"></a>链表法</h3><p><strong>链表法是一种更加常用的散列冲突解决办法</strong>，相比开放寻址法，它要简单很多。我们来看这个图，在散列表中，每个“桶（Bucket）”或者“槽（Slot）”会对应一条链表，所有散列值相同的元素我们都放到相同槽位对应的链表中：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/87.png" alt></p><p>当插入的时候，我们只需要通过散列函数计算出对应的散列槽位，将其插入到对应链表中即可，所以插入的时间复杂度是 O(1)。当查找、删除一个元素时，我们同样通过散列函数计算出对应的槽，然后遍历链表查找或者删除。实际上，这两个操作的<strong>时间复杂度跟链表的长度 k 成正比，也就是 O(k)</strong>。对于散列比较均匀的散列函数来说，理论上讲，k=n/m，其中 n 表示散列中数据的个数，m 表示散列表中槽的个数。</p><h2 id="如何实现-Word-中的单词拼写检查"><a href="#如何实现-Word-中的单词拼写检查" class="headerlink" title="如何实现 Word 中的单词拼写检查"></a>如何实现 Word 中的单词拼写检查</h2><p>常用的英文单词有 20 万个左右，假设单词的平均长度是 10 个字母，平均一个单词占用 10 个字节的内存空间，那 20 万英文单词大约占 2MB 的存储空间，就算放大 10 倍也就是 20MB。对于现在的计算机来说，这个大小完全可以放在内存里面。所以我们可以用散列表来存储整个英文单词词典。</p><p>当用户输入某个英文单词时，我们拿用户输入的单词去散列表中查找。如果查到，则说明拼写正确；<strong>如果没有查到，则说明拼写可能有误，给予提示</strong>。借助散列表这种数据结构，我们就可以轻松实现快速判断是否存在拼写错误。</p><h2 id="如何设计散列函数？"><a href="#如何设计散列函数？" class="headerlink" title="如何设计散列函数？"></a>如何设计散列函数？</h2><p>散列函数设计的好坏，决定了散列表冲突的概率大小，也直接决定了散列表的性能。首先，<strong>散列函数的设计不能太复杂</strong>。过于复杂的散列函数，势必会消耗很多计算时间，也就间接地影响到散列表的性能；其次，<strong>散列函数生成的值要尽可能随机并且均匀分布</strong>，这样才能避免或者最小化散列冲突，而且即便出现冲突，散列到每个槽里的数据也会比较平均，不会出现某个槽内数据特别多的情况。</p><p>实际工作中，我们还需要综合考虑各种因素。这些因素有关键字的长度、特点、分布、还有散列表的大小等。散列函数各式各样，我举几个常用的、简单的散列函数的设计方法，让你有个直观的感受。第一个例子是学生运动会的例子，我们通过分析参赛编号的特征，把编号中的后两位作为散列值。我们还可以用类似的散列函数处理手机号码，因为手机号码前几位重复的可能性很大，但是后面几位就比较随机，我们可以取手机号的后四位作为散列值。这种散列函数的设计方法，我们一般叫做<code>数据分析法</code>。</p><p>第二个例子是 Word 的拼写检查功能。这里面的散列函数，我们就可以这样设计：将单词中每个字母的 ASCII 码值“进位”相加，然后再跟散列表的大小求余、取模，作为散列值。比如，英文单词 nice，我们转化出来的散列值就是下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash(<span class="string">"nice"</span>) = ((<span class="string">"n"</span>-<span class="string">"a"</span>) * <span class="number">26</span>*<span class="number">26</span>*<span class="number">26</span> + (<span class="string">"i"</span>-<span class="string">"a"</span>) * <span class="number">26</span>*<span class="number">26</span> + (<span class="string">"c"</span>-<span class="string">"a"</span>) * <span class="number">26</span> + (<span class="string">"e"</span>-<span class="string">"a"</span>)) / <span class="number">78978</span></span><br></pre></td></tr></table></figure><p>实际上，散列函数的设计方法还有很多，比如直接寻址法、平方取中法、折叠法、随机数法等，这些你只要了解就行了，不需要全都掌握。</p><h2 id="装载因子过大了怎么办？"><a href="#装载因子过大了怎么办？" class="headerlink" title="装载因子过大了怎么办？"></a>装载因子过大了怎么办？</h2><p>对于没有频繁插入和删除的静态数据集合来说，我们很容易根据数据的特点、分布等，设计出完美的、极少冲突的散列函数，因为毕竟之前数据都是已知的。<strong>对于动态散列表来说，数据集合是频繁变动的，我们事先无法预估将要加入的数据个数</strong>，所以我们也无法事先申请一个足够大的散列表。随着数据慢慢加入，装载因子就会慢慢变大。当装载因子大到一定程度之后，散列冲突就会变得不可接受。</p><p>针对散列表，当装载因子过大时，我们也可以进行<code>动态扩容</code>，重新申请一个更大的散列表，将数据搬移到这个新散列表中。假设每次扩容我们都申请一个原来散列表大小两倍的空间。如果原来散列表的装载因子是 0.8，那经过扩容之后，新散列表的装载因子就下降为原来的一半，变成了 0.4。但是，针对散列表的扩容，数据搬移操作要复杂很多。因为散列表的大小变了，数据的存储位置也变了，所以我们<strong>需要通过散列函数重新计算每个数据的存储位置</strong>。在原来的散列表中，21 这个元素原来存储在下标为 0 的位置，搬移到新的散列表中，存储在下标为 7 的位置：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/88.png" alt></p><p>插入一个数据，最好情况下，不需要扩容，最好时间复杂度是 O(1)。最坏情况下，散列表装载因子过高，启动扩容，我们需要重新申请内存空间，重新计算哈希位置，并且搬移数据，所以时间复杂度是 O(n)。用摊还分析法，均摊情况下，时间复杂度接近最好情况，就是 O(1)。实际上，对于动态散列表，随着数据的删除，散列表中的数据会越来越少，空闲空间会越来越多。如果我们对空间消耗非常敏感，我们<strong>可以在装载因子小于某个值之后，启动动态缩容</strong>。当然，如果我们更加在意执行效率，能够容忍多消耗一点内存空间，那就可以不用费劲来缩容了。</p><p>当散列表的装载因子超过某个阈值时，就需要进行扩容。装载因子阈值需要选择得当，<strong>如果太大，会导致冲突过多；如果太小，会导致内存浪费严重</strong>。装载因子阈值的设置要权衡时间、空间复杂度。如果内存空间不紧张，对执行效率要求很高，可以降低负载因子的阈值；相反，如果内存空间紧张，对执行效率要求又不高，可以增加负载因子的值，甚至可以大于 1。</p><h2 id="如何避免低效的扩容？"><a href="#如何避免低效的扩容？" class="headerlink" title="如何避免低效的扩容？"></a>如何避免低效的扩容？</h2><p>大部分情况下，动态扩容的散列表插入一个数据都很快，但是在特殊情况下，<strong>当装载因子已经到达阈值，需要先进行扩容，再插入数据</strong>。这个时候，插入数据就会变得很慢，甚至会无法接受。我举一个极端的例子，如果散列表当前大小为 1GB，要想扩容为原来的两倍大小，那就需要对 1GB 的数据重新计算哈希值，并且从原来的散列表搬移到新的散列表。如果我们的业务代码直接服务于用户，尽管大部分情况下，插入一个数据的操作都很快，但是，极个别非常慢的插入操作，也会让用户崩溃。这个时候，一次性扩容的机制就不合适了。</p><p>为了解决一次性扩容耗时过多的情况，我们<strong>可以将扩容操作穿插在插入操作的过程中，分批完成</strong>。当装载因子触达阈值之后，我们只申请新空间，但并不将老的数据搬移到新散列表中。当有新数据要插入时，我们将新数据插入新散列表中，并且从老的散列表中拿出一个数据放入到新散列表。每次插入一个数据到散列表，我们都重复上面的过程。经过多次插入操作之后，老的散列表中的数据就一点一点全部搬移到新散列表中了。这样没有了集中的一次性数据搬移，插入操作就都变得很快了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/89.png" alt></p><p>对于查询操作，为了兼容了新、老散列表中的数据，我们<strong>先从新散列表中查找，如果没有找到，再去老的散列表中查找</strong>。通过这样均摊的方法，将一次性扩容的代价，均摊到多次插入操作中，就避免了一次性扩容耗时过多的情况。这种实现方式，任何情况下，插入一个数据的时间复杂度都是 O(1)。</p><h2 id="如何选择冲突解决方法？"><a href="#如何选择冲突解决方法？" class="headerlink" title="如何选择冲突解决方法？"></a>如何选择冲突解决方法？</h2><p>开放寻址法和链表法在实际的软件开发中都非常常用。比如，Java 中 LinkedHashMap 就采用了链表法解决冲突，ThreadLocalMap 是通过线性探测的开放寻址法来解决冲突。</p><h3 id="开放寻址法-1"><a href="#开放寻址法-1" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p>开放寻址法不像链表法，需要拉很多链表。散列表中的数据都存储在数组中，可以<strong>有效地利用 CPU 缓存加快查询速度</strong>。而且，这种方法实现的散列表，序列化起来比较简单。链表法包含指针，序列化起来就没那么容易。</p><p>用开放寻址法解决冲突的散列表，删除数据的时候比较麻烦，需要特殊标记已经删除掉的数据。而且，在开放寻址法中，所有的数据都存储在一个数组中，<strong>比起链表法来说，冲突的代价更高</strong>。所以，使用开放寻址法解决冲突的散列表，装载因子的上限不能太大。这也导致这种方法比链表法更浪费内存空间。</p><p>我总结一下，<strong>当数据量比较小、装载因子小的时候，适合采用开放寻址法</strong>。这也是 Java 中的 ThreadLocalMap 使用开放寻址法解决散列冲突的原因。</p><h3 id="链表法-1"><a href="#链表法-1" class="headerlink" title="链表法"></a>链表法</h3><p><strong>链表法对内存的利用率比开放寻址法要高</strong>。因为链表结点可以在需要的时候再创建，并不需要像开放寻址法那样事先申请好。链表法比起开放寻址法，<strong>对大装载因子的容忍度更高</strong>。开放寻址法只能适用装载因子小于 1 的情况。接近 1 时，就可能会有大量的散列冲突，导致大量的探测、再散列等，性能会下降很多。但是对于链表法来说，只要散列函数的值随机均匀，即便装载因子变成 10，也就是链表的长度变长了而已，虽然查找效率有所下降，但是比起顺序查找还是快很多。</p><p>实际上，我们对链表法稍加改造，可以实现一个更加高效的散列表。那就是，我们<strong>将链表法中的链表改造为其他高效的动态数据结构</strong>，比如跳表、红黑树。这样，即便出现散列冲突，极端情况下，所有的数据都散列到同一个桶内，那最终退化成的散列表的查找时间也只不过是 O(logn)。这样也就有效避免了散列碰撞攻击：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/90.png" alt></p><p>我总结一下，基于链表的散列冲突处理方法<strong>比较适合存储大对象、大数据量的散列表</strong>，而且，比起开放寻址法，它更加灵活，支持更多的优化策略，比如用红黑树代替链表。</p><h2 id="工业级散列表举例分析"><a href="#工业级散列表举例分析" class="headerlink" title="工业级散列表举例分析"></a>工业级散列表举例分析</h2><p>现在，我就拿一个具体的例子，Java 中的 HashMap 这样一个工业级的散列表，来具体看下，这些技术是怎么应用的：</p><ol><li>初始大小：<br>HashMap 默认的初始大小是 16，当然这个默认值是可以设置的，如果事先知道大概的数据量有多大，可以通过修改默认初始大小，减少动态扩容的次数，这样会大大提高 HashMap 的性能；</li><li>装载因子和动态扩容：<br>最大装载因子默认是 0.75，当 HashMap 中元素个数超过 capacity*0.75 的时候，就会启动扩容，每次扩容都会扩容为原来的两倍大小；</li><li>散列冲突解决方法：<br>在 JDK1.8 版本中，为了对 HashMap 做进一步优化，我们引入了红黑树。而当链表长度太长（默认超过 8）时，链表就转换为红黑树。我们可以利用红黑树快速增删改查的特点，提高 HashMap 的性能。当红黑树结点个数少于 8 个的时候，又会将红黑树转化为链表。因为在数据量较小的情况下，红黑树要维护平衡，比起链表来，性能上的优势并不明显；</li><li>散列函数：<br>散列函数的设计并不复杂，追求的是简单高效、分布均匀：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> h = key.hashCode()；</span><br><span class="line">    <span class="keyword">return</span> (h ^ (h &gt;&gt;&gt; <span class="number">16</span>)) &amp; (capacity - <span class="number">1</span>); <span class="comment">// capacity 表示散列表的大小</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="如何设计一个工业级的散列函数"><a href="#如何设计一个工业级的散列函数" class="headerlink" title="如何设计一个工业级的散列函数"></a>如何设计一个工业级的散列函数</h2><p>在极端情况下，有些恶意的攻击者，还有可能通过精心构造的数据，使得所有的数据经过散列函数之后，都散列到同一个槽里。如果我们使用的是基于链表的冲突解决方法，那这个时候，<strong>散列表就会退化为链表，查询的时间复杂度就从 O(1) 急剧退化为 O(n)</strong>。</p><p>如果散列表中有 10 万个数据，退化后的散列表查询的效率就下降了 10 万倍。更直接点说，如果之前运行 100 次查询只需要 0.1 秒，那现在就需要 1 万秒。这样就有可能因为查询操作消耗大量 CPU 或者线程资源，导致系统无法响应其他请求，从而达到<code>拒绝服务攻击</code>（DoS）的目的。这也就是散列表碰撞攻击的基本原理。</p><p>工业级的散列表应该具有哪些特性：</p><ul><li>支持快速地查询、插入、删除操作；</li><li>内存占用合理，不能浪费过多的内存空间；</li><li>性能稳定，极端情况下，散列表的性能也不会退化到无法接受的情况；</li></ul><p>根据前面讲到的知识，我会从这三个方面来考虑设计思路：</p><ul><li>设计一个合适的散列函数；</li><li>定义装载因子阈值，并且设计动态扩容策略；</li><li>选择合适的散列冲突解决方法；</li></ul><h2 id="LRU-缓存淘汰算法"><a href="#LRU-缓存淘汰算法" class="headerlink" title="LRU 缓存淘汰算法"></a>LRU 缓存淘汰算法</h2><p>一个缓存（Cache）系统主要包含下面这几个操作：</p><ul><li>往缓存中添加一个数据；</li><li>从缓存中删除一个数据；</li><li>在缓存中查找一个数据；</li></ul><p><strong>这三个操作都要涉及查找操作</strong>，如果单纯地采用链表的话，时间复杂度只能是 O(n)。如果我们将散列表和链表两种数据结构组合使用，可以将这三个操作的时间复杂度都降低到 O(1)。具体的结构就是下面这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/91.png" alt></p><p>我们使用双向链表存储数据，链表中的每个结点处理存储数据（data）、前驱指针（prev）、后继指针（next）之外，还新增了一个特殊的字段 <code>hnext</code>。因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在两条链中。一个链是刚刚我们提到的双向链表，另一个链是散列表中的拉链。<strong>前驱和后继指针是为了将结点串在双向链表中，hnext 指针是为了将结点串在散列表的拉链中</strong>。</p><p>我们再来看，前面讲到的缓存的三个操作，是如何做到时间复杂度是 O(1) 的：</p><ul><li>如何查找一个数据：<br>散列表中查找数据的时间复杂度接近 O(1)，所以通过散列表，我们可以很快地在缓存中找到一个数据。当找到数据之后，我们还需要将它移动到双向链表的尾部；</li><li>如何删除一个数据：<br>我们需要找到数据所在的结点，然后将结点删除。借助散列表，我们可以在 O(1) 时间复杂度里找到要删除的结点。因为我们的链表是双向链表，双向链表可以通过前驱指针 O(1) 时间复杂度获取前驱结点，所以在双向链表中，删除结点只需要 O(1) 的时间复杂度；</li><li>如何添加一个数据：<br>添加数据到缓存稍微有点麻烦，我们需要先看这个数据是否已经在缓存中。如果已经在其中，需要将其移动到双向链表的尾部；如果不在其中，还要看缓存有没有满。如果满了，则将双向链表头部的结点删除，然后再将数据放到链表的尾部；如果没有满，就直接将数据放到链表的尾部；</li></ul><p>这整个过程涉及的查找操作都可以通过散列表来完成。其他的操作，比如删除头结点、链表尾部插入数据等，都可以在 O(1) 的时间复杂度内完成。所以，这三个操作的时间复杂度都是 O(1)。至此，我们就<strong>通过散列表和双向链表的组合使用，实现了一个高效的、支持 LRU 缓存淘汰算法的缓存系统原型</strong>。</p><h2 id="Redis-有序集合"><a href="#Redis-有序集合" class="headerlink" title="Redis 有序集合"></a>Redis 有序集合</h2><p>在有序集合中，每个成员对象有两个重要的属性，<code>key</code>（键值）和 <code>score</code>（分值）。我们不仅会通过 score 来查找数据，还会通过 key 来查找数据。举个例子，比如用户积分排行榜有这样一个功能：我们可以通过用户的 ID 来查找积分信息，也可以通过积分区间来查找用户 ID 或者姓名信息。这里包含 ID、姓名和积分的用户信息，就是成员对象，用户 ID 就是 key，积分就是 score。</p><p>所以，如果我们细化一下 Redis 有序集合的操作，那就是下面这样：</p><ul><li>添加一个成员对象；</li><li>按照键值来删除一个成员对象；</li><li>按照键值来查找一个成员对象；</li><li>按照分值区间查找数据，比如查找积分在 [100, 356] 之间的成员对象；</li><li>按照分值从小到大排序成员变量；</li></ul><p>如果我们仅仅按照分值将成员对象组织成跳表的结构，那按照键值来删除、查询成员对象就会很慢，解决方法与 LRU 缓存淘汰算法的解决方法类似。我们可以再<strong>按照键值构建一个散列表，这样按照 key 来删除、查找一个成员对象的时间复杂度就变成了 O(1)</strong>。同时，借助跳表结构，其他操作也非常高效。</p><h2 id="Java-LinkedHashMap"><a href="#Java-LinkedHashMap" class="headerlink" title="Java LinkedHashMap"></a>Java LinkedHashMap</h2><p>如果你熟悉 Java，那你几乎天天会用到 LinkedHashMap 容器。我们之前讲过，HashMap 底层是通过散列表这种数据结构实现的。我们先来看一段代码。你觉得这段代码会以什么样的顺序打印 3, 1, 5, 2 这几个 key 呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line">m.put(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">m.put(<span class="number">5</span>, <span class="number">23</span>);</span><br><span class="line">m.put(<span class="number">2</span>, <span class="number">22</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : m.entrySet()) &#123;</span><br><span class="line">    System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap 也是通过散列表和链表组合在一起实现的。上面的代码会按照数据插入的顺序依次来打印，也就是说，打印的顺序就是 3, 1, 5, 2。实际上，它<strong>不仅支持按照插入顺序遍历数据，还支持按照访问顺序来遍历数据</strong>。你可以看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 10 是初始大小，0.75 是装载因子，true 是表示按照访问时间排序</span></span><br><span class="line">HashMap&lt;Integer, Integer&gt; m = <span class="keyword">new</span> LinkedHashMap&lt;&gt;(<span class="number">10</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">11</span>);</span><br><span class="line">m.put(<span class="number">1</span>, <span class="number">12</span>);</span><br><span class="line">m.put(<span class="number">5</span>, <span class="number">23</span>);</span><br><span class="line">m.put(<span class="number">2</span>, <span class="number">22</span>);</span><br><span class="line">m.put(<span class="number">3</span>, <span class="number">26</span>);</span><br><span class="line">m.get(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span> (Map.Entry e : m.entrySet()) &#123;</span><br><span class="line">    System.out.println(e.getKey());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码打印的结果是 1, 2, 3, 5。每次调用 put() 函数，往 LinkedHashMap 中添加数据的时候，都会将数据添加到链表的尾部，所以，在前四个操作完成之后，链表中的数据是下面这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/92.png" alt></p><p>在第 7 行代码中，再次将键值为 3 的数据放入到 LinkedHashMap 的时候，会先查找这个键值是否已经有了，然后，再将已经存在的 (3, 11) 删除，并且将新的 (3, 26) 放到链表的尾部。所以，这个时候链表中的数据就是下面这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/93.png" alt></p><p>当第 8 行代码访问到 key 为 5 的数据的时候，我们将被访问到的数据移动到链表的尾部。所以，第 8 行代码之后，链表中的数据是下面这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/94.png" alt></p><p>所以，最后打印出来的数据是 1, 2, 3, 5。从上面的分析，我们可以发现，按照访问时间排序的 LinkedHashMap 本身就是一个支持 LRU 缓存淘汰策略的缓存系统。实际上，LinkedHashMap 是通过双向链表和散列表这两种数据结构组合实现的。<strong>LinkedHashMap 中的 Linked 实际上是指的是双向链表，并非指用链表法解决散列冲突</strong>。</p><h2 id="为什么散列表和链表经常一起使用"><a href="#为什么散列表和链表经常一起使用" class="headerlink" title="为什么散列表和链表经常一起使用"></a>为什么散列表和链表经常一起使用</h2><p>散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作，但是散列表中的数据都是通过散列函数打乱之后无规律存储的。也就说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列表中的数据拷贝到数组中，然后排序，再遍历。因为散列表是动态数据结构，不停地有数据的插入、删除，所以<strong>每当我们希望按顺序遍历散列表中的数据的时候，都需要先排序，那效率势必会很低</strong>。为了解决这个问题，我们将散列表和链表（或者跳表）结合在一起使用。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>跳表</title>
      <link href="2020/12/31/%E8%B7%B3%E8%A1%A8/"/>
      <url>2020/12/31/%E8%B7%B3%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p>我们只需要对链表稍加改造，就可以支持类似“二分”的查找算法。我们把改造之后的数据结构叫做<code>跳表</code>（Skip List）。它是一种<strong>各方面性能都比较优秀的动态数据结构</strong>，可以支持快速地插入、删除、查找操作，写起来也不复杂，甚至可以替代红黑树。</p><h2 id="如何理解“跳表”？"><a href="#如何理解“跳表”？" class="headerlink" title="如何理解“跳表”？"></a>如何理解“跳表”？</h2><p>对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是 O(n)：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/72.png" alt></p><p>如果像图中那样，对链表建立一级“索引”，每两个结点提取一个结点到上一级，我们把抽出来的那一级叫做<code>索引层</code>。图中的 down 表示 down 指针，指向下一级结点：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/73.png" alt></p><p>如果我们现在要查找某个结点，比如 16。我们可以先在索引层遍历，当遍历到索引层中值为 13 的结点时，我们发现下一个结点是 17，那要查找的结点 16 肯定就在这两个结点之间。然后我们通过索引层结点的 down 指针，下降到原始链表这一层，继续遍历。这个时候，我们只需要再遍历 2 个结点，就可以找到值等于 16 的这个结点了。这样，<strong>原来如果要查找 16，需要遍历 10 个结点，现在只需要遍历 7 个结点</strong>。</p><a id="more"></a><p>从这个例子里，我们看出，加来一层索引之后，<strong>查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了</strong>。跟前面建立第一级索引的方式相似，我们在第一级索引的基础之上，每两个结点就抽出一个结点到第二级索引。现在我们再来查找 16，只需要遍历 6 个结点了，需要遍历的结点数量又减少了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/74.png" alt></p><p>我举的例子数据量不大，所以即便加了两级索引，查找效率的提升也并不明显。为了让你能真切地感受索引提升查询效率。我画了一个包含 64 个结点的链表，按照前面讲的这种思路，建立了五级索引：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/75.png" alt></p><p>从图中我们可以看出，原来没有索引的时候，查找 62 需要遍历 62 个结点，现在只需要遍历 11 个结点。所以，当链表的长度 n 比较大时，比如 1000、10000 的时候，在构建索引之后，查找效率的提升就会非常明显。这种<strong>链表加多级索引的结构，就是跳表</strong>。我通过例子给你展示了跳表是如何减少查询次数的，现在你应该比较清晰地知道，跳表确实是可以提高查询效率的。</p><h2 id="用跳表查询到底有多快？"><a href="#用跳表查询到底有多快？" class="headerlink" title="用跳表查询到底有多快？"></a>用跳表查询到底有多快？</h2><p>按照我们刚才讲的，每两个结点会抽出一个结点作为上一级索引的结点，那第一级索引的结点个数大约就是 n/2，第二级索引的结点个数大约就是 n/4，第三级索引的结点个数大约就是 n/8，依次类推，也就是说，第 k 级索引的结点个数是第 k-1 级索引的结点个数的 1/2，那第 k 级索引结点的个数就是 n/(2^k)。</p><p><strong>假设索引有 h 级，最高级的索引有 2 个结点</strong>。通过上面的公式，我们可以得到 n/(2^h)=2，从而求得 h=log2n-1。如果包含原始链表这一层，整个跳表的高度就是 log2n。我们在跳表中查询某个数据的时候，如果每一层都要遍历 m 个结点，那在跳表中查询一个数据的时间复杂度就是 O(m*logn)。</p><p>假设我们要查找的数据是 x，在第 k 级索引中，我们遍历到 y 结点之后，发现 x 大于 y，小于后面的结点 z，所以我们通过 y 的 down 指针，从第 k 级索引下降到第 k-1 级索引。在第 k-1 级索引中，y 和 z 之间只有 3 个结点（包含 y 和 z），所以，我们在 k-1 级索引中最多只需要遍历 3 个结点，依次类推，<strong>每一级索引都最多只需要遍历 3 个结点</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/76.png" alt></p><p>通过上面的分析，我们得到 m=3，所以在跳表中查询任意数据的时间复杂度就是 O(logn)。这个查找的时间复杂度跟二分查找是一样的。换句话说，我们其实是基于单链表实现了二分查找。这种<strong>查询效率的提升，前提是建立了很多级索引</strong>，也就是空间换时间的设计思路。</p><h2 id="跳表是不是很浪费内存？"><a href="#跳表是不是很浪费内存？" class="headerlink" title="跳表是不是很浪费内存？"></a>跳表是不是很浪费内存？</h2><p>跳表的空间复杂度分析并不难，我在前面说了，假设原始链表大小为 n，那第一级索引大约有 n/2 个结点，第二级索引大约有 n/4 个结点，以此类推，每上升一级就减少一半，直到剩下 2 个结点。如果我们把每层索引的结点数写出来，就是一个等比数列：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/77.png" alt></p><p>这几级索引的结点总和就是 n/2+n/4+n/8+…+8+4+2=n-2。所以，跳表的空间复杂度是 O(n)。也就是说，如果将包含 n 个结点的单链表构造成跳表，我们需要额外再用接近 n 个结点的存储空间。如果我们每三个结点或五个结点，抽一个结点到上级索引，是不是就不用那么多索引结点了呢？我画了一个每三个结点抽一个的示意图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/78.png" alt></p><p>从图中可以看出，第一级索引需要大约 n/3 个结点，第二级索引需要大约 n/9 个结点。每往上一级，索引结点个数都除以 3。为了方便计算，我们假设最高一级的索引结点个数是 1。我们把每级索引的结点个数都写下来，也是一个等比数列：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/79.png" alt></p><p>通过等比数列求和公式，总的索引结点大约就是 n/3+n/9+n/27+…+9+3+1=n/2。尽管空间复杂度还是 O(n)，但比上面的每两个结点抽一个结点的索引构建方法，要<strong>减少了一半的索引结点存储空间</strong>。实际上，在软件开发中，我们不必太在意索引占用的额外空间。在讲数据结构和算法时，我们习惯性地把要处理的数据看成整数，但是在实际的软件开发中，原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，所以<strong>当对象比索引结点大很多时，索引占用的额外空间就可以忽略</strong>。</p><h2 id="高效的动态插入和删除"><a href="#高效的动态插入和删除" class="headerlink" title="高效的动态插入和删除"></a>高效的动态插入和删除</h2><p>跳表这个动态数据结构，不仅支持查找操作，还支持动态的插入、删除操作，而且插入、删除操作的时间复杂度也是 O(logn)。我们知道，在单链表中，<strong>一旦定位好要插入的位置，插入结点的时间复杂度是很低的</strong>，就是 O(1)。但是，这里为了保证原始链表中数据的有序性，我们需要先找到要插入的位置，这个查找操作就会比较耗时。</p><p>对于纯粹的单链表，需要遍历每个结点，来找到插入的位置。但是，对于跳表来说，我们讲过查找某个结点的时间复杂度是 O(logn)，所以这里查找某个数据应该插入的位置，方法也是类似的，时间复杂度也是 O(logn)。我画了一张图，你可以很清晰地看到插入的过程：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/80.png" alt></p><p>如果这个结点在索引中也有出现，我们除了要删除原始链表中的结点，还要删除索引中的。因为单链表中的删除操作需要拿到要删除结点的前驱结点，然后通过指针操作完成删除。所以<strong>在查找要删除的结点的时候，一定要获取前驱结点</strong>。当然，如果我们用的是双向链表，就不需要考虑这个问题了。</p><h2 id="跳表索引动态更新"><a href="#跳表索引动态更新" class="headerlink" title="跳表索引动态更新"></a>跳表索引动态更新</h2><p>当我们不停地往跳表中插入数据时，<strong>如果我们不更新索引，就有可能出现某 2 个索引结点之间数据非常多的情况</strong>。极端情况下，跳表还会退化成单链表：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/81.png" alt></p><p>作为一种动态数据结构，我们<strong>需要某种手段来维护索引与原始链表大小之间的平衡</strong>，也就是说，如果链表中结点多了，索引结点就相应地增加一些，避免复杂度退化，以及查找、插入、删除操作性能下降。如果你了解红黑树、AVL 树这样平衡二叉树，你就知道它们是通过左右旋的方式保持左右子树的大小平衡，而跳表是通过<code>随机函数</code>来维护前面提到的平衡性。</p><p>我们通过一个随机函数，来决定将这个结点插入到哪几级索引中，比如<strong>随机函数生成了值 k，那我们就将这个结点添加到第一级到第 k 级这 k 级索引中</strong>。随机函数的选择很有讲究，从概率上来讲，能够保证跳表的索引大小和数据大小平衡性，不至于性能过度退化：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/82.png" alt></p><h2 id="为什么-Redis-要用跳表来实现有序集合"><a href="#为什么-Redis-要用跳表来实现有序集合" class="headerlink" title="为什么 Redis 要用跳表来实现有序集合"></a>为什么 Redis 要用跳表来实现有序集合</h2><p>Redis 中的<code>有序集合</code>（Sorted Set）是通过跳表来实现的，如果你去查看 Redis 的开发手册，就会发现，Redis 中的有序集合支持的核心操作主要有下面这几个：</p><ul><li>插入、删除、查找一个数据；</li><li>迭代输出有序序列；</li><li>按照区间查找数据（比如查找值在[100, 356]之间的数据）；</li></ul><p>其中，插入、删除、查找以及迭代输出有序序列这几个操作，红黑树也可以完成，时间复杂度跟跳表是一样的。但是，<strong>按照区间来查找数据这个操作，红黑树的效率没有跳表高</strong>。对于按照区间查找数据这个操作，跳表可以做到 O(logn) 的时间复杂度定位区间的起点，然后在原始链表中顺序往后遍历就可以了。这样做非常高效。</p><p>当然，Redis 之所以用跳表来实现有序集合，还有其他原因，比如，跳表更容易代码实现。虽然跳表的实现也不简单，但<strong>比起红黑树来说还是好懂、好写多了，而简单就意味着可读性好，不容易出错</strong>。还有，跳表更加灵活，它可以通过改变索引构建策略，有效平衡执行效率和内存消耗。</p><p>不过，跳表也不能完全替代红黑树。因为红黑树比跳表的出现要早一些，很多编程语言中的 Map 类型都是通过红黑树来实现的。我们做业务开发的时候，直接拿来用就可以了，不用费劲自己去实现一个红黑树，但是跳表并没有一个现成的实现，所以<strong>在开发中，如果你想使用跳表，必须要自己实现</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找</title>
      <link href="2020/12/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
      <url>2020/12/31/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<p><code>二分查找</code>（Binary Search）算法，也叫折半查找算法。二分查找的思想非常简单，很多非计算机专业的同学很容易就能理解，但是看似越简单的东西往往越难掌握好，想要灵活应用就更加困难。</p><h2 id="无处不在的二分思想"><a href="#无处不在的二分思想" class="headerlink" title="无处不在的二分思想"></a>无处不在的二分思想</h2><p>我们现在来做一个猜字游戏：我随机写一个 0 到 99 之间的数字，然后你来猜我写的是什么。猜的过程中，你每猜一次，我就会告诉你猜的大了还是小了，直到猜中为止。假设我写的数字是 23，你可以按照下面的步骤来试一试：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/68.png" alt></p><a id="more"></a><p>假设有 1000 条订单数据，已经按照订单金额从小到大排序，每个订单金额都不同，并且最小单位是元。我们现在想知道是否存在金额等于 19 元的订单。如果存在，则返回订单数据，如果不存在则返回 null。为了方便讲解，我们假设只有 10 个订单，订单金额分别是：8, 11, 19, 23, 27, 33, 45, 55, 67, 98。还是利用二分思想，每次都与区间的中间数据比对大小，缩小查找区间的范围。为了更加直观，我画了一张查找过程的图。其中，low 和 high 表示待查找区间的下标，mid 表示待查找区间的中间元素下标：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/69.png" alt></p><p>二分查找针对的是一个<strong>有序的数据集合</strong>，查找思想有点类似分治思想。每次都通过跟区间的中间元素对比，将待查找的区间缩小为之前的一半，<strong>直到找到要查找的元素，或者区间被缩小为 0</strong>。</p><h2 id="O-logn-惊人的查找速度"><a href="#O-logn-惊人的查找速度" class="headerlink" title="O(logn) 惊人的查找速度"></a>O(logn) 惊人的查找速度</h2><p>我们假设数据大小是 n，每次查找后数据都会缩小为原来的一半，也就是会除以 2。最坏情况下，直到查找区间被缩小为空，才停止：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/69.png" alt></p><p>可以看出来，这是一个等比数列。其中 n/2^k=1 时，k 的值就是总共缩小的次数。而每一次缩小操作只涉及两个数据的大小比较，所以，<strong>经过了 k 次区间缩小操作，时间复杂度就是 O(k)</strong>。通过 n/2^k=1，我们可以求得 k=log2n，所以时间复杂度就是 O(logn)。</p><p>logn 是一个非常恐怖的数量级，即便 n 非常非常大，对应的 logn 也很小。比如 n 等于 2 的 32 次方，这个数很大了吧？大约是 42 亿。也就是说，如果我们在 42 亿个数据中用二分查找一个数据，最多需要比较 32 次。我们前面讲过，用大 O 标记法表示时间复杂度的时候，会省略掉常数、系数和低阶。对于常量级时间复杂度的算法来说，O(1) 有可能表示的是一个非常大的常量值，比如 O(1000)、O(10000)。所以，<strong>常量级时间复杂度的算法有时候可能还没有 O(logn) 的算法执行效率高</strong>。</p><blockquote><p>指数时间复杂度的算法在大规模数据面前是无效的</p></blockquote><h2 id="二分查找的递归与非递归实现"><a href="#二分查找的递归与非递归实现" class="headerlink" title="二分查找的递归与非递归实现"></a>二分查找的递归与非递归实现</h2><p>最简单的情况就是<strong>有序数组中不存在重复元素</strong>，我们在其中用二分查找值等于给定值的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (low + high) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码我稍微解释一下，low、high、mid 都是指数组下标，其中 low 和 high 表示当前查找的区间范围，初始 low=0， high=n-1。mid 表示 [low, high] 的中间位置。我们通过对比 a[mid] 与 value 的大小，来更新接下来要查找的区间范围，<strong>直到找到或者区间缩小为 0，就退出</strong>。</p><p>现在，我就着重强调一下容易出错的 3 个地方：</p><ol><li>循环退出条件：<br>注意是 low&lt;=high，而不是 low&lt;high；</li><li>mid 的取值：<br>实际上，mid=(low+high)/2 这种写法是有问题的。因为如果 low 和 high 比较大的话，两者之和就有可能会溢出。改进的方法是将 mid 的计算方式写成 low+(high-low)/2。更进一步，如果要将性能优化到极致的话，我们可以将这里的除以 2 操作转化成位运算 low+((high-low)&gt;&gt;1)。因为<strong>相比除法运算来说，计算机处理位运算要快得多</strong>；</li><li>low 和 high 的更新：<br>low=mid+1，high=mid-1。注意这里的 +1 和 -1，如果直接写成 low=mid 或者 high=mid，就可能会发生死循环。比如，当 high=3，low=3 时，如果 a[3]不等于 value，就会导致一直循环不退出；</li></ol><p>实际上，二分查找<strong>除了用循环来实现，还可以用递归来实现</strong>，过程也非常简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 二分查找的递归实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> bsearchInternally(a, <span class="number">0</span>, n - <span class="number">1</span>, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">bsearchInternally</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> low, <span class="keyword">int</span> high, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &gt; high) &#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span> (a[mid] == value) &#123;</span><br><span class="line">        <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">        <span class="keyword">return</span> bsearchInternally(a, mid+<span class="number">1</span>, high, value);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> bsearchInternally(a, low, mid-<span class="number">1</span>, value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分查找应用场景的局限性"><a href="#二分查找应用场景的局限性" class="headerlink" title="二分查找应用场景的局限性"></a>二分查找应用场景的局限性</h2><p>前面我们分析过，二分查找的时间复杂度是 O(logn)，查找数据的效率非常高。不过，并不是什么情况下都可以用二分查找，它的应用场景是有很大局限性的：</p><ol><li>二分查找依赖的是顺序表结构，简单点说就是数组：<br>数组按照下标随机访问数据的时间复杂度是 O(1)，而链表随机访问的时间复杂度是 O(n)。所以，如果数据使用链表存储，二分查找的时间复杂就会变得很高。<strong>二分查找只能用在数据是通过顺序表来存储的数据结构上</strong>。如果你的数据是通过其他数据结构存储的，则无法应用二分查找；</li><li>二分查找针对的是有序数据：<br>如果数据没有序，我们需要先排序。前面章节里我们讲到，排序的时间复杂度最低是 O(nlogn)。所以，如果我们针对的是一组静态的数据，没有频繁地插入、删除，我们可以进行一次排序，多次二分查找。这样排序的成本可被均摊，二分查找的边际成本就会比较低。所以，<strong>二分查找只能用在插入、删除操作不频繁，一次排序多次查找的场景中</strong>。针对动态变化的数据集合，二分查找将不再适用；</li><li>数据量太小不适合二分查找：<br>如果要处理的数据量很小，完全没有必要用二分查找，顺序遍历就足够了。比如我们在一个大小为 10 的数组中查找一个元素，不管用二分查找还是顺序遍历，查找速度都差不多。<strong>只有数据量比较大的时候，二分查找的优势才会比较明显</strong>；</li><li>数据量太大也不适合二分查找：<br>二分查找的底层需要依赖数组这种数据结构，而<strong>数组为了支持随机访问的特性，要求内存空间连续，对内存的要求比较苛刻</strong>。比如，我们有 1GB 大小的数据，如果希望用数组来存储，那就需要 1GB 的连续内存空间。所以，太大的数据用数组存储就比较吃力了，也就不能用二分查找了；</li></ol><h2 id="如何在-1000-万个整数中快速查找某个整数"><a href="#如何在-1000-万个整数中快速查找某个整数" class="headerlink" title="如何在 1000 万个整数中快速查找某个整数"></a>如何在 1000 万个整数中快速查找某个整数</h2><p>这个问题并不难。我们的内存限制是 100MB，每个数据大小是 8 字节，最简单的办法就是将数据存储在数组中，内存占用差不多是 80MB，符合内存的限制。我们可以<strong>先对这 1000 万数据从小到大排序，然后再利用二分查找算法</strong>，就可以快速地查找想要的数据了。</p><p>虽然大部分情况下，用二分查找可以解决的问题，用散列表、二叉树都可以解决。但是，<strong>不管是散列表还是二叉树，都会需要比较多的额外的内存空间</strong>。如果用散列表或者二叉树来存储这 1000 万的数据，用 100MB 的内存肯定是存不下的。而二分查找底层依赖的是数组，除了数据本身之外，不需要额外存储其他信息，是最省内存空间的存储方式，所以刚好能在限定的内存大小下解决这个问题。</p><h2 id="变体一：查找第一个值等于给定值的元素"><a href="#变体一：查找第一个值等于给定值的元素" class="headerlink" title="变体一：查找第一个值等于给定值的元素"></a>变体一：查找第一个值等于给定值的元素</h2><p>我们将问题稍微修改下，<strong>有序数据集合中存在重复的数据</strong>，我们希望找到第一个值等于给定值的数据。比如下面这样一个有序数组，其中，a[5]，a[6]，a[7] 的值都等于 8，是重复的数据。我们希望查找第一个等于 8 的数据，也就是下标是 5 的元素：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/71.png" alt></p><p>如果我们用上一节课讲的二分查找的代码实现，首先拿 8 与区间的中间值 a[4] 比较，8 比 6 大，于是在下标 5 到 9 之间继续查找。下标 5 和 9 的中间位置是下标 7，a[7] 正好等于 8，所以代码就返回了。尽管 a[7] 也等于 8，但它并不是我们想要找的第一个等于 8 的元素，因为第一个值等于 8 的元素是数组下标为 5 的元素。所以，我换了一种实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] != value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们重点看第 13 行代码。如果 mid 等于 0，那这个元素已经是数组的第一个元素，那它肯定是我们要找的；如果 mid 不等于 0，但 a[mid] 的前一个元素 a[mid-1] 不等于 value，那也说明 a[mid] 就是我们要找的第一个值等于给定值的元素；如果经过检查之后发现 a[mid] 前面的一个元素 a[mid-1] 也等于 value，那说明此时的 a[mid] 肯定不是我们要查找的第一个值等于给定值的元素。那我们就更新 high=mid-1，因为要找的元素肯定出现在 [low, mid-1] 之间。</p><p>实际上，很多人都觉得变形的二分查找很难写，主要原因是太追求完美、简洁的写法。而对于我们做工程开发的人来说，<strong>代码易读懂、没 bug，其实更重要</strong>。</p><h2 id="变体二：查找最后一个值等于给定值的元素"><a href="#变体二：查找最后一个值等于给定值的元素" class="headerlink" title="变体二：查找最后一个值等于给定值的元素"></a>变体二：查找最后一个值等于给定值的元素</h2><p>我现在把问题稍微改一下，查找最后一个值等于给定值的元素。如果你掌握了前面的写法，那这个问题你应该很轻松就能解决：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (a[mid] &lt; value) &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] != value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="变体三：查找第一个大于等于给定值的元素"><a href="#变体三：查找第一个大于等于给定值的元素" class="headerlink" title="变体三：查找第一个大于等于给定值的元素"></a>变体三：查找第一个大于等于给定值的元素</h2><p>现在我们再来看另外一类变形问题。在有序数组中，查找第一个大于等于给定值的元素。比如，数组中存储的这样一个序列：3, 4, 6, 7, 10。如果查找第一个大于等于 5 的元素，那就是 6。实际上，实现的思路跟前面的那两种变形问题的实现思路类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt;= value) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == <span class="number">0</span>) || (a[mid - <span class="number">1</span>] &lt; value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123; </span><br><span class="line">                high = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果 a[mid] 小于要查找的值 value，那要查找的值肯定在 [mid+1, high] 之间，所以，我们更新 low=mid+1。对于 a[mid] 大于等于给定值 value 的情况，我们要先看下这个 a[mid] 是不是我们要找的第一个值大于等于给定值的元素。如果 a[mid] 前面已经没有元素，或者前面一个元素小于要查找的值 value，那 a[mid] 就是我们要找的元素；如果 a[mid-1] 也大于等于要查找的值 value，那说明要查找的元素在 [low, mid-1] 之间，所以，我们将 high 更新为 mid-1。</p><h2 id="变体四：查找最后一个小于等于给定值的元素"><a href="#变体四：查找最后一个小于等于给定值的元素" class="headerlink" title="变体四：查找最后一个小于等于给定值的元素"></a>变体四：查找最后一个小于等于给定值的元素</h2><p>现在，我们来看最后一种二分查找的变形问题，查找最后一个小于等于给定值的元素。比如，数组中存储了这样一组数据：3, 5, 6, 8, 9, 10。最后一个小于等于 7 的元素就是 6。实际上，实现思路也是一样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">bsearch7</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> high = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (low &lt;= high) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid =  low + ((high - low) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (a[mid] &gt; value) &#123;</span><br><span class="line">            high = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((mid == n - <span class="number">1</span>) || (a[mid + <span class="number">1</span>] &gt; value)) &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何快速定位出一个-IP-地址的归属地"><a href="#如何快速定位出一个-IP-地址的归属地" class="headerlink" title="如何快速定位出一个 IP 地址的归属地"></a>如何快速定位出一个 IP 地址的归属地</h2><p>当我们想要查询 202.102.133.13 这个 IP 地址的归属地时，我们就在地址库中搜索，发现这个 IP 地址落在 [202.102.133.0, 202.102.133.255] 这个地址范围内，那我们就可以将这个 IP 地址范围对应的归属地“山东东营市”显示给用户了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[202.102.133.0, 202.102.133.255]  山东东营市 </span><br><span class="line">[202.102.135.0, 202.102.136.255]  山东烟台 </span><br><span class="line">[202.102.156.34, 202.102.157.255] 山东青岛 </span><br><span class="line">[202.102.48.0, 202.102.48.255]    江苏宿迁 </span><br><span class="line">[202.102.49.15, 202.102.51.251]   江苏泰州 </span><br><span class="line">[202.102.56.0, 202.102.56.255]    江苏连云港</span><br></pre></td></tr></table></figure><p>现在这个问题应该很简单了。如果 IP 区间与归属地的对应关系不经常更新，我们可以先预处理这 12 万条数据，让其按照起始 IP 从小到大排序。如何来排序呢？我们知道，<strong>IP 地址可以转化为 32 位的整型数</strong>。所以，我们可以将起始地址，按照对应的整型值的大小关系，从小到大进行排序。</p><p>然后，这个问题就可以转化为我刚讲的第四种变形问题“在有序数组中，查找最后一个小于等于某个给定值的元素”了。当我们要查询某个 IP 归属地时，我们可以先通过二分查找，<strong>找到最后一个起始 IP 小于等于这个 IP 的 IP 区间</strong>，然后，检查这个 IP 是否在这个 IP 区间内，如果在，我们就取出对应的归属地显示；如果不在，就返回未查找到。</p><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">Sqrt(x)</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序优化</title>
      <link href="2020/12/30/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/"/>
      <url>2020/12/30/%E6%8E%92%E5%BA%8F%E4%BC%98%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<p>几乎所有的编程语言都会提供排序函数，比如 C 语言中 qsort()，C++ STL 中的 sort()、stable_sort()，还有 Java 语言中的 Collections.sort()。在平时的开发中，我们也都是直接使用这些现成的函数来实现业务逻辑中的排序功能。那你知道这些排序函数是如何实现的吗？</p><h2 id="如何选择合适的排序算法？"><a href="#如何选择合适的排序算法？" class="headerlink" title="如何选择合适的排序算法？"></a>如何选择合适的排序算法？</h2><p>如果要实现一个通用的、高效率的排序函数，我们应该选择哪种排序算法？我们先回顾一下前面讲过的几种排序算法：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/67.png" alt></p><p>我们前面讲过，线性排序算法的时间复杂度比较低，适用场景比较特殊。所以如果要写一个通用的排序函数，<strong>不能选择线性排序算法</strong>。如果对小规模数据进行排序，可以选择时间复杂度是 O(n^2) 的算法；如果对大规模数据进行排序，时间复杂度是 O(nlogn) 的算法更加高效。所以，为了兼顾任意规模数据的排序，一般都会<strong>首选时间复杂度是 O(nlogn) 的排序算法来实现排序函数</strong>。</p><a id="more"></a><p>时间复杂度是 O(nlogn) 的排序算法不止一个，我们已经讲过的有归并排序、快速排序，后面讲堆的时候我们还会讲到堆排序。<strong>堆排序和快速排序都有比较多的应用</strong>，比如 Java 语言采用堆排序实现排序函数，C 语言使用快速排序实现排序函数。</p><h2 id="如何优化快速排序？"><a href="#如何优化快速排序？" class="headerlink" title="如何优化快速排序？"></a>如何优化快速排序？</h2><p>如果数据原来就是有序的或者接近有序的，每次分区点都选择最后一个数据，那快速排序算法就会变得非常糟糕，时间复杂度就会退化为 O(n^2)。实际上，这种 O(n^2) 时间复杂度出现的主要原因还是因为我们<strong>分区点选得不够合理</strong>。最理想的分区点是：<strong>被分区点分开的两个分区中，数据的数量差不多</strong>。</p><h3 id="三数取中法"><a href="#三数取中法" class="headerlink" title="三数取中法"></a>三数取中法</h3><p>我们从区间的首、尾、中间，分别取出一个数，然后<strong>对比大小，取这 3 个数的中间值作为分区点</strong>。这样每间隔某个固定的长度，取数据出来比较，将中间值作为分区点的分区算法，肯定要比单纯取某一个数据更好。但是，如果要排序的数组比较大，那“三数取中”可能就不够了，可能要“五数取中”或者“十数取中”。</p><h3 id="随机法"><a href="#随机法" class="headerlink" title="随机法"></a>随机法</h3><p>随机法就是每次从要排序的区间中，<strong>随机选择一个元素作为分区点</strong>。这种方法并不能保证每次分区点都选的比较好，但是从概率的角度来看，也不大可能会出现每次分区点都选得很差的情况，所以平均情况下，这样选的分区点是比较好的。</p><p>为了避免快速排序里，递归过深而堆栈过小，导致堆栈溢出，我们有两种解决办法：</p><ol><li>限制递归深度。一旦递归过深，超过了我们事先设定的阈值，就停止递归；</li><li>通过在堆上模拟实现一个函数调用栈，<strong>手动模拟递归压栈、出栈的过程</strong>，这样就没有了系统栈大小的限制；</li></ol><h2 id="举例分析排序函数"><a href="#举例分析排序函数" class="headerlink" title="举例分析排序函数"></a>举例分析排序函数</h2><p>为了让你对如何实现一个排序函数有一个更直观的感受，我拿 Glibc 中的 qsort() 函数举例说明一下。如果你去看源码，你就会发现，<strong>qsort() 会优先使用归并排序来排序输入数据</strong>，因为归并排序的空间复杂度是 O(n)，所以对于小数据量的排序，比如 1KB、2KB 等，归并排序额外需要 1KB、2KB 的内存空间，这个问题不大。现在计算机的内存都挺大的，我们很多时候追求的是速度。</p><p><strong>要排序的数据量比较大的时候，qsort() 会改为用快速排序算法来排序</strong>。qsort() 选择分区点的方法就是“三数取中法”，还有我们前面提到的递归太深会导致堆栈溢出的问题，qsort() 是通过自己实现一个堆上的栈，手动模拟递归来解决的。</p><p>实际上，qsort() 并不仅仅用到了归并排序和快速排序，它还用到了插入排序。在快速排序的过程中，当要排序的区间中，元素的个数小于等于 4 时，qsort() 就退化为插入排序，不再继续用递归来做快速排序，因为我们前面也讲过，<strong>在小规模数据面前，O(n^2) 时间复杂度的算法并不一定比 O(nlogn) 的算法执行时间长</strong>。</p><p>在大 O 复杂度表示法中，我们会省略低阶、系数和常数，也就是说，O(nlogn) 在没有省略低阶、系数、常数之前可能是 O(knlogn + c)，而且 k 和 c 有可能还是一个比较大的数。假设 k=1000，c=200，当我们对小规模数据（比如 n=100）排序时，n^2 的值实际上比 knlogn + c 还要小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">knlogn + c = <span class="number">1000</span> * <span class="number">100</span> * log100 + <span class="number">200</span> <span class="comment">// 远大于 10000</span></span><br><span class="line"></span><br><span class="line">n^<span class="number">2</span> = <span class="number">100</span> * <span class="number">100</span> = <span class="number">10000</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性排序</title>
      <link href="2020/12/30/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/"/>
      <url>2020/12/30/%E7%BA%BF%E6%80%A7%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>时间复杂度是线性的排序算法叫作<code>线性排序</code>（Linear Sort）。之所以能做到线性的时间复杂度，主要原因是它们<strong>不涉及元素之间的比较操作，但是对要排序的数据要求很苛刻</strong>，应用不是非常广泛。学习重点是掌握这些排序算法的适用场景。</p><h2 id="桶排序（Bucket-Sort）"><a href="#桶排序（Bucket-Sort）" class="headerlink" title="桶排序（Bucket Sort）"></a>桶排序（Bucket Sort）</h2><p>桶排序，顾名思义，会用到“桶”，核心思想是将要排序的数据分到几个有序的桶里，每个桶里的数据再单独进行排序。桶内排完序之后，再<strong>把每个桶里的数据按照顺序依次取出，组成的序列就是有序的了</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/61.png" alt></p><p>如果要排序的数据有 n 个，我们把它们均匀地划分到 m 个桶内，每个桶里就有 k=n/m 个元素。每个桶内部使用快速排序，时间复杂度为 O(k * logk)。m 个桶排序的时间复杂度就是 O(m * k * logk)，因为 k=n/m，所以整个桶排序的时间复杂度就是 O(n*log(n/m))。当桶的个数 m 接近数据个数 n 时，log(n/m) 就是一个非常小的常量，这个时候桶排序的时间复杂度接近 O(n)。</p><a id="more"></a><p>实际上，桶排序对要排序数据的要求是非常苛刻的。首先，要排序的数据需要很容易就能划分成 m 个桶，并且，<strong>桶与桶之间有着天然的大小顺序</strong>。这样每个桶内的数据都排序完之后，桶与桶之间的数据不需要再进行排序。其次，<strong>数据在各个桶之间的分布是比较均匀的</strong>。如果数据经过桶的划分之后，有些桶里的数据非常多，有些非常少，很不平均，那桶内数据排序的时间复杂度就不是常量级了。<strong>在极端情况下，如果数据都被划分到一个桶里，那就退化为 O(nlogn) 的排序算法了</strong>。</p><p><strong>桶排序比较适合用在外部排序中</strong>。所谓的外部排序就是数据存储在外部磁盘中，数据量比较大，内存有限，无法将数据全部加载到内存中。比如说我们有 10GB 的订单数据，我们希望按订单金额（假设金额都是正整数）进行排序，但是我们的内存有限，只有几百 MB，没办法一次性把 10GB 的数据都加载到内存中。</p><p>我们可以先扫描一遍文件，看订单金额所处的数据范围。假设经过扫描之后我们得到，订单金额最小是 1 元，最大是 10 万元。我们将所有订单根据金额划分到 100 个桶里，第一个桶我们存储金额在 1 元到 1000 元之内的订单，第二桶存储金额在 1001 元到 2000 元之内的订单，以此类推。<strong>每一个桶对应一个文件，并且按照金额范围的大小顺序编号命名</strong>。</p><p>理想的情况下，如果订单金额在 1 到 10 万之间均匀分布，那订单会被均匀划分到 100 个文件中，每个小文件中存储大约 100MB 的订单数据，我们就可以将这 100 个小文件依次放到内存中，用快排来排序。等所有文件都排好序之后，我们只需要按照文件编号，从小到大依次读取每个小文件中的订单数据，并将其写入到一个文件中，那这个文件中存储的就是按照金额从小到大排序的订单数据了。如果划分之后，1001 元到 2000 元之间的订单还是太多，无法一次性读入内存，那就<strong>继续再划分，直到所有的文件都能读入内存为止</strong>。</p><h2 id="计数排序（Counting-Sort）"><a href="#计数排序（Counting-Sort）" class="headerlink" title="计数排序（Counting Sort）"></a>计数排序（Counting Sort）</h2><p><strong>计数排序其实是桶排序的一种特殊情况</strong>。当要排序的 n 个数据，所处的范围并不大的时候，比如最大值是 k，我们就可以把数据划分成 k 个桶。每个桶内的数据值都是相同的，省掉了桶内排序的时间。</p><p>假设只有 8 个考生，分数在 0 到 5 分之间。这 8 个考生的成绩我们放在一个数组 A[8] 中，它们分别是：2, 5, 3, 0, 2, 3, 0, 3。考生的成绩从 0 到 5 分，我们使用大小为 6 的数组 C[6] 表示桶，其中下标对应分数。不过，C[6] 内存储的并不是考生，而是对应的考生个数。像我刚刚举的那个例子，我们只需要遍历一遍考生分数，就可以得到 C[6] 的值：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/62.png" alt></p><p>从图中可以看出，分数为 3 分的考生有 3 个，小于 3 分的考生有 4 个，所以，成绩为 3 分的考生在排序之后的有序数组 R[8] 中，会保存下标 4, 5, 6 的位置：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/63.png" alt></p><p>那我们如何快速计算出，每个分数的考生在有序数组中对应的存储位置呢？思路是这样的：我们<strong>对 C[6] 数组顺序求和</strong>，C[6] 存储的数据就变成了下面这样子。<strong>C[k] 里存储小于等于分数 k 的考生个数</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/64.png" alt></p><p>我们从后到前依次扫描数组 A。比如，当扫描到 3 时，我们可以从数组 C 中取出下标为 3 的值 7，也就是说，到目前为止，包括自己在内，分数小于等于 3 的考生有 7 个，也就是说 3 是数组 R 中的第 7 个元素（也就是数组 R 中下标为 6 的位置）。当 3 放入到数组 R 中后，小于等于 3 的元素就只剩下了 6 个了，所以相应的 C[3] 要减 1，变成 6。当我们扫描完整个数组 A 后，数组 R 内的数据就是按照分数从小到大有序排列的了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/65.png" alt></p><p>上面的过程有点复杂，我写成了代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 计数排序，a 是数组，n 是数组大小。假设数组中存储的都是非负整数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countingSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 查找数组中数据的范围</span></span><br><span class="line">    <span class="keyword">int</span> max = a[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (max &lt; a[i]) &#123;</span><br><span class="line">            max = a[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span>[] c = <span class="keyword">new</span> <span class="keyword">int</span>[max+<span class="number">1</span>]; <span class="comment">// 申请一个计数数组 c，下标大小 [0, max]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">        c[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 计算每个元素的个数，放入 c 中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        c[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 依次累加</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= max; ++i) &#123;</span><br><span class="line">        c[i] = c[i-<span class="number">1</span>] + c[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 临时数组 r，存储排序之后的结果</span></span><br><span class="line">    <span class="keyword">int</span>[] r = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    <span class="comment">// 计算排序的关键步骤，有点难理解</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = c[a[i]]-<span class="number">1</span>;</span><br><span class="line">        r[index] = a[i];</span><br><span class="line">        c[a[i]]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将结果拷贝给 a 数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        a[i] = r[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>计数排序只能用在数据范围不大的场景中</strong>，如果数据范围 k 比要排序的数据 n 大很多，就不适合用计数排序了。而且，计数排序只能给非负整数排序，<strong>如果要排序的数据是其他类型的，要将其在不改变相对大小的情况下，转化为非负整数</strong>。比如，还是拿考生这个例子。如果考生成绩精确到小数后一位，我们就需要将所有的分数都先乘以 10，转化成整数，然后再放到 9010 个桶内。再比如，如果要排序的数据中有负数，数据的范围是[-1000, 1000]，那我们就需要先对每个数据都加 1000，转化成非负整数。</p><h2 id="基数排序（Radix-Sort）"><a href="#基数排序（Radix-Sort）" class="headerlink" title="基数排序（Radix Sort）"></a>基数排序（Radix Sort）</h2><p>假设我们有 10 万个手机号码，希望将这 10 万个手机号码从小到大排序，你有什么比较快速的排序方法呢？我们之前讲的快排，时间复杂度可以做到 O(nlogn)，还有更高效的排序算法吗？桶排序、计数排序能派上用场吗？<strong>手机号码有 11 位，范围太大</strong>，显然不适合用这两种排序算法。刚刚这个问题里有这样的规律：假设要比较两个手机号码 a, b 的大小，如果在前面几位中，a 手机号码已经比 b 手机号码大了，那后面的几位就不用看了。</p><p><strong>借助稳定排序算法</strong>，这里有一个巧妙的实现思路。先按照最后一位来排序手机号码，然后，再按照倒数第二位重新排序，以此类推，最后按照第一位重新排序。经过 11 次排序之后，手机号码就都有序了。手机号码稍微有点长，画图比较不容易看清楚，我用字符串排序的例子，画了一张基数排序的过程分解图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/66.png" alt></p><p>根据每一位来排序，我们可以用刚讲过的桶排序或者计数排序，它们的时间复杂度可以做到 O(n)。如果要排序的数据有 k 位，那我们就需要 k 次桶排序或者计数排序，总的时间复杂度是 O(k*n)。当 k 不大的时候，比如手机号码排序的例子，k 最大就是 11，所以基数排序的时间复杂度就近似于 O(n)。</p><p>实际上，有时候要排序的数据并不都是等长的，比如我们排序牛津字典中的 20 万个英文单词。我们可以<strong>把所有的单词补齐到相同长度，位数不够的可以在后面补“0”</strong>，因为根据 ASCII 值，所有字母都大于“0”，所以补“0”不会影响到原有的大小顺序。这样就可以继续用基数排序了。</p><p>基数排序对要排序的数据是有要求的，需要可以分割出独立的“位”来比较，而且<strong>位之间有递进的关系</strong>，如果 a 数据的高位比 b 数据大，那剩下的低位就不用比较了。除此之外，<strong>每一位的数据范围不能太大，要可以用线性排序算法来排序</strong>，否则，基数排序的时间复杂度就无法做到 O(n) 了。</p><h2 id="如何根据年龄给-100-万用户排序"><a href="#如何根据年龄给-100-万用户排序" class="headerlink" title="如何根据年龄给 100 万用户排序"></a>如何根据年龄给 100 万用户排序</h2><p>实际上，根据年龄给 100 万用户排序，就类似按照成绩给 50 万考生排序。我们假设年龄的范围最小 1 岁，最大不超过 120 岁。我们可以遍历这 100 万用户，<strong>根据年龄将其划分到这 120 个桶里，然后依次顺序遍历这 120 个桶中的元素</strong>。这样就得到了按照年龄排序的 100 万用户数据。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2020/12/29/%E6%8E%92%E5%BA%8F/"/>
      <url>2020/12/29/%E6%8E%92%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<p>最经典的、最常用的排序算法：冒泡排序、插入排序、选择排序、归并排序、快速排序、计数排序、基数排序、桶排序。我<strong>按照时间复杂度</strong>把它们分成了三类：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/41.png" alt></p><a id="more"></a><h2 id="如何分析一个“排序算法”？"><a href="#如何分析一个“排序算法”？" class="headerlink" title="如何分析一个“排序算法”？"></a>如何分析一个“排序算法”？</h2><p>学习排序算法，我们除了学习它的算法原理、代码实现之外，更重要的是要学会如何评价、分析一个排序算法。</p><h3 id="排序算法的执行效率"><a href="#排序算法的执行效率" class="headerlink" title="排序算法的执行效率"></a>排序算法的执行效率</h3><p>对于排序算法执行效率的分析，我们一般会从这几个方面来衡量：</p><ol><li><strong>最好情况、最坏情况、平均情况时间复杂度</strong>：为什么要区分这三种时间复杂度呢？第一，有些排序算法会区分，为了好对比，所以我们最好都做一下区分。第二，对于要排序的数据，有的接近有序，有的完全无序。有序度不同的数据，对于排序的执行时间肯定是有影响的，我们要知道<strong>排序算法在不同数据下的性能表现</strong>；</li><li><strong>时间复杂度的系数、常数 、低阶</strong>：我们知道，时间复杂度反映的是数据规模 n 很大的时候的一个增长趋势，所以它表示的时候会忽略系数、常数、低阶。但是<strong>实际的软件开发中，我们排序的可能是 10 个、100 个、1000 个这样规模很小的数据</strong>，所以，在对同一阶时间复杂度的排序算法性能对比的时候，我们就要把系数、常数、低阶也考虑进来；</li><li><strong>比较次数和交换（或移动）次数</strong>：基于比较的排序算法的执行过程，会<strong>涉及两种操作，一种是元素比较大小，另一种是元素交换或移动</strong>。所以，如果我们在分析排序算法的执行效率的时候，应该把比较次数和交换（或移动）次数也考虑进去；</li></ol><h3 id="排序算法的内存消耗"><a href="#排序算法的内存消耗" class="headerlink" title="排序算法的内存消耗"></a>排序算法的内存消耗</h3><p>针对排序算法的空间复杂度，我们还引入了一个新的概念，<code>原地排序</code>（In-Place Sorting）。原地排序算法，就是特指空间复杂度是 O(1) 的排序算法。</p><h3 id="排序算法的稳定性"><a href="#排序算法的稳定性" class="headerlink" title="排序算法的稳定性"></a>排序算法的稳定性</h3><p>针对排序算法，我们还有一个重要的度量指标，<code>稳定性</code>。这个概念是说，如果待排序的序列中存在值相等的元素，经过排序之后，相等元素之间原有的先后顺序不变。</p><p>在真正软件开发中，我们要排序的往往不是单纯的整数，而是一组对象，我们<strong>需要按照对象的某个 key 来排序</strong>。比如说，我们现在要给电商交易系统中的“订单”排序。订单有两个属性，一个是下单时间，另一个是订单金额。如果我们现在有 10 万条订单数据，我们希望按照金额从小到大对订单数据排序。对于金额相同的订单，我们希望按照下单时间从早到晚有序。</p><p>借助稳定排序算法，这个问题可以非常简洁地解决。解决思路是这样的：我们先按照下单时间给订单排序，注意是按照下单时间，不是金额。排序完成之后，我们用稳定排序算法，按照订单金额重新排序。两遍排序之后，我们得到的订单数据就是按照金额从小到大排序，金额相同的订单按照下单时间从早到晚排序的。<strong>稳定排序算法可以保持金额相同的两个对象，在排序之后的前后顺序不变</strong>。第一次排序之后，所有的订单按照下单时间从早到晚有序了。在第二次排序中，我们用的是稳定的排序算法，所以经过第二次排序之后，相同金额的订单仍然保持下单时间从早到晚有序：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/42.png" alt></p><h2 id="冒泡排序（Bubble-Sort）"><a href="#冒泡排序（Bubble-Sort）" class="headerlink" title="冒泡排序（Bubble Sort）"></a>冒泡排序（Bubble Sort）</h2><p>冒泡排序只会操作相邻的两个数据。每次冒泡操作都会对相邻的两个元素进行比较，看是否满足大小关系要求。如果不满足就让它俩互换。<strong>一次冒泡会让至少一个元素移动到它应该在的位置</strong>，重复 n 次，就完成了 n 个数据的排序工作。</p><p>我用一个例子，带你看下冒泡排序的整个过程。我们要对一组数据 4, 5, 6, 3, 2, 1，从小到大进行排序。第一次冒泡操作的详细过程就是这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/43.png" alt></p><p>可以看出，经过一次冒泡操作之后，6 这个元素已经存储在正确的位置上。要想完成所有数据的排序，我们只要进行 6 次这样的冒泡操作就行了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/44.png" alt></p><p>实际上，刚讲的冒泡过程还可以优化。<strong>当某次冒泡操作已经没有数据交换时，说明已经达到完全有序，不用再继续执行后续的冒泡操作</strong>。我这里还有另外一个例子，这里面给 6 个元素排序，只需要 4 次冒泡操作就可以了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/45.png" alt></p><p>冒泡排序算法的原理比较容易理解，具体的代码我贴到下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="comment">// 提前退出冒泡循环的标志位</span></span><br><span class="line">        <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n - i - <span class="number">1</span>; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; </span><br><span class="line">                <span class="comment">// 交换</span></span><br><span class="line">                <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">                a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">                a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">                flag = <span class="keyword">true</span>; <span class="comment">// 表示有数据交换      </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 没有数据交换，提前退出</span></span><br><span class="line">        <span class="keyword">if</span> (!flag) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>冒泡的过程只涉及相邻数据的交换操作，只需要常量级的临时空间，所以它的空间复杂度为 O(1)，是一个原地排序算法。在冒泡排序中，只有交换才可以改变两个元素的前后顺序。为了保证冒泡排序算法的稳定性，<strong>当有相邻的两个元素大小相等的时候，我们不做交换</strong>，相同大小的数据在排序前后不会改变顺序，所以冒泡排序是稳定的排序算法。最好情况下，要排序的数据已经是有序的了，我们只需要进行一次冒泡操作，就可以结束了，所以最好情况时间复杂度是 O(n)。而最坏的情况是，要排序的数据刚好是倒序排列的，我们需要进行 n 次冒泡操作，所以最坏情况时间复杂度为 O(n^2)：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/46.png" alt></p><p>对于包含 n 个数据的数组，这 n 个数据就有 n! 种排列方式。不同的排列方式，冒泡排序执行的时间肯定是不同的。比如我们前面举的那两个例子，其中一个要进行 6 次冒泡，而另一个只需要 4 次。如果用概率论方法定量分析平均时间复杂度，涉及的数学推理和计算就会很复杂。我这里还有一种思路，通过<code>有序度</code>和<code>逆序度</code>这两个概念来进行分析。</p><p><strong>有序度是数组中具有有序关系的元素对的个数</strong>。有序元素对用数学表达式表示就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有序元素对：a[i] &lt;= a[j], 如果 i &lt; j</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/47.png" alt></p><p>同理，对于一个倒序排列的数组，比如 6, 5, 4, 3, 2, 1，有序度是 0；对于一个完全有序的数组，比如 1, 2, 3, 4, 5, 6，有序度就是 n*(n-1)/2，也就是 15。我们把这种完全有序的数组的有序度叫作<code>满有序度</code>。逆序度 = 满有序度 - 有序度，我们<strong>排序的过程就是一种增加有序度，减少逆序度的过程</strong>，最后达到满有序度，就说明排序完成了。</p><p>我还是拿前面举的那个冒泡排序的例子来说明。要排序的数组的初始状态是 4, 5, 6, 3, 2, 1 ，其中，有序元素对有 (4，5)、 (4，6)、(5，6)，所以有序度是 3。n=6，所以排序完成之后终态的满有序度为 n*(n-1)/2=15：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/48.png" alt></p><p>冒泡排序包含两个操作原子，比较和交换。每交换一次，有序度就加 1。<strong>不管算法怎么改进，交换次数总是确定的，即为逆序度</strong>。对于包含 n 个数据的数组进行冒泡排序，平均交换次数是多少呢？最坏情况下，初始状态的有序度是 0，所以要进行 n*(n-1)/2 次交换。最好情况下，初始状态的有序度是 n*(n-1)/2，就不需要进行交换。我们可以取个中间值 n*(n-1)/4，来表示初始有序度既不是很高也不是很低的平均情况。</p><p>换句话说，平均情况下，需要 n*(n-1)/4 次交换操作，<strong>比较操作肯定要比交换操作多，而复杂度的上限是 O(n^2)</strong>，所以平均情况下的时间复杂度就是 O(n^2)。这个平均时间复杂度推导过程其实并不严格，但是很多时候很实用，毕竟概率论的定量分析太复杂，不太好用。</p><h2 id="插入排序（Insertion-Sort）"><a href="#插入排序（Insertion-Sort）" class="headerlink" title="插入排序（Insertion Sort）"></a>插入排序（Insertion Sort）</h2><p>我们先来看一个问题。一个有序的数组，我们往里面添加一个新的数据后，如何继续保持数据有序呢？很简单，我们<strong>只要遍历数组，找到数据应该插入的位置将其插入即可</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/49.png" alt></p><p>这是一个动态排序的过程，即动态地往有序集合中添加数据，我们可以通过这种方法保持集合中的数据一直有序。而对于一组静态数据，我们也可以借鉴上面讲的插入方法，来进行排序，于是就有了插入排序算法。首先，我们将数组中的数据分为两个区间，<code>已排序区间</code>和<code>未排序区间</code>。初始已排序区间只有一个元素，就是数组的第一个元素。插入算法的核心思想是取未排序区间中的元素，在已排序区间中找到合适的插入位置将其插入，并保证已排序区间数据一直有序。重复这个过程，直到未排序区间中元素为空，算法结束。</p><p>如图所示，要排序的数据是 4, 5, 6, 1, 3, 2，其中左侧为已排序区间，右侧是未排序区间：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/50.png" alt></p><p><strong>插入排序也包含两种操作，一种是元素的比较，一种是元素的移动</strong>。当我们需要将一个数据 a 插入到已排序区间时，需要拿 a 与已排序区间的元素依次比较大小，找到合适的插入位置。找到插入点之后，我们还需要将插入点之后的元素顺序往后移动一位，这样才能腾出位置给元素 a 插入。为什么说<strong>移动次数就等于逆序度</strong>呢？我拿刚才的例子画了一个图表，你一看就明白了。满有序度是 n*(n-1)/2=15，初始序列的有序度是 5，所以逆序度是 10。插入排序中，数据移动的个数总和也等于 10=3+3+4：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/51.png" alt></p><p>我也将代码实现贴在这里，你可以结合着代码再看下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 插入排序，a 表示数组，n 表示数组大小</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">int</span> value = a[i];</span><br><span class="line">        <span class="keyword">int</span> j = i - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 查找插入的位置</span></span><br><span class="line">        <span class="keyword">for</span> (; j &gt;= <span class="number">0</span>; --j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">                a[j+<span class="number">1</span>] = a[j]; <span class="comment">// 数据移动</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        a[j+<span class="number">1</span>] = value; <span class="comment">// 插入数据</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从实现过程可以很明显地看出，插入排序算法的运行并不需要额外的存储空间，所以空间复杂度是 O(1)，也就是说，这是一个原地排序算法。在插入排序中，<strong>对于值相同的元素，我们可以选择将后面出现的元素，插入到前面出现元素的后面</strong>，这样就可以保持原有的前后顺序不变，所以插入排序是稳定的排序算法。</p><p>如果要排序的数据已经是有序的，我们并不需要搬移任何数据。如果我们从尾到头在有序数据组里面查找插入位置，<strong>每次只需要比较一个数据就能确定插入的位置</strong>。所以这种情况下，最好是时间复杂度为 O(n)。如果数组是倒序的，每次插入都相当于在数组的第一个位置插入新的数据，所以需要移动大量的数据，所以最坏情况时间复杂度为 O(n^2)。</p><p>我们在数组中插入一个数据的平均时间复杂度是 O(n)。所以，对于插入排序来说，<strong>每次插入操作都相当于在数组中插入一个数据</strong>，循环执行 n 次插入操作，所以平均时间复杂度为 O(n^2)。</p><h2 id="选择排序（Selection-Sort）"><a href="#选择排序（Selection-Sort）" class="headerlink" title="选择排序（Selection Sort）"></a>选择排序（Selection Sort）</h2><p>选择排序算法的实现思路有点类似插入排序，也分已排序区间和未排序区间。但是选择排序每次会<strong>从未排序区间中找到最小的元素，将其放到已排序区间的末尾</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/52.png" alt></p><p>选择排序空间复杂度为 O(1)，是一种原地排序算法。选择排序的<strong>最好情况时间复杂度、最坏情况和平均情况时间复杂度都为 O(n^2)</strong>。选择排序是一种不稳定的排序算法。从我前面画的那张图中，你可以看出来，选择排序每次都要找剩余未排序元素中的最小值，并<strong>和前面的元素交换位置，这样破坏了稳定性</strong>。比如 5, 8, 5, 2, 9 这样一组数据，使用选择排序算法来排序的话，第一次找到最小元素 2，与第一个 5 交换位置，那第一个 5 和中间的 5 顺序就变了，所以就不稳定了。</p><h2 id="为什么插入排序要比冒泡排序更受欢迎"><a href="#为什么插入排序要比冒泡排序更受欢迎" class="headerlink" title="为什么插入排序要比冒泡排序更受欢迎"></a>为什么插入排序要比冒泡排序更受欢迎</h2><p>我们前面分析冒泡排序和插入排序的时候讲到，冒泡排序不管怎么优化，元素交换的次数是一个固定值，是原始数据的逆序度。插入排序是同样的，不管怎么优化，元素移动的次数也等于原始数据的逆序度。但是，从代码实现上来看，冒泡排序的数据交换要比插入排序的数据移动要复杂，<strong>冒泡排序需要 3 个赋值操作，而插入排序只需要 1 个</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序中数据的交换操作</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; a[j+<span class="number">1</span>]) &#123; </span><br><span class="line">    <span class="comment">// 数据交换</span></span><br><span class="line">    <span class="keyword">int</span> tmp = a[j];</span><br><span class="line">    a[j] = a[j+<span class="number">1</span>];</span><br><span class="line">    a[j+<span class="number">1</span>] = tmp;</span><br><span class="line">    flag = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入排序中数据的移动操作</span></span><br><span class="line"><span class="keyword">if</span> (a[j] &gt; value) &#123;</span><br><span class="line">    <span class="comment">// 数据移动</span></span><br><span class="line">    a[j+<span class="number">1</span>] = a[j];</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们把执行一个赋值语句的时间粗略地计为单位时间（unit_time），然后分别用冒泡排序和插入排序对同一个逆序度是 K 的数组进行排序。用冒泡排序，需要 K 次交换操作，每次需要 3 个赋值语句，所以交换操作总耗时就是 3*K 单位时间。而插入排序中数据移动操作只需要 K 个单位时间。所以，虽然冒泡排序和插入排序在时间复杂度上是一样的，都是 O(n^2)，但是<strong>如果我们希望把性能优化做到极致，那肯定首选插入排序</strong>。</p><p>这三种时间复杂度为 O(n^2) 的排序算法中，冒泡排序、选择排序，可能就纯粹停留在理论的层面了，学习的目的也只是为了开拓思维，实际开发中应用并不多，但是插入排序还是挺有用的。<strong>有些编程语言中的排序函数的实现原理会用到插入排序算法</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/53.png" alt></p><h2 id="归并排序的原理"><a href="#归并排序的原理" class="headerlink" title="归并排序的原理"></a>归并排序的原理</h2><p><code>归并排序</code>（Merge Sort）的核心思想还是蛮简单的。如果要排序一个数组，我们先把数组从中间分成前后两部分，然后对前后两部分分别排序，再将排好序的两部分合并在一起，这样整个数组就都有序了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/54.png" alt></p><p>归并排序使用的就是<code>分治思想</code>。分治，顾名思义，就是分而治之，将一个大问题分解成小的子问题来解决。小的子问题解决了，大问题也就解决了。分治算法一般都是用递归来实现的，<strong>分治是一种解决问题的处理思想，递归是一种编程技巧</strong>，这两者并不冲突。</p><p>写递归代码的技巧就是，<strong>分析得出递推公式，然后找到终止条件，最后将递推公式翻译成递归代码</strong>。所以，要想写出归并排序的代码，我们先写出归并排序的递推公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推公式</span></span><br><span class="line">merge_sort(p...r) = merge(merge_sort(p...q), merge_sort(q+<span class="number">1.</span>..r))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure><p>有了递推公式，转化成代码就简单多了。为了阅读方便，我这里只给出伪代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 归并排序算法, A 是数组，n 表示数组大小</span></span><br><span class="line">merge_sort(A, n) &#123;</span><br><span class="line">    merge_sort_c(A, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 递归调用函数</span></span><br><span class="line">merge_sort_c(A, p, r) &#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">    <span class="comment">// 取 p 到 r 之间的中间位置 q</span></span><br><span class="line">    q = (p + r) / <span class="number">2</span></span><br><span class="line">    <span class="comment">// 分治递归</span></span><br><span class="line">    merge_sort_c(A, p, q)</span><br><span class="line">    merge_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">    <span class="comment">// 将 A[p...q] 和 A[q+1...r] 合并为 A[p...r]</span></span><br><span class="line">    merge(A[p...r], A[p...q], A[q+<span class="number">1.</span>..r])</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你可能已经发现了，merge(A[p…r], A[p…q], A[q+1…r]) 这个函数的作用就是，将已经有序的 A[p…q] 和 A[q+1…r] 合并成一个有序的数组，并且放入 A[p…r]。那这个过程具体该如何做呢？</p><p>我们申请一个临时数组 tmp，大小与 A[p…r] 相同。我们用两个游标 i 和 j，分别指向 A[p…q] 和 A[q+1…r] 的第一个元素。比较这两个元素 A[i] 和 A[j]，如果 A[i]&lt;=A[j]，我们就把 A[i] 放入到临时数组 tmp，并且 i 后移一位，否则将 A[j] 放入到数组 tmp，j 后移一位。继续上述比较过程，<strong>直到其中一个子数组中的所有数据都放入临时数组中，再把另一个数组中的数据依次加入到临时数组的末尾</strong>。最后再把临时数组 tmp 中的数据拷贝到原数组 A[p…r] 中，如图所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/55.png" alt></p><p>我们把 merge() 函数写成伪代码，就是下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">merge(A[p...r], A[p...q], A[q+<span class="number">1.</span>..r]) &#123;</span><br><span class="line">    var i := p, j := q+<span class="number">1</span>, k := <span class="number">0</span>   <span class="comment">// 初始化变量 i, j, k</span></span><br><span class="line">    var tmp := <span class="keyword">new</span> <span class="built_in">array</span>[<span class="number">0.</span>..r-p]  <span class="comment">// 申请一个大小跟 A[p...r] 一样的临时数组</span></span><br><span class="line">    <span class="keyword">while</span> i&lt;=q AND j&lt;=r <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> A[i] &lt;= A[j] &#123;</span><br><span class="line">            tmp[k++] = A[i++]</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            tmp[k++] = A[j++]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断哪个子数组中有剩余的数据</span></span><br><span class="line">    var start := i, end := q</span><br><span class="line">    <span class="keyword">if</span> j&lt;=r then start := j, end := r</span><br><span class="line">    <span class="comment">// 将剩余的数据拷贝到临时数组 tmp</span></span><br><span class="line">    <span class="keyword">while</span> start &lt;= end <span class="keyword">do</span> &#123;</span><br><span class="line">        tmp[k++] = A[start++]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将 tmp 中的数组拷贝回 A[p...r]</span></span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span> to r-p <span class="keyword">do</span> &#123;</span><br><span class="line">        A[p+i] = tmp[i]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序的性能分析"><a href="#归并排序的性能分析" class="headerlink" title="归并排序的性能分析"></a>归并排序的性能分析</h2><p><strong>归并排序稳不稳定关键要看 merge() 函数</strong>，也就是两个有序子数组合并成一个有序数组的那部分代码。在合并的过程中，如果 A[p…q] 和 A[q+1…r] 之间有值相同的元素，那我们可以像伪代码中那样，先把 A[p…q] 中的元素放入 tmp 数组。这样就保证了值相同的元素，在合并前后的先后顺序不变。所以，归并排序是一个稳定的排序算法。</p><p>不仅递归求解的问题可以写成递推公式，<strong>递归代码的时间复杂度也可以写成递推公式</strong>。如果我们定义求解问题 a 的时间是 T(a)，求解问题 b, c 的时间分别是 T(b) 和 T(c)，那我们就可以得到这样的递推关系式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(a) = T(b) + T(c) + K </span><br><span class="line"><span class="comment">// K 等于将两个子问题 b, c 的结果合并成问题 a 的结果所消耗的时间</span></span><br></pre></td></tr></table></figure><p>套用这个公式，我们来分析一下归并排序的时间复杂度：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">T(<span class="number">1</span>) = C;            <span class="comment">// n=1 时，只需要常量级的执行时间，所以表示为 C</span></span><br><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n; <span class="comment">// n&gt;1</span></span><br><span class="line">     = <span class="number">2</span>^k * T(n/<span class="number">2</span>^k) + k*n</span><br></pre></td></tr></table></figure><p><strong>当 T(n/2^k)=T(1) 时，也就是 n/2^k=1，我们得到 k=log2n</strong>。我们将 k 值代入上面的公式，得到 T(n)=Cn+nlog2n。如果我们用大 O 标记法来表示的话，T(n) 就等于 O(nlogn)。所以归并排序的时间复杂度是 O(nlogn)。从我们的原理分析和伪代码可以看出，<strong>归并排序的执行效率与要排序的原始数组的有序程度无关</strong>，所以其时间复杂度是非常稳定的，不管是最好情况、最坏情况，还是平均情况，时间复杂度都是 O(nlogn)。</p><p>递归代码的空间复杂度并不能像时间复杂度那样累加。刚刚我们忘记了最重要的一点，那就是，尽管每次合并操作都需要申请额外的内存空间，但在合并完成之后，临时开辟的内存空间就被释放掉了。<strong>在任意时刻，CPU 只会有一个函数在执行，也就只会有一个临时的内存空间在使用</strong>。临时内存空间最大也不会超过 n 个数据的大小，所以空间复杂度是 O(n)。</p><h2 id="快速排序的原理"><a href="#快速排序的原理" class="headerlink" title="快速排序的原理"></a>快速排序的原理</h2><p><code>快速排序</code>（Quicksort）的思想是这样的：如果要排序数组中下标从 p 到 r 之间的一组数据，我们选择 p 到 r 之间的任意一个数据作为 <code>pivot</code>（分区点）。我们遍历 p 到 r 之间的数据，<strong>将小于 pivot 的放到左边，将大于 pivot 的放到右边，将 pivot 放到中间</strong>。经过这一步骤之后，数组 p 到 r 之间的数据就被分成了三个部分，前面 p 到 q-1 之间都是小于 pivot 的，中间是 pivot，后面的 q+1 到 r 之间是大于 pivot 的：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/56.png" alt></p><p>根据分治、递归的处理思想，我们可以用递归排序下标从 p 到 q-1 之间的数据和下标从 q+1 到 r 之间的数据，<strong>直到区间缩小为 1，就说明所有的数据都有序了</strong>。如果我们用递推公式来将上面的过程写出来的话，就是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递推公式</span></span><br><span class="line">quick_sort(p...r) = quick_sort(p...q<span class="number">-1</span>) + quick_sort(q+<span class="number">1.</span>..r)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 终止条件</span></span><br><span class="line">p &gt;= r</span><br></pre></td></tr></table></figure><p>我将递推公式转化成递归代码。跟归并排序一样，我还是用伪代码来实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速排序，A 是数组，n 表示数组的大小</span></span><br><span class="line">quick_sort(A, n) &#123;</span><br><span class="line">    quick_sort_c(A, <span class="number">0</span>, n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 快速排序递归函数，p, r 为下标</span></span><br><span class="line">quick_sort_c(A, p, r) &#123;</span><br><span class="line">    <span class="keyword">if</span> p &gt;= r then <span class="keyword">return</span></span><br><span class="line">    q = partition(A, p, r) <span class="comment">// 获取分区点</span></span><br><span class="line">    quick_sort_c(A, p, q<span class="number">-1</span>)</span><br><span class="line">    quick_sort_c(A, q+<span class="number">1</span>, r)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们不考虑空间消耗的话，partition() 分区函数可以写得非常简单。我们申请两个临时数组 X 和 Y，遍历 A[p…r]，将小于 pivot 的元素都拷贝到临时数组 X，将大于 pivot 的元素都拷贝到临时数组 Y，最后再将数组 X 和数组 Y 中数据顺序拷贝到 A[p…r]：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/57.png" alt></p><p>但是，如果按照这种思路实现的话，partition() 函数就需要很多额外的内存空间，所以快排就不是原地排序算法了。如果我们希望快排是原地排序算法，那它的空间复杂度得是 O(1)，那 <strong>partition() 分区函数就不能占用太多额外的内存空间</strong>，我们就需要在 A[p…r] 的原地完成分区操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">partition(A, p, r) &#123;</span><br><span class="line">    pivot := A[r]</span><br><span class="line">    i := p</span><br><span class="line">    <span class="keyword">for</span> j := p to r<span class="number">-1</span> <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> A[j] &lt; pivot &#123;</span><br><span class="line">            swap A[i] with A[j]</span><br><span class="line">            i := i+<span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    swap A[i] with A[r]</span><br><span class="line">    <span class="keyword">return</span> i</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里的处理有点类似选择排序。我们通过游标 i 把 A[p…r-1] 分成两部分。A[p…i-1] 的元素都是小于 pivot 的，我们暂且叫它<code>已处理区间</code>，A[i…r-1] 是<code>未处理区间</code>。我们每次都从未处理的区间 A[i…r-1] 中取一个元素 A[j]，与 pivot 对比，如果小于 pivot，则将其加入到已处理区间的尾部，也就是 A[i]的位置。文字不如图直观，所以我画了一张图来展示分区的整个过程：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/58.png" alt></p><p>因为<strong>分区的过程涉及交换操作</strong>，如果数组中有两个相同的元素，比如序列 6, 8, 7, 6, 3, 5, 9, 4，在经过第一次分区操作之后，两个 6 的相对先后顺序就会改变。所以，<strong>快速排序并不是一个稳定的排序算法</strong>。</p><p>快排和归并用的都是分治思想，递推公式和递归代码也非常相似，那它们的区别在哪里呢：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/59.png" alt></p><p>可以发现，归并排序的处理过程是<strong>由下到上</strong>的，先处理子问题，然后再合并。而快排正好相反，它的处理过程是<strong>由上到下</strong>的，先分区，然后再处理子问题。归并排序虽然是稳定的、时间复杂度为 O(nlogn) 的排序算法，但是它是非原地排序算法。我们前面讲过，归并之所以是非原地排序算法，主要原因是合并函数无法在原地执行。<strong>快速排序通过设计巧妙的原地分区函数，可以实现原地排序，解决了归并排序占用太多内存的问题</strong>。</p><h2 id="快速排序的性能分析"><a href="#快速排序的性能分析" class="headerlink" title="快速排序的性能分析"></a>快速排序的性能分析</h2><p>快排也是用递归来实现的。对于递归代码的时间复杂度，我前面总结的公式，这里也还是适用的。如果每次分区操作，都能正好把数组分成大小接近相等的两个小区间，那快排的时间复杂度递推求解公式跟归并是相同的。所以，快排的时间复杂度也是 O(nlogn)：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">T(<span class="number">1</span>) = C;            <span class="comment">// n=1 时，只需要常量级的执行时间，所以表示为 C</span></span><br><span class="line">T(n) = <span class="number">2</span>*T(n/<span class="number">2</span>) + n; <span class="comment">// n&gt;1</span></span><br></pre></td></tr></table></figure><p>但是，<strong>公式成立的前提是每次分区操作，我们选择的 pivot 都很合适，正好能将大区间对等地一分为二</strong>。但实际上这种情况是很难实现的。我举一个比较极端的例子。如果数组中的数据原来已经是有序的了，比如 1, 3, 5, 6, 8。如果我们每次选择最后一个元素作为 pivot，那每次分区得到的两个区间都是不均等的。我们需要进行大约 n 次分区操作，才能完成快排的整个过程。每次分区我们平均要扫描大约 n/2 个元素，这种情况下，快排的时间复杂度就从 O(nlogn) 退化成了 O(n^2)。</p><h2 id="O-n-时间复杂度内求无序数组中的第-K-大元素"><a href="#O-n-时间复杂度内求无序数组中的第-K-大元素" class="headerlink" title="O(n) 时间复杂度内求无序数组中的第 K 大元素"></a>O(n) 时间复杂度内求无序数组中的第 K 大元素</h2><p>我们选择数组区间 A[0…n-1] 的最后一个元素 A[n-1] 作为 pivot，对数组 A[0…n-1] 原地分区，这样数组就分成了三部分，A[0…p-1], A[p], A[p+1…n-1]。<strong>如果 p+1=K，那 A[p] 就是要求解的元素</strong>；如果 K&gt;p+1, 说明第 K 大元素出现在 A[p+1…n-1] 区间，我们再按照上面的思路递归地在 A[p+1…n-1] 这个区间内查找。同理，如果 K&lt;p+1，那我们就在 A[0…p-1] 区间查找：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/60.png" alt></p><p>第一次分区查找，我们需要对大小为 n 的数组执行分区操作，需要遍历 n 个元素。第二次分区查找，我们只需要对大小为 n/2 的数组执行分区操作，需要遍历 n/2 个元素。依次类推，分区遍历元素的个数分别为 n, n/2, n/4, n/8, n/16, …直到区间缩小为 1。如果我们把每次分区遍历的元素个数加起来，就是：n+n/2+n/4+n/8+…+1。这是一个等比数列求和，最后的和等于 2n-1。所以，上述解决思路的时间复杂度就为 O(n)。</p><p>你可能会说，我有个很笨的办法，每次取数组中的最小值，将其移动到数组的最前面，然后在剩下的数组中继续找最小值，以此类推，执行 K 次，找到的数据不就是第 K 大元素了吗？不过，<strong>时间复杂度就并不是 O(n) 了，而是 O(K * n)</strong>。当 K 是比较小的常量时，比如 1, 2，那最好时间复杂度确实是 O(n)；但当 K 等于 n/2 或者 n 时，这种最坏情况下的时间复杂度就是 O(n^2) 了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>递归</title>
      <link href="2020/12/29/%E9%80%92%E5%BD%92/"/>
      <url>2020/12/29/%E9%80%92%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>现在很多 App 都有推荐注册返佣金的功能。这个功能中，用户 A 推荐用户 B 来注册，用户 B 又推荐了用户 C 来注册。我们可以说，用户 C 的“最终推荐人”为用户 A，用户 B 的“最终推荐人”也为用户 A，而用户 A 没有“最终推荐人”。一般来说，我们会<strong>通过数据库来记录这种推荐关系</strong>。在数据库表中，我们可以记录两行数据，其中 actor_id 表示用户 id，referrer_id 表示推荐人 id：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/39.png" alt></p><h2 id="如何理解“递归”？"><a href="#如何理解“递归”？" class="headerlink" title="如何理解“递归”？"></a>如何理解“递归”？</h2><p><code>递归</code>（Recursion）是一种应用非常广泛的算法（或者编程技巧）。很多数据结构和算法的编码实现都要用到递归，比如 DFS 深度优先搜索、前中后序二叉树遍历等等。所以，<strong>搞懂递归非常重要</strong>，否则，复杂一些的数据结构和算法学起来就会比较吃力。</p><a id="more"></a><p>周末你带着女朋友去电影院看电影，女朋友问你，咱们现在坐在第几排啊？于是你就问前面一排的人他是第几排，你想只要在他的数字上加一，就知道自己在哪一排了。但是，前面的人也看不清啊，所以他也问他前面的人。就这样一排一排往前问，直到问到第一排的人，说我在第一排，然后再这样一排一排再把数字传回来。直到你前面的人告诉你他在哪一排，于是你就知道答案了。</p><p>这就是一个非常标准的递归求解问题的分解过程，<strong>去的过程叫递，回来的过程叫归</strong>。基本上，所有的递归问题都可以用<code>递推公式</code>来表示。刚刚这个生活中的例子，我们用递推公式将它表示出来就是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>) = <span class="number">1</span></span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + <span class="number">1</span></span><br></pre></td></tr></table></figure><p>f(n) 表示你想知道自己在哪一排，f(n-1) 表示前面一排所在的排数，f(1)=1 表示第一排的人知道自己在第一排。有了这个递推公式，我们就可以很轻松地将它改为递归代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归需要满足的三个条件"><a href="#递归需要满足的三个条件" class="headerlink" title="递归需要满足的三个条件"></a>递归需要满足的三个条件</h2><p>我总结了三个条件，只要同时满足以下三个条件，就可以用递归来解决：</p><ol><li><strong>一个问题的解可以分解为几个子问题的解</strong>：子问题就是数据规模更小的问题。比如，前面讲的电影院的例子，你要知道，“自己在哪一排”的问题，可以分解为“前一排的人在哪一排”这样一个子问题；</li><li><strong>这个问题与分解之后的子问题，除了数据规模不同，求解思路完全一样</strong>：比如电影院那个例子，你求解“自己在哪一排”的思路，和前面一排人求解“自己在哪一排”的思路，是一模一样的；</li><li><strong>存在递归终止条件</strong>：把问题分解为子问题，把子问题再分解为子子问题，一层一层分解下去，不能存在无限循环，这就需要有终止条件。还是电影院的例子，第一排的人不需要再继续询问任何人，就知道自己在哪一排，也就是 f(1)=1，这就是递归的终止条件；</li></ol><h2 id="如何编写递归代码？"><a href="#如何编写递归代码？" class="headerlink" title="如何编写递归代码？"></a>如何编写递归代码？</h2><p>我个人觉得，写递归代码最关键的是<strong>写出递推公式，找到终止条件</strong>，剩下将递推公式转化为代码就很简单了。</p><p>假如这里有 n 个台阶，每次你可以跨 1 个台阶或者 2 个台阶，请问走这 n 个台阶有多少种走法？如果有 7 个台阶，你可以 2, 2, 2, 1 这样子上去，也可以 1, 2, 1, 1, 2 这样子上去。我们仔细想下，实际上，可以根据第一步的走法把所有走法分为两类，第一类是第一步走了 1 个台阶，另一类是第一步走了 2 个台阶。所以 n 个台阶的走法就等于先走 1 阶后，n-1 个台阶的走法 加上先走 2 阶后，n-2 个台阶的走法。用公式表示就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f(n) = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>我们再来看下终止条件。当有一个台阶时，我们不需要再继续递归，就只有一种走法。所以 f(1)=1。这个递归终止条件足够吗？我们可以<strong>用 n=2, n=3 这样比较小的数试验一下</strong>。n=2 时，f(2)=f(1)+f(0)。如果递归终止条件只有一个 f(1)=1，那 f(2) 就无法求解了。所以除了 f(1)=1 这一个递归终止条件外，还要有 f(0)=1，表示走 0 个台阶有一种走法，不过这样子看起来就不符合正常的逻辑思维了。所以，我们可以把 f(2)=2 作为一种终止条件，表示走 2 个台阶，有两种走法，一步走完或者分两步来走。所以，递归终止条件就是 f(1)=1, f(2)=2。</p><p>我们把递归终止条件和刚刚得到的递推公式放到一起就是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(<span class="number">1</span>) = <span class="number">1</span>;</span><br><span class="line">f(<span class="number">2</span>) = <span class="number">2</span>;</span><br><span class="line">f(n) = f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>)</span><br></pre></td></tr></table></figure><p>有了这个公式，我们转化成递归代码就简单多了。最终的递归代码是这样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(n<span class="number">-1</span>) + f(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果一个问题 A 可以分解为若干子问题 B、C、D，你可以假设子问题 B、C、D 已经解决，在此基础上思考如何解决问题 A。而且，你<strong>只需要思考问题 A 与子问题 B、C、D 两层之间的关系即可</strong>，不需要一层一层往下思考子问题与子子问题，子子问题与子子子问题之间的关系。屏蔽掉递归细节，这样子理解起来就简单多了。</p><blockquote><p>编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。</p></blockquote><h2 id="递归代码要警惕堆栈溢出"><a href="#递归代码要警惕堆栈溢出" class="headerlink" title="递归代码要警惕堆栈溢出"></a>递归代码要警惕堆栈溢出</h2><p>函数调用会使用栈来保存临时变量。每调用一个函数，都会将临时变量封装为栈帧压入内存栈，等函数执行完成返回时，才出栈。系统栈或者虚拟机栈空间一般都不大。<strong>如果递归求解的数据规模很大，调用层次很深，一直压入栈，就会有堆栈溢出的风险</strong>。比如前面的讲到的电影院的例子，如果我们将系统栈或者 JVM 堆栈大小设置为 1KB，在求解 f(19999) 时便会出现如下堆栈报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread <span class="string">"main"</span> java.lang.StackOverflowError</span><br></pre></td></tr></table></figure><p>我们可以通过在代码中限制递归调用的最大深度的方式来解决这个问题。递归调用超过一定深度（比如 1000）之后，我们就不继续往下再递归了，直接返回报错。还是电影院那个例子，我们可以改造成下面这样子，就可以避免堆栈溢出了：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局变量，表示递归的深度</span></span><br><span class="line"><span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    ++depth；</span><br><span class="line">    <span class="keyword">if</span> (depth &gt; <span class="number">1000</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f(n - <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但这种做法并不能完全解决问题，因为<strong>最大允许的递归深度跟当前线程剩余的栈空间大小有关，事先无法计算</strong>。如果实时计算，代码过于复杂，就会影响代码的可读性。所以，如果最大深度比较小，比如 10、50，就可以用这种方法，否则这种方法并不是很实用。</p><h2 id="递归代码要警惕重复计算"><a href="#递归代码要警惕重复计算" class="headerlink" title="递归代码要警惕重复计算"></a>递归代码要警惕重复计算</h2><p>除此之外，使用递归时还会出现重复计算的问题。刚才我讲的第二个递归代码的例子，如果我们把整个递归过程分解一下的话，那就是这样的：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/40.png" alt></p><p>从图中，我们可以直观地看到，想要计算 f(5)，需要先计算 f(4) 和 f(3)，而计算 f(4) 还需要计算 f(3)，因此，f(3) 就被计算了很多次，这就是重复计算问题。为了避免重复计算，我们可以<strong>通过一个数据结构（比如散列表）来保存已经求解过的 f(k)</strong>。当递归调用到 f(k) 时，先看下是否已经求解过了。如果是，则直接从散列表中取值返回，不需要重复计算，这样就能避免刚讲的问题了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// hasSolvedList 可以理解成一个 Map，key 是 n，value 是 f(n)</span></span><br><span class="line">    <span class="keyword">if</span> (hasSolvedList.containsKey(n)) &#123;</span><br><span class="line">        <span class="keyword">return</span> hasSolvedList.get(n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = f(n-<span class="number">1</span>) + f(n-<span class="number">2</span>);</span><br><span class="line">    hasSolvedList.put(n, ret);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在时间复杂度上，递归代码里多了很多函数调用，<strong>当这些函数调用的数量较大时，就会积聚成一个可观的时间成本</strong>；在空间复杂度上，因为<strong>递归调用一次就会在内存栈中保存一次现场数据</strong>，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面讲到的电影院递归代码，空间复杂度并不是 O(1)，而是 O(n)。</p><h2 id="怎么将递归代码改写为非递归代码？"><a href="#怎么将递归代码改写为非递归代码？" class="headerlink" title="怎么将递归代码改写为非递归代码？"></a>怎么将递归代码改写为非递归代码？</h2><p>我们刚说了，递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是<strong>空间复杂度高、有堆栈溢出的风险、存在重复计算、过多的函数调用会耗时较多等问题</strong>。所以，在开发过程中，我们要根据实际情况来选择是否需要用递归的方式来实现。</p><p>那我们是否可以把递归代码改写为非递归代码呢？比如刚才那个电影院的例子，我们抛开场景，只看 f(x)=f(x-1)+1 这个递推公式。我们这样改写看看：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ret = ret + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同样，第二个例子也可以改为非递归的实现方式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> prepre = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        ret = pre + prepre;</span><br><span class="line">        prepre = pre;</span><br><span class="line">        pre = ret;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那是不是所有的递归代码都可以改为这种<code>迭代循环</code>的非递归写法呢？笼统地讲，是的。因为递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。<strong>如果我们自己在内存堆上实现栈，手动模拟入栈、出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子</strong>。但是这种思路实际上是<strong>将递归改为了手动递归，本质并没有变</strong>，而且也并没有解决前面讲到的某些问题，徒增了实现的复杂度。</p><h2 id="如何找到“最终推荐人”"><a href="#如何找到“最终推荐人”" class="headerlink" title="如何找到“最终推荐人”"></a>如何找到“最终推荐人”</h2><p>我的解决方案是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">findRootReferrerId</span><span class="params">(<span class="keyword">long</span> actorId)</span> </span>&#123;</span><br><span class="line">    Long referrerId = SELECT referrer_id FROM [table] WHERE actor_id = actorId;</span><br><span class="line">    <span class="keyword">if</span> (referrerId == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> actorId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> findRootReferrerId(referrerId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过在实际项目中，上面的代码并不能工作，这里面有两个问题：</p><ol><li>如果递归很深，可能会有堆栈溢出的问题；</li><li><strong>如果数据库里存在脏数据，我们还需要处理由此产生的无限递归问题</strong>。比如 demo 环境下数据库中，测试工程师为了方便测试，会人为地插入一些数据，就会出现脏数据。如果 A 的推荐人是 B，B 的推荐人是 C，C 的推荐人是 A，这样就会发生死循环；</li></ol><p>第一个问题，我前面已经解答过了，可以用限制递归深度来解决。第二个问题，也可以用限制递归深度来解决。不过，还有一个更高级的处理方法，就是<strong>自动检测 A-&gt;B-&gt;C-&gt;A 这种环的存在</strong>。</p><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/climbing-stairs/" target="_blank" rel="noopener">Climbing Stairs</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列</title>
      <link href="2020/12/28/%E9%98%9F%E5%88%97/"/>
      <url>2020/12/28/%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>我们知道，CPU 资源是有限的，<strong>任务的处理速度与线程个数并不是线性正相关</strong>。相反，过多的线程反而会导致 CPU 频繁切换，处理性能下降。所以，线程池的大小一般都是综合考虑要处理任务的特点和硬件环境，来事先设置的。</p><h2 id="如何理解“队列”？"><a href="#如何理解“队列”？" class="headerlink" title="如何理解“队列”？"></a>如何理解“队列”？</h2><p><code>队列</code>（Queue）这个概念非常好理解。你可以把它想象成排队买票，先来的先买，后来的人只能站末尾，不允许插队。<strong>先进者先出</strong>，这就是典型的队列。</p><p>我们知道，栈只支持两个基本操作：入栈 push()和出栈 pop()。队列跟栈非常相似，支持的操作也很有限，最基本的操作也是两个：<strong>入队 enqueue()</strong>，放一个数据到队列尾部；<strong>出队 dequeue()</strong>，从队列头部取一个元素。所以，队列跟栈一样，也是一种操作受限的线性表数据结构：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/29.png" alt></p><p>队列的概念很好理解，基本操作也很容易掌握。作为一种非常基础的数据结构，队列的应用也非常广泛，特别是一些具有某些额外特性的队列，比如循环队列、阻塞队列、并发队列。它们<strong>在很多偏底层系统、框架、中间件的开发中，起着关键性的作用</strong>。比如高性能队列 Disruptor、Linux 环形缓存，都用到了循环并发队列；java.util.concurrent 并发包利用 ArrayBlockingQueue 来实现公平锁等。</p><a id="more"></a><h2 id="顺序队列和链式队列"><a href="#顺序队列和链式队列" class="headerlink" title="顺序队列和链式队列"></a>顺序队列和链式队列</h2><p>跟栈一样，队列可以用数组来实现，也可以用链表来实现。用数组实现的队列叫作<code>顺序队列</code>，用链表实现的队列叫作<code>链式队列</code>。我们先来看下基于数组的实现方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用数组实现的队列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">        n = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 tail == n 表示队列已经满了</span></span><br><span class="line">        <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        ++tail;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ret = items[head];</span><br><span class="line">        ++head;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于栈来说，我们只需要一个栈顶指针就可以了。但是<strong>队列需要两个指针：一个是 head 指针，指向队头；一个是 tail 指针，指向队尾</strong>。你可以结合下面这张图来理解。当 a, b, c, d 依次入队之后，队列中的 head 指针指向下标为 0 的位置，tail 指针指向下标为 4 的位置：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/30.png" alt></p><p>当我们调用两次出队操作之后，队列中 head 指针指向下标为 2 的位置，tail 指针仍然指向下标为 4 的位置：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/31.png" alt></p><p>你肯定已经发现了，随着不停地进行入队、出队操作，head 和 tail 都会持续往后移动。当 tail 移动到最右边，即使数组中还有空闲空间，也无法继续往队列中添加数据了。实际上，我们在出队时可以不用搬移数据。如果没有空闲空间了，我们<strong>只需要在入队时，再集中触发一次数据的搬移操作</strong>。借助这个思想，出队函数 dequeue() 保持不变，我们稍加改造一下入队函数 enqueue() 的实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入队操作，将 item 放入队尾</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// tail == n 表示队列末尾没有空间了</span></span><br><span class="line">    <span class="keyword">if</span> (tail == n) &#123;</span><br><span class="line">        <span class="comment">// tail==n &amp;&amp; head==0，表示整个队列都占满了</span></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数据搬移</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = head; i &lt; tail; ++i) &#123;</span><br><span class="line">            items[i-head] = items[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 搬移完之后重新更新 head 和 tail</span></span><br><span class="line">        tail -= head;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    items[tail] = item;</span><br><span class="line">    ++tail;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们看到，当队列的 tail 指针移动到数组的最右边后，如果有新的数据入队，我们可以<strong>将 head 到 tail 之间的数据，整体搬移到数组中 0 到 tail-head 的位置</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/32.png" alt></p><p>基于链表的实现，我们同样需要两个指针：head 指针和 tail 指针。它们分别指向链表的第一个结点和最后一个结点。如图所示，入队时，tail-&gt;next= new_node, tail = tail-&gt;next；出队时，head = head-&gt;next：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/33.png" alt></p><h2 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h2><p><code>循环队列</code>，顾名思义，它长得像一个环。原本数组是有头有尾的，是一条直线。现在我们把首尾相连，扳成了一个环。我画了一张图，你可以直观地感受一下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/34.png" alt></p><p>我们可以发现，图中这个队列的大小为 8，当前 head=4, tail=7。当有一个新的元素 a 入队时，我们放入下标为 7 的位置。但这个时候，我们<strong>并不把 tail 更新为 8，而是将其在环中后移一位，到下标为 0 的位置</strong>。当再有一个元素 b 入队时，我们将 b 放入下标为 0 的位置，然后 tail 加 1 更新为 1。所以，在 a, b 依次入队之后，循环队列中的元素就变成了下面的样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/35.png" alt></p><p>通过这样的方法，我们成功避免了数据搬移操作。看起来不难理解，但是循环队列的代码实现难度要比前面讲的非循环队列难多了。要想写出没有 bug 的循环队列的实现代码，我个人觉得，最关键的是，<strong>确定好队空和队满的判定条件</strong>。在用数组实现的非循环队列中，队满的判断条件是 tail == n，队空的判断条件是 head == tail。针对循环队列，<strong>队列为空的判断条件仍然是 head == tail</strong>。但队列满的判断条件就稍微有点复杂了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/36.png" alt></p><p>就像我图中画的队满的情况，tail=3, head=4, n=8，所以总结一下规律就是：(3+1)%8=4。多画几张队满的图，你就会发现，<strong>当队满时，(tail+1)%n=head</strong>。你有没有发现，当队列满时，图中的 tail 指向的位置实际上是没有存储数据的。所以，循环队列会浪费一个数组的存储空间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CircularQueue</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 数组：items，数组大小：n</span></span><br><span class="line">    <span class="keyword">private</span> String[] items;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// head 表示队头下标，tail 表示队尾下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 申请一个大小为 capacity 的数组</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CircularQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">        items = <span class="keyword">new</span> String[capacity];</span><br><span class="line">        n = capacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">enqueue</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 队列满了</span></span><br><span class="line">        <span class="keyword">if</span> ((tail + <span class="number">1</span>) % n == head) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        items[tail] = item;</span><br><span class="line">        tail = (tail + <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出队</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果 head == tail 表示队列为空</span></span><br><span class="line">        <span class="keyword">if</span> (head == tail) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        String ret = items[head];</span><br><span class="line">        head = (head + <span class="number">1</span>) % n;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="阻塞队列和并发队列"><a href="#阻塞队列和并发队列" class="headerlink" title="阻塞队列和并发队列"></a>阻塞队列和并发队列</h2><p>队列这种数据结构很基础，平时的业务开发不大可能从零实现一个队列，甚至都不会直接用到。而<strong>一些具有特殊特性的队列应用却比较广泛</strong>，比如阻塞队列和并发队列。</p><h3 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h3><p><code>阻塞队列</code>其实就是<strong>在队列基础上增加了阻塞操作</strong>。简单来说，就是在队列为空的时候，从队头取数据会被阻塞。因为此时还没有数据可取，直到队列中有了数据才能返回；如果队列已经满了，那么插入数据的操作就会被阻塞，直到队列中有空闲位置后再插入数据，然后再返回：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/37.png" alt></p><p>这种基于阻塞队列实现的“生产者-消费者模型”，可以有效地协调生产和消费的速度。当“生产者”生产数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就阻塞等待，直到“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。而且不仅如此，基于阻塞队列，我们还可以<strong>通过协调“生产者”和“消费者”的个数，来提高数据的处理效率</strong>。比如前面的例子，我们可以多配置几个“消费者”，来应对一个“生产者”：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/38.png" alt></p><h3 id="并发队列"><a href="#并发队列" class="headerlink" title="并发队列"></a>并发队列</h3><p>前面我们讲了阻塞队列，在多线程情况下，会有多个线程同时操作队列，这个时候就会存在线程安全问题。<strong>线程安全的队列</strong>我们叫作<code>并发队列</code>。最简单直接的实现方式是直接在 enqueue()、dequeue() 方法上加锁，但是锁粒度大并发度会比较低，同一时刻仅允许一个存或者取操作。实际上，<strong>基于数组的循环队列，利用 CAS 原子操作，可以实现非常高效的并发队列</strong>。这也是循环队列比链式队列应用更加广泛的原因。</p><h2 id="队列在有限资源池中的应用"><a href="#队列在有限资源池中的应用" class="headerlink" title="队列在有限资源池中的应用"></a>队列在有限资源池中的应用</h2><p>我们一般有两种处理策略。第一种是<strong>非阻塞的处理方式，直接拒绝任务请求</strong>；另一种是阻塞的处理方式，将请求排队，等到有空闲线程时，取出排队的请求继续处理。</p><p>基于链表的实现方式，可以实现一个支持无限排队的<code>无界队列</code>（Unbounded Queue），但是可能会导致过多的请求排队等待，请求处理的响应时间过长。所以，<strong>针对响应时间比较敏感的系统，基于链表实现的无限排队的线程池是不合适的</strong>；而基于数组实现的<code>有界队列</code>（Bounded Queue），队列的大小有限，所以线程池中排队的请求超过队列大小时，接下来的请求就会被拒绝，这种方式对响应时间敏感的系统来说，就相对更加合理。不过，<strong>设置一个合理的队列大小，也是非常有讲究的</strong>。队列太大导致等待的请求太多，队列太小会导致无法充分利用系统资源、发挥最大性能。</p><p>除了前面讲到队列应用在线程池请求排队的场景之外，队列可以应用在任何有限资源池中，用于排队请求，比如数据库连接池等。实际上，<strong>对于大部分资源有限的场景，当没有空闲资源时，基本上都可以通过队列这种数据结构来实现请求排队</strong>。</p><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/design-circular-deque/" target="_blank" rel="noopener">Design Circular Deque</a><br><a href="https://leetcode.com/problems/sliding-window-maximum/" target="_blank" rel="noopener">Sliding Window Maximum</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈</title>
      <link href="2020/12/27/%E6%A0%88/"/>
      <url>2020/12/27/%E6%A0%88/</url>
      
        <content type="html"><![CDATA[<p>当你依次访问完一串页面 a-&gt;b-&gt;c 之后，点击浏览器的后退按钮，就可以查看之前浏览过的页面 b 和 a。当你后退到页面 a，点击前进按钮，就可以重新查看页面 b 和 c。但是，如果你后退到页面 b 后，点击了新的页面 d，那就无法再通过前进、后退功能查看页面 c 了。</p><h2 id="如何理解“栈”？"><a href="#如何理解“栈”？" class="headerlink" title="如何理解“栈”？"></a>如何理解“栈”？</h2><p>关于<code>栈</code>（Stack），我有一个非常贴切的例子，就是一摞叠在一起的盘子。我们平时放盘子的时候，都是从下往上一个一个放；取的时候，我们也是从上往下一个一个地依次取，不能从中间任意抽出。<strong>后进者先出，先进者后出</strong>，这就是典型的栈结构：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/20.png" alt></p><p>从栈的操作特性上来看，栈是一种<strong>操作受限的线性表</strong>，只允许在一端插入和删除数据。事实上，从功能上来说，数组或链表确实可以替代栈，但你要知道，特定的数据结构是对特定场景的抽象，而且，<strong>数组或链表暴露了太多的操作接口</strong>，操作上的确灵活自由，但使用时就比较不可控，自然也就更容易出错。</p><blockquote><p>当某个数据集合只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性，这时我们就应该首选栈这种数据结构。</p></blockquote><a id="more"></a><h2 id="如何实现一个“栈”？"><a href="#如何实现一个“栈”？" class="headerlink" title="如何实现一个“栈”？"></a>如何实现一个“栈”？</h2><p>从刚才栈的定义里，我们可以看出，栈主要包含两个操作，入栈和出栈，也就是在栈顶插入一个数据和从栈顶删除一个数据。实际上，栈既可以用数组来实现，也可以用链表来实现。用数组实现的栈，我们叫作<code>顺序栈</code>，用链表实现的栈，我们叫作<code>链式栈</code>。我这里实现一个基于数组的顺序栈：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 基于数组实现的顺序栈</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayStack</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] items;  <span class="comment">// 数组</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;       <span class="comment">// 栈中元素个数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;           <span class="comment">// 栈的大小</span></span><br><span class="line">    <span class="comment">// 初始化数组，申请一个大小为 n 的数组空间</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayStack</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.items = <span class="keyword">new</span> String[n];</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">        <span class="keyword">this</span>.count = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 入栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">push</span><span class="params">(String item)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 数组空间不够了，直接返回 false，入栈失败</span></span><br><span class="line">        <span class="keyword">if</span> (count == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 item 放到下标为 count 的位置，并且 count 加一</span></span><br><span class="line">        items[count] = item;</span><br><span class="line">        ++count;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 栈为空，则直接返回 null</span></span><br><span class="line">        <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 返回下标为 count-1 的数组元素，并且栈中元素个数 count 减一</span></span><br><span class="line">        String tmp = items[count-<span class="number">1</span>];</span><br><span class="line">        --count;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不管是顺序栈还是链式栈，我们存储数据只需要一个大小为 n 的数组就够了。在入栈和出栈过程中，只需要一两个临时变量存储空间，所以空间复杂度是 O(1)。注意，这里存储数据需要一个大小为 n 的数组，并不是说空间复杂度就是 O(n)。因为，这 n 个空间是必须的，无法省掉。所以我们说空间复杂度的时候，是指<strong>除了原本的数据存储空间外，算法运行还需要额外的存储空间</strong>。</p><p>不管是顺序栈还是链式栈，入栈、出栈只涉及栈顶个别数据的操作，所以时间复杂度都是 O(1)。</p><h2 id="支持动态扩容的顺序栈"><a href="#支持动态扩容的顺序栈" class="headerlink" title="支持动态扩容的顺序栈"></a>支持动态扩容的顺序栈</h2><p>刚才那个基于数组实现的栈，是一个固定大小的栈，也就是说，<strong>在初始化栈时需要事先指定栈的大小</strong>。当栈满之后，就无法再往栈里添加数据了。尽管链式栈的大小不受限，但要存储 next 指针，内存消耗相对较多。</p><p>如果要实现一个支持动态扩容的栈，我们只需要<strong>底层依赖一个支持动态扩容的数组</strong>就可以了。当栈满了之后，我们就申请一个更大的数组，将原来的数据搬移到新数组中。我画了一张图，你可以对照着理解一下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/21.png" alt></p><p>对于出栈操作来说，我们不会涉及内存的重新申请和数据的搬移，所以出栈的时间复杂度仍然是 O(1)。但是，对于入栈操作来说，情况就不一样了。当栈中有空闲空间时，入栈操作的时间复杂度为 O(1)。但当空间不够时，就需要重新申请内存和数据搬移，所以时间复杂度就变成了 O(n)。也就是说，对于入栈操作来说，最好情况时间复杂度是 O(1)，最坏情况时间复杂度是 O(n)。</p><p>为了分析的方便，我们需要事先做一些假设和定义：</p><ul><li>栈空间不够时，我们重新申请一个是原来大小两倍的数组；</li><li>为了简化分析，假设只有入栈操作没有出栈操作；</li><li>定义不涉及内存搬移的入栈操作为 simple-push 操作，时间复杂度为 O(1)；</li></ul><p>如果当前栈大小为 K，并且已满，当再有新的数据要入栈时，就需要重新申请 2 倍大小的内存，并且做 K 个数据的搬移操作，然后再入栈。但是，接下来的 K-1 次入栈操作，我们都不需要再重新申请内存和搬移数据，所以这 K-1 次入栈操作都只需要一个 simple-push 操作就可以完成：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/22.png" alt></p><p>你应该可以看出来，这 K 次入栈操作，总共涉及了 K 个数据的搬移，以及 K 次 simple-push 操作。将 K 个数据搬移均摊到 K 次入栈操作，那每个入栈操作只需要一个数据搬移和一个 simple-push 操作。以此类推，<strong>入栈操作的均摊时间复杂度就为 O(1)</strong>。</p><h2 id="栈在函数调用中的应用"><a href="#栈在函数调用中的应用" class="headerlink" title="栈在函数调用中的应用"></a>栈在函数调用中的应用</h2><p>我们知道，<strong>操作系统给每个线程分配了一块独立的内存空间</strong>，这块内存被组织成栈这种结构, 用来存储函数调用时的临时变量。每进入一个函数，就会将临时变量作为一个栈帧入栈，当被调用函数执行完成，返回之后，将这个函数对应的栈帧出栈：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    ret = add(<span class="number">3</span>, <span class="number">5</span>);</span><br><span class="line">    res = a + ret;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    sum = x + y;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看出，main() 函数调用了 add() 函数，获取计算结果，并且与临时变量 a 相加，最后打印 res 的值。为了让你清晰地看到这个过程对应的函数栈里出栈、入栈的操作，我画了一张图。图中显示的是，在执行到 add() 函数时，函数调用栈的情况：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/23.png" alt></p><h2 id="栈在表达式求值中的应用"><a href="#栈在表达式求值中的应用" class="headerlink" title="栈在表达式求值中的应用"></a>栈在表达式求值中的应用</h2><p>为了方便解释，我将算术表达式简化为只包含加减乘除四则运算，比如：34+13*9+44-12/3。</p><p>实际上，编译器就是通过两个栈来实现的。其中一个保存操作数的栈，另一个是保存运算符的栈。我们从左向右遍历表达式，当遇到数字，我们就直接压入操作数栈；当遇到运算符，就与运算符栈的栈顶元素进行比较。如果比运算符栈顶元素的优先级高，就将当前运算符压入栈；<strong>如果比运算符栈顶元素的优先级低或者相同，从运算符栈中取栈顶运算符，从操作数栈的栈顶取 2 个操作数</strong>，然后进行计算，再把计算完的结果压入操作数栈，继续比较。</p><p>我将 3+5*8-6 这个表达式的计算过程画成了一张图，你可以结合图来理解我刚讲的计算过程：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/24.png" alt></p><h2 id="栈在括号匹配中的应用"><a href="#栈在括号匹配中的应用" class="headerlink" title="栈在括号匹配中的应用"></a>栈在括号匹配中的应用</h2><p>我们同样简化一下背景。我们假设表达式中只包含三种括号，圆括号()、方括号[]和花括号{}，并且它们可以任意嵌套。比如，{<a href></a>[{}]} 或 [{()}([])] 等都为合法格式，而 {[}()] 或 [({)] 为不合法的格式。</p><p>我们用栈来保存未匹配的左括号，从左到右依次扫描字符串。当扫描到左括号时，则将其压入栈中；当扫描到右括号时，从栈顶取出一个左括号。如果能够匹配，比如“(”跟“)”匹配，“[”跟“]”匹配，“{”跟“}”匹配，则继续扫描剩下的字符串。如果扫描的过程中，遇到不能配对的右括号，或者栈中没有数据，则说明为非法格式。<strong>当所有的括号都扫描完成之后，如果栈为空，则说明字符串为合法格式</strong>；否则，说明有未匹配的左括号，为非法格式。</p><h2 id="基于栈实现浏览器的前进、后退功能"><a href="#基于栈实现浏览器的前进、后退功能" class="headerlink" title="基于栈实现浏览器的前进、后退功能"></a>基于栈实现浏览器的前进、后退功能</h2><p>我们使用两个栈，X 和 Y，我们把首次浏览的页面依次压入栈 X，<strong>当点击后退按钮时，再依次从栈 X 中出栈，并将出栈的数据依次放入栈 Y</strong>。当我们点击前进按钮时，我们依次从栈 Y 中取出数据，放入栈 X 中。当栈 X 中没有数据时，那就说明没有页面可以继续后退浏览了。当栈 Y 中没有数据，那就说明没有页面可以点击前进按钮浏览了：</p><ol><li>比如你顺序查看了 a, b, c 三个页面，我们就依次把 a, b, c 压入栈，这个时候，两个栈的数据就是这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/25.png" alt></li><li>当你通过浏览器的后退按钮，从页面 c 后退到页面 a 之后，我们就依次把 c 和 b 从栈 X 中弹出，并且依次放入到栈 Y。这个时候，两个栈的数据就是这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/26.png" alt></li><li>这个时候你又想看页面 b，于是你又点击前进按钮回到 b 页面，我们就把 b 再从栈 Y 中出栈，放入栈 X 中。此时两个栈的数据是这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/27.png" alt></li><li>这个时候，你通过页面 b 又跳转到新的页面 d 了，<strong>页面 c 就无法再通过前进、后退按钮重复查看了，所以需要清空栈 Y</strong>。此时两个栈的数据这个样子：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/28.png" alt></li></ol><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/valid-parentheses/" target="_blank" rel="noopener">Valid Parentheses</a><br><a href="https://leetcode.com/problems/longest-valid-parentheses/" target="_blank" rel="noopener">Longest Valid Parentheses</a><br><a href="https://leetcode.com/problems/evaluate-reverse-polish-notation/" target="_blank" rel="noopener">Evaluate Reverse Polish Notation</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表</title>
      <link href="2020/12/27/%E9%93%BE%E8%A1%A8/"/>
      <url>2020/12/27/%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<p><code>缓存</code>是一种提高数据读取性能的技术，在硬件设计、软件开发中都有着非常广泛的应用，比如常见的 CPU 缓存、数据库缓存、浏览器缓存等等。缓存的大小有限，当缓存被用满时，哪些数据应该被清理出去，哪些数据应该被保留？这就需要缓存淘汰策略来决定。常见的策略有三种：</p><ul><li>先进先出策略 FIFO（First In, First Out）；</li><li>最少使用策略 LFU（Least Frequently Used）；</li><li>最近最少使用策略 LRU（Least Recently Used）；</li></ul><h2 id="五花八门的链表结构"><a href="#五花八门的链表结构" class="headerlink" title="五花八门的链表结构"></a>五花八门的链表结构</h2><p>相比数组，<code>链表</code>（Linked List）是一种稍微复杂一点的数据结构。我们先从<strong>底层的存储结构</strong>上来看一看，为了直观地对比，我画了一张图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/10.png" alt></p><p>从图中我们看到，数组需要一块<strong>连续的内存空间</strong>来存储，对内存的要求比较高。如果我们申请一个 100MB 大小的数组，当内存中没有连续的、足够大的存储空间时，即便内存的剩余总可用空间大于 100MB，仍然会申请失败；而链表恰恰相反，它并不需要一块连续的内存空间，它通过“指针”将一组<strong>零散的内存块</strong>串联起来使用，所以如果我们申请的是 100MB 大小的链表，根本不会有问题。</p><a id="more"></a><h3 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h3><p>我们刚刚讲到，链表通过指针将一组零散的内存块串联在一起。其中，我们把内存块称为链表的<code>结点</code>。为了将所有的结点串起来，每个链表的结点除了存储数据之外，还需要记录链上的下一个结点的地址。如图所示，我们把这个记录下个结点地址的指针叫作<strong>后继指针 next</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/11.png" alt></p><p>从我画的单链表图中，你应该可以发现，其中有两个结点是比较特殊的，它们分别是第一个结点和最后一个结点。我们习惯性地把第一个结点叫作<code>头结点</code>，把最后一个结点叫作<code>尾结点</code>。其中，头结点用来记录链表的基地址。有了它，我们就可以遍历得到整条链表。而尾结点特殊的地方是：指针不是指向下一个结点，而是指向一个<strong>空地址 NULL</strong>，表示这是链表上最后一个结点。</p><p>在链表中插入或者删除一个数据，我们并不需要为了保持内存的连续性而搬移结点，因为链表的存储空间本身就不是连续的。所以，在链表中插入和删除一个数据是非常快速的。为了方便你理解，我画了一张图，从图中我们可以看出，针对链表的插入和删除操作，我们只需要考虑相邻结点的指针改变，所以对应的<strong>时间复杂度是 O(1)</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/12.png" alt></p><p>但是，有利就有弊。链表要想随机访问第 k 个元素，就没有数组那么高效了。因为链表中的数据并非连续存储的，所以无法像数组那样，根据首地址和下标，通过寻址公式就能直接计算出对应的内存地址，而是需要根据指针一个结点一个结点地依次遍历，直到找到相应的结点。<strong>需要 O(n) 的时间复杂度</strong>。</p><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><strong>循环链表是一种特殊的单链表</strong>。实际上，循环链表也很简单。它跟单链表唯一的区别就在尾结点。我们知道，单链表的尾结点指针指向空地址，表示这就是最后的结点了。而循环链表的尾结点指针是指向链表的头结点。从我画的循环链表图中，你应该可以看出来，它像一个环一样首尾相连，所以叫作循环链表：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/13.png" alt></p><p>和单链表相比，循环链表的优点是从链尾到链头比较方便。当要处理的数据具有环型结构特点时，就特别适合采用循环链表。比如著名的<code>约瑟夫问题</code>。尽管用单链表也可以实现，但是用循环链表实现的话，代码就会简洁很多。</p><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p>单向链表只有一个方向，结点只有一个后继指针 next 指向后面的结点。而双向链表，顾名思义，它支持两个方向，每个结点不止有一个后继指针 next 指向后面的结点，还有一个<strong>前驱指针 prev</strong> 指向前面的结点：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/14.png" alt></p><p>从我画的图中可以看出来，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。所以，如果存储同样多的数据，双向链表要比单链表占用更多的内存空间。虽然两个指针比较浪费存储空间，但可以支持双向遍历，这样也带来了双向链表操作的灵活性。从结构上来看，<strong>双向链表可以支持 O(1) 时间复杂度的情况下找到前驱结点</strong>，正是这样的特点，也使双向链表在某些情况下的插入、删除等操作都要比单链表简单、高效。</p><p>在实际的软件开发中，从链表中删除一个数据无外乎这两种情况：</p><ul><li>删除结点中“值等于某个给定值”的结点；</li><li>删除给定指针指向的结点；</li></ul><p>对于第一种情况，不管是单链表还是双向链表，为了查找到值等于给定值的结点，都需要从头结点开始一个一个依次遍历对比，直到找到值等于给定值的结点，然后再通过我前面讲的指针操作将其删除。尽管单纯的删除操作时间复杂度是 O(1)，但<strong>遍历查找的时间是主要的耗时点，对应的时间复杂度为 O(n)</strong>。根据时间复杂度分析中的加法法则，删除值等于给定值的结点对应的链表操作的总时间复杂度为 O(n)。</p><p>对于第二种情况，我们已经找到了要删除的结点，但是<strong>删除某个结点 q 需要知道其前驱结点</strong>，而单链表并不支持直接获取前驱结点，所以，为了找到前驱结点，我们还是要从头结点开始遍历链表，直到 p-&gt;next=q，说明 p 是 q 的前驱结点。但是对于双向链表来说，这种情况就比较有优势了。因为双向链表中的结点已经保存了前驱结点的指针，不需要像单链表那样遍历。所以，针对第二种情况，单链表删除操作需要 O(n) 的时间复杂度，而双向链表只需要在 O(1) 的时间复杂度内就搞定了。</p><p>除了插入、删除操作有优势之外，<strong>对于一个有序链表，双向链表的按值查询的效率也要比单链表高一些</strong>。因为，我们可以记录上次查找的位置 p，每次查询时，根据要查找的值与 p 的大小关系，决定是往前还是往后查找，所以平均只需要查找一半的数据。</p><p>这就是为什么在实际的软件开发中，双向链表尽管比较费内存，但还是比单链表的应用更加广泛的原因。如果你熟悉 Java 语言，你肯定用过 <code>LinkedHashMap</code> 这个容器。如果你深入研究 LinkedHashMap 的实现原理，就会发现其中就用到了双向链表这种数据结构。</p><p>实际上，这里有一个更加重要的知识点需要你掌握，那就是<strong>用空间换时间</strong>的设计思想。当内存空间充足的时候，如果我们更加追求代码的执行速度，我们就可以选择空间复杂度相对较高、但时间复杂度相对很低的算法或者数据结构。相反，如果内存比较紧缺，比如代码跑在手机或者单片机上，这个时候，就要反过来用时间换空间的设计思路。</p><p>缓存实际上就是利用了空间换时间的设计思想。如果我们把数据存储在硬盘上，会比较节省内存，但每次查找数据都要询问一次硬盘，会比较慢。但如果我们通过缓存技术，事先将数据加载在内存中，虽然会比较耗费内存空间，但是每次数据查询的速度就大大提高了。</p><blockquote><p>对于执行较慢的程序，可以通过消耗更多的内存（空间换时间）来进行优化；而消耗过多内存的程序，可以通过消耗更多的时间（时间换空间）来降低内存的消耗。</p></blockquote><p>如果把这两种链表整合在一起就是一个新的版本：<strong>双向循环链表</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/15.png" alt></p><h2 id="链表-vs-数组性能大比拼"><a href="#链表-vs-数组性能大比拼" class="headerlink" title="链表 vs. 数组性能大比拼"></a>链表 vs. 数组性能大比拼</h2><p>数组和链表是两种截然不同的内存组织方式。正是因为内存存储的区别，它们插入、删除、随机访问操作的时间复杂度正好相反：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/16.png" alt></p><p>数组简单易用，在实现上使用的是连续的内存空间，可以借助 CPU 的缓存机制，预读数组中的数据，所以访问效率更高。而链表在内存中并不是连续存储，所以<strong>对 CPU 缓存不友好，没办法有效预读</strong>。</p><p>数组的缺点是大小固定，一经声明就要占用整块连续内存空间。如果声明的数组过大，系统可能没有足够的连续内存空间分配给它，导致 out of memory。如果声明的数组过小，则可能出现不够用的情况。这时<strong>只能再申请一个更大的内存空间，把原数组拷贝进去，非常费时</strong>。链表本身没有大小的限制，天然地支持动态扩容，我觉得这也是它与数组最大的区别。</p><p>除此之外，如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，如果是 Java 语言，就有<strong>可能会导致频繁的 GC</strong>。</p><h2 id="基于链表实现-LRU-缓存淘汰算法"><a href="#基于链表实现-LRU-缓存淘汰算法" class="headerlink" title="基于链表实现 LRU 缓存淘汰算法"></a>基于链表实现 LRU 缓存淘汰算法</h2><p>我的思路是这样的：我们需要维护一个<strong>按照访问时间从大到小有序排列的链表结构</strong>。因为缓存大小有限，当缓存空间不够，需要淘汰一个数据的时候，我们就直接将链表头部的结点删除。</p><p><strong>当要缓存某个数据的时候，先在链表中查找这个数据</strong>。如果没有找到，则直接将数据放到链表的尾部；如果找到了，我们就把它移动到链表的尾部。因为查找数据需要遍历链表，所以单纯用链表实现的 LRU 缓存淘汰算法的时间复杂很高，是 O(n)。实际上，我们可以继续优化这个实现思路，比如引入<code>散列表</code>（Hash Table）来记录每个数据的位置，<strong>将缓存访问的时间复杂度降到 O(1)</strong>。</p><h2 id="技巧一：理解指针或引用的含义"><a href="#技巧一：理解指针或引用的含义" class="headerlink" title="技巧一：理解指针或引用的含义"></a>技巧一：理解指针或引用的含义</h2><p>事实上，看懂链表的结构并不是很难，但是一旦把它和指针混在一起，就很容易让人摸不着头脑。所以，<strong>要想写对链表代码，首先就要理解好指针</strong>。有些语言有<code>指针</code>的概念，比如 C 语言；有些语言没有指针，取而代之的是<code>引用</code>，比如 Java、Python。不管是指针还是引用，实际上，它们的意思都是一样的，都是<strong>存储所指对象的内存地址</strong>。</p><blockquote><p>将某个变量赋值给指针，实际上就是将这个变量的地址赋值给指针，或者反过来说，指针中存储了这个变量的内存地址，指向了这个变量，通过指针就能找到这个变量。</p></blockquote><p>在编写链表代码的时候，我们经常会有这样的代码：<code>p-&gt;next=q;</code>。这行代码是说，p 结点中的 next 指针存储了 q 结点的内存地址。还有一个更复杂的，也是我们写链表代码经常会用到的：<code>p-&gt;next=p-&gt;next-&gt;next;</code>。这行代码表示，p 结点的 next 指针存储了 p 结点的下下一个结点的内存地址。</p><h2 id="技巧二：警惕指针丢失和内存泄漏"><a href="#技巧二：警惕指针丢失和内存泄漏" class="headerlink" title="技巧二：警惕指针丢失和内存泄漏"></a>技巧二：警惕指针丢失和内存泄漏</h2><p>指针往往都是怎么弄丢的呢？我拿单链表的插入操作为例来给你分析一下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/17.png" alt></p><p>如图所示，我们希望在结点 a 和相邻的结点 b 之间插入结点 x，假设当前指针 p 指向结点 a。如果我们将代码实现变成下面这个样子，就会发生指针丢失和内存泄露：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = x;       <span class="comment">// 将 p 的 next 指针指向 x 结点</span></span><br><span class="line">x-&gt;next = p-&gt;next; <span class="comment">// 将 x 的结点的 next 指针指向 b 结点</span></span><br></pre></td></tr></table></figure><p>p-&gt;next 指针在完成第一步操作之后，已经不再指向结点 b 了，而是指向结点 x。第 2 行代码相当于将 x 赋值给 x-&gt;next，自己指向自己。因此，整个链表也就断成了两半，从结点 b 往后的所有结点都无法访问到了。对于有些语言来说，比如 C 语言，内存管理是由程序员负责的，<strong>如果没有手动释放结点对应的内存空间，就会产生内存泄露</strong>。所以，我们<strong>插入结点时，一定要注意操作的顺序</strong>，要先将结点 x 的 next 指针指向结点 b，再把结点 a 的 next 指针指向结点 x，这样才不会丢失指针，导致内存泄漏。</p><p>同理，<strong>删除链表结点时，也一定要记得手动释放内存空间</strong>，否则，也会出现内存泄漏的问题。当然，对于像 Java 这种虚拟机自动管理内存的编程语言来说，就不需要考虑这么多了。</p><h2 id="技巧三：利用哨兵简化实现难度"><a href="#技巧三：利用哨兵简化实现难度" class="headerlink" title="技巧三：利用哨兵简化实现难度"></a>技巧三：利用哨兵简化实现难度</h2><p>我们先来回顾一下单链表的插入和删除操作。如果我们在结点 p 后面插入一个新的结点，只需要下面两行代码就可以搞定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">new_node-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = new_node;</span><br></pre></td></tr></table></figure><p>但是，当我们要向一个空链表中插入第一个结点，刚刚的逻辑就不能用了。我们需要进行下面这样的特殊处理，其中 head 表示链表的头结点。所以，从这段代码，我们可以发现，对于单链表的插入操作，第一个结点和其他结点的插入逻辑是不一样的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head == null) &#123;</span><br><span class="line">    head = new_node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看单链表结点删除操作。如果要删除结点 p 的后继结点，我们只需要一行代码就可以搞定：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br></pre></td></tr></table></figure><p>但是，如果我们要删除链表中的最后一个结点，前面的删除代码就不 work 了。跟插入类似，我们也需要对于这种情况特殊处理。写成代码是这样子的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (head-&gt;next == null) &#123;</span><br><span class="line">    head = null;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从前面的一步一步分析，我们可以看出，<strong>针对链表的插入、删除操作，需要对插入第一个结点和删除最后一个结点的情况进行特殊处理</strong>。这样代码实现起来就会很繁琐，不简洁，而且也容易因为考虑不全而出错。<code>哨兵</code>，解决的是国家之间的边界问题。同理，这里说的哨兵也是<strong>解决边界问题的，不直接参与业务逻辑</strong>。</p><p>如果我们引入哨兵结点，在任何时候，<strong>不管链表是不是空，head 指针都会一直指向这个哨兵结点</strong>。我们也把这种有哨兵结点的链表叫<code>带头链表</code>。相反，没有哨兵结点的链表就叫作不带头链表。我画了一个带头链表，你可以发现，哨兵结点是不存储数据的。因为哨兵结点一直存在，所以插入第一个结点和插入其他结点，删除最后一个结点和删除其他结点，都可以统一为相同的代码实现逻辑了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/18.png" alt></p><p>现在为了让你感受更深，我再举一个非常简单的例子：<br>代码一：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组 a 中，查找 key，返回 key 所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n 表示数组 a 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 边界条件处理，如果 a 为空，或者 n&lt;= 0，说明数组中没有数据，就不用 while 循环比较了</span></span><br><span class="line">    <span class="keyword">if</span> (a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 这里有两个比较操作：i&lt;n 和 a[i]==key</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == key) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在数组 a 中，查找 key，返回 key 所在的位置</span></span><br><span class="line"><span class="comment">// 其中，n 表示数组 a 的长度</span></span><br><span class="line"><span class="comment">// 我举两个例子，你可以拿例子走一下代码</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;, n=6, key=7</span></span><br><span class="line"><span class="comment">// a = &#123;4, 2, 3, 5, 9, 6&#125;, n=6, key=6</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">char</span>* a, <span class="keyword">int</span> n, <span class="keyword">char</span> key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == null || n &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 这里因为要将 a[n-1] 的值替换成 key，所以要特殊处理这个值</span></span><br><span class="line">    <span class="keyword">if</span> (a[n<span class="number">-1</span>] == key) &#123;</span><br><span class="line">        <span class="keyword">return</span> n<span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把 a[n-1] 的值临时保存在变量 tmp 中，以便之后恢复。tmp=6</span></span><br><span class="line">    <span class="comment">// 之所以这样做的目的是：希望 find() 代码不要改变 a 数组中的内容</span></span><br><span class="line">    <span class="keyword">char</span> tmp = a[n<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 把 key 的值放到 a[n-1] 中，此时 a = &#123;4, 2, 3, 5, 9, 7&#125;</span></span><br><span class="line">    a[n<span class="number">-1</span>] = key;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// while 循环比起代码一，少了 i&lt;n 这个比较操作</span></span><br><span class="line">    <span class="keyword">while</span> (a[i] != key) &#123;</span><br><span class="line">        ++i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 恢复 a[n-1] 原来的值，此时 a= &#123;4, 2, 3, 5, 9, 6&#125;</span></span><br><span class="line">    a[n<span class="number">-1</span>] = tmp;</span><br><span class="line">    <span class="keyword">if</span> (i == n<span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 i==n-1 说明，在 0~n-2 之间都没有 key，所以返回 -1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则，返回 i，就是等于 key 值的元素的下标</span></span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码二运行得更快，因为两段代码中执行次数最多就是 while 循环那一部分。第二段代码中，我们<strong>通过一个哨兵 a[n-1] = key，成功省掉了一个比较语句 i&lt;n</strong>。</p><h2 id="技巧四：重点留意边界条件处理"><a href="#技巧四：重点留意边界条件处理" class="headerlink" title="技巧四：重点留意边界条件处理"></a>技巧四：重点留意边界条件处理</h2><p>软件开发中，代码在一些边界或者异常情况下，最容易产生 Bug。链表代码也不例外。要实现没有 Bug 的链表代码，一定要<strong>在编写的过程中以及编写完成之后，检查边界条件是否考虑全面</strong>，以及代码在边界条件下是否能正确运行：</p><ul><li>如果链表为空时，代码是否能正常工作？</li><li>如果链表只包含一个结点时，代码是否能正常工作？</li><li>如果链表只包含两个结点时，代码是否能正常工作？</li><li>代码逻辑在处理头结点和尾结点的时候，是否能正常工作？</li></ul><p>当你写完链表代码之后，除了看下你写的代码在正常的情况下能否工作，还要看下在上面我列举的几个边界条件下，代码仍然能否正确工作。如果这些边界条件下都没有问题，那基本上可以认为没有问题了。</p><h2 id="技巧五：举例画图，辅助思考"><a href="#技巧五：举例画图，辅助思考" class="headerlink" title="技巧五：举例画图，辅助思考"></a>技巧五：举例画图，辅助思考</h2><p>你可以找一个具体的例子，把它画在纸上，<strong>释放一些脑容量，留更多的给逻辑思考</strong>，这样就会感觉到思路清晰很多。比如往单链表中插入一个数据这样一个操作，我一般都是把各种情况都举一个例子，画出插入前和插入后的链表变化，如图所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/19.png" alt></p><p>而且，当我们写完代码之后，也可以举几个例子，画在纸上，照着代码走一遍，很容易就能发现代码中的 Bug。</p><h2 id="技巧六：多写多练，没有捷径"><a href="#技巧六：多写多练，没有捷径" class="headerlink" title="技巧六：多写多练，没有捷径"></a>技巧六：多写多练，没有捷径</h2><p>如果你已经理解并掌握了我前面所讲的方法，但是手写链表代码还是会出现各种各样的错误，也不要着急。因为我最开始学的时候，这种状况也持续了一段时间。现在我写这些代码，简直就和“玩儿”一样，其实也没有什么技巧，就是把常见的链表操作都自己多写几遍，出问题就一点一点调试，熟能生巧。</p><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/linked-list-cycle/" target="_blank" rel="noopener">Linked List Cycle</a><br><a href="https://leetcode.com/problems/merge-k-sorted-lists/" target="_blank" rel="noopener">Merge k Sorted Lists</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数组</title>
      <link href="2020/12/25/%E6%95%B0%E7%BB%84/"/>
      <url>2020/12/25/%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<p>在大部分编程语言中，数组都是从 0 开始编号的，但你是否下意识地想过，为什么数组要从 0 开始编号，而不是从 1 开始呢？ 从 1 开始不是更符合人类的思维习惯吗？</p><h2 id="如何实现随机访问？"><a href="#如何实现随机访问？" class="headerlink" title="如何实现随机访问？"></a>如何实现随机访问？</h2><p><code>数组</code>（Array）是一种线性表数据结构。它<strong>用一组连续的内存空间，来存储一组具有相同类型的数据</strong>。</p><p>顾名思义，<code>线性表</code>（Linear List）就是数据排成像一条线一样的结构。每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/05.png" alt></p><a id="more"></a><p>而与它相对立的概念是<code>非线性表</code>，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，<strong>数据之间并不是简单的前后关系</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/06.png" alt></p><p><strong>连续的内存空间和相同类型的数据</strong>。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：<code>随机访问</code>。但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，<strong>为了保证连续性，就需要做大量的数据搬移工作</strong>。</p><p>我们拿一个长度为 10 的 int 类型的数组 int[] a = new int[10]来举例。在我画的这个图中，计算机给数组 a[10]，分配了一块连续内存空间 1000～1039，其中，内存块的首地址为 base_address = 1000：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/07.png" alt></p><p>我们知道，计算机会给每个内存单元分配一个地址，计算机通过地址来访问内存中的数据。当计算机需要随机访问数组中的某个元素时，它会首先通过下面的寻址公式，计算出该元素存储的内存地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[i]_address = base_address + i * data_type_size</span><br></pre></td></tr></table></figure><p>其中 data_type_size 表示数组中每个元素的大小。我们举的这个例子里，数组中存储的是 int 类型数据，所以 data_type_size 就为 4 个字节。</p><p>我在面试的时候，常常会问数组和链表的区别，很多人都回答说，“链表适合插入、删除，时间复杂度 O(1)；数组适合查找，查找时间复杂度为 O(1)”。实际上，这种表述是不准确的。数组是适合查找操作，但是查找的时间复杂度并不为 O(1)。即便是排好序的数组，你用二分查找，时间复杂度也是 O(logn)。所以，正确的表述应该是，<strong>数组支持随机访问，根据下标随机访问的时间复杂度为 O(1)</strong>。</p><h2 id="低效的“插入”和“删除”"><a href="#低效的“插入”和“删除”" class="headerlink" title="低效的“插入”和“删除”"></a>低效的“插入”和“删除”</h2><p>数组为了保持内存数据的连续性，会导致插入、删除这两个操作比较低效。</p><h3 id="插入操作"><a href="#插入操作" class="headerlink" title="插入操作"></a>插入操作</h3><p>假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k~n 这部分的元素都顺序地往后挪一位。</p><p>如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以<strong>平均情况时间复杂度为 (1+2+…+n)/n=O(n)</strong>。</p><p>如果数组中的数据是有序的，我们在某个位置插入一个新的元素时，就必须按照刚才的方法搬移 k 之后的数据。但是，<strong>如果数组中存储的数据并没有任何规律，数组只是被当作一个存储数据的集合</strong>。在这种情况下，如果要将某个数据插入到第 k 个位置，为了避免大规模的数据搬移，我们还有一个简单的办法就是，直接将第 k 位的数据搬移到数组元素的最后，把新的元素直接放入第 k 个位置。</p><p>假设数组 a[10] 中存储了如下 5 个元素：a, b, c, d, e，我们现在需要将元素 x 插入到第 3 个位置。我们只需要将 c 放入到 a[5]，将 a[2] 赋值为 x 即可。最后，数组中的元素如下： a, b, x, d, e, c：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/08.png" alt></p><p>利用这种处理技巧，在特定场景下，在第 k 个位置插入一个元素的<strong>时间复杂度就会降为 O(1)</strong>。这个处理思想在快排中也会用到。</p><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><p>跟插入数据类似，如果我们要删除第 k 个位置的数据，为了内存的连续性，也需要搬移数据，不然中间就会出现空洞，内存就不连续了。如果删除数组末尾的数据，则最好情况时间复杂度为 O(1)；如果删除开头的数据，则最坏情况时间复杂度为 O(n)；<strong>平均情况时间复杂度也为 O(n)</strong>。</p><p>实际上，在某些特殊场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率是不是会提高很多呢？数组 a[10] 中存储了 8 个元素：a, b, c, d, e, f, g, h。现在，我们要依次删除 a, b, c 三个元素：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/09.png" alt></p><p>为了避免 d, e, f, g, h 这几个数据会被搬移三次，我们可以先记录下已经删除的数据。每次的删除操作并不是真正地搬移数据，只是记录数据已经被删除。<strong>当数组没有更多空间存储数据时，我们再触发执行一次真正的删除操作</strong>，这样就大大减少了删除操作导致的数据搬移。</p><p>如果你了解 JVM，你会发现，这不就是 <strong>JVM 标记清除垃圾回收算法的核心思想</strong>吗？没错，数据结构和算法的魅力就在于此，很多时候我们并不是要去死记硬背某个数据结构或者算法，而是要<strong>学习它背后的思想和处理技巧，这些东西才是最有价值的</strong>。如果你细心留意，不管是在软件开发还是架构设计中，总能找到某些算法和数据结构的影子。</p><h2 id="警惕数组的访问越界问题"><a href="#警惕数组的访问越界问题" class="headerlink" title="警惕数组的访问越界问题"></a>警惕数组的访问越界问题</h2><p>首先，我请你来分析一下这段 C 语言代码的运行结果：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">3</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>(; i&lt;=<span class="number">3</span>; i++) &#123;</span><br><span class="line">        arr[i] = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"hello world\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>你发现问题了吗？这段代码的运行结果并非是打印三行“hello word”，而是会无限打印“hello world”。因为，数组大小为 3：a[0]，a[1]，a[2]，而我们的代码因为书写错误，导致 for 循环的结束条件错写为了 i&lt;=3 而非 i&lt;3，所以当 i=3 时，数组 a[3] 访问越界。我们知道，在 C 语言中，<strong>只要不是访问受限的内存，所有的内存空间都是可以自由访问的</strong>。根据我们前面讲的数组寻址公式，a[3]也会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量 i 的内存地址，那么 a[3]=0 就相当于 i=0，所以就会导致代码无限循环。</p><p>这种情况下，一般都会出现莫名其妙的逻辑错误，就像我们刚刚举的那个例子，debug 的难度非常的大。而且，<strong>很多计算机病毒也正是利用到了代码中的数组越界可以访问非法地址的漏洞，来攻击系统</strong>，所以写代码的时候一定要警惕数组越界。但<strong>并非所有的语言都像 C 一样，把数组越界检查的工作丢给程序员来做</strong>，像 Java 本身就会做越界检查，比如下面这几行 Java 代码，就会抛出 java.lang.ArrayIndexOutOfBoundsException：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">a[<span class="number">3</span>] = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="容器能否完全替代数组？"><a href="#容器能否完全替代数组？" class="headerlink" title="容器能否完全替代数组？"></a>容器能否完全替代数组？</h2><p>针对数组类型，很多语言都提供了容器类，比如 Java 中的 <code>ArrayList</code>、C++ STL 中的 <code>vector</code>。</p><p>我个人觉得，ArrayList 最大的优势就是可以<strong>将很多数组操作的细节封装起来</strong>。比如前面提到的数组插入、删除数据时需要搬移其他数据等。另外，它还有一个优势，就是<strong>支持动态扩容</strong>。如果使用 ArrayList，我们就完全不需要关心底层的扩容逻辑，ArrayList 已经帮我们实现好了。每次存储空间不够的时候，它都会将空间自动扩容为 1.5 倍大小。</p><p>不过，这里需要注意一点，因为扩容操作涉及内存申请和数据搬移，是比较耗时的。所以，如果事先能确定需要存储的数据大小，<strong>最好在创建 ArrayList 的时候事先指定数据大小</strong>。比如我们要从数据库中取出 10000 条数据放入 ArrayList。我们看下面这几行代码，你会发现，相比之下，事先指定数据大小可以省掉很多次内存申请和数据搬移操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ArrayList&lt;User&gt; users = <span class="keyword">new</span> ArrayList(<span class="number">10000</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; ++i) &#123;</span><br><span class="line">    users.add(xxx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有些时候，用数组会更合适些，我总结了几点自己的经验：</p><ul><li><strong>Java ArrayList 无法存储基本类型</strong>，比如 int、long，需要封装为 Integer、Long 类，而 Autoboxing、Unboxing 则有一定的性能消耗，所以如果特别关注性能，或者希望使用基本类型，就可以选用数组；</li><li>如果数据大小事先已知，并且对数据的操作非常简单，用不到 ArrayList 提供的大部分方法，也可以直接使用数组；</li><li>还有一个是我个人的喜好，当要表示多维数组时，用数组往往会更加直观。比如 Object[][] array；而用容器的话则需要这样定义：ArrayList&lt;ArrayList&lt;object&gt;&gt; array；</li></ul><p>我总结一下，对于业务开发，直接使用容器就足够了，省时省力。毕竟损耗一丢丢性能，完全不会影响到系统整体的性能。但如果你是做<strong>一些非常底层的开发，比如开发网络框架，性能的优化需要做到极致，这个时候数组就会优于容器</strong>，成为首选。</p><h2 id="数组为什么从-0-开始编号"><a href="#数组为什么从-0-开始编号" class="headerlink" title="数组为什么从 0 开始编号"></a>数组为什么从 0 开始编号</h2><p>从数组存储的内存模型上来看，“下标”最确切的定义应该是<code>偏移</code>（Offset）。前面也讲到，如果用 a 来表示数组的首地址，a[0] 就是偏移为 0 的位置，也就是首地址，a[k] 就表示偏移 k 个 type_size 的位置，所以计算 a[k] 的内存地址只需要用这个公式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + k * type_size</span><br></pre></td></tr></table></figure><p>但是，如果数组从 1 开始计数，那我们计算数组元素 a[k] 的内存地址就会变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[k]_address = base_address + (k<span class="number">-1</span>) * type_size</span><br></pre></td></tr></table></figure><p>对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。数组作为非常基础的数据结构，通过下标随机访问数组元素又是其非常基础的编程操作，效率的优化就要尽可能做到极致。所以<strong>为了减少一次减法操作，数组选择了从 0 开始编号</strong>，而不是从 1 开始。</p><h2 id="LeetCode"><a href="#LeetCode" class="headerlink" title="LeetCode"></a>LeetCode</h2><p><a href="https://leetcode.com/problems/3sum/" target="_blank" rel="noopener">3Sum</a><br><a href="https://leetcode.com/problems/majority-element/" target="_blank" rel="noopener">Majority Element</a><br><a href="https://leetcode.com/problems/first-missing-positive/" target="_blank" rel="noopener">First Missing Positive</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mediator Design Pattern</title>
      <link href="2020/12/24/Mediator-Design-Pattern/"/>
      <url>2020/12/24/Mediator-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="中介模式的原理和实现"><a href="#中介模式的原理和实现" class="headerlink" title="中介模式的原理和实现"></a>中介模式的原理和实现</h2><p><code>中介模式</code>的英文翻译是 Mediator Design Pattern。它是这样定义的：</p><blockquote><p>Mediator pattern defines a separate (mediator) object that encapsulates the interaction between a set of objects and the objects delegate their interaction to a mediator object instead of interacting with each other directly.</p></blockquote><p>翻译成中文就是：中介模式定义了一个单独的（中介）对象，来封装一组对象之间的交互。<strong>将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互</strong>。实际上，中介模式的设计思想跟中间层很像，通过引入中介这个中间层，将一组对象之间的交互关系（或者说依赖关系）从多对多（网状关系）转换为一对多（星状关系）。原来一个对象要跟 n 个对象交互，现在只需要跟一个中介对象交互，从而<strong>最小化对象之间的交互关系，降低了代码的复杂度，提高了代码的可读性和可维护性</strong>。</p><p>这里我画了一张对象交互关系的对比图。其中，右边的交互图是利用中介模式对左边交互关系优化之后的结果，从图中我们可以很直观地看出，右边的交互关系更加清晰、简洁：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/30.png" alt></p><a id="more"></a><p>假设我们有一个比较复杂的对话框，对话框中有很多控件，比如按钮、文本框、下拉框等。当我们对某个控件进行操作的时候，其他控件会做出相应的反应，比如，我们在下拉框中选择“注册”，注册相关的控件就会显示在对话框中。如果我们在下拉框中选择“登陆”，登陆相关的控件就会显示在对话框中。按照通常我们习惯的 UI 界面的开发方式，我们将刚刚的需求用代码实现出来。在这种实现方式中，<strong>控件和控件之间互相操作、互相依赖</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIControl</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN_BTN_ID = <span class="string">"login_btn"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REG_BTN_ID = <span class="string">"reg_btn"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME_INPUT_ID = <span class="string">"username_input"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD_INPUT_ID = <span class="string">"pswd_input"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPEATED_PASSWORD_INPUT_ID = <span class="string">"repeated_pswd_input"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HINT_TEXT_ID = <span class="string">"hint_text"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECTION_ID = <span class="string">"selection"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="line">        Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class="line">        Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="line">        Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="line">        Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="line">        Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class="line">        Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class="line"></span><br><span class="line">        loginButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                String username = usernameInput.text();</span><br><span class="line">                String password = passwordInput.text();</span><br><span class="line">                <span class="comment">// 校验数据...</span></span><br><span class="line">                <span class="comment">// 做业务处理...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        regButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">            <span class="comment">// 获取 usernameInput、passwordInput、repeatedPswdInput 数据...</span></span><br><span class="line">            <span class="comment">// 校验数据...</span></span><br><span class="line">            <span class="comment">// 做业务处理...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...省略 selection 下拉选择框相关代码...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再按照中介模式，将上面的代码重新实现一下。在新的代码实现中，<strong>各个控件只跟中介对象交互，中介对象负责所有业务逻辑的处理</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Mediator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(Component component, String event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LandingPageDialog</span> <span class="keyword">implements</span> <span class="title">Mediator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Button loginButton;</span><br><span class="line">    <span class="keyword">private</span> Button regButton;</span><br><span class="line">    <span class="keyword">private</span> Selection selection;</span><br><span class="line">    <span class="keyword">private</span> Input usernameInput;</span><br><span class="line">    <span class="keyword">private</span> Input passwordInput;</span><br><span class="line">    <span class="keyword">private</span> Input repeatedPswdInput;</span><br><span class="line">    <span class="keyword">private</span> Text hintText;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleEvent</span><span class="params">(Component component, String event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (component.equals(loginButton)) </span><br><span class="line">        &#123;</span><br><span class="line">            String username = usernameInput.text();</span><br><span class="line">            String password = passwordInput.text();</span><br><span class="line">            <span class="comment">// 校验数据...</span></span><br><span class="line">            <span class="comment">// 做业务处理...</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (component.equals(regButton)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 获取 usernameInput、passwordInput、repeatedPswdInput 数据...</span></span><br><span class="line">            <span class="comment">// 校验数据...</span></span><br><span class="line">            <span class="comment">// 做业务处理...</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (component.equals(selection)) </span><br><span class="line">        &#123;</span><br><span class="line">            String selectedItem = selection.select();</span><br><span class="line">            <span class="keyword">if</span> (selectedItem.equals(<span class="string">"login"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                usernameInput.show();</span><br><span class="line">                passwordInput.show();</span><br><span class="line">                repeatedPswdInput.hide();</span><br><span class="line">                hintText.hide();</span><br><span class="line">                <span class="comment">//...省略其他代码</span></span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (selectedItem.equals(<span class="string">"register"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UIControl</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String LOGIN_BTN_ID = <span class="string">"login_btn"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REG_BTN_ID = <span class="string">"reg_btn"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String USERNAME_INPUT_ID = <span class="string">"username_input"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String PASSWORD_INPUT_ID = <span class="string">"pswd_input"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPEATED_PASSWORD_INPUT_ID = <span class="string">"repeated_pswd_input"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String HINT_TEXT_ID = <span class="string">"hint_text"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String SELECTION_ID = <span class="string">"selection"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Button loginButton = (Button)findViewById(LOGIN_BTN_ID);</span><br><span class="line">        Button regButton = (Button)findViewById(REG_BTN_ID);</span><br><span class="line">        Input usernameInput = (Input)findViewById(USERNAME_INPUT_ID);</span><br><span class="line">        Input passwordInput = (Input)findViewById(PASSWORD_INPUT_ID);</span><br><span class="line">        Input repeatedPswdInput = (Input)findViewById(REPEATED_PASSWORD_INPUT_ID);</span><br><span class="line">        Text hintText = (Text)findViewById(HINT_TEXT_ID);</span><br><span class="line">        Selection selection = (Selection)findViewById(SELECTION_ID);</span><br><span class="line"></span><br><span class="line">        Mediator dialog = <span class="keyword">new</span> LandingPageDialog();</span><br><span class="line">        dialog.setLoginButton(loginButton);</span><br><span class="line">        dialog.setRegButton(regButton);</span><br><span class="line">        dialog.setUsernameInput(usernameInput);</span><br><span class="line">        dialog.setPasswordInput(passwordInput);</span><br><span class="line">        dialog.setRepeatedPswdInput(repeatedPswdInput);</span><br><span class="line">        dialog.setHintText(hintText);</span><br><span class="line">        dialog.setSelection(selection);</span><br><span class="line"></span><br><span class="line">        loginButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                dialog.handleEvent(loginButton, <span class="string">"click"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        regButton.setOnClickListener(<span class="keyword">new</span> OnClickListener() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                dialog.handleEvent(regButton, <span class="string">"click"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以看出，原本业务逻辑会分散在各个控件中，现在都集中到了中介类中。实际上，这样做既有好处，也有坏处。<strong>好处是简化了控件之间的交互，坏处是中介类有可能会变成大而复杂的 God Class</strong>。所以，在使用中介模式的时候，我们要根据实际的情况，平衡对象之间交互的复杂度和中介类本身的复杂度。</p><h2 id="中介模式-vs-观察者模式"><a href="#中介模式-vs-观察者模式" class="headerlink" title="中介模式 vs. 观察者模式"></a>中介模式 vs. 观察者模式</h2><p>在观察者模式中，尽管一个参与者既可以是观察者，同时也可以是被观察者，但是，大部分情况下，<strong>交互关系往往都是单向的，一个参与者要么是观察者，要么是被观察者</strong>，不会兼具两种身份。也就是说，在观察者模式的应用场景中，参与者之间的交互关系比较有条理。</p><p>而中介模式正好相反。<strong>只有当参与者之间的交互关系错综复杂，维护成本很高的时候，我们才考虑使用中介模式</strong>。毕竟，中介模式的应用会带来一定的副作用，前面也讲到，它有可能会产生大而复杂的上帝类。除此之外，如果一个参与者状态的改变，其他参与者执行的操作有一定先后顺序的要求，这个时候，中介模式就可以利用中介类，通过先后调用不同参与者的方法，来实现顺序的控制，而<strong>观察者模式是无法实现这样的顺序要求的</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interpreter Design Pattern</title>
      <link href="2020/12/24/Interpreter-Design-Pattern/"/>
      <url>2020/12/24/Interpreter-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="解释器模式的原理和实现"><a href="#解释器模式的原理和实现" class="headerlink" title="解释器模式的原理和实现"></a>解释器模式的原理和实现</h2><p><code>解释器模式</code>的英文翻译是 Interpreter Design Pattern。它是这样定义的：</p><blockquote><p>Interpreter pattern is used to defines a grammatical representation for a language and provides an interpreter to deal with this grammar.</p></blockquote><p>翻译成中文就是：解释器模式<strong>为某个语言定义它的语法表示，并定义一个解释器用来处理这个语法</strong>。要想了解“语言”表达的信息，我们就必须定义相应的语法规则。这样，书写者就可以根据语法规则来书写“表达式”，阅读者根据语法规则来阅读“表达式”，这样才能做到信息的正确传递。而我们要讲的解释器模式，其实就是用来实现根据语法规则解读“表达式”的解释器。假设我们定义了一个新的加减乘除计算“语言”，语法规则如下：</p><ul><li>运算符只包含加、减、乘、除，并且没有优先级的概念；</li><li>表达式中，先书写数字，后书写运算符，空格隔开；</li><li>按照先后顺序，取出两个数字和一个运算符计算结果，结果重新放入数字的最头部位置，循环上述过程，直到只剩下一个数字，这个数字就是表达式最终的计算结果；</li></ul><p>看懂了上面的语法规则，我们将它用代码实现出来。代码非常简单，<strong>用户按照上面的规则书写表达式，传递给 interpret() 函数</strong>，就可以得到最终的计算结果：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionInterpreter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Long&gt; numbers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">(String expression)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] elements = expression.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> length = elements.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (length + <span class="number">1</span>) / <span class="number">2</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            numbers.addLast(Long.parseLong(elements[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (length + <span class="number">1</span>) / <span class="number">2</span>; i &lt; length; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            String operator = elements[i];</span><br><span class="line">            <span class="keyword">boolean</span> isValid = <span class="string">"+"</span>.equals(operator) || <span class="string">"-"</span>.equals(operator) || <span class="string">"*"</span>.equals(operator) || <span class="string">"/"</span>.equals(operator);</span><br><span class="line">            <span class="keyword">if</span> (!isValid) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Expression is invalid: "</span> + expression);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">long</span> number1 = numbers.pollFirst();</span><br><span class="line">            <span class="keyword">long</span> number2 = numbers.pollFirst();</span><br><span class="line">            <span class="keyword">long</span> result = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (operator.equals(<span class="string">"+"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                result = number1 + number2;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"-"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                result = number1 - number2;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"*"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                result = number1 * number2;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"/"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                result = number1 / number2;</span><br><span class="line">            &#125;</span><br><span class="line">            numbers.addFirst(result);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numbers.size() != <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Expression is invalid: "</span> + expression);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，语法规则的解析逻辑（第 28、32、36、40 行）都集中在一个函数中，对于简单的语法规则的解析，这样的设计就足够了。但是，对于复杂的语法规则的解析，逻辑复杂，代码量多，所有的解析逻辑都耦合在一个函数中，这样显然是不合适的。这个时候，我们就要<strong>考虑拆分代码，将解析逻辑拆分到独立的小类中</strong>。</p><p>解释器模式的代码实现比较灵活，没有固定的模板。我们前面也说过，应用设计模式主要是应对代码的复杂性，实际上，解释器模式也不例外。它的代码实现的核心思想，就是<strong>将语法解析的工作拆分到各个小类中，以此来避免大而全的解析类</strong>。一般的做法是，将语法规则拆分成一些小的独立的单元，然后对每个单元进行解析，最终合并为对整个语法规则的解析。</p><p>前面定义的语法规则有两类表达式，一类是数字，一类是运算符，运算符又包括加减乘除。利用解释器模式，我们把解析的工作拆分到 NumberExpression、AdditionExpression、SubtractionExpression、MultiplicationExpression、DivisionExpression 这样五个解析类中。按照这个思路，我们对代码进行重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NumberExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> number;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(<span class="keyword">long</span> number)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = number;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NumberExpression</span><span class="params">(String number)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.number = Long.parseLong(number);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.number;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdditionExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Expression exp1;</span><br><span class="line">    <span class="keyword">private</span> Expression exp2;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AdditionExpression</span><span class="params">(Expression exp1, Expression exp2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.exp1 = exp1;</span><br><span class="line">        <span class="keyword">this</span>.exp2 = exp2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> exp1.interpret() + exp2.interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// SubtractionExpression/MultiplicationExpression/DivisionExpression 与 AdditionExpression 代码结构类似</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExpressionInterpreter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deque&lt;Expression&gt; numbers = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">interpret</span><span class="params">(String expression)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] elements = expression.split(<span class="string">" "</span>);</span><br><span class="line">        <span class="keyword">int</span> length = elements.length;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (length + <span class="number">1</span>) / <span class="number">2</span>; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            numbers.addLast(<span class="keyword">new</span> NumberExpression(elements[i]));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = (length + <span class="number">1</span>) / <span class="number">2</span>; i &lt; length; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            String operator = elements[i];</span><br><span class="line">            <span class="keyword">boolean</span> isValid = <span class="string">"+"</span>.equals(operator) || <span class="string">"-"</span>.equals(operator) || <span class="string">"*"</span>.equals(operator) || <span class="string">"/"</span>.equals(operator);</span><br><span class="line">            <span class="keyword">if</span> (!isValid) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Expression is invalid: "</span> + expression);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Expression exp1 = numbers.pollFirst();</span><br><span class="line">            Expression exp2 = numbers.pollFirst();</span><br><span class="line">            Expression combinedExp = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (operator.equals(<span class="string">"+"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                combinedExp = <span class="keyword">new</span> AdditionExpression(exp1, exp2);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"-"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                combinedExp = <span class="keyword">new</span> SubtractionExpression(exp1, exp2);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"*"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                combinedExp = <span class="keyword">new</span> MultiplicationExpression(exp1, exp2);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (operator.equals(<span class="string">"/"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                combinedExp = <span class="keyword">new</span> DivisionExpression(exp1, exp2);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> result = combinedExp.interpret();</span><br><span class="line">            numbers.addFirst(<span class="keyword">new</span> NumberExpression(result));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (numbers.size() != <span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Expression is invalid: "</span> + expression);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> numbers.pop().interpret();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解释器模式实战举例"><a href="#解释器模式实战举例" class="headerlink" title="解释器模式实战举例"></a>解释器模式实战举例</h2><p>在我们平时的项目开发中，监控系统非常重要，它可以时刻监控业务系统的运行情况，及时将异常报告给开发者。比如，如果每分钟接口出错数超过 100，监控系统就通过短信、微信、邮件等方式发送告警给开发者。一般来讲，<strong>监控系统支持开发者自定义告警规则</strong>，比如我们可以用下面这样一个表达式，来表示一个告警规则，它表达的意思是：每分钟 API 总出错数超过 100 或者每分钟 API 总调用数超过 10000 就触发告警：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">api_error_per_minute &gt; <span class="number">100</span> || api_count_per_minute &gt; <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>在监控系统中，<strong>告警模块只负责根据统计数据和告警规则，判断是否触发告警</strong>。至于每分钟 API 接口出错数、每分钟接口调用数等统计数据的计算，是由其他模块来负责的。其他模块将统计数据放到一个 Map 中，发送给告警模块。数据的格式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;String, Long&gt; apiStat = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">apiStat.put(<span class="string">"api_error_per_minute"</span>, <span class="number">103</span>);</span><br><span class="line">apiStat.put(<span class="string">"api_count_per_minute"</span>, <span class="number">987</span>);</span><br></pre></td></tr></table></figure><p>为了简化讲解和代码实现，我们假设自定义的告警规则只包含“||、&amp;&amp;、&gt;、&lt;、==”这五个运算符，其中，“&gt;、&lt;、==”运算符的优先级高于“||、&amp;&amp;”运算符，“&amp;&amp;”运算符优先级高于“||”。在表达式中，任意元素之间需要通过空格来分隔。除此之外，用户可以自定义要监控的 key，比如前面的 api_error_per_minute、api_count_per_minute。我写了一个骨架代码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertRuleInterpreter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// key1 &gt; 100 &amp;&amp; key2 &lt; 1000 || key3 == 200</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlertRuleInterpreter</span><span class="params">(String ruleExpression)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// &lt;String, Long&gt; apiStat = new HashMap&lt;&gt;();</span></span><br><span class="line">    <span class="comment">// apiStat.put("key1", 103);</span></span><br><span class="line">    <span class="comment">// apiStat.put("key2", 987);</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String rule = <span class="string">"key1 &gt; 100 &amp;&amp; key2 &lt; 30 || key3 &lt; 100 || key4 == 88"</span>;</span><br><span class="line">        AlertRuleInterpreter interpreter = <span class="keyword">new</span> AlertRuleInterpreter(rule);</span><br><span class="line">        Map&lt;String, Long&gt; stats = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        stats.put(<span class="string">"key1"</span>, <span class="number">101l</span>);</span><br><span class="line">        stats.put(<span class="string">"key3"</span>, <span class="number">121l</span>);</span><br><span class="line">        stats.put(<span class="string">"key4"</span>, <span class="number">88l</span>);</span><br><span class="line">        <span class="keyword">boolean</span> alert = interpreter.interpret(stats);</span><br><span class="line">        System.out.println(alert);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，我们可以把自定义的告警规则，看作一种特殊“语言”的语法规则。我们<strong>实现一个解释器，能够根据规则，针对用户输入的数据，判断是否触发告警</strong>。利用解释器模式，我们把解析表达式的逻辑拆分到各个小类中，避免大而复杂的大类的出现。按照这个实现思路，我把刚刚的代码补全：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Expression</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GreaterExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreaterExpression</span><span class="params">(String strExpression)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] elements = strExpression.trim().split(<span class="string">"\\s+"</span>);</span><br><span class="line">        <span class="keyword">if</span> (elements.length != <span class="number">3</span> || !elements[<span class="number">1</span>].trim().equals(<span class="string">"&gt;"</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Expression is invalid: "</span> + strExpression);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.key = elements[<span class="number">0</span>].trim();</span><br><span class="line">        <span class="keyword">this</span>.value = Long.parseLong(elements[<span class="number">2</span>].trim());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GreaterExpression</span><span class="params">(String key, <span class="keyword">long</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!stats.containsKey(key)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> statValue = stats.get(key);</span><br><span class="line">        <span class="keyword">return</span> statValue &gt; value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LessExpression/EqualExpression 跟 GreaterExpression 代码类似</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Expression&gt; expressions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(String strAndExpression)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] strExpressions = strAndExpression.split(<span class="string">"&amp;&amp;"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String strExpr : strExpressions) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (strExpr.contains(<span class="string">"&gt;"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                expressions.add(<span class="keyword">new</span> GreaterExpression(strExpr));</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strExpr.contains(<span class="string">"&lt;"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                expressions.add(<span class="keyword">new</span> LessExpression(strExpr));</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (strExpr.contains(<span class="string">"=="</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                expressions.add(<span class="keyword">new</span> EqualExpression(strExpr));</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Expression is invalid: "</span> + strAndExpression);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndExpression</span><span class="params">(List&lt;Expression&gt; expressions)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expressions.addAll(expressions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Expression expr : expressions) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!expr.interpret(stats)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrExpression</span> <span class="keyword">implements</span> <span class="title">Expression</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Expression&gt; expressions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(String strOrExpression)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String[] andExpressions = strOrExpression.split(<span class="string">"\\|\\|"</span>);</span><br><span class="line">        <span class="keyword">for</span> (String andExpr : andExpressions) </span><br><span class="line">        &#123;</span><br><span class="line">            expressions.add(<span class="keyword">new</span> AndExpression(andExpr));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OrExpression</span><span class="params">(List&lt;Expression&gt; expressions)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expressions.addAll(expressions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Expression expr : expressions) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (expr.interpret(stats)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertRuleInterpreter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Expression expression;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlertRuleInterpreter</span><span class="params">(String ruleExpression)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.expression = <span class="keyword">new</span> OrExpression(ruleExpression);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">interpret</span><span class="params">(Map&lt;String, Long&gt; stats)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> expression.interpret(stats);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Command Design Pattern</title>
      <link href="2020/12/24/Command-Design-Pattern/"/>
      <url>2020/12/24/Command-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="命令模式的原理解读"><a href="#命令模式的原理解读" class="headerlink" title="命令模式的原理解读"></a>命令模式的原理解读</h2><p><code>命令模式</code>的英文翻译是 Command Design Pattern。它是这么定义的：</p><blockquote><p>The command pattern encapsulates a request as an object, thereby letting us parameterize other objects with different requests, queue or log requests, and support undoable operations.</p></blockquote><p>翻译成中文就是：<strong>命令模式将请求（命令）封装为一个对象，这样可以使用不同的请求参数化其他对象（将不同请求依赖注入到其他对象）</strong>，并且能够支持请求（命令）的排队执行、记录日志、撤销等（附加控制）功能。落实到编码实现，命令模式用的最核心的实现手段，是<strong>将函数封装成对象</strong>。</p><p>我们知道，C 语言支持函数指针，我们可以把函数当作变量传递来传递去。但是，在大部分编程语言中，函数没法儿作为参数传递给其他函数，也没法儿赋值给变量。借助命令模式，我们可以将函数封装成对象。具体来说就是，<strong>设计一个包含这个函数的类，实例化一个对象传来传去</strong>，这样就可以实现把函数像对象一样使用。从实现的角度来说，它类似我们之前讲过的<code>回调</code>。</p><p>当我们把函数封装成对象之后，对象就可以存储下来，方便控制执行。所以，<strong>命令模式的主要作用和应用场景，是用来控制命令的执行</strong>，比如，异步、延迟、排队执行命令、撤销重做命令、存储命令、给命令记录日志等等。</p><a id="more"></a><h2 id="命令模式的实战讲解"><a href="#命令模式的实战讲解" class="headerlink" title="命令模式的实战讲解"></a>命令模式的实战讲解</h2><p>假设我们正在开发一个类似《天天酷跑》或者《QQ 飞车》这样的手游。这种游戏本身的复杂度集中在客户端。后端基本上只负责数据（比如积分、生命值、装备）的更新和查询，所以，<strong>后端逻辑相对于客户端来说，要简单很多</strong>。为了提高性能，我们会把游戏中玩家的信息保存在内存中。<strong>在游戏进行的过程中，只更新内存中的数据，游戏结束之后，再将内存中的数据存档</strong>，也就是持久化到数据库中。为了降低实现的难度，一般来说，同一个游戏场景里的玩家，会被分配到同一台服务上。这样，一个玩家拉取同一个游戏场景中的其他玩家的信息，就不需要跨服务器去查找了，实现起来就简单了很多。</p><p>一般来说，游戏客户端和服务器之间的数据交互是比较频繁的，所以，<strong>为了节省网络连接建立的开销，客户端和服务器之间一般采用长连接的方式来通信</strong>。通信的格式有多种，比如 Protocol Buffer、JSON、XML，甚至可以自定义格式。不管是什么格式，客户端发送给服务器的请求，一般都包括两部分内容：指令和数据。其中，<strong>指令我们也可以叫作事件，数据是执行这个指令所需的数据</strong>。服务器在接收到客户端的请求之后，会解析出指令和数据，并且根据指令的不同，执行不同的处理逻辑。对于这样的一个业务场景，一般有两种架构实现思路：</p><ul><li>利用<code>多线程</code>，一个线程接收请求，接收到请求之后，启动一个新的线程来处理请求。具体点讲，一般是通过一个主线程来接收客户端发来的请求。每当接收到一个请求之后，就从一个专门用来处理请求的线程池中，捞出一个空闲线程来处理；</li><li><strong>在一个线程内轮询接收请求和处理请求</strong>。尽管它无法利用多线程多核处理的优势，但是对于 IO 密集型的业务来说，它避免了多线程不停切换对性能的损耗，并且克服了多线程编程 Bug 比较难调试的缺点，是<strong>手游后端服务器开发中比较常见的架构模式</strong>；</li></ul><p>整个手游后端服务器轮询获取客户端发来的请求，获取到请求之后，借助命令模式，<strong>把请求包含的数据和处理逻辑封装为命令对象，并存储在内存队列中</strong>。然后，再从队列中取出一定数量的命令来执行。执行完成之后，再重新开始新的一轮轮询。具体的示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Command</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GotDiamondCommand</span> <span class="keyword">implements</span> <span class="title">Command</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略成员变量</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GotDiamondCommand</span><span class="params">(<span class="comment">/*数据*/</span>)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 执行相应的逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// GotStartCommand/HitObstacleCommand/ArchiveCommand 类省略</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GameApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_HANDLED_REQ_COUNT_PER_LOOP = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Command&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">mainLoop</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            List&lt;Request&gt; requests = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 省略从 epoll 或者 select 中获取数据，并封装成 Request 的逻辑</span></span><br><span class="line">            <span class="comment">// 注意设置超时时间，如果很长时间没有接收到请求，就继续下面的逻辑处理</span></span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span> (Request request : requests) </span><br><span class="line">            &#123;</span><br><span class="line">                Event event = request.getEvent();</span><br><span class="line">                Command command = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (event.equals(Event.GOT_DIAMOND)) </span><br><span class="line">                &#123;</span><br><span class="line">                    command = <span class="keyword">new</span> GotDiamondCommand(<span class="comment">/*数据*/</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.GOT_STAR)) </span><br><span class="line">                &#123;</span><br><span class="line">                    command = <span class="keyword">new</span> GotStartCommand(<span class="comment">/*数据*/</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.HIT_OBSTACLE)) </span><br><span class="line">                &#123;</span><br><span class="line">                    command = <span class="keyword">new</span> HitObstacleCommand(<span class="comment">/*数据*/</span>);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (event.equals(Event.ARCHIVE)) </span><br><span class="line">                &#123;</span><br><span class="line">                    command = <span class="keyword">new</span> ArchiveCommand(<span class="comment">/*数据*/</span>);</span><br><span class="line">                &#125; <span class="comment">//...一堆 else if...</span></span><br><span class="line"></span><br><span class="line">                queue.add(command);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> handledCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (handledCount &lt; MAX_HANDLED_REQ_COUNT_PER_LOOP) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (queue.isEmpty()) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                Command command = queue.poll();</span><br><span class="line">                command.execute();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="命令模式-vs-策略模式"><a href="#命令模式-vs-策略模式" class="headerlink" title="命令模式 vs. 策略模式"></a>命令模式 vs. 策略模式</h2><p>实际上，每个设计模式都应该由两部分组成：</p><ol><li><strong>应用场景</strong>：这个模式可以解决哪类问题；</li><li><strong>解决方案</strong>：这个模式的设计思路和具体的代码实现；</li></ol><p>不过，代码实现并不是模式必须包含的。如果你单纯地只关注解决方案这一部分，甚至<strong>只关注代码实现，就会产生大部分模式看起来都很相似的错觉</strong>。接下来，我们再来看命令模式跟策略模式的区别。你可能会觉得，命令的执行逻辑也可以看作策略，那它是不是就是策略模式了呢？实际上，这两者有一点细微的区别。</p><p>在策略模式中，不同的策略具有相同的目的、不同的实现、互相之间可以替换。比如，BubbleSort、SelectionSort 都是为了实现排序的，只不过一个是用冒泡排序算法来实现的，另一个是用选择排序算法来实现的。而在命令模式中，<strong>不同的命令具有不同的目的，对应不同的处理逻辑，并且互相之间不可替换</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Memento Design Pattern</title>
      <link href="2020/12/24/Memento-Design-Pattern/"/>
      <url>2020/12/24/Memento-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="备忘录模式的原理与实现"><a href="#备忘录模式的原理与实现" class="headerlink" title="备忘录模式的原理与实现"></a>备忘录模式的原理与实现</h2><p><code>备忘录模式</code>，也叫快照（Snapshot）模式，英文翻译是 Memento Design Pattern。它是这么定义的：</p><blockquote><p>Captures and externalizes an object’s internal state so that it can be restored later, all without violating encapsulation.</p></blockquote><p>翻译成中文就是：<strong>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态</strong>。在我看来，这个模式的定义主要表达了两部分内容：一部分是，存储副本以便后期恢复；另一部分是，要在不违背封装原则的前提下，进行对象的备份和恢复。接下来，我就结合一个例子来解释一下，带你搞清楚这两个问题：</p><ul><li>为什么存储和恢复副本会违背封装原则？</li><li>备忘录模式是如何做到不违背封装原则的？</li></ul><p>假设有这样一道面试题，希望你编写一个小程序，可以接收命令行的输入。用户输入文本时，程序将其追加存储在内存文本中；用户输入“:list”，程序在命令行中输出内存文本的内容；用户输入“:undo”，程序会撤销上一次输入的文本，也就是从内存文本中将上次输入的文本删除掉。如下所示：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt;hello</span><br><span class="line">&gt;:list</span><br><span class="line">hello</span><br><span class="line">&gt;world</span><br><span class="line">&gt;:list</span><br><span class="line">helloworld</span><br><span class="line">&gt;:undo</span><br><span class="line">&gt;:list</span><br><span class="line">hello</span><br></pre></td></tr></table></figure><p>整体上来讲，这个小程序实现起来并不复杂：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputText</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder text = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String input)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        text.append(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setText</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text.replace(<span class="number">0</span>, <span class="keyword">this</span>.text.length(), text);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotHolder</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;InputText&gt; snapshots = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> InputText <span class="title">popSnapshot</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushSnapshot</span><span class="params">(InputText inputText)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InputText deepClonedInputText = <span class="keyword">new</span> InputText();</span><br><span class="line">        deepClonedInputText.setText(inputText.getText());</span><br><span class="line">        snapshots.push(deepClonedInputText);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMain</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InputText inputText = <span class="keyword">new</span> InputText();</span><br><span class="line">        SnapshotHolder snapshotsHolder = <span class="keyword">new</span> SnapshotHolder();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            String input = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (input.equals(<span class="string">":list"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(inputText.getText());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">":undo"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                InputText snapshot = snapshotsHolder.popSnapshot();</span><br><span class="line">                inputText.setText(snapshot.getText());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                snapshotsHolder.pushSnapshot(inputText);</span><br><span class="line">                inputText.append(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，备忘录模式的实现很灵活，也没有很固定的实现方式，在不同的业务需求、不同编程语言下，代码实现可能都不大一样。但是，如果我们深究一下的话，还有一些问题要解决，那就是前面定义中提到的第二点：<strong>要在不违背封装原则的前提下，进行对象的备份和恢复</strong>。而上面的代码并不满足这一点，主要体现在下面两方面：</p><ol><li>为了能用快照恢复 InputText 对象，我们在 InputText 类中定义了 setText() 函数，但这个函数有可能会被其他业务使用，所以，<strong>暴露不应该暴露的函数违背了封装原则</strong>；</li><li>快照本身是不可变的，理论上讲，不应该包含任何 set() 等修改内部状态的函数，但在上面的代码实现中，“快照“这个业务模型复用了 InputText 类的定义，而 InputText 类本身有一系列修改内部状态的函数，所以，<strong>用 InputText 类来表示快照违背了封装原则</strong>；</li></ol><p>针对以上问题，我们对代码做两点修改。其一，<strong>定义一个独立的类（Snapshot 类）来表示快照，而不是复用 InputText 类</strong>。这个类只暴露 get() 方法，没有 set() 等任何修改内部状态的方法。其二，在 InputText 类中，我们<strong>把 setText() 方法重命名为 restoreSnapshot() 方法，用意更加明确</strong>，只用来恢复对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InputText</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> StringBuilder text = <span class="keyword">new</span> StringBuilder();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> text.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">append</span><span class="params">(String input)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        text.append(input);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Snapshot <span class="title">createSnapshot</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(text.toString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">restoreSnapshot</span><span class="params">(Snapshot snapshot)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text.replace(<span class="number">0</span>, <span class="keyword">this</span>.text.length(), snapshot.getText());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Snapshot</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Snapshot</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getText</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.text;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotHolder</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Snapshot&gt; snapshots = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Snapshot <span class="title">popSnapshot</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> snapshots.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pushSnapshot</span><span class="params">(Snapshot snapshot)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        snapshots.push(snapshot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationMain</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InputText inputText = <span class="keyword">new</span> InputText();</span><br><span class="line">        SnapshotHolder snapshotsHolder = <span class="keyword">new</span> SnapshotHolder();</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        <span class="keyword">while</span> (scanner.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            String input = scanner.next();</span><br><span class="line">            <span class="keyword">if</span> (input.equals(<span class="string">":list"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                System.out.println(inputText.toString());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (input.equals(<span class="string">":undo"</span>)) </span><br><span class="line">            &#123;</span><br><span class="line">                Snapshot snapshot = snapshotsHolder.popSnapshot();</span><br><span class="line">                inputText.restoreSnapshot(snapshot);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                snapshotsHolder.pushSnapshot(inputText.createSnapshot());</span><br><span class="line">                inputText.append(input);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了备忘录模式，还有一个跟它很类似的概念：<code>备份</code>，它在我们平时的开发中更常听到。实际上，这两者的应用场景很类似，都应用在防丢失、恢复、撤销等场景中。它们的区别在于，<strong>备忘录模式更侧重于代码的设计和实现，备份更侧重架构设计或产品设计</strong>。</p><h2 id="如何优化内存和时间消耗？"><a href="#如何优化内存和时间消耗？" class="headerlink" title="如何优化内存和时间消耗？"></a>如何优化内存和时间消耗？</h2><p>前面我们只是简单介绍了备忘录模式的原理和经典实现，现在我们再继续深挖一下。如果要备份的对象数据比较大，备份频率又比较高，那快照占用的内存会比较大，备份和恢复的耗时会比较长。这个问题该如何解决呢？</p><p>不同的应用场景下有不同的解决方法。比如，我们前面举的那个例子，应用场景是利用备忘录来实现撤销操作，而且仅支持顺序撤销，也就是说，<strong>每次操作只能撤销上一次的输入，不能跳过上次输入撤销之前的输入</strong>。在具有这样特点的应用场景下，为了节省内存，我们不需要在快照中存储完整的文本，只需要记录少许信息，比如在获取快照当下的文本长度，用这个值结合 InputText 类对象存储的文本来做撤销操作。</p><p>假设每当有数据改动，我们都需要生成一个备份，以备之后恢复。如果需要备份的数据很大，这样高频率的备份，不管是对存储（内存或者硬盘）的消耗，还是对时间的消耗，都可能是无法接受的。想要解决这个问题，我们一般会<strong>采用低频率全量备份和高频率增量备份相结合的方法</strong>。当我们需要恢复到某一时间点的备份的时候，如果这一时间点有做全量备份，我们直接拿来恢复就可以了。如果这一时间点没有对应的全量备份，我们就先找到最近的一次全量备份，然后用它来恢复，之后执行此次全量备份跟这一时间点之间的所有增量备份，也就是对应的操作或者数据变动。这样就能<strong>减少全量备份的数量和频率，减少对时间、内存的消耗</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Visitor Design Pattern</title>
      <link href="2020/12/23/Visitor-Design-Pattern/"/>
      <url>2020/12/23/Visitor-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="带你“发明”访问者模式"><a href="#带你“发明”访问者模式" class="headerlink" title="带你“发明”访问者模式"></a>带你“发明”访问者模式</h2><p>假设我们从网站上爬取了很多资源文件，它们的格式有三种：PDF、PPT、WORD。我们现在要开发一个工具来处理这批资源文件。这个工具的其中一个功能是，<strong>把这些资源文件中的文本内容抽取出来放到 txt 文件中</strong>。其中，ResourceFile 是一个抽象类，包含一个抽象函数 extract2txt()。PDFFile、PPTFile、WORDFile 都继承 ResourceFile 类，并且重写了 extract2txt() 函数。在 ToolApplication 中，我们可以利用<code>多态特性</code>，根据对象的实际类型，来决定执行哪个方法：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PPTFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PPTFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略一大坨从 PPT 中抽取文本的代码...</span></span><br><span class="line">        <span class="comment">//...将抽取出来的文本保存在跟 filePath 同名的 txt 文件中...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract PPT."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PDFFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract PDF."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WORDFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">WORDFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract WORD."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行结果是：</span></span><br><span class="line"><span class="comment">// Extract PDF.</span></span><br><span class="line"><span class="comment">// Extract WORD.</span></span><br><span class="line"><span class="comment">// Extract PPT.</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) </span><br><span class="line">        &#123;</span><br><span class="line">            resourceFile.extract2txt();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀（pdf/ppt/word）由工厂方法创建不同的类对象（PDFFile/PPTFile/WORDFile）</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PDFFile(<span class="string">"a.pdf"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WORDFile(<span class="string">"b.word"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">"c.ppt"</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>如果工具的功能不停地扩展，不仅要能抽取文本内容，还要支持压缩、提取文件元信息（文件名、大小、更新时间等等）构建索引等一系列的功能</strong>，那如果我们继续按照上面的实现思路，就会存在这样几个问题：</p><ul><li>违背开闭原则，添加一个新的功能，所有类的代码都要修改；</li><li>虽然功能增多，每个类的代码都不断膨胀，可读性和可维护性都变差了；</li><li>把所有比较上层的业务逻辑都耦合到 PDFFile、PPTFile、WORDFile 类中，导致这些类的职责不够单一，变成了大杂烩；</li></ul><p>针对上面的问题，我们常用的解决方法就是拆分解耦，<strong>把业务操作跟具体的数据结构解耦，设计成独立的类</strong>。这里我们按照访问者模式的演进思路来对上面的代码进行重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PDFFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...PPTFile、WORDFile 代码省略...</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Extractor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(PPTFile pptFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract PPT."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(PDFFile pdfFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract PDF."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(WORDFile wordFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract WORD."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Extractor extractor = <span class="keyword">new</span> Extractor();</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) </span><br><span class="line">        &#123;</span><br><span class="line">            extractor.extract2txt(resourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀（pdf/ppt/word）由工厂方法创建不同的类对象（PDFFile/PPTFile/WORDFile）</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PDFFile(<span class="string">"a.pdf"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WORDFile(<span class="string">"b.word"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">"c.ppt"</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这其中最关键的一点设计是，我们<strong>把抽取文本内容的操作，设计成了三个重载函数</strong>。函数重载是 Java、C++ 这类面向对象编程语言中常见的语法机制。所谓重载函数是指，在同一类中函数名相同、参数不同的一组函数。不过，如果你足够细心，就会发现，上面的代码是编译通过不了的，第 48 行会报错。</p><p>我们知道，多态是一种动态绑定，可以在运行时获取对象的实际类型，来运行实际类型对应的方法。而<strong>函数重载是一种静态绑定，在编译时并不能获取对象的实际类型，而是根据声明类型执行声明类型对应的方法</strong>。在上面代码的第 45~49 行中，resourceFiles 包含的对象的声明类型都是 ResourceFile，而我们并没有在 Extractor 类中定义参数类型是 ResourceFile 的 extract2txt() 重载函数，所以在编译阶段就通过不了，更别说在运行时根据对象的实际类型执行不同的重载函数了。解决的办法稍微有点难理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Extractor extractor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PDFFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Extractor extractor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        extractor.extract2txt(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...PPTFile、WORDFile 跟 PDFFile 类似，这里就省略了...</span></span><br><span class="line"><span class="comment">//...Extractor 代码不变...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Extractor extractor = <span class="keyword">new</span> Extractor();</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) </span><br><span class="line">        &#123;</span><br><span class="line">            resourceFile.accept(extractor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀（pdf/ppt/word）由工厂方法创建不同的类对象（PDFFile/PPTFile/WORDFile）</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PDFFile(<span class="string">"a.pdf"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WORDFile(<span class="string">"b.word"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">"c.ppt"</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行第 38 行的时候，<strong>根据多态特性，程序会调用实际类型的 accept 函数</strong>，比如 PDFFile 的 accept 函数，也就是第 21 行代码。而 <strong>21 行代码中的 this 类型是 PDFFile 的，在编译的时候就确定了</strong>，所以会调用 extractor 的 extract2txt(PDFFile pdfFile) 这个重载函数。</p><p>现在，如果要继续添加新的功能，比如前面提到的压缩功能，根据不同的文件类型，使用不同的压缩算法来压缩资源文件。我们需要实现一个类似 Extractor 类的新类 Compressor 类，在其中<strong>定义三个重载函数，实现对不同类型资源文件的压缩</strong>。除此之外，我们还要<strong>在每个资源文件类中定义新的 accept 重载函数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Extractor extractor)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Compressor compressor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PDFFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Extractor extractor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        extractor.extract2txt(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Compressor compressor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        compressor.compress(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...PPTFile、WORDFile 跟 PDFFile 类似，这里就省略了...</span></span><br><span class="line"><span class="comment">//...Extractor 代码不变</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Extractor extractor = <span class="keyword">new</span> Extractor();</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) </span><br><span class="line">        &#123;</span><br><span class="line">            resourceFile.accept(extractor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Compressor compressor = <span class="keyword">new</span> Compressor();</span><br><span class="line">        <span class="keyword">for</span>(ResourceFile resourceFile : resourceFiles) </span><br><span class="line">        &#123;</span><br><span class="line">            resourceFile.accept(compressor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀（pdf/ppt/word）由工厂方法创建不同的类对象（PDFFile/PPTFile/WORDFile）</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PDFFile(<span class="string">"a.pdf"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WORDFile(<span class="string">"b.word"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">"c.ppt"</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码还存在一些问题，添加一个新的业务，还是需要修改每个资源文件类，违反了开闭原则。针对这个问题，我们<strong>抽象出来一个 Visitor 接口，包含是三个命名非常通用的 visit() 重载函数，分别处理三种不同类型的资源文件</strong>。具体做什么业务处理，由实现这个 Visitor 接口的具体的类来决定，比如 Extractor 负责抽取文本内容，Compressor 负责压缩。<strong>当我们新添加一个业务功能的时候，资源文件类不需要做任何修改，只需要修改 ToolApplication 的代码就可以了</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PDFFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accept</span><span class="params">(Visitor visitor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        visitor.visit(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...PPTFile、WORDFile 跟 PDFFile 类似，这里就省略了...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Visitor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(PDFFile pdfFile)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(PPTFile pdfFile)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(WORDFile pdfFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Extractor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(PPTFile pptFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract PPT."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(PDFFile pdfFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract PDF."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(WORDFile wordFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Extract WORD."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Compressor</span> <span class="keyword">implements</span> <span class="title">Visitor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(PPTFile pptFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Compress PPT."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(PDFFile pdfFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Compress PDF."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(WORDFile wordFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        System.out.println(<span class="string">"Compress WORD."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Extractor extractor = <span class="keyword">new</span> Extractor();</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) </span><br><span class="line">        &#123;</span><br><span class="line">            resourceFile.accept(extractor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Compressor compressor = <span class="keyword">new</span> Compressor();</span><br><span class="line">        <span class="keyword">for</span>(ResourceFile resourceFile : resourceFiles) </span><br><span class="line">        &#123;</span><br><span class="line">            resourceFile.accept(compressor);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀（pdf/ppt/word）由工厂方法创建不同的类对象（PDFFile/PPTFile/WORDFile）</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PDFFile(<span class="string">"a.pdf"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WORDFile(<span class="string">"b.word"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">"c.ppt"</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重新来看访问者模式"><a href="#重新来看访问者模式" class="headerlink" title="重新来看访问者模式"></a>重新来看访问者模式</h2><p><code>访问者者模式</code>的英文翻译是 Visitor Design Pattern。它是这么定义的：</p><blockquote><p>Allows for one or more operation to be applied to a set of objects at runtime, decoupling the operations from the object structure.</p></blockquote><p>翻译成中文就是：<strong>允许一个或者多个操作应用到一组对象上，解耦操作和对象本身</strong>。对于访问者模式的代码实现，实际上，在上面例子中，经过层层重构之后的最终代码，就是标准的访问者模式的实现代码。这里，我又总结了一张类图，贴在了下面：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/29.png" alt></p><p>一般来说，访问者模式针对的是一组类型不同的对象（PDFFile、PPTFile、WORDFile）。不过，尽管这组对象的类型是不同的，但是，它们继承相同的父类（ResourceFile）或者实现相同的接口。在不同的应用场景下，我们需要对这组对象进行一系列不相关的业务操作（抽取文本、压缩等），但<strong>为了避免不断添加功能导致类不断膨胀，职责越来越不单一，以及避免频繁地添加功能导致的频繁代码修改</strong>，我们使用访问者模式，将对象与操作解耦，将这些业务操作抽离出来，定义在独立细分的访问者类（Extractor、Compressor）中。</p><h2 id="为什么支持双分派的语言不需要访问者模式？"><a href="#为什么支持双分派的语言不需要访问者模式？" class="headerlink" title="为什么支持双分派的语言不需要访问者模式？"></a>为什么支持双分派的语言不需要访问者模式？</h2><p>实际上，讲到访问者模式，大部分书籍或者资料都会讲到 <code>Double Dispatch</code>，中文翻译为双分派。既然有 Double Dispatch，对应的就有 <code>Single Dispatch</code>：</p><ul><li>Single Dispatch：执行哪个对象的方法，根据对象的运行时类型来决定；<strong>执行对象的哪个方法，根据方法参数的编译时类型来决定</strong>；</li><li>Double Dispatch：执行哪个对象的方法，根据对象的运行时类型来决定；<strong>执行对象的哪个方法，根据方法参数的运行时类型来决定</strong>；</li></ul><p>在面向对象编程语言中，我们可以把方法调用理解为一种消息传递，也就是“Dispatch”。<strong>一个对象调用另一个对象的方法，就相当于给它发送一条消息。这条消息起码要包含对象名、方法名、方法参数</strong>。“Single”、“Double”指的是执行哪个对象的哪个方法，跟几个因素的运行时类型有关。我们进一步解释一下，Single Dispatch 之所以称为“Single”，是因为执行哪个对象的哪个方法，<strong>只跟“对象”的运行时类型有关</strong>。Double Dispatch 之所以称为“Double”，是因为执行哪个对象的哪个方法，<strong>跟“对象”和“方法参数”两者的运行时类型有关</strong>。</p><p>具体到编程语言的语法机制，Single Dispatch 和 Double Dispatch 跟多态和函数重载直接相关。<strong>当前主流的面向对象编程语言（比如，Java、C++、C#）都只支持 Single Dispatch，不支持 Double Dispatch</strong>。我举个例子来具体说明一下，代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParentClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am ParentClass's f()."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChildClass</span> <span class="keyword">extends</span> <span class="title">ParentClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am ChildClass's f()."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleDispatchClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">polymorphismFunction</span><span class="params">(ParentClass p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        p.f();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overloadFunction</span><span class="params">(ParentClass p)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am overloadFunction(ParentClass p)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">overloadFunction</span><span class="params">(ChildClass c)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am overloadFunction(ChildClass c)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoMain</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SingleDispatchClass demo = <span class="keyword">new</span> SingleDispatchClass();</span><br><span class="line">        ParentClass p = <span class="keyword">new</span> ChildClass();</span><br><span class="line">        demo.polymorphismFunction(p); <span class="comment">// 执行哪个对象的方法，由对象的实际类型决定</span></span><br><span class="line">        demo.overloadFunction(p); <span class="comment">// 执行对象的哪个方法，由参数对象的声明类型决定</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码执行结果:</span></span><br><span class="line"><span class="string">"I am ChildClass's f()."</span></span><br><span class="line"><span class="string">"I am overloadFunction(ParentClass p)."</span></span><br></pre></td></tr></table></figure><p>在上面的代码中，第 41 行代码的 polymorphismFunction() 函数，<strong>执行 p 的实际类型的 f() 函数</strong>，也就是 ChildClass 的 f() 函数。第 42 行代码的 overloadFunction() 函数，匹配的是重载函数中的 overloadFunction(ParentClass p)，也就是<strong>根据 p 的声明类型来决定匹配哪个重载函数</strong>。</p><h2 id="除了访问者模式，还有其他实现方案吗？"><a href="#除了访问者模式，还有其他实现方案吗？" class="headerlink" title="除了访问者模式，还有其他实现方案吗？"></a>除了访问者模式，还有其他实现方案吗？</h2><p>实际上，开发这个工具有很多种代码设计和实现思路。为了讲解访问者模式，上节课我们选择了用访问者模式来实现。实际上，我们还有其他的实现方法，比如，我们还可以<strong>利用工厂模式来实现，定义一个包含 extract2txt() 接口函数的 Extractor 接口</strong>。PDFExtractor、PPTExtractor、WORDExtractor 类实现 Extractor 接口，并且在各自的 extract2txt() 函数中，分别实现 PDF、PPT、WORD 格式文件的文本内容抽取。<strong>ExtractorFactory 工厂类根据不同的文件类型，返回不同的 Extractor</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String filePath;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourceFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filePath = filePath;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ResourceFileType <span class="title">getType</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFFile</span> <span class="keyword">extends</span> <span class="title">ResourceFile</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PDFFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResourceFileType <span class="title">getType</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ResourceFileType.PDF;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...PPTFile/WORDFile 跟 PDFFile 代码结构类似，此处省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Extractor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(ResourceFile resourceFile)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PDFExtractor</span> <span class="keyword">implements</span> <span class="title">Extractor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">extract2txt</span><span class="params">(ResourceFile resourceFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...PPTExtractor/WORDExtractor 跟 PDFExtractor 代码结构类似，此处省略...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtractorFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;ResourceFileType, Extractor&gt; extractors = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        extractors.put(ResourceFileType.PDF, <span class="keyword">new</span> PDFExtractor());</span><br><span class="line">        extractors.put(ResourceFileType.PPT, <span class="keyword">new</span> PPTExtractor());</span><br><span class="line">        extractors.put(ResourceFileType.WORD, <span class="keyword">new</span> WORDExtractor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Extractor <span class="title">getExtractor</span><span class="params">(ResourceFileType type)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> extractors.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ToolApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = listAllResourceFiles(args[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">for</span> (ResourceFile resourceFile : resourceFiles) </span><br><span class="line">        &#123;</span><br><span class="line">            Extractor extractor = ExtractorFactory.getExtractor(resourceFile.getType());</span><br><span class="line">            extractor.extract2txt(resourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> List&lt;ResourceFile&gt; <span class="title">listAllResourceFiles</span><span class="params">(String resourceDirectory)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ResourceFile&gt; resourceFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">//...根据后缀（pdf/ppt/word）由工厂方法创建不同的类对象（PDFFile/PPTFile/WORDFile）</span></span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PDFFile(<span class="string">"a.pdf"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> WORDFile(<span class="string">"b.word"</span>));</span><br><span class="line">        resourceFiles.add(<span class="keyword">new</span> PPTFile(<span class="string">"c.ppt"</span>));</span><br><span class="line">        <span class="keyword">return</span> resourceFiles;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当需要添加新的功能的时候，比如压缩资源文件，类似抽取文本内容功能的代码实现，我们<strong>只需要添加一个 Compressor 接口，PDFCompressor、PPTCompressor、WORDCompressor 三个实现类，以及创建它们的 CompressorFactory 工厂类即可</strong>。唯一需要修改的只有最上层的 ToolApplication 类。基本上符合“对扩展开放、对修改关闭”的设计原则。</p><p>对于资源文件处理工具这个例子，<strong>如果工具提供的功能并不是非常多，只有几个而已，那我更推荐使用工厂模式的实现方式</strong>，毕竟代码更加清晰、易懂。相反，如果工具提供非常多的功能，比如有十几个，那我更推荐使用访问者模式，因为<strong>访问者模式需要定义的类要比工厂模式的实现方式少很多，类太多也会影响到代码的可维护性</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Iterator Design Pattern</title>
      <link href="2020/12/23/Iterator-Design-Pattern/"/>
      <url>2020/12/23/Iterator-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器模式的原理和实现"><a href="#迭代器模式的原理和实现" class="headerlink" title="迭代器模式的原理和实现"></a>迭代器模式的原理和实现</h2><p><code>迭代器模式</code>（Iterator Design Pattern），也叫作游标模式（Cursor Design Pattern）。它用来遍历集合对象，这里说的“集合对象”也可以叫“容器”、“聚合对象”，实际上就是包含一组对象的对象，比如数组、链表、树、图、跳表。<strong>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一</strong>。</p><p>迭代器是用来遍历容器的，所以，一个完整的迭代器模式一般会涉及<code>容器</code>和<code>容器迭代器</code>两部分内容。为了达到基于接口而非实现编程的目的，容器又包含容器接口、容器实现类，迭代器又包含迭代器接口、迭代器实现类：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/25.png" alt></p><p>大部分编程语言都提供了遍历容器的迭代器类，我们在平时开发中，直接拿来用即可，几乎不大可能从零编写一个迭代器。不过，这里为了讲解迭代器的实现原理，我们<strong>假设某个新的编程语言的基础类库中，还没有提供线性容器对应的迭代器，需要我们从零开始开发</strong>。线性数据结构包括数组和链表，假设在这种新的编程语言中，这两个数据结构分别对应 ArrayList 和 LinkedList 两个类。除此之外，我们<strong>从两个类中抽象出公共的接口，定义为 List 接口，以方便开发者基于接口而非实现编程</strong>，编写的代码能在两种数据存储结构之间灵活切换。</p><p>现在，我们针对 ArrayList 和 LinkedList 两个线性容器，设计实现对应的迭代器。按照之前给出的迭代器模式的类图，我们<strong>定义一个迭代器接口 Iterator，以及针对两种容器的具体的迭代器实现类 ArrayIterator 和 ListIterator</strong>。我们先来看下 Iterator 接口的定义：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口定义方式一</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接口定义方式二</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在第一种定义中，next() 函数用来将游标后移一位元素，currentItem() 函数用来返回当前游标指向的元素。在第二种定义中，返回当前元素与后移一位这两个操作，要放到同一个函数 next() 中完成。第一种定义方式更加灵活一些，比如我们<strong>可以多次调用 currentItem() 查询当前元素，而不移动游标</strong>。</p><p>现在，我们再来看下 ArrayIterator 的代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.arrayList = arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor != arrayList.size(); <span class="comment">// 注意这里，cursor 在指向最后一个元素的时候，hasNext() 仍旧返回 true</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cursor++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">currentItem</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor &gt;= arrayList.size()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ArrayList&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"xzg"</span>);</span><br><span class="line">        names.add(<span class="string">"wang"</span>);</span><br><span class="line">        names.add(<span class="string">"zheng"</span>);</span><br><span class="line">        </span><br><span class="line">        Iterator&lt;String&gt; iterator = <span class="keyword">new</span> ArrayIterator(names);</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.currentItem());</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，我们需要将待遍历的容器对象，通过构造函数传递给迭代器类。实际上，<strong>为了封装迭代器的创建细节，我们可以在容器中定义一个 iterator() 方法</strong>，来创建对应的迭代器。为了能实现基于接口而非实现编程，我们还需要将这个方法定义在 List 接口中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...省略其他接口函数...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他代码</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"xzg"</span>);</span><br><span class="line">        names.add(<span class="string">"wang"</span>);</span><br><span class="line">        names.add(<span class="string">"zheng"</span>);</span><br><span class="line">        </span><br><span class="line">        Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.currentItem());</span><br><span class="line">            iterator.next();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合刚刚的例子，我们来总结一下迭代器的设计思路。总结下来就三句话：</p><ol><li>迭代器中需要定义 hasNext()、currentItem()、next() 三个最基本的方法；</li><li>待遍历的容器对象通过依赖注入传递到迭代器类中；</li><li>容器通过 iterator() 方法来创建迭代器；</li></ol><p>这里我画了一张类图，如下所示。实际上就是对上面那张类图的细化：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/26.png" alt></p><h2 id="迭代器模式的优势"><a href="#迭代器模式的优势" class="headerlink" title="迭代器模式的优势"></a>迭代器模式的优势</h2><p>一般来讲，遍历集合数据有三种方法：<code>for 循环</code>、<code>foreach 循环</code>、<code>iterator 迭代器</code>。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">names.add(<span class="string">"xzg"</span>);</span><br><span class="line">names.add(<span class="string">"wang"</span>);</span><br><span class="line">names.add(<span class="string">"zheng"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种遍历方式：for 循环</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; names.size(); i++) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(names.get(i) + <span class="string">","</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种遍历方式：foreach 循环</span></span><br><span class="line"><span class="keyword">for</span> (String name : names) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(name + <span class="string">","</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种遍历方式：迭代器遍历</span></span><br><span class="line">Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line"><span class="keyword">while</span> (iterator.hasNext()) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(iterator.next() + <span class="string">","</span>); <span class="comment">// Java 中的迭代器接口是第二种定义方式，next() 既移动游标又返回数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，<strong>foreach 循环只是一个语法糖而已，底层是基于迭代器来实现的</strong>。也就是说，上面代码中的第二种遍历方式（foreach 循环代码）的底层实现，就是第三种遍历方式（迭代器遍历代码）。</p><p>相对于 for 循环遍历，利用迭代器来遍历有下面三个优势：</p><ul><li>迭代器模式封装集合内部的复杂数据结构，开发者不需要了解如何遍历，直接使用容器提供的迭代器即可；</li><li>迭代器模式将集合对象的遍历操作从集合类中拆分出来，放到迭代器类中，让两者的职责更加单一；</li><li>迭代器模式让添加新的遍历算法更加容易，更符合开闭原则。除此之外，因为迭代器都实现自相同的接口，在开发中，基于接口而非实现编程，替换迭代器也变得更加容易；</li></ul><h2 id="在遍历的同时增删集合元素会发生什么？"><a href="#在遍历的同时增删集合元素会发生什么？" class="headerlink" title="在遍历的同时增删集合元素会发生什么？"></a>在遍历的同时增删集合元素会发生什么？</h2><p>在通过迭代器来遍历集合元素的同时，增加或者删除集合中的元素，有可能会导致某个元素被重复遍历或遍历不到。不过，并不是所有情况下都会遍历出错，有的时候也可以正常遍历，所以，这种行为称为<code>未决行为</code>，也就是说，运行结果到底是对还是错，要视情况而定。我们通过一个例子来解释一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">E <span class="title">currentItem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.arrayList = arrayList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; arrayList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cursor++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">currentItem</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cursor &gt;= arrayList.size()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Iterator <span class="title">iterator</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator <span class="title">iterator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ArrayIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"a"</span>);</span><br><span class="line">        names.add(<span class="string">"b"</span>);</span><br><span class="line">        names.add(<span class="string">"c"</span>);</span><br><span class="line">        names.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">        iterator.next();</span><br><span class="line">        names.remove(<span class="string">"a"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道，ArrayList 底层对应的是数组这种数据结构，在执行完第 67 行代码的时候，数组中存储的是 a、b、c、d 四个元素，迭代器的游标 cursor 指向元素 a。当执行完第 68 行代码的时候，游标指向元素 b，到这里都没有问题。</p><p><strong>为了保持数组存储数据的连续性，数组的删除操作会涉及元素的搬移</strong>。当执行到第 69 行代码的时候，我们从数组中将元素 a 删除掉，b、c、d 三个元素会依次往前搬移一位，这就会导致游标本来指向元素 b，现在变成了指向元素 c。原本在执行完第 68 行代码之后，我们还可以遍历到 b、c、d 三个元素，但在执行完第 69 行代码之后，我们只能遍历到 c、d 两个元素，b 遍历不到了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/27.png" alt></p><p>还是结合刚刚那个例子来讲解，我们将上面的代码稍微改造一下，<strong>把删除元素改为添加元素</strong>。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"a"</span>);</span><br><span class="line">        names.add(<span class="string">"b"</span>);</span><br><span class="line">        names.add(<span class="string">"c"</span>);</span><br><span class="line">        names.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">        iterator.next();</span><br><span class="line">        names.add(<span class="number">0</span>, <span class="string">"x"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在执行完第 12 行代码之后，数组中包含 a、b、c、d 四个元素，游标指向 b 这个元素，已经跳过了元素 a。在执行完第 13 行代码之后，我们将 x 插入到下标为 0 的位置，a、b、c、d 四个元素依次往后移动一位。这个时候，游标又重新指向了元素 a。元素 a 被游标重复指向两次，也就是说，元素 a 存在被重复遍历的情况：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/28.png" alt></p><h2 id="如何应对遍历时改变集合导致的未决行为？"><a href="#如何应对遍历时改变集合导致的未决行为？" class="headerlink" title="如何应对遍历时改变集合导致的未决行为？"></a>如何应对遍历时改变集合导致的未决行为？</h2><p>当通过迭代器来遍历集合的时候，增加、删除集合元素会导致不可预期的遍历结果。实际上，<strong>不可预期比直接出错更加可怕</strong>，有的时候运行正确，有的时候运行错误，一些隐藏很深、很难 debug 的 bug 就是这么产生的。</p><p>有两种比较干脆利索的解决方案：</p><ol><li>遍历的时候不允许增删元素；</li><li>增删元素之后让遍历报错；</li></ol><p>实际上，<strong>第一种解决方案比较难实现，我们要确定遍历开始和结束的时间点</strong>。遍历开始的时间节点我们很容易获得。我们可以把创建迭代器的时间点作为遍历开始的时间点。但是，遍历结束的时间点该如何来确定呢？在实际的软件开发中，<strong>每次使用迭代器来遍历元素，并不一定非要把所有元素都遍历一遍</strong>。你可能还会说，那我们可以在迭代器类中定义一个新的接口 finishIteration()，主动告知容器迭代器使用完了，你可以增删元素了。但是，这就要求程序员在使用完迭代器之后要主动调用这个函数，也<strong>增加了开发成本，还很容易漏掉</strong>。</p><p>第二种解决方法更加合理。Java 语言就是采用的这种解决方案，<strong>增删元素之后，让遍历报错</strong>。我们在 ArrayList 中定义一个成员变量 modCount，记录集合被修改的次数，集合每调用一次增加或删除元素的函数，就会给 modCount 加 1。当通过调用集合上的 iterator() 函数来创建迭代器的时候，我们把 modCount 值传递给迭代器的 expectedModCount 成员变量，之后<strong>每次调用迭代器上的 hasNext()、next()、currentItem() 函数，我们都会检查集合上的 modCount 是否等于 expectedModCount</strong>。</p><p>如果两个值不相同，那就说明集合存储的元素已经改变了，要么增加了元素，要么删除了元素，之前创建的迭代器已经不能正确运行了，再继续使用就会产生不可预期的结果，所以我们选择 <code>fail-fast</code> 解决方式，抛出运行时异常，结束掉程序，让程序员尽快修复这个因为不正确使用迭代器而产生的 bug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayIterator</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList arrayList;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> expectedModCount;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayIterator</span><span class="params">(ArrayList arrayList)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.arrayList = arrayList;</span><br><span class="line">        <span class="keyword">this</span>.expectedModCount = arrayList.modCount;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        checkForModification();</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; arrayList.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        checkForModification();</span><br><span class="line">        cursor++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">currentItem</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        checkForModification();</span><br><span class="line">        <span class="keyword">return</span> arrayList.get(cursor);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForModification</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (arrayList.modCount != expectedModCount) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 代码示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"a"</span>);</span><br><span class="line">        names.add(<span class="string">"b"</span>);</span><br><span class="line">        names.add(<span class="string">"c"</span>);</span><br><span class="line">        names.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">        iterator.next();</span><br><span class="line">        names.remove(<span class="string">"a"</span>);</span><br><span class="line">        iterator.next(); <span class="comment">// 抛出 ConcurrentModificationException 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何在遍历的同时安全地删除集合元素？"><a href="#如何在遍历的同时安全地删除集合元素？" class="headerlink" title="如何在遍历的同时安全地删除集合元素？"></a>如何在遍历的同时安全地删除集合元素？</h2><p>像 Java 语言，迭代器类中除了前面提到的几个最基本的方法之外，还定义了一个 <code>remove() 方法</code>，能够在遍历集合的同时，安全地删除集合中的元素。不过，需要说明的是，它并没有提供添加元素的方法。毕竟迭代器的主要作用是遍历，添加元素放到迭代器里本身就不合适。我个人觉得，Java 迭代器中提供的 remove() 方法还是比较鸡肋的，作用有限。它<strong>只能删除游标指向的前一个元素，而且一个 next() 函数之后，只能跟着最多一个 remove() 操作</strong>，多次调用 remove() 操作会报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;String&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        names.add(<span class="string">"a"</span>);</span><br><span class="line">        names.add(<span class="string">"b"</span>);</span><br><span class="line">        names.add(<span class="string">"c"</span>);</span><br><span class="line">        names.add(<span class="string">"d"</span>);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; iterator = names.iterator();</span><br><span class="line">        iterator.next();</span><br><span class="line">        iterator.remove();</span><br><span class="line">        iterator.remove(); <span class="comment">// 报错，抛出 IllegalStateException 异常</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看下 remove() 函数是如何实现的。稍微提醒一下，在 Java 实现中，<strong>迭代器类是容器类的内部类，并且 next() 函数不仅将游标后移一位，还会返回当前的元素</strong>。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Itr();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Itr</span> <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> cursor;       <span class="comment">// index of next element to return</span></span><br><span class="line">        <span class="keyword">int</span> lastRet = -<span class="number">1</span>; <span class="comment">// index of last element returned; -1 if no such element</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount = modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> cursor != size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            checkForModification();</span><br><span class="line">            <span class="keyword">int</span> i = cursor;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= size)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">            &#125;</span><br><span class="line">            Object[] elementData = ArrayList.<span class="keyword">this</span>.elementData;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= elementData.length)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">            cursor = i + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> (E) elementData[lastRet = i];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (lastRet &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">            &#125;</span><br><span class="line">            checkForModification();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                ArrayList.<span class="keyword">this</span>.remove(lastRet);</span><br><span class="line">                cursor = lastRet;</span><br><span class="line">                lastRet = -<span class="number">1</span>;</span><br><span class="line">                expectedModCount = modCount;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (IndexOutOfBoundsException ex) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，<strong>迭代器类新增了一个 lastRet 成员变量，用来记录游标指向的前一个元素</strong>。通过迭代器去删除这个元素的时候，我们可以更新迭代器中的游标和 lastRet 值，来保证不会因为删除元素而导致某个元素遍历不到。如果通过容器来删除元素，并且希望更新迭代器中的游标值来保证遍历不出错，我们就要<strong>维护这个容器都创建了哪些迭代器，每个迭代器是否还在使用等信息</strong>，代码实现就变得比较复杂了。</p><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>如何实现一个支持“快照”功能的迭代器模式？理解这个问题最关键的是理解“快照”两个字。所谓“快照”，指我们为容器创建迭代器的时候，相当于给容器拍了一张快照（Snapshot）。之后即便我们增删容器中的元素，快照中的元素并不会做相应的改动。而<strong>迭代器遍历的对象是快照而非容器，这样就避免了在使用迭代器遍历的过程中，增删容器中的元素，导致的不可预期的结果或者报错</strong>。</p><p>容器 list 中初始存储了 3、8、2 三个元素。尽管在创建迭代器 iter1 之后，容器 list 删除了元素 3，只剩下 8、2 两个元素，但是，通过 iter1 遍历的对象是快照，而非容器 list 本身。所以，遍历的结果仍然是 3、8、2。同理，iter2、iter3 也是在各自的快照上遍历，输出的结果如代码中注释所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">list.add(<span class="number">3</span>);</span><br><span class="line">list.add(<span class="number">8</span>);</span><br><span class="line">list.add(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">Iterator&lt;Integer&gt; iter1 = list.iterator(); <span class="comment">// snapshot: 3, 8, 2</span></span><br><span class="line">list.remove(<span class="keyword">new</span> Integer(<span class="number">2</span>)); <span class="comment">// list：3, 8</span></span><br><span class="line">Iterator&lt;Integer&gt; iter2 = list.iterator(); <span class="comment">// snapshot: 3, 8</span></span><br><span class="line">list.remove(<span class="keyword">new</span> Integer(<span class="number">3</span>));<span class="comment">// list：8</span></span><br><span class="line">Iterator&lt;Integer&gt; iter3 = list.iterator(); <span class="comment">// snapshot: 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：3 8 2</span></span><br><span class="line"><span class="keyword">while</span> (iter1.hasNext()) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(iter1.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：3 8</span></span><br><span class="line"><span class="keyword">while</span> (iter2.hasNext()) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(iter1.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出结果：8</span></span><br><span class="line"><span class="keyword">while</span> (iter3.hasNext()) </span><br><span class="line">&#123;</span><br><span class="line">    System.out.print(iter1.next() + <span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line">System.out.println();</span><br></pre></td></tr></table></figure><p>下面是针对这个功能需求的骨架代码，其中包含 ArrayList、SnapshotArrayIterator 两个类。对于这两个类，我<strong>只定义了必须的几个关键接口，完整的代码实现我并没有给出</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ArrayList&lt;E&gt; implements List&lt;E&gt; </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E obj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E obj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SnapshotArrayIterator(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> 成员变量、私有函数等随便你定义</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 返回当前元素，并且游标后移一位</span></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 由你来完善</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="解决方案一"><a href="#解决方案一" class="headerlink" title="解决方案一"></a>解决方案一</h2><p>在迭代器类中定义一个成员变量 snapshot 来存储快照。<strong>每当创建迭代器的时候，都拷贝一份容器中的元素到快照中</strong>，后续的遍历操作都基于这个迭代器自己持有的快照来进行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;</span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; snapshot;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.cursor = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.snapshot = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">this</span>.snapshot.addAll(arrayList);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.size();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        E currentItem = snapshot.get(cursor);</span><br><span class="line">        cursor++;</span><br><span class="line">        <span class="keyword">return</span> currentItem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个解决方案虽然简单，但代价也有点高。<strong>每次创建迭代器的时候，都要拷贝一份数据到快照中，会增加内存的消耗</strong>。如果一个容器同时有多个迭代器在遍历元素，就会导致数据在内存中重复存储多份。不过，庆幸的是，Java 中的拷贝属于<code>浅拷贝</code>，也就是说，容器中的对象并非真的拷贝了多份，而只是拷贝了对象的引用而已。</p><h2 id="解决方案二"><a href="#解决方案二" class="headerlink" title="解决方案二"></a>解决方案二</h2><p>我们可以在容器中，<strong>为每个元素保存两个时间戳，一个是添加时间戳 addTimestamp，一个是删除时间戳 delTimestamp</strong>。当元素被加入到集合中的时候，我们将 addTimestamp 设置为当前时间，将 delTimestamp 设置成最大长整型值（Long.MAX_VALUE）。当元素被删除时，我们将 delTimestamp 更新为当前时间，表示已经被删除。</p><p>同时，<strong>每个迭代器也保存一个迭代器创建时间戳 snapshotTimestamp，也就是迭代器对应的快照的创建时间戳</strong>。当使用迭代器来遍历容器的时候，只有满足 <code>addTimestamp &lt; snapshotTimestamp &lt; delTimestamp</code> 的元素，才是属于这个迭代器的快照。这样就在不拷贝容器的情况下，在容器本身上借助时间戳实现了快照功能。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> actualSize; <span class="comment">// 不包含标记删除元素</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> totalSize; <span class="comment">// 包含标记删除元素</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Object[] elements;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] addTimestamps;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span>[] delTimestamps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elements = <span class="keyword">new</span> Object[DEFAULT_CAPACITY];</span><br><span class="line">        <span class="keyword">this</span>.addTimestamps = <span class="keyword">new</span> <span class="keyword">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">        <span class="keyword">this</span>.delTimestamps = <span class="keyword">new</span> <span class="keyword">long</span>[DEFAULT_CAPACITY];</span><br><span class="line">        <span class="keyword">this</span>.totalSize = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.actualSize = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(E obj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        elements[totalSize] = obj;</span><br><span class="line">        addTimestamps[totalSize] = System.currentTimeMillis();</span><br><span class="line">        delTimestamps[totalSize] = Long.MAX_VALUE;</span><br><span class="line">        totalSize++;</span><br><span class="line">        actualSize++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(E obj)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; totalSize; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (elements[i].equals(obj) &amp;&amp; delTimestamps[i] == Long.MAX_VALUE) <span class="comment">// 防止重复删除</span></span><br><span class="line">            &#123;</span><br><span class="line">                delTimestamps[i] = System.currentTimeMillis();</span><br><span class="line">                actualSize--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">actualSize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.actualSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">totalSize</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.totalSize;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= totalSize) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (E)elements[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getAddTimestamp</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= totalSize) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> addTimestamps[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getDelTimestamp</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= totalSize) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> delTimestamps[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SnapshotArrayIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> snapshotTimestamp;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursorInAll; <span class="comment">// 在整个容器中的下标，而非快照中的下标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> leftCount; <span class="comment">// 快照中还有几个元素未被遍历</span></span><br><span class="line">    <span class="keyword">private</span> ArrayList&lt;E&gt; arrayList;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SnapshotArrayIterator</span><span class="params">(ArrayList&lt;E&gt; arrayList)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.snapshotTimestamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">this</span>.cursorInAll = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.leftCount = arrayList.actualSize();;</span><br><span class="line">        <span class="keyword">this</span>.arrayList = arrayList;</span><br><span class="line"></span><br><span class="line">        justNext(); <span class="comment">// 先跳到这个迭代器快照的第一个元素</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursorInAll &lt; arrayList.totalSize()；</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        E currentItem = arrayList.get(cursorInAll);</span><br><span class="line">        justNext();</span><br><span class="line">        cursorInAll++； <span class="comment">// 自增，否则 cursorInAll 一直不变</span></span><br><span class="line">        <span class="keyword">return</span> currentItem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">justNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cursorInAll &lt; arrayList.totalSize()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> addTimestamp = arrayList.getAddTimestamp(cursorInAll);</span><br><span class="line">            <span class="keyword">long</span> delTimestamp = arrayList.getDelTimestamp(cursorInAll);</span><br><span class="line">            <span class="keyword">if</span> (snapshotTimestamp &gt; addTimestamp &amp;&amp; snapshotTimestamp &lt; delTimestamp) </span><br><span class="line">            &#123;</span><br><span class="line">                leftCount--;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            cursorInAll++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，上面的解决方案相当于解决了一个问题，又引入了另外一个问题。ArrayList 底层依赖数组这种数据结构，原本可以支持快速的随机访问，在 O(1) 时间复杂度内获取下标为 i 的元素，但现在，<strong>删除数据并非真正的删除，只是通过时间戳来标记删除，这就导致无法支持按照下标快速随机访问了</strong>。</p><p>解决的方法也不难，我稍微提示一下。我们可以<strong>在 ArrayList 中存储两个数组：一个支持标记删除的，用来实现快照遍历功能；一个不支持标记删除的（也就是将要删除的数据直接从数组中移除）</strong>，用来支持随机访问。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>State Design Pattern</title>
      <link href="2020/12/23/State-Design-Pattern/"/>
      <url>2020/12/23/State-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是有限状态机？"><a href="#什么是有限状态机？" class="headerlink" title="什么是有限状态机？"></a>什么是有限状态机？</h2><p><code>有限状态机</code>，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：状态（State）、事件（Event）、动作（Action）。其中，<strong>事件也称为转移条件（Transition Condition），事件触发状态的转移及动作的执行</strong>。不过，动作不是必须的，也可能只转移状态，不执行任何动作。</p><p>在超级马里奥中，马里奥可以变身为多种形态，比如小马里奥（Small Mario）、超级马里奥（Super Mario）、火焰马里奥（Fire Mario）、斗篷马里奥（Cape Mario）等等。在不同的游戏情节下，各个形态会互相转化，并相应的增减积分。比如，初始形态是小马里奥，吃了蘑菇之后就会变成超级马里奥，并且增加 100 积分。</p><p>实际上，<strong>马里奥形态的转变就是一个状态机</strong>。其中，马里奥的不同形态就是状态机中的“状态”，游戏情节（比如吃了蘑菇）就是状态机中的“事件”，加减积分就是状态机中的“动作”。比如，吃蘑菇这个事件，会触发状态的转移：从小马里奥转移到超级马里奥，以及触发动作的执行（增加 100 积分）。为了方便接下来的讲解，我对游戏背景做了简化，只保留了部分状态和事件：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/23.png" alt></p><p>我写了一个骨架代码，如下所示。其中，obtainMushRoom()、obtainCape()、obtainFireFlower()、meetMonster() 这几个函数，能够根据当前的状态和事件，更新状态和增减积分：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> State </span><br><span class="line">&#123;</span><br><span class="line">    SMALL(<span class="number">0</span>),</span><br><span class="line">    SUPER(<span class="number">1</span>),</span><br><span class="line">    FIRE(<span class="number">2</span>),</span><br><span class="line">    CAPE(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">State</span><span class="params">(<span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// TODO</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MarioStateMachine mario = <span class="keyword">new</span> MarioStateMachine();</span><br><span class="line">        mario.obtainMushRoom();</span><br><span class="line">        <span class="keyword">int</span> score = mario.getScore();</span><br><span class="line">        State state = mario.getCurrentState();</span><br><span class="line">        System.out.println(<span class="string">"mario score: "</span> + score + <span class="string">"; state: "</span> + state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态机实现方式一：分支逻辑法"><a href="#状态机实现方式一：分支逻辑法" class="headerlink" title="状态机实现方式一：分支逻辑法"></a>状态机实现方式一：分支逻辑法</h2><p>对于如何实现状态机，我总结了三种方式。其中，最简单直接的实现方式是，<strong>参照状态转移图，将每一个状态转移，原模原样地直译成代码</strong>。这样编写的代码会包含大量的 if-else 或 switch-case 分支判断逻辑，甚至是嵌套的分支判断逻辑，所以，我把这种方法暂且命名为分支逻辑法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.SMALL)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.SUPER;</span><br><span class="line">            <span class="keyword">this</span>.score += <span class="number">100</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.CAPE;</span><br><span class="line">            <span class="keyword">this</span>.score += <span class="number">200</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.SMALL) || currentState.equals(State.SUPER)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.FIRE;</span><br><span class="line">            <span class="keyword">this</span>.score += <span class="number">300</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.SUPER)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">            <span class="keyword">this</span>.score -= <span class="number">100</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.CAPE)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">            <span class="keyword">this</span>.score -= <span class="number">200</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (currentState.equals(State.FIRE)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">            <span class="keyword">this</span>.score -= <span class="number">300</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于简单的状态机来说，分支逻辑这种实现方式是可以接受的。但是，<strong>对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移</strong>。除此之外，代码中充斥着大量的 if-else 或者 switch-case 分支判断逻辑，可读性和可维护性都很差。如果哪天修改了状态机中的某个状态转移，我们要在冗长的分支逻辑中找到对应的代码进行修改，很容易改错，引入 bug。</p><h2 id="状态机实现方式二：查表法"><a href="#状态机实现方式二：查表法" class="headerlink" title="状态机实现方式二：查表法"></a>状态机实现方式二：查表法</h2><p>实际上，上面这种实现方法有点类似 hard code，对于复杂的状态机来说不适用，而状态机的第二种实现方式查表法，就更加合适了。<strong>除了用状态转移图来表示之外，状态机还可以用二维表来表示</strong>。在这个二维表中，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作，如下所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/24.png" alt></p><p>相对于分支逻辑的实现方式，查表法的代码实现更加清晰，可读性和可维护性更好。<strong>当修改状态机时，我们只需要修改 transitionTable 和 actionTable 两个二维数组即可</strong>。实际上，如果我们把这两个二维数组存储在配置文件中，当需要修改状态机时，我们甚至可以不修改任何代码，只需要修改配置文件就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Event </span><br><span class="line">&#123;</span><br><span class="line">    GOT_MUSHROOM(<span class="number">0</span>),</span><br><span class="line">    GOT_CAPE(<span class="number">1</span>),</span><br><span class="line">    GOT_FIRE(<span class="number">2</span>),</span><br><span class="line">    MET_MONSTER(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Event</span><span class="params">(<span class="keyword">int</span> value)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getValue</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> State currentState;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> State[][] transitionTable = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">        &#123;SUPER, CAPE, FIRE, SMALL&#125;,</span><br><span class="line">        &#123;CAPE, CAPE, CAPE, SMALL&#125;,</span><br><span class="line">        &#123;FIRE, FIRE, FIRE, SMALL&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span>[][] actionTable = </span><br><span class="line">    &#123;</span><br><span class="line">        &#123;+<span class="number">100</span>, +<span class="number">200</span>, +<span class="number">300</span>, +<span class="number">0</span>&#125;,</span><br><span class="line">        &#123;+<span class="number">0</span>, +<span class="number">200</span>, +<span class="number">300</span>, -<span class="number">100</span>&#125;,</span><br><span class="line">        &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">200</span>&#125;,</span><br><span class="line">        &#123;+<span class="number">0</span>, +<span class="number">0</span>, +<span class="number">0</span>, -<span class="number">300</span>&#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        executeEvent(Event.GOT_MUSHROOM);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        executeEvent(Event.GOT_CAPE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        executeEvent(Event.GOT_FIRE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        executeEvent(Event.MET_MONSTER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeEvent</span><span class="params">(Event event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> stateValue = currentState.getValue();</span><br><span class="line">        <span class="keyword">int</span> eventValue = event.getValue();</span><br><span class="line">        <span class="keyword">this</span>.currentState = transitionTable[stateValue][eventValue];</span><br><span class="line">        <span class="keyword">this</span>.score += actionTable[stateValue][eventValue];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="状态机实现方式三：状态模式"><a href="#状态机实现方式三：状态模式" class="headerlink" title="状态机实现方式三：状态模式"></a>状态机实现方式三：状态模式</h2><p>在查表法的代码实现中，事件触发的动作只是简单的积分加减，所以，我们用一个 int 类型的二维数组 actionTable 就能表示，二维数组中的值表示积分的加减值。但是，<strong>如果要执行的动作并非这么简单，而是一系列复杂的逻辑操作</strong>（比如加减积分、写数据库，还有可能发送消息通知等等），我们就没法用如此简单的二维数组来表示了。这也就是说，查表法的实现方式有一定局限性。</p><p><strong>状态模式通过将事件触发的状态转移和动作执行，拆分到不同的状态类中，来避免分支判断逻辑</strong>。利用状态模式，我们来补全 MarioStateMachine 类。其中，IMario 是状态的接口，定义了所有的事件。SmallMario、SuperMario、CapeMario、FireMario 是 IMario 接口的实现类，分别对应状态机中的 4 个状态。原来所有的状态转移和动作执行的代码逻辑，都集中在 MarioStateMachine 类中，现在，这些代码逻辑被分散到了这 4 个状态类中。补全后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMario</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 所有状态类的接口</span></span><br><span class="line">    <span class="function">State <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 以下是定义的事件</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SmallMario</span><span class="params">(MarioStateMachine stateMachine)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stateMachine = stateMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(<span class="keyword">new</span> SuperMario(stateMachine));</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(<span class="keyword">new</span> CapeMario(stateMachine));</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(<span class="keyword">new</span> FireMario(stateMachine));</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SuperMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MarioStateMachine stateMachine;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SuperMario</span><span class="params">(MarioStateMachine stateMachine)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.stateMachine = stateMachine;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> State.SUPER;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(<span class="keyword">new</span> CapeMario(stateMachine));</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(<span class="keyword">new</span> FireMario(stateMachine));</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(<span class="keyword">new</span> SmallMario(stateMachine));</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() - <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略 CapeMario、FireMario 类...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> IMario currentState; <span class="comment">// 不再使用枚举来表示状态</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = <span class="keyword">new</span> SmallMario(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainMushRoom();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainCape();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainFireFlower();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.meetMonster();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentState.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(IMario currentState)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码实现不难看懂，我只强调其中的一点，即 <strong>MarioStateMachine 和各个状态类之间是双向依赖关系</strong>。MarioStateMachine 依赖各个状态类是理所当然的，但是，反过来，各个状态类为什么要依赖 MarioStateMachine 呢？这是因为，各个状态类需要更新 MarioStateMachine 中的两个变量，score 和 currentState。</p><p>实际上，上面的代码还可以继续优化，我们<strong>可以将状态类设计成单例，毕竟状态类中不包含任何成员变量</strong>。在这里，我们可以通过函数参数将 MarioStateMachine 传递进状态类。根据这个设计思路，我们对上面的代码进行重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMario</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">State <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">(MarioStateMachine stateMachine)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">(MarioStateMachine stateMachine)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">(MarioStateMachine stateMachine)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">(MarioStateMachine stateMachine)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmallMario</span> <span class="keyword">implements</span> <span class="title">IMario</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SmallMario instance = <span class="keyword">new</span> SmallMario();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SmallMario</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SmallMario <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getName</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> State.SMALL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">(MarioStateMachine stateMachine)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(SuperMario.getInstance());</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">(MarioStateMachine stateMachine)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(CapeMario.getInstance());</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">200</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">(MarioStateMachine stateMachine)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stateMachine.setCurrentState(FireMario.getInstance());</span><br><span class="line">        stateMachine.setScore(stateMachine.getScore() + <span class="number">300</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">(MarioStateMachine stateMachine)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// do nothing...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略 SuperMario、CapeMario、FireMario 类...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MarioStateMachine</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line">    <span class="keyword">private</span> IMario currentState;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MarioStateMachine</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.currentState = SmallMario.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainMushRoom</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainMushRoom(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainCape</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainCape(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">obtainFireFlower</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.obtainFireFlower(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">meetMonster</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState.meetMonster(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> State <span class="title">getCurrentState</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.currentState.getName();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCurrentState</span><span class="params">(IMario currentState)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.currentState = currentState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，像游戏这种比较复杂的状态机，包含的状态比较多，我优先推荐使用查表法，而状态模式会引入非常多的状态类，会导致代码比较难维护。相反，像电商下单、外卖下单这种类型的状态机，它们的<strong>状态并不多，状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能会比较复杂</strong>，所以，更加推荐使用状态模式来实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Chain of Responsibility Design Pattern</title>
      <link href="2020/12/20/Chain-of-Responsibility-Design-Pattern/"/>
      <url>2020/12/20/Chain-of-Responsibility-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="职责链模式的原理和实现"><a href="#职责链模式的原理和实现" class="headerlink" title="职责链模式的原理和实现"></a>职责链模式的原理和实现</h2><p><code>职责链模式</code>的英文翻译是 Chain of Responsibility Design Pattern。它是这么定义的：</p><blockquote><p>Avoid coupling the sender of a request to its receiver by giving more than one object a chance to handle the request. Chain the receiving objects and pass the request along the chain until an object handles it.</p></blockquote><p>翻译成中文就是：将请求的发送和接收解耦，让多个接收对象都有机会处理这个请求。<strong>将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止</strong>。在职责链模式中，多个处理器（也就是刚刚定义中说的接收对象）依次处理同一个请求。一个请求先经过 A 处理器处理，然后再把请求传递给 B 处理器，B 处理器处理完后再传递给 C 处理器，以此类推，形成一个链条。<strong>链条上的每个处理器各自承担各自的处理职责，所以叫作职责链模式</strong>。</p><p>第一种实现方式如下所示。其中，<strong>Handler 是所有处理器类的抽象父类，handle() 是抽象方法</strong>。每个具体的处理器类的 handle() 函数的代码结构类似，如果它能处理该请求，就不继续往下传递；如果不能处理，则交由后面的处理器来处理（也就是调用 successor.handle()）。<strong>HandlerChain 是处理器链，从数据结构的角度来看，它就是一个记录了链头、链尾的链表</strong>。其中，记录链尾是为了方便添加处理器：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (!handled &amp;&amp; successor != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Handler head = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Handler tail = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(Handler handler)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        handler.setSuccessor(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            head = handler;</span><br><span class="line">            tail = handler;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        tail.setSuccessor(handler);</span><br><span class="line">        tail = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            head.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HandlerChain chain = <span class="keyword">new</span> HandlerChain();</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> HandlerA());</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> HandlerB());</span><br><span class="line">        chain.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，上面的代码实现不够优雅。处理器类的 <strong>handle() 函数，不仅包含自己的业务逻辑，还包含对下一个处理器的调用</strong>，也就是代码中的 successor.handle()。一个不熟悉这种代码结构的程序员，在添加新的处理器类的时候，很有可能忘记在 handle() 函数中调用 successor.handle()，这就会导致代码出现 bug。</p><p>针对这个问题，我们对代码进行重构，利用模板模式，<strong>将调用 successor.handle() 的逻辑从具体的处理器类中剥离出来，放到抽象父类中</strong>。这样具体的处理器类只需要实现自己的业务逻辑就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Handler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> Handler successor = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSuccessor</span><span class="params">(Handler successor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.successor = successor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = doHandle();</span><br><span class="line">        <span class="keyword">if</span> (successor != <span class="keyword">null</span> &amp;&amp; !handled) </span><br><span class="line">        &#123;</span><br><span class="line">            successor.handle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doHandle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doHandle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">doHandle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// HandlerChain 和 Application 代码不变</span></span><br></pre></td></tr></table></figure><p>我们再来看第二种实现方式，代码如下所示。这种实现方式更加简单。<strong>HandlerChain 类用数组而非链表来保存所有的处理器</strong>，并且需要在 HandlerChain 的 handle() 函数中，依次调用每个处理器的 handle() 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerA</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerB</span> <span class="keyword">implements</span> <span class="title">IHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> handled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerChain</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;IHandler&gt; handlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(IHandler handler)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.handlers.add(handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handle</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (IHandler handler : handlers) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">boolean</span> handled = handler.handle();</span><br><span class="line">            <span class="keyword">if</span> (handled) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HandlerChain chain = <span class="keyword">new</span> HandlerChain();</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> HandlerA());</span><br><span class="line">        chain.addHandler(<span class="keyword">new</span> HandlerB());</span><br><span class="line">        chain.handle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 GoF 给出的定义中，如果处理器链上的某个处理器能够处理这个请求，那就不会继续往下传递请求。实际上，<strong>职责链模式还有一种变体，那就是请求会被所有的处理器都处理一遍</strong>，不存在中途终止的情况。</p><h2 id="职责链模式的应用场景举例"><a href="#职责链模式的应用场景举例" class="headerlink" title="职责链模式的应用场景举例"></a>职责链模式的应用场景举例</h2><p>对于支持 <code>UGC</code>（User Generated Content，用户生成内容）的应用（比如论坛）来说，用户生成的内容（比如，在论坛中发表的帖子）可能会包含一些敏感词（比如涉黄、广告、反动等词汇）。针对这个应用场景，我们就<strong>可以利用职责链模式来过滤这些敏感词</strong>。对于包含敏感词的内容，我们有两种处理方式，一种是直接禁止发布，另一种是给敏感词打马赛克（比如，用 *** 替换敏感词）之后再发布。第一种处理方式符合 GoF 给出的职责链模式的定义，第二种处理方式是职责链模式的变体。</p><p>我们这里只给出第一种实现方式的代码示例，如下所示，并且，我们只给出了代码实现的骨架，具体的敏感词过滤算法并没有给出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SensitiveWordFilter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Content content)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SexyWordFilter</span> <span class="keyword">implements</span> <span class="title">SensitiveWordFilter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doFilter</span><span class="params">(Content content)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> legal = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> legal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// PoliticalWordFilter、AdsWordFilter 类代码结构与 SexyWordFilter 类似</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveWordFilterChain</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;SensitiveWordFilter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(SensitiveWordFilter filter)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.filters.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// return true if content doesn't contain sensitive words.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Content content)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (SensitiveWordFilter filter : filters) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!filter.doFilter(content)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SensitiveWordFilterChain filterChain = <span class="keyword">new</span> SensitiveWordFilterChain();</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> AdsWordFilter());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> SexyWordFilter());</span><br><span class="line">        filterChain.addFilter(<span class="keyword">new</span> PoliticalWordFilter());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> legal = filterChain.filter(<span class="keyword">new</span> Content());</span><br><span class="line">        <span class="keyword">if</span> (!legal) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 不发表</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 发表</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了上面的实现，你可能会说，为什么非要使用职责链模式呢？像下面这样也可以实现敏感词过滤功能，而且代码更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SensitiveWordFilter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// return true if content doesn't contain sensitive words.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">filter</span><span class="params">(Content content)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!filterSexyWord(content)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!filterAdsWord(content)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!filterPoliticalWord(content)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">filterSexyWord</span><span class="params">(Content content)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">filterAdsWord</span><span class="params">(Content content)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">filterPoliticalWord</span><span class="params">(Content content)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="应对代码的复杂性"><a href="#应对代码的复杂性" class="headerlink" title="应对代码的复杂性"></a>应对代码的复杂性</h3><p><strong>将大块代码逻辑拆分成函数，将大类拆分成小类，是应对代码复杂性的常用方法</strong>。应用职责链模式，我们把各个敏感词过滤函数继续拆分出来，设计成独立的类，进一步简化了 SensitiveWordFilter 类，让 SensitiveWordFilter 类的代码不会过多，过复杂。</p><h3 id="提高代码的扩展性"><a href="#提高代码的扩展性" class="headerlink" title="提高代码的扩展性"></a>提高代码的扩展性</h3><p>当我们要扩展新的过滤算法的时候，比如，我们还需要过滤特殊符号，按照非职责链模式的代码实现方式，我们需要修改 SensitiveWordFilter 的代码，违反开闭原则。不过，这样的修改还算比较集中，也是可以接受的。而<strong>职责链模式的实现方式更加优雅，只需要新添加一个 Filter 类</strong>，并且通过 addFilter() 函数将它添加到 FilterChain 中即可，其他代码完全不需要修改。</p><p>实际上，细化一下的话，我们<strong>可以把上面的代码分成两类：框架代码和客户端代码</strong>。其中，ApplicationDemo 属于客户端代码，也就是使用框架的代码。除 ApplicationDemo 之外的代码属于敏感词过滤框架代码。假设敏感词过滤框架并不是我们开发维护的，而是我们引入的一个第三方框架，我们要扩展一个新的过滤算法，不可能直接去修改框架的源码。这个时候，利用职责链模式就能达到开篇所说的，在不修改框架源码的情况下，基于职责链模式提供的扩展点，来扩展新的功能。换句话说，我们<strong>在框架这个代码范围内实现了开闭原则</strong>。</p><p>除此之外，利用职责链模式相对于不用职责链的实现方式，还有一个好处，那就是<strong>配置过滤算法更加灵活，可以只选择使用某几个过滤算法</strong>。</p><h2 id="Servlet-Filter"><a href="#Servlet-Filter" class="headerlink" title="Servlet Filter"></a>Servlet Filter</h2><p>Servlet Filter 是 Java Servlet 规范中定义的组件，翻译成中文就是过滤器，它可以实现对 HTTP 请求的过滤功能，比如鉴权、限流、记录日志、验证参数等等。因为它是 Servlet 规范的一部分，所以，<strong>只要是支持 Servlet 的 Web 容器（比如，Tomcat、Jetty 等），都支持过滤器功能</strong>。为了帮助你理解，我画了一张示意图阐述它的工作原理，如下所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/21.png" alt></p><p>在实际项目中，添加一个过滤器，我们只需要<strong>定义一个实现 javax.servlet.Filter 接口的过滤器类，并且将它配置在 web.xml 配置文件中</strong>。Web 容器启动的时候，会读取 web.xml 中的配置，创建过滤器对象。当有请求到来的时候，会先经过过滤器，然后才由 Servlet 来处理：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FilterConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 在创建 Filter 时自动调用，</span></span><br><span class="line">        <span class="comment">// 其中 filterConfig 包含这个 Filter 的配置参数，比如 name 之类的（从配置文件中读取的）</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response, FilterChain chain)</span> <span class="keyword">throws</span> IOException, ServletException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截客户端发送来的请求."</span>);</span><br><span class="line">        chain.doFilter(request, response);</span><br><span class="line">        System.out.println(<span class="string">"拦截发送给客户端的响应."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 在销毁 Filter 时自动调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 web.xml 配置文件中如下配置：</span></span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;logFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-<span class="class"><span class="keyword">class</span>&gt;<span class="title">com</span>.<span class="title">xzg</span>.<span class="title">cd</span>.<span class="title">LogFilter</span>&lt;/<span class="title">filter</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>&gt;</span></span><br><span class="line"><span class="class">&lt;<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">filter</span>-<span class="title">name</span>&gt;<span class="title">logFilter</span>&lt;/<span class="title">filter</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">    &lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/*&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&lt;/<span class="title">filter</span>-<span class="title">mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从刚刚的示例代码中，我们发现，添加过滤器非常方便，不需要修改任何代码，定义一个实现 javax.servlet.Filter 的类，再改改配置就搞定了，完全符合开闭原则。职责链模式的实现包含处理器接口（IHandler）或抽象类（Handler），以及处理器链（HandlerChain）。对应到 Servlet Filter，<strong>javax.servlet.Filter 就是处理器接口，FilterChain 就是处理器链</strong>。接下来，我们重点来看 FilterChain 是如何实现的。</p><p>不过，我们前面也讲过，<strong>Servlet 只是一个规范，并不包含具体的实现</strong>，所以，Servlet 中的 FilterChain 只是一个接口定义。具体的实现类由遵从 Servlet 规范的 Web 容器来提供，比如，ApplicationFilterChain 类就是 Tomcat 提供的 FilterChain 的实现类，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationFilterChain</span> <span class="keyword">implements</span> <span class="title">FilterChain</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// 当前执行到了哪个 filter</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n; <span class="comment">// filter 的个数</span></span><br><span class="line">    <span class="keyword">private</span> ApplicationFilterConfig[] filters;</span><br><span class="line">    <span class="keyword">private</span> Servlet servlet;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; n) </span><br><span class="line">        &#123;</span><br><span class="line">            ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">            Filter filter = filterConfig.getFilter();</span><br><span class="line">            filter.doFilter(request, response, <span class="keyword">this</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// filter 都处理完毕后，执行 servlet</span></span><br><span class="line">            servlet.service(request, response);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFilter</span><span class="params">(ApplicationFilterConfig filterConfig)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (ApplicationFilterConfig filter : filters)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (filter == filterConfig)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (n == filters.length) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 扩容</span></span><br><span class="line">            ApplicationFilterConfig[] newFilters = <span class="keyword">new</span> ApplicationFilterConfig[n + INCREMENT];</span><br><span class="line">            System.arraycopy(filters, <span class="number">0</span>, newFilters, <span class="number">0</span>, n);</span><br><span class="line">            filters = newFilters;</span><br><span class="line">        &#125;</span><br><span class="line">        filters[n++] = filterConfig;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ApplicationFilterChain 中的 <strong>doFilter() 函数的代码实现比较有技巧，实际上是一个递归调用</strong>。你可以用每个 Filter 的 doFilter() 的代码实现，直接替换 ApplicationFilterChain 的第 15 行代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest request, ServletResponse response)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pos &lt; n) </span><br><span class="line">    &#123;</span><br><span class="line">        ApplicationFilterConfig filterConfig = filters[pos++];</span><br><span class="line">        Filter filter = filterConfig.getFilter();</span><br><span class="line">        <span class="comment">// filter.doFilter(request, response, this);</span></span><br><span class="line">        <span class="comment">// 把 filter.doFilter 的代码实现展开替换到这里</span></span><br><span class="line">        System.out.println(<span class="string">"拦截客户端发送来的请求"</span>);</span><br><span class="line">        chain.doFilter(request, response); <span class="comment">// chain 就是 this</span></span><br><span class="line">        System.out.println(<span class="string">"拦截发送给客户端的响应"</span>)</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// filter 都处理完毕后，执行 servlet</span></span><br><span class="line">        servlet.service(request, response);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样实现主要是为了在一个 doFilter() 方法中，<strong>支持双向拦截，既能拦截客户端发送来的请求，也能拦截发送给客户端的响应</strong>。</p><h2 id="Spring-Interceptor"><a href="#Spring-Interceptor" class="headerlink" title="Spring Interceptor"></a>Spring Interceptor</h2><p>Spring Interceptor，翻译成中文就是拦截器。尽管英文单词和中文翻译都不同，但和 Servlet Filter 基本上可以看作一个概念，都用来实现对 HTTP 请求进行拦截处理。它们不同之处在于，<strong>Servlet Filter 是 Servlet 规范的一部分，实现依赖于 Web 容器</strong>。<strong>Spring Interceptor 是 Spring MVC 框架的一部分，由 Spring MVC 框架来提供实现</strong>。客户端发送的请求，会先经过 Servlet Filter，然后再经过 Spring Interceptor，最后到达具体的业务代码中。我画了一张图来阐述一个请求的处理流程，具体如下所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/22.png" alt></p><p>LogInterceptor 实现的功能跟刚才的 LogFilter 完全相同，只是实现方式上稍有区别。LogFilter 对请求和响应的拦截是在 doFilter() 一个函数中实现的，而 LogInterceptor <strong>对请求的拦截在 preHandle() 中实现，对响应的拦截在 postHandle() 中实现</strong>：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LogInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截客户端发送来的请求"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// 继续后续的处理</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截发送给客户端的响应"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这里总是被执行"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 Spring MVC 配置文件中配置 interceptors</span></span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;mvc:mapping path=<span class="string">"/*"</span>/&gt;</span><br><span class="line">        &lt;bean <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xzg.cd.LogInterceptor"</span>/&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><p>当然，它也是基于职责链模式实现的。其中，HandlerExecutionChain 类是职责链模式中的处理器链。它的实现<strong>相较于 Tomcat 中的 ApplicationFilterChain 来说，逻辑更加清晰，不需要使用递归来实现</strong>，主要是因为它将请求和响应的拦截工作，拆分到了两个函数中实现。HandlerExecutionChain 的源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptor</span><span class="params">(HandlerInterceptor interceptor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        initInterceptorList().add(interceptor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; interceptors.length; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                <span class="keyword">if</span> (!interceptor.preHandle(request, response, <span class="keyword">this</span>.handler)) </span><br><span class="line">                &#123;</span><br><span class="line">                    triggerAfterCompletion(request, response, <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = interceptors.length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">            &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                interceptor.postHandle(request, response, <span class="keyword">this</span>.handler, mv);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">triggerAfterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Exception ex)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HandlerInterceptor[] interceptors = getInterceptors();</span><br><span class="line">        <span class="keyword">if</span> (!ObjectUtils.isEmpty(interceptors)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="keyword">this</span>.interceptorIndex; i &gt;= <span class="number">0</span>; i--) </span><br><span class="line">            &#123;</span><br><span class="line">                HandlerInterceptor interceptor = interceptors[i];</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    interceptor.afterCompletion(request, response, <span class="keyword">this</span>.handler, ex);</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (Throwable ex2) </span><br><span class="line">                &#123;</span><br><span class="line">                    logger.error(<span class="string">"HandlerInterceptor.afterCompletion threw exception"</span>, ex2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>在 Spring 框架中，通过 DispatcherServlet 的 doDispatch() 方法来分发请求</strong>，它在真正的业务逻辑执行前后，执行 HandlerExecutionChain 中的 applyPreHandle() 和 applyPostHandle() 函数，用来实现拦截的功能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Strategy Design Pattern</title>
      <link href="2020/12/19/Strategy-Design-Pattern/"/>
      <url>2020/12/19/Strategy-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="策略模式的原理与实现"><a href="#策略模式的原理与实现" class="headerlink" title="策略模式的原理与实现"></a>策略模式的原理与实现</h2><p><code>策略模式</code>，英文全称是 Strategy Design Pattern。它是这样定义的：</p><blockquote><p>Define a family of algorithms, encapsulate each one, and make them interchangeable. Strategy lets the algorithm vary independently from clients that use it.</p></blockquote><p>翻译成中文就是：定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端。工厂模式是解耦对象的创建和使用，观察者模式是解耦观察者和被观察者。策略模式跟两者类似，也能起到解耦的作用，不过，它<strong>解耦的是策略的定义、创建、使用</strong>这三部分。</p><h3 id="策略的定义"><a href="#策略的定义" class="headerlink" title="策略的定义"></a>策略的定义</h3><p>策略类的定义比较简单，<strong>包含一个策略接口和一组实现这个接口的策略类</strong>。因为所有的策略类都实现相同的接口，所以，客户端代码基于接口而非实现编程，可以灵活地替换不同的策略。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Strategy</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">algorithmInterface</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyA</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">algorithmInterface</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteStrategyB</span> <span class="keyword">implements</span> <span class="title">Strategy</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span>  <span class="title">algorithmInterface</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 具体的算法...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h3 id="策略的创建"><a href="#策略的创建" class="headerlink" title="策略的创建"></a>策略的创建</h3><p>因为策略模式会包含一组策略，在使用它们的时候，一般会通过类型（type）来判断创建哪个策略来使用。为了封装创建逻辑，我们需要对客户端代码屏蔽创建细节。我们可以<strong>把根据 type 创建策略的逻辑抽离出来，放到工厂类中</strong>。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, Strategy&gt; strategies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        strategies.put(<span class="string">"A"</span>, <span class="keyword">new</span> ConcreteStrategyA());</span><br><span class="line">        strategies.put(<span class="string">"B"</span>, <span class="keyword">new</span> ConcreteStrategyB());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title">getStrategy</span><span class="params">(String type)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"type should not be empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来讲，如果策略类是无状态的，不包含成员变量，只是纯粹的算法实现，这样的策略对象是可以被共享使用的，不需要在每次调用 getStrategy() 的时候，都创建一个新的策略对象。针对这种情况，我们可以<strong>使用上面这种工厂类的实现方式，事先创建好每个策略对象，缓存到工厂类中</strong>，用的时候直接返回。</p><p>相反，<strong>如果策略类是有状态的，根据业务场景的需要，我们希望每次从工厂方法中，获得的都是新创建的策略对象</strong>，而不是缓存好可共享的策略对象，那我们就需要按照如下方式来实现策略工厂类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StrategyFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Strategy <span class="title">getStrategy</span><span class="params">(String type)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"type should not be empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (type.equals(<span class="string">"A"</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteStrategyA();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(<span class="string">"B"</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ConcreteStrategyB();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="策略的使用"><a href="#策略的使用" class="headerlink" title="策略的使用"></a>策略的使用</h3><p>客户端代码运行时动态确定使用哪种策略，这也是策略模式最典型的应用场景。这里的<strong>运行时动态确定</strong>指的是，我们事先并不知道会使用哪个策略，而是在程序运行期间，根据配置、用户输入、计算结果等这些不确定因素，动态决定使用哪种策略：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略接口：EvictionStrategy</span></span><br><span class="line"><span class="comment">// 策略类：LruEvictionStrategy、FifoEvictionStrategy、LfuEvictionStrategy...</span></span><br><span class="line"><span class="comment">// 策略工厂：EvictionStrategyFactory</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserCache</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, User&gt; cacheData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> EvictionStrategy eviction;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserCache</span><span class="params">(EvictionStrategy eviction)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.eviction = eviction;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 运行时动态确定，根据配置文件的配置决定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        EvictionStrategy evictionStrategy = <span class="keyword">null</span>;</span><br><span class="line">        Properties props = <span class="keyword">new</span> Properties();</span><br><span class="line">        props.load(<span class="keyword">new</span> FileInputStream(<span class="string">"./config.properties"</span>));</span><br><span class="line">        String type = props.getProperty(<span class="string">"eviction_type"</span>);</span><br><span class="line">        evictionStrategy = EvictionStrategyFactory.getEvictionStrategy(type);</span><br><span class="line">        UserCache userCache = <span class="keyword">new</span> UserCache(evictionStrategy);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非运行时动态确定，在代码中指定使用哪种策略</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        EvictionStrategy evictionStrategy = <span class="keyword">new</span> LruEvictionStrategy();</span><br><span class="line">        UserCache userCache = <span class="keyword">new</span> UserCache(evictionStrategy);</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们也可以看出，<strong>非运行时动态确定</strong>并不能发挥策略模式的优势。在这种应用场景下，<strong>策略模式实际上退化成了“面向对象的多态特性”或“基于接口而非实现编程原则”</strong>。</p><h2 id="如何利用策略模式避免分支判断？"><a href="#如何利用策略模式避免分支判断？" class="headerlink" title="如何利用策略模式避免分支判断？"></a>如何利用策略模式避免分支判断？</h2><p>我们先通过一个例子来看下，if-else 或 switch-case 分支判断逻辑是如何产生的。在这个例子中，我们没有使用策略模式，而是将策略的定义、创建、使用直接耦合在一起。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">discount</span><span class="params">(Order order)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">        OrderType type = order.getType();</span><br><span class="line">        <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 普通订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 团购订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 促销订单</span></span><br><span class="line">            <span class="comment">//...省略折扣计算算法代码</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> discount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们使用策略模式对上面的代码重构，<strong>将不同类型订单的打折策略设计成策略类，并由工厂类来负责创建策略对象</strong>。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 策略的定义</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DiscountStrategy</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">calDiscount</span><span class="params">(Order order)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略 NormalDiscountStrategy、GrouponDiscountStrategy、PromotionDiscountStrategy 类代码...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的创建</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountStrategyFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;OrderType, DiscountStrategy&gt; strategies = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        strategies.put(OrderType.NORMAL, <span class="keyword">new</span> NormalDiscountStrategy());</span><br><span class="line">        strategies.put(OrderType.GROUPON, <span class="keyword">new</span> GrouponDiscountStrategy());</span><br><span class="line">        strategies.put(OrderType.PROMOTION, <span class="keyword">new</span> PromotionDiscountStrategy());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title">getDiscountStrategy</span><span class="params">(OrderType type)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> strategies.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 策略的使用</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">discount</span><span class="params">(Order order)</span> </span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">        OrderType type = order.getType();</span><br><span class="line">        DiscountStrategy discountStrategy = DiscountStrategyFactory.getDiscountStrategy(type);</span><br><span class="line">        <span class="keyword">return</span> discountStrategy.calDiscount(order);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重构之后的代码就没有了 if-else 分支判断语句了。实际上，这得益于策略工厂类。在工厂类中，我们用 Map 来缓存策略，根据 type 直接从 Map 中获取对应的策略，从而避免 if-else 分支判断逻辑。等后面讲到使用状态模式来避免分支判断逻辑的时候，你会发现，它们使用的是同样的套路。本质上都是借助<code>查表法</code>，<strong>根据 type 查表替代根据 type 分支判断</strong>。</p><p>但是，如果业务场景需要每次都创建不同的策略对象，我们就要用另外一种工厂类的实现方式了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DiscountStrategyFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiscountStrategy <span class="title">getDiscountStrategy</span><span class="params">(OrderType type)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Type should not be null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (type.equals(OrderType.NORMAL)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> NormalDiscountStrategy();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.GROUPON)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> GrouponDiscountStrategy();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (type.equals(OrderType.PROMOTION)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PromotionDiscountStrategy();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种实现方式相当于把原来的 if-else 分支逻辑，从 OrderService 类中转移到了工厂类中，实际上并没有真正将它移除。</p><h2 id="问题与解决思路"><a href="#问题与解决思路" class="headerlink" title="问题与解决思路"></a>问题与解决思路</h2><p>假设有这样一个需求，希望写一个小程序，实现对一个文件进行排序的功能。文件中只包含整型数，并且，相邻的数字通过逗号来区隔。你可能会说，这不是很简单嘛，只需要将文件中的内容读取出来，并且<strong>通过逗号分割成一个一个的数字，放到内存数组中，然后编写某种排序算法</strong>（比如快排），或者直接使用编程语言提供的排序函数，对数组进行排序，最后再将数组中的数据写入文件就可以了。</p><p>但是，如果文件很大呢？比如有 10GB 大小，因为内存有限（比如只有 8GB 大小），我们没办法一次性加载文件中的所有数据到内存中，这个时候，我们就要利用<code>外部排序算法</code>。</p><p>如果文件更大，比如有 100GB 大小，我们为了利用 CPU 多核的优势，可以在外部排序的基础之上进行优化，<strong>加入多线程并发排序的功能，这就有点类似单机版的 MapReduce</strong>。如果文件非常大，比如有 1TB 大小，即便是单机多线程排序，这也算很慢了。这个时候，我们可以<strong>使用真正的 MapReduce 框架，利用多机的处理能力，提高排序的效率</strong>。</p><h2 id="代码实现与分析"><a href="#代码实现与分析" class="headerlink" title="代码实现与分析"></a>代码实现与分析</h2><p>我先用最简单直接的方式将它实现出来。在下面的代码实现中，我只给出了跟设计模式相关的骨架代码，并没有给出每种排序算法的具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> GB = <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略校验逻辑</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">long</span> fileSize = file.length();</span><br><span class="line">        <span class="keyword">if</span> (fileSize &lt; <span class="number">6</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [0, 6GB)</span></span><br><span class="line">            quickSort(filePath);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">10</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [6GB, 10GB)</span></span><br><span class="line">            externalSort(filePath);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">100</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [10GB, 100GB)</span></span><br><span class="line">            concurrentExternalSort(filePath);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [100GB, ~)</span></span><br><span class="line">            mapreduceSort(filePath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 快速排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">externalSort</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 外部排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">concurrentExternalSort</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 多线程外部排序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">mapreduceSort</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 利用 MapReduce 多机排序</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortingTool</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Sorter sorter = <span class="keyword">new</span> Sorter();</span><br><span class="line">        sorter.sortFile(args[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在编码规范那一部分我们讲过，<strong>函数的行数不能过多，最好不要超过一屏的大小</strong>。所以，为了避免 sortFile() 函数过长，我们把每种排序算法从 sortFile() 函数中抽离出来，拆分成 4 个独立的排序函数。</p><p>如果只是开发一个简单的工具，那上面的代码实现就足够了。毕竟，代码不多，后续修改、扩展的需求也不多，怎么写都不会导致代码不可维护。但是，如果我们是在开发一个大型项目，排序文件只是其中的一个功能模块，那我们就要在代码设计、代码质量上下点儿功夫了。<strong>只有每个小的功能模块都写好，整个项目的代码才能不差</strong>。</p><p>在刚刚的代码中，我们并没有给出每种排序算法的代码实现。实际上，如果自己实现一下的话，你会发现，每种排序算法的实现逻辑都比较复杂，代码行数都比较多。所有排序算法的代码实现都堆在 Sorter 一个类中，这就会导致这个类的代码很多。而在编码规范那一部分中，我们也讲到，<strong>一个类的代码太多也会影响到可读性、可维护性</strong>。除此之外，<strong>所有的排序算法都设计成 Sorter 的私有函数，也会影响代码的可复用性</strong>。</p><h2 id="代码优化与重构"><a href="#代码优化与重构" class="headerlink" title="代码优化与重构"></a>代码优化与重构</h2><p>只要掌握了我们之前讲过的设计原则和思想，针对上面的问题，即便我们想不到该用什么设计模式来重构，也应该能知道该如何解决，那就是将 Sorter 类中的某些代码拆分出来，独立成职责更加单一的小类。实际上，<strong>拆分是应对类或者函数代码过多、应对代码复杂性的一个常用手段</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISortAlg</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(String filePath)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">QuickSort</span> <span class="keyword">implements</span> <span class="title">ISortAlg</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExternalSort</span> <span class="keyword">implements</span> <span class="title">ISortAlg</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentExternalSort</span> <span class="keyword">implements</span> <span class="title">ISortAlg</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MapReduceSort</span> <span class="keyword">implements</span> <span class="title">ISortAlg</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> GB = <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略校验逻辑</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">long</span> fileSize = file.length();</span><br><span class="line">        ISortAlg sortAlg;</span><br><span class="line">        <span class="keyword">if</span> (fileSize &lt; <span class="number">6</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [0, 6GB)</span></span><br><span class="line">            sortAlg = <span class="keyword">new</span> QuickSort();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">10</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [6GB, 10GB)</span></span><br><span class="line">            sortAlg = <span class="keyword">new</span> ExternalSort();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">100</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [10GB, 100GB)</span></span><br><span class="line">            sortAlg = <span class="keyword">new</span> ConcurrentExternalSort();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [100GB, ~)</span></span><br><span class="line">            sortAlg = <span class="keyword">new</span> MapReduceSort();</span><br><span class="line">        &#125;</span><br><span class="line">        sortAlg.sort(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，上面的代码还可以继续优化。<strong>每种排序类都是无状态的，我们没必要在每次使用的时候，都重新创建一个新的对象</strong>。所以，我们可以使用工厂模式对对象的创建进行封装：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortAlgFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, ISortAlg&gt; algs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        algs.put(<span class="string">"QuickSort"</span>, <span class="keyword">new</span> QuickSort());</span><br><span class="line">        algs.put(<span class="string">"ExternalSort"</span>, <span class="keyword">new</span> ExternalSort());</span><br><span class="line">        algs.put(<span class="string">"ConcurrentExternalSort"</span>, <span class="keyword">new</span> ConcurrentExternalSort());</span><br><span class="line">        algs.put(<span class="string">"MapReduceSort"</span>, <span class="keyword">new</span> MapReduceSort());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ISortAlg <span class="title">getSortAlg</span><span class="params">(String type)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"type should not be empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> algs.get(type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> GB = <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略校验逻辑</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">long</span> fileSize = file.length();</span><br><span class="line">        ISortAlg sortAlg;</span><br><span class="line">        <span class="keyword">if</span> (fileSize &lt; <span class="number">6</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [0, 6GB)</span></span><br><span class="line">            sortAlg = SortAlgFactory.getSortAlg(<span class="string">"QuickSort"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">10</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [6GB, 10GB)</span></span><br><span class="line">            sortAlg = SortAlgFactory.getSortAlg(<span class="string">"ExternalSort"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fileSize &lt; <span class="number">100</span> * GB) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [10GB, 100GB)</span></span><br><span class="line">            sortAlg = SortAlgFactory.getSortAlg(<span class="string">"ConcurrentExternalSort"</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// [100GB, ~)</span></span><br><span class="line">            sortAlg = SortAlgFactory.getSortAlg(<span class="string">"MapReduceSort"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sortAlg.sort(filePath);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>经过上面两次重构之后，现在的代码实际上已经符合策略模式的代码结构了。我们<strong>通过策略模式将策略的定义、创建、使用解耦，让每一部分都不至于太复杂</strong>。不过，Sorter 类中的 sortFile() 函数还是有一堆 if-else 逻辑。如果你特别想将 if-else 分支判断移除掉，那也是有办法的。实际上，这<strong>也是基于查表法来解决的</strong>，其中的“algs”就是“表”：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sorter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> GB = <span class="number">1000</span> * <span class="number">1000</span> * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;AlgRange&gt; algs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">0</span>, <span class="number">6</span>*GB, SortAlgFactory.getSortAlg(<span class="string">"QuickSort"</span>)));</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">6</span>*GB, <span class="number">10</span>*GB, SortAlgFactory.getSortAlg(<span class="string">"ExternalSort"</span>)));</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">10</span>*GB, <span class="number">100</span>*GB, SortAlgFactory.getSortAlg(<span class="string">"ConcurrentExternalSort"</span>)));</span><br><span class="line">        algs.add(<span class="keyword">new</span> AlgRange(<span class="number">100</span>*GB, Long.MAX_VALUE, SortAlgFactory.getSortAlg(<span class="string">"MapReduceSort"</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sortFile</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略校验逻辑</span></span><br><span class="line">        File file = <span class="keyword">new</span> File(filePath);</span><br><span class="line">        <span class="keyword">long</span> fileSize = file.length();</span><br><span class="line">        ISortAlg sortAlg = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (AlgRange algRange : algs) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (algRange.inRange(fileSize)) </span><br><span class="line">            &#123;</span><br><span class="line">                sortAlg = algRange.getAlg();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        sortAlg.sort(filePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AlgRange</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> start;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">long</span> end;</span><br><span class="line">        <span class="keyword">private</span> ISortAlg alg;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">AlgRange</span><span class="params">(<span class="keyword">long</span> start, <span class="keyword">long</span> end, ISortAlg alg)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.start = start;</span><br><span class="line">            <span class="keyword">this</span>.end = end;</span><br><span class="line">            <span class="keyword">this</span>.alg = alg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ISortAlg <span class="title">getAlg</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> alg;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">inRange</span><span class="params">(<span class="keyword">long</span> size)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> size &gt;= start &amp;&amp; size &lt; end;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在的代码实现就更加优美了。我们把可变的部分隔离到了策略工厂类和 Sorter 类中的静态代码段中。<strong>当要添加一个新的排序算法时，我们只需要修改策略工厂类和 Sort 类中的静态代码段</strong>，其他代码都不需要修改，这样就将代码改动最小化、集中化了。</p><p>对于 Java 语言来说，我们<strong>可以通过反射来避免对策略工厂类的修改</strong>。具体是这么做的：我们通过一个配置文件或者自定义的 annotation 来标注都有哪些策略类；策略工厂类读取配置文件或者搜索被 annotation 标注的策略类，然后通过反射动态地加载这些策略类、创建策略对象；<strong>当我们新添加一个策略的时候，只需要将这个新添加的策略类添加到配置文件或者用 annotation 标注即可</strong>。</p><blockquote><p>设计原则和思想其实比设计模式更加普适和重要，掌握了代码的设计原则和思想，我们甚至可以自己创造出来新的设计模式。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Template Method Design Pattern</title>
      <link href="2020/12/16/Template-Method-Design-Pattern/"/>
      <url>2020/12/16/Template-Method-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="模板模式的原理与实现"><a href="#模板模式的原理与实现" class="headerlink" title="模板模式的原理与实现"></a>模板模式的原理与实现</h2><p><code>模板模式</code>，全称是模板方法设计模式，英文是 Template Method Design Pattern。它是这么定义的：</p><blockquote><p>Define the skeleton of an algorithm in an operation, deferring some steps to subclasses. Template method lets subclasses redefine certain steps of an algorithm without changing the algorithm’s structure.</p></blockquote><p>翻译成中文就是：模板方法模式<strong>在一个方法中定义一个算法骨架，并将某些步骤推迟到子类中实现</strong>。模板方法模式可以让子类在不改变算法整体结构的情况下，重新定义算法中的某些步骤。这里的“算法”，我们<strong>可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”</strong>。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。</p><p>原理很简单，代码实现就更加简单，我写了一个示例代码，templateMethod() 函数<strong>定义为 final，是为了避免子类重写它</strong>。method1() 和 method2() <strong>定义为 abstract，是为了强迫子类去实现</strong>。不过，这些都不是必须的，在实际的项目开发中，模板模式的代码实现比较灵活：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">templateMethod</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        method1();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        method2();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass1</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteClass2</span> <span class="keyword">extends</span> <span class="title">AbstractClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AbstractClass demo = ConcreteClass1();</span><br><span class="line">demo.templateMethod();</span><br></pre></td></tr></table></figure><h2 id="模板模式作用一：复用"><a href="#模板模式作用一：复用" class="headerlink" title="模板模式作用一：复用"></a>模板模式作用一：复用</h2><p>模板模式<strong>把一个算法中不变的流程抽象到父类的模板方法 templateMethod() 中，将可变的部分 method1()、method2() 留给子类 ConcreteClass1 和 ConcreteClass2 来实现</strong>。所有的子类都可以复用父类中模板方法定义的流程代码。</p><h3 id="Java-InputStream"><a href="#Java-InputStream" class="headerlink" title="Java InputStream"></a>Java InputStream</h3><p>在代码中，<strong>read() 函数是一个模板方法，定义了读取数据的整个流程</strong>，并且暴露了一个可以由子类来定制的抽象方法。不过这个方法也被命名为了 read()，只是参数跟模板方法不同：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = read();</span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off] = (<span class="keyword">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) </span><br><span class="line">            &#123;</span><br><span class="line">                c = read();</span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b[off + i] = (<span class="keyword">byte</span>)c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IOException ee) &#123;&#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ByteArrayInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Java-AbstractList"><a href="#Java-AbstractList" class="headerlink" title="Java AbstractList"></a>Java AbstractList</h3><p>在 Java AbstractList 类中，addAll() 函数可以看作模板方法，add() 是子类需要重写的方法，尽管没有声明为 abstract 的，但函数实现<strong>直接抛出了 UnsupportedOperationException 异常</strong>（如果子类不重写是不能使用的）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    rangeCheckForAdd(index);</span><br><span class="line">    <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) </span><br><span class="line">    &#123;</span><br><span class="line">        add(index++, e);</span><br><span class="line">        modified = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> modified;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="模板模式作用二：扩展"><a href="#模板模式作用二：扩展" class="headerlink" title="模板模式作用二：扩展"></a>模板模式作用二：扩展</h2><p>模板模式的第二大作用的是扩展。这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似我们之前讲到的<code>控制反转</code>。基于这个作用，模板模式常用在框架的开发中，<strong>让框架用户可以在不修改框架源码的情况下，定制化框架的功能</strong>。</p><h3 id="Java-Servlet"><a href="#Java-Servlet" class="headerlink" title="Java Servlet"></a>Java Servlet</h3><p>对于 Java Web 项目开发来说，如果我们抛开高级框架来开发 Web 项目，必然会用到 Servlet。实际上，使用比较底层的 Servlet 来开发 Web 项目也不难。我们<strong>只需要定义一个继承 HttpServlet 的类，并且重写其中的 doGet() 或 doPost() 方法</strong>，来分别处理 get 和 post 请求。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.doPost(req, resp);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        resp.getWriter().write(<span class="string">"Hello World."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，我们还需要在配置文件 web.xml 中做如下配置。<strong>Tomcat、Jetty 等 Servlet 容器</strong>在启动的时候，会自动加载这个配置文件中的 URL 和 Servlet 之间的映射关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.xzg.cd.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当我们在浏览器中输入网址的时候，Servlet 容器会接收到相应的请求，并且根据 URL 和 Servlet 之间的映射关系，找到相应的 Servlet（HelloServlet），然后执行它的 service() 方法。service() 方法定义在父类 HttpServlet 中，它会调用 doGet() 或 doPost() 方法，然后输出数据（“Hello world”）到网页。</p><p>我们现在来看，HttpServlet 的 service() 函数长什么样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest req, ServletResponse res)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HttpServletRequest  request;</span><br><span class="line">    HttpServletResponse response;</span><br><span class="line">    <span class="keyword">if</span> (!(req <span class="keyword">instanceof</span> HttpServletRequest &amp;&amp; res <span class="keyword">instanceof</span> HttpServletResponse)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ServletException(<span class="string">"non-HTTP request or response"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    request = (HttpServletRequest) req;</span><br><span class="line">    response = (HttpServletResponse) res;</span><br><span class="line">    service(request, response);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException, IOException</span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String method = req.getMethod();</span><br><span class="line">    <span class="keyword">if</span> (method.equals(METHOD_GET)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        <span class="keyword">if</span> (lastModified == -<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// servlet doesn't support if-modified-since, no reason</span></span><br><span class="line">            <span class="comment">// to go through further expensive logic</span></span><br><span class="line">            doGet(req, resp);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">long</span> ifModifiedSince = req.getDateHeader(HEADER_IFMODSINCE);</span><br><span class="line">            <span class="keyword">if</span> (ifModifiedSince &lt; lastModified) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// If the servlet mod time is later, call doGet()</span></span><br><span class="line">                <span class="comment">// Round down to the nearest second for a proper compare</span></span><br><span class="line">                <span class="comment">// A ifModifiedSince of -1 will always be less</span></span><br><span class="line">                maybeSetLastModified(resp, lastModified);</span><br><span class="line">                doGet(req, resp);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                resp.setStatus(HttpServletResponse.SC_NOT_MODIFIED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_HEAD)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> lastModified = getLastModified(req);</span><br><span class="line">        maybeSetLastModified(resp, lastModified);</span><br><span class="line">        doHead(req, resp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_POST)) </span><br><span class="line">    &#123;</span><br><span class="line">        doPost(req, resp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_PUT)) </span><br><span class="line">    &#123;</span><br><span class="line">        doPut(req, resp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_DELETE)) </span><br><span class="line">    &#123;</span><br><span class="line">        doDelete(req, resp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_OPTIONS)) </span><br><span class="line">    &#123;</span><br><span class="line">        doOptions(req,resp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (method.equals(METHOD_TRACE)) </span><br><span class="line">    &#123;</span><br><span class="line">        doTrace(req,resp);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        String errMsg = lStrings.getString(<span class="string">"http.method_not_implemented"</span>);</span><br><span class="line">        Object[] errArgs = <span class="keyword">new</span> Object[<span class="number">1</span>];</span><br><span class="line">        errArgs[<span class="number">0</span>] = method;</span><br><span class="line">        errMsg = MessageFormat.format(errMsg, errArgs);</span><br><span class="line">        resp.sendError(HttpServletResponse.SC_NOT_IMPLEMENTED, errMsg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中我们可以看出，HttpServlet 的 service() 方法就是一个模板方法，它实现了整个 HTTP 请求的执行流程，doGet()、doPost() 是模板中可以由子类来定制的部分。实际上，这就<strong>相当于 Servlet 框架提供了一个扩展点</strong>，让框架用户在不用修改 Servlet 框架源码的情况下，将业务代码通过扩展点镶嵌到框架中执行。</p><h3 id="JUnit-TestCase"><a href="#JUnit-TestCase" class="headerlink" title="JUnit TestCase"></a>JUnit TestCase</h3><p>在使用 JUnit 测试框架来编写单元测试的时候，我们编写的测试类都要继承框架提供的 TestCase 类。<strong>在 TestCase 类中，runBare() 函数是模板方法，它定义了执行测试用例的整体流程</strong>：先执行 setUp() 做些准备工作，然后执行 runTest() 运行真正的测试代码，最后执行 tearDown() 做扫尾工作。</p><p>尽管 setUp()、tearDown() 并不是抽象函数，还提供了默认的实现，<strong>不强制子类去重新实现，但这部分也是可以在子类中定制的</strong>，所以也符合模板模式的定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> <span class="keyword">extends</span> <span class="title">Assert</span> <span class="keyword">implements</span> <span class="title">Test</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runBare</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Throwable exception = <span class="keyword">null</span>;</span><br><span class="line">        setUp();</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            runTest();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (Throwable running) </span><br><span class="line">        &#123;</span><br><span class="line">            exception = running;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                tearDown();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> (Throwable tearingDown) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (exception == <span class="keyword">null</span>) exception = tearingDown;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (exception != <span class="keyword">null</span>) <span class="keyword">throw</span> exception;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Sets up the fixture, for example, open a network connection.</span></span><br><span class="line"><span class="comment">     * This method is called before a test is executed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Tears down the fixture, for example, close a network connection.</span></span><br><span class="line"><span class="comment">     * This method is called after a test is executed.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回调的原理解析"><a href="#回调的原理解析" class="headerlink" title="回调的原理解析"></a>回调的原理解析</h2><p><strong>相对于普通的函数调用来说，回调是一种双向调用关系</strong>。A 类事先注册某个函数 F 到 B 类，A 类在调用 B 类的 P 函数的时候，B 类反过来调用 A 类注册给它的 F 函数。这里的 F 函数就是回调函数。A 调用 B，B 反过来又调用 A，这种调用机制就叫作<code>回调</code>。</p><p>不同的编程语言，有不同的实现方法。<strong>C 语言可以使用函数指针，Java 则需要使用包裹了回调函数的类对象</strong>，我们简称为回调对象。代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ICallback</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">methodToCallback</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(ICallback callback)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        callback.methodToCallback();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AClass</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BClass b = <span class="keyword">new</span> BClass();</span><br><span class="line">        b.process(<span class="keyword">new</span> ICallback() </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 回调对象</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodToCallback</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"Callback me."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码实现中，我们可以看出，回调跟模板模式一样，也具有复用和扩展的功能。除了回调函数之外，<strong>BClass 类的 process() 函数中的逻辑都可以复用</strong>。如果 ICallback、BClass 类是框架代码，AClass 是使用框架的客户端代码，我们<strong>可以通过 ICallback 定制 process() 函数</strong>，也就是说，框架因此具有了扩展的能力。</p><p>实际上，<strong>回调不仅可以应用在代码设计上，在更高层次的架构设计上也比较常用</strong>。比如，通过三方支付系统来实现支付功能，用户在发起支付请求之后，一般不会一直阻塞到支付结果返回，而是注册回调接口（类似回调函数，一般是一个回调用的 URL）给三方支付系统，等三方支付系统执行完成之后，将结果通过回调接口返回给用户。</p><p>回调可以分为同步回调和异步回调。<strong>同步回调指在函数返回之前执行回调函数；异步回调指的是在函数返回之后执行回调函数</strong>。上面的代码实际上是同步回调的实现方式，在 process() 函数返回之前，执行完回调函数 methodToCallback()。而上面支付的例子是异步回调的实现方式，发起支付之后不需要等待回调接口被调用就直接返回。</p><blockquote><p>从应用场景上来看，同步回调看起来更像模板模式，异步回调看起来更像观察者模式。</p></blockquote><h2 id="应用举例一：JdbcTemplate"><a href="#应用举例一：JdbcTemplate" class="headerlink" title="应用举例一：JdbcTemplate"></a>应用举例一：JdbcTemplate</h2><p>Spring 提供了很多 Template 类，比如，JdbcTemplate、RedisTemplate、RestTemplate。<strong>尽管都叫作 xxxTemplate，但它们并非基于模板模式来实现的</strong>，而是基于回调来实现的，确切地说应该是同步回调。而同步回调从应用场景上很像模板模式，所以，在命名上，这些类使用 Template 这个单词作为后缀。</p><p>Java 提供了 JDBC 类库来封装不同类型的数据库操作。不过，直接使用 JDBC 来编写操作数据库的代码，还是有点复杂的。比如，下面这段是使用 JDBC 来查询用户信息的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUser</span><span class="params">(<span class="keyword">long</span> id)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 1. 加载驱动</span></span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(<span class="string">"jdbc:mysql://localhost:3306/demo"</span>, <span class="string">"xzg"</span>, <span class="string">"xzg"</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 2. 创建 statement 类对象，用来执行 SQL 语句</span></span><br><span class="line">            stmt = conn.createStatement();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 3. ResultSet 类，用来存放获取的结果集</span></span><br><span class="line">            String sql = <span class="string">"select * from user where id="</span> + id;</span><br><span class="line">            ResultSet resultSet = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            String eid = <span class="keyword">null</span>, ename = <span class="keyword">null</span>, price = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (resultSet.next()) </span><br><span class="line">            &#123;</span><br><span class="line">                User user = <span class="keyword">new</span> User();</span><br><span class="line">                user.setId(resultSet.getLong(<span class="string">"id"</span>));</span><br><span class="line">                user.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">                user.setTelephone(resultSet.getString(<span class="string">"telephone"</span>));</span><br><span class="line">                <span class="keyword">return</span> user;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException e) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (SQLException e) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (conn != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    conn.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (stmt != <span class="keyword">null</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    stmt.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (SQLException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> log...</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>queryUser() 函数包含很多流程性质的代码，跟业务无关，比如，加载驱动、创建数据库连接、创建 statement、关闭连接、关闭 statement、处理异常。<strong>针对不同的 SQL 执行请求，这些流程性质的代码是相同的、可以复用的</strong>，我们不需要每次都重新敲一遍。</p><p>针对这个问题，<strong>Spring 提供了 JdbcTemplate，对 JDBC 进一步封装，来简化数据库编程</strong>。使用 JdbcTemplate 查询用户信息，我们只需要编写跟这个业务有关的代码，其中包括，查询用户的 SQL 语句、查询结果与 User 对象之间的映射关系。其他流程性质的代码都封装在了 JdbcTemplate 类中，不需要我们每次都重新编写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> JdbcTemplate jdbcTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryUser</span><span class="params">(<span class="keyword">long</span> id)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String sql = <span class="string">"select * from user where id="</span>+id;</span><br><span class="line">        <span class="keyword">return</span> jdbcTemplate.query(sql, <span class="keyword">new</span> UserRowMapper()).get(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">UserRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">User</span>&gt; </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> User <span class="title">mapRow</span><span class="params">(ResultSet rs, <span class="keyword">int</span> rowNum)</span> <span class="keyword">throws</span> SQLException </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            User user = <span class="keyword">new</span> User();</span><br><span class="line">            user.setId(rs.getLong(<span class="string">"id"</span>));</span><br><span class="line">            user.setName(rs.getString(<span class="string">"name"</span>));</span><br><span class="line">            user.setTelephone(rs.getString(<span class="string">"telephone"</span>));</span><br><span class="line">            <span class="keyword">return</span> user;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们来看一下 JdbcTemplate 的源码。其中，JdbcTemplate 通过回调的机制，<strong>将不变的执行流程抽离出来，放到模板方法 execute() 中，将可变的部分设计成回调 StatementCallback，由用户来定制</strong>。query() 函数是对 execute() 函数的二次封装，让接口用起来更加方便：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">List&lt;T&gt; <span class="title">query</span><span class="params">(String sql, RowMapper&lt;T&gt; rowMapper)</span> <span class="keyword">throws</span> DataAccessException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> query(sql, <span class="keyword">new</span> RowMapperResultSetExtractor&lt;T&gt;(rowMapper));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">query</span><span class="params">(<span class="keyword">final</span> String sql, <span class="keyword">final</span> ResultSetExtractor&lt;T&gt; rse)</span> <span class="keyword">throws</span> DataAccessException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Assert.notNull(sql, <span class="string">"SQL must not be null"</span>);</span><br><span class="line">    Assert.notNull(rse, <span class="string">"ResultSetExtractor must not be null"</span>);</span><br><span class="line">    <span class="keyword">if</span> (logger.isDebugEnabled()) </span><br><span class="line">    &#123;</span><br><span class="line">        logger.debug(<span class="string">"Executing SQL query ["</span> + sql + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">QueryStatementCallback</span> <span class="keyword">implements</span> <span class="title">StatementCallback</span>&lt;<span class="title">T</span>&gt;, <span class="title">SqlProvider</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> T <span class="title">doInStatement</span><span class="params">(Statement stmt)</span> <span class="keyword">throws</span> SQLException </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                rs = stmt.executeQuery(sql);</span><br><span class="line">                ResultSet rsToUse = rs;</span><br><span class="line">                <span class="keyword">if</span> (nativeJdbcExtractor != <span class="keyword">null</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    rsToUse = nativeJdbcExtractor.getNativeResultSet(rs);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> rse.extractData(rsToUse);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">finally</span> </span><br><span class="line">            &#123;</span><br><span class="line">                JdbcUtils.closeResultSet(rs);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getSql</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sql;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> execute(<span class="keyword">new</span> QueryStatementCallback());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">execute</span><span class="params">(StatementCallback&lt;T&gt; action)</span> <span class="keyword">throws</span> DataAccessException </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Assert.notNull(action, <span class="string">"Callback object must not be null"</span>);</span><br><span class="line"></span><br><span class="line">    Connection con = DataSourceUtils.getConnection(getDataSource());</span><br><span class="line">    Statement stmt = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> </span><br><span class="line">    &#123;</span><br><span class="line">        Connection conToUse = con;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nativeJdbcExtractor != <span class="keyword">null</span> &amp;&amp; <span class="keyword">this</span>.nativeJdbcExtractor.isNativeConnectionNecessaryForNativeStatements()) </span><br><span class="line">        &#123;</span><br><span class="line">            conToUse = <span class="keyword">this</span>.nativeJdbcExtractor.getNativeConnection(con);</span><br><span class="line">        &#125;</span><br><span class="line">        stmt = conToUse.createStatement();</span><br><span class="line">        applyStatementSettings(stmt);</span><br><span class="line">        Statement stmtToUse = stmt;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.nativeJdbcExtractor != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            stmtToUse = <span class="keyword">this</span>.nativeJdbcExtractor.getNativeStatement(stmt);</span><br><span class="line">        &#125;</span><br><span class="line">        T result = action.doInStatement(stmtToUse);</span><br><span class="line">        handleWarnings(stmt);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (SQLException ex) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// Release Connection early, to avoid potential connection pool deadlock</span></span><br><span class="line">        <span class="comment">// in the case when the exception translator hasn't been initialized yet.</span></span><br><span class="line">        JdbcUtils.closeStatement(stmt);</span><br><span class="line">        stmt = <span class="keyword">null</span>;</span><br><span class="line">        DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">        con = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">throw</span> getExceptionTranslator().translate(<span class="string">"StatementCallback"</span>, getSql(action), ex);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">finally</span> </span><br><span class="line">    &#123;</span><br><span class="line">        JdbcUtils.closeStatement(stmt);</span><br><span class="line">        DataSourceUtils.releaseConnection(con, getDataSource());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用举例二：setClickListener-）"><a href="#应用举例二：setClickListener-）" class="headerlink" title="应用举例二：setClickListener(）"></a>应用举例二：setClickListener(）</h2><p><strong>在客户端开发中，我们经常给控件注册事件监听器</strong>，比如下面这段代码，就是在 Android 应用开发中，给 Button 控件的点击事件注册监听器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Button button = (Button)findViewById(R.id.button);</span><br><span class="line">button.setOnClickListener(<span class="keyword">new</span> OnClickListener() </span><br><span class="line">&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"I am clicked."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>从代码结构上来看，事件监听器很像回调，即传递一个包含回调函数（onClick()）的对象给另一个函数。从应用场景上来看，它又很像观察者模式，即事先注册观察者（OnClickListener），当用户点击按钮的时候，发送点击事件给观察者，并且执行相应的 onClick() 函数。<strong>这里的回调算是异步回调，我们往 setOnClickListener() 函数中注册好回调函数之后，并不需要等待回调函数执行</strong>。</p><h2 id="应用举例三：addShutdownHook"><a href="#应用举例三：addShutdownHook" class="headerlink" title="应用举例三：addShutdownHook()"></a>应用举例三：addShutdownHook()</h2><p>Hook 是 Callback 的一种应用。<strong>Callback 更侧重语法机制的描述，Hook 更加侧重应用场景的描述</strong>。Hook 比较经典的应用场景是 Tomcat 和 JVM 的 shutdown hook。JVM 提供了 Runtime.addShutdownHook(Thread hook) 方法，可以注册一个 JVM 关闭的 Hook。当应用程序关闭的时候，JVM 会自动调用 Hook 代码。代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHookDemo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ShutdownHook</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"I am called during shutting down."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> ShutdownHook());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再来看 addShutdownHook() 的代码实现，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Runtime</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addShutdownHook</span><span class="params">(Thread hook)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SecurityManager sm = System.getSecurityManager();</span><br><span class="line">        <span class="keyword">if</span> (sm != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            sm.checkPermission(<span class="keyword">new</span> RuntimePermission(<span class="string">"shutdownHooks"</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        ApplicationShutdownHooks.add(hook);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ApplicationShutdownHooks</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">/* The set of registered hooks */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdentityHashMap&lt;Thread, Thread&gt; hooks;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">        &#123;</span><br><span class="line">            hooks = <span class="keyword">new</span> IdentityHashMap&lt;&gt;();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (IllegalStateException e) </span><br><span class="line">        &#123;</span><br><span class="line">            hooks = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Thread hook)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(hooks == <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Shutdown in progress"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hook.isAlive())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Hook already running"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hooks.containsKey(hook))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Hook previously registered"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        hooks.put(hook, hook);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runHooks</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Collection&lt;Thread&gt; threads;</span><br><span class="line">        <span class="keyword">synchronized</span>(ApplicationShutdownHooks<span class="class">.<span class="keyword">class</span>) </span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            threads = hooks.keySet();</span><br><span class="line">            hooks = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Thread hook : threads) </span><br><span class="line">        &#123;</span><br><span class="line">            hook.start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (Thread hook : threads) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (<span class="keyword">true</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    hook.join();</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (InterruptedException ignored) &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中我们可以发现，有关 Hook 的逻辑都被封装到 ApplicationShutdownHooks 类中了。当应用程序关闭的时候，JVM 会调用这个类的 runHooks() 方法，创建多个线程，并发地执行多个 Hook。<strong>我们在注册完 Hook 之后，并不需要等待 Hook 执行完成</strong>，所以，这也算是一种异步回调。</p><h2 id="模板模式-vs-回调"><a href="#模板模式-vs-回调" class="headerlink" title="模板模式 vs. 回调"></a>模板模式 vs. 回调</h2><p>接下来，我们从应用场景和代码实现两个角度，来对比一下模板模式和回调。</p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><p>从应用场景上来看，<strong>同步回调跟模板模式几乎一致</strong>。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而<strong>异步回调跟模板模式有较大差别，更像是观察者模式</strong>。</p><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>从代码实现上来看，回调和模板模式完全不同。<strong>回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系</strong>；<strong>模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系</strong>。</p><p>组合优于继承，这里也不例外。在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点：</p><ul><li>像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，<strong>不再具有继承的能力</strong>；</li><li>回调可以使用匿名类来创建回调对象，<strong>可以不用事先定义类</strong>；而模板模式针对不同的实现都要定义不同的子类；</li><li>如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们<strong>只需要往用到的模板方法中注入回调对象即可</strong>；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Observer Design Pattern</title>
      <link href="2020/12/13/Observer-Design-Pattern/"/>
      <url>2020/12/13/Observer-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="原理及应用场景剖析"><a href="#原理及应用场景剖析" class="headerlink" title="原理及应用场景剖析"></a>原理及应用场景剖析</h2><p><code>观察者模式</code>（Observer Design Pattern）的定义是这样的：</p><blockquote><p>Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.</p></blockquote><p>翻译成中文就是：在对象之间定义一个一对多的依赖，<strong>当一个对象状态改变的时候，所有依赖的对象都会自动收到通知</strong>。</p><p>一般情况下，被依赖的对象叫作<code>被观察者</code>（Observable），依赖的对象叫作<code>观察者</code>（Observer）。不过，在实际的项目开发中，这两种对象的称呼是比较灵活的，有各种不同的叫法，比如：Subject-Observer、Publisher-Subscriber、Producer-Consumer、EventEmitter-EventListener、Dispatcher-Listener。不管怎么称呼，只要应用场景符合刚刚给出的定义，都可以看作观察者模式。</p><p>实际上，观察者模式是一个比较抽象的模式，根据不同的应用场景和需求，有完全不同的实现方式。现在，我们先来看其中最经典的一种实现方式：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Subject</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">implements</span> <span class="title">Subject</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; observers = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerObserver</span><span class="params">(Observer observer)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.add(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(Observer observer)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        observers.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyObservers</span><span class="params">(Message message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Observer observer : observers) </span><br><span class="line">        &#123;</span><br><span class="line">            observer.update(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverOne</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">        System.out.println(<span class="string">"ConcreteObserverOne is notified."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserverTwo</span> <span class="keyword">implements</span> <span class="title">Observer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(Message message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 获取消息通知，执行自己的逻辑...</span></span><br><span class="line">        System.out.println(<span class="string">"ConcreteObserverTwo is notified."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> ConcreteObserverOne());</span><br><span class="line">        subject.registerObserver(<span class="keyword">new</span> ConcreteObserverTwo());</span><br><span class="line">        subject.notifyObservers(<span class="keyword">new</span> Message());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，上面的代码算是观察者模式的<code>模板代码</code>，只能反映大体的设计思路。<strong>在真实的软件开发中，并不需要照搬上面的模板代码</strong>。观察者模式的实现方法各式各样，函数、类的命名等会根据业务场景的不同有很大的差别，比如 register 函数还可以叫作 attach，remove 函数还可以叫作 detach 等等。不过，万变不离其宗，设计思路都是差不多的。</p><p>假设我们在开发一个 P2P 投资理财系统，用户注册成功之后，我们会给用户发放投资体验金。代码实现大致是下面这个样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略输入参数的校验代码</span></span><br><span class="line">        <span class="comment">// 省略 userService.register() 异常的 try-catch 代码</span></span><br><span class="line">        <span class="keyword">long</span> userId = userService.register(telephone, password);</span><br><span class="line">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然注册接口做了两件事情，注册和发放体验金，违反单一职责原则，但是，<strong>如果没有扩展和修改的需求，现在的代码实现是可以接受的</strong>。相反，如果需求频繁变动，比如，用户注册成功之后，不再发放体验金，而是改为发放优惠券，并且还要给用户发送一封“欢迎注册成功”的站内信。这种情况下，我们就需要频繁地修改 register() 函数中的代码，违反开闭原则。而且，如果注册成功之后需要执行的后续操作越来越多，那 register() 函数的逻辑会变得越来越复杂，也就影响到代码的可读性和可维护性。利用观察者模式，我对上面的代码进行了重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RegObserver</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(<span class="keyword">long</span> userId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title">RegObserver</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(<span class="keyword">long</span> userId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegNotificationObserver</span> <span class="keyword">implements</span> <span class="title">RegObserver</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(<span class="keyword">long</span> userId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notificationService.sendInboxMessage(userId, <span class="string">"Welcome..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一次性设置好，之后也不可能动态的修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        regObservers.addAll(observers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略输入参数的校验代码</span></span><br><span class="line">        <span class="comment">// 省略 userService.register() 异常的 try-catch 代码</span></span><br><span class="line">        <span class="keyword">long</span> userId = userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RegObserver observer : regObservers) </span><br><span class="line">        &#123;</span><br><span class="line">            observer.handleRegSuccess(userId);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们需要添加新的观察者的时候，比如，用户注册成功之后，推送用户注册信息给大数据征信系统，基于观察者模式的代码实现，<strong>UserController 类的 register() 函数完全不需要修改</strong>，只需要再添加一个实现了 RegObserver 接口的类，并且通过 setRegObservers() 函数将它注册到 UserController 类中即可。</p><p>不过，你可能会说，当我们把发送体验金替换为发送优惠券的时候，需要修改 RegPromotionObserver 类中 handleRegSuccess() 函数的代码，这还是违反开闭原则呀？你说得没错，不过，<strong>相对于 register() 函数来说，handleRegSuccess() 函数的逻辑要简单很多</strong>，修改更不容易出错，引入 bug 的风险更低。</p><p>实际上，设计模式要干的事情就是<code>解耦</code>。<strong>创建型模式是将创建和使用代码解耦，结构型模式是将不同功能代码解耦，行为型模式是将不同的行为代码解耦</strong>，具体到观察者模式，它是将观察者和被观察者代码解耦。借助设计模式，我们利用更好的代码结构，将一大坨代码拆分成职责更单一的小类，让其满足开闭原则、高内聚松耦合等特性，以此来控制和应对代码的复杂性，提高代码的可扩展性。</p><h2 id="基于不同应用场景的不同实现方式"><a href="#基于不同应用场景的不同实现方式" class="headerlink" title="基于不同应用场景的不同实现方式"></a>基于不同应用场景的不同实现方式</h2><p>观察者模式的应用场景非常广泛，小到代码层面的解耦，大到架构层面的系统解耦，再或者一些产品的设计思路，都有这种模式的影子，比如，邮件订阅、RSS Feeds，本质上都是观察者模式。<strong>不同的应用场景和需求下，这个模式也有截然不同的实现方式</strong>，有同步阻塞的实现方式，也有异步非阻塞的实现方式；有进程内的实现方式，也有跨进程的实现方式。</p><p>之前讲到的实现方式是一种同步阻塞的实现方式。观察者和被观察者代码在同一个线程内执行，<strong>被观察者一直阻塞，直到所有的观察者代码都执行完成之后，才执行后续的代码</strong>。对照上面讲到的用户注册的例子，register() 函数依次调用执行每个观察者的 handleRegSuccess() 函数，等到都执行完成之后，才会返回结果给客户端。</p><p>如果注册接口是一个调用比较频繁的接口，对性能非常敏感，希望接口的响应时间尽可能短，那我们可以<strong>将同步阻塞的实现方式改为异步非阻塞的实现方式，以此来减少响应时间</strong>。具体来讲，当 userService.register() 函数执行完成之后，我们启动一个新的线程来执行观察者的 handleRegSuccess() 函数，这样 userController.register() 函数就不需要等到所有的 handleRegSuccess() 函数都执行完成之后才返回结果给客户端。</p><p>userController.register() 函数从执行 3 个 SQL 语句才返回，减少到只需要执行 1 个 SQL 语句就返回，响应时间粗略来讲减少为原来的 1/3。不过，我们还有更加优雅的实现方式，那就是基于 <code>EventBus</code> 来实现。它可以复用在任何需要异步非阻塞观察者模式的应用场景中。</p><p>刚刚讲到的两个场景，都是进程内的实现方式。如果用户注册成功之后，我们需要发送用户信息给大数据征信系统，而<strong>大数据征信系统是一个独立的系统，跟它之间的交互是跨不同进程的</strong>，那如何实现一个跨进程的观察者模式呢？如果大数据征信系统提供了发送用户注册信息的 RPC 接口，我们仍然可以沿用之前的实现思路，在 handleRegSuccess() 函数中调用 RPC 接口来发送数据。但是，我们还有更加优雅、更加常用的一种实现方式，那就是基于<code>消息队列</code>（比如 ActiveMQ）来实现。</p><p>当然，这种实现方式也有弊端，那就是需要引入一个新的系统（消息队列），增加了维护成本。不过，它的好处也非常明显。在原来的实现方式中，观察者需要注册到被观察者中，被观察者需要依次遍历观察者来发送消息。而<strong>基于消息队列的实现方式，被观察者和观察者解耦更加彻底，两部分的耦合更小</strong>。被观察者完全不感知观察者，同理，观察者也完全不感知被观察者。被观察者只管发送消息到消息队列，观察者只管从消息队列中读取消息来执行相应的逻辑。</p><h2 id="异步非阻塞观察者模式的简易实现"><a href="#异步非阻塞观察者模式的简易实现" class="headerlink" title="异步非阻塞观察者模式的简易实现"></a>异步非阻塞观察者模式的简易实现</h2><p>我们有两种实现方式。其中一种是：在每个 handleRegSuccess() 函数中创建一个新的线程执行代码逻辑；另一种是：在 UserController 的 register() 函数中使用<code>线程池</code>来执行每个观察者的 handleRegSuccess() 函数。两种实现方式的具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegPromotionObserver</span> <span class="keyword">implements</span> <span class="title">RegObserver</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(Long userId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式，其他类代码不变，就没有再重复罗列</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;RegObserver&gt; regObservers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">(Executor executor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegObservers</span><span class="params">(List&lt;RegObserver&gt; observers)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        regObservers.addAll(observers);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略输入参数的校验代码</span></span><br><span class="line">        <span class="comment">// 省略 userService.register() 异常的 try-catch 代码</span></span><br><span class="line">        <span class="keyword">long</span> userId = userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (RegObserver observer : regObservers) </span><br><span class="line">        &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    observer.handleRegSuccess(userId);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于第一种实现方式，<strong>频繁地创建和销毁线程比较耗时，并且并发线程数无法控制，创建过多的线程会导致堆栈溢出</strong>。第二种实现方式，尽管利用了线程池解决了第一种实现方式的问题，但<strong>线程池、异步执行逻辑都耦合在了 register() 函数中，增加了这部分业务代码的维护成本</strong>。</p><p>我们知道，框架的作用有：<strong>隐藏实现细节，降低开发难度，做到代码复用，解耦业务与非业务代码，让程序员聚焦业务开发</strong>。针对异步非阻塞观察者模式，我们也可以将它抽象成框架来达到这样的效果。</p><h2 id="EventBus-框架功能需求介绍"><a href="#EventBus-框架功能需求介绍" class="headerlink" title="EventBus 框架功能需求介绍"></a>EventBus 框架功能需求介绍</h2><p>EventBus 翻译为“事件总线”，它提供了实现观察者模式的骨架代码。我们可以基于此框架，非常容易地在自己的业务场景中实现观察者模式，不需要从零开始开发。其中，Google Guava EventBus 就是一个比较著名的 EventBus 框架，它<strong>不仅仅支持异步非阻塞模式，同时也支持同步阻塞模式</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> EventBus eventBus;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENTBUS_THREAD_POOL_SIZE = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserController</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// eventBus = new EventBus(); // 同步阻塞模式</span></span><br><span class="line">        eventBus = <span class="keyword">new</span> AsyncEventBus(Executors.newFixedThreadPool(DEFAULT_EVENTBUS_THREAD_POOL_SIZE)); <span class="comment">// 异步非阻塞模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setRegObservers</span><span class="params">(List&lt;Object&gt; observers)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (Object observer : observers) </span><br><span class="line">        &#123;</span><br><span class="line">            eventBus.register(observer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">register</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 省略输入参数的校验代码</span></span><br><span class="line">        <span class="comment">// 省略 userService.register() 异常的 try-catch 代码</span></span><br><span class="line">        <span class="keyword">long</span> userId = userService.register(telephone, password);</span><br><span class="line"></span><br><span class="line">        eventBus.post(userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegPromotionObserver</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> PromotionService promotionService; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(Long userId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        promotionService.issueNewUserExperienceCash(userId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RegNotificationObserver</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NotificationService notificationService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRegSuccess</span><span class="params">(Long userId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        notificationService.sendInboxMessage(userId, <span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用 EventBus 框架实现的观察者模式，跟从零开始编写的观察者模式相比，从大的流程上来说，实现思路大致一样，<strong>都需要定义 Observer，并且通过 register() 函数注册 Observer</strong>，也都需要通过调用某个函数（比如，EventBus 中的 post() 函数）来给 Observer 发送消息。</p><p>但在实现细节方面，它们又有些区别。基于 EventBus，我们不需要定义 Observer 接口，任意类型的对象都可以注册到 EventBus 中，<strong>通过 @Subscribe 注解来标明类中哪个函数可以接收被观察者发送的消息</strong>。</p><h3 id="EventBus、AsyncEventBus"><a href="#EventBus、AsyncEventBus" class="headerlink" title="EventBus、AsyncEventBus"></a>EventBus、AsyncEventBus</h3><p>Guava EventBus <strong>对外暴露的所有可调用接口，都封装在 EventBus 类中</strong>。其中，EventBus 实现了同步阻塞的观察者模式，AsyncEventBus 继承自 EventBus，提供了异步非阻塞的观察者模式。具体使用方式如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EventBus eventBus = <span class="keyword">new</span> EventBus(); <span class="comment">// 同步阻塞模式</span></span><br><span class="line">EventBus eventBus = <span class="keyword">new</span> AsyncEventBus(Executors.newFixedThreadPool(<span class="number">8</span>))；<span class="comment">// 异步阻塞模式</span></span><br></pre></td></tr></table></figure><h3 id="register-函数"><a href="#register-函数" class="headerlink" title="register() 函数"></a>register() 函数</h3><p>EventBus 类提供了 register() 函数用来注册观察者。它<strong>可以接受任何类型的观察者</strong>。而在经典的观察者模式的实现中，register() 函数必须接受实现了同一 Observer 接口的类对象。具体的函数定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="unregister-函数"><a href="#unregister-函数" class="headerlink" title="unregister() 函数"></a>unregister() 函数</h3><p>相对于 register() 函数，unregister() 函数用来从 EventBus 中删除某个观察者。具体的函数定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object object)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="post-函数"><a href="#post-函数" class="headerlink" title="post() 函数"></a>post() 函数</h3><p>EventBus 类提供了 post() 函数，<strong>用来给观察者发送消息</strong>。具体的函数定义如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span></span>;</span><br></pre></td></tr></table></figure><p>跟经典的观察者模式的不同之处在于，当我们调用 post() 函数发送消息的时候，并非把消息发送给所有的观察者，而是<strong>发送给可匹配的观察者</strong>。所谓可匹配指的是，能接收的消息类型是发送消息（post 函数定义中的 event）类型的父类。比如，AObserver 能接收的消息类型是 XMsg，BObserver 能接收的消息类型是 YMsg，CObserver 能接收的消息类型是 ZMsg。其中，XMsg 是 YMsg 的父类。当我们如下发送消息的时候，相应能接收到消息的可匹配观察者如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">XMsg xMsg = <span class="keyword">new</span> XMsg();</span><br><span class="line">YMsg yMsg = <span class="keyword">new</span> YMsg();</span><br><span class="line">ZMsg zMsg = <span class="keyword">new</span> ZMsg();</span><br><span class="line">post(xMsg); =&gt; AObserver 接收到消息</span><br><span class="line">post(yMsg); =&gt; AObserver、BObserver 接收到消息</span><br><span class="line">post(zMsg); =&gt; CObserver 接收到消息</span><br></pre></td></tr></table></figure><h3 id="Subscribe-注解"><a href="#Subscribe-注解" class="headerlink" title="@Subscribe 注解"></a>@Subscribe 注解</h3><p>EventBus <strong>通过 @Subscribe 注解来标明，某个函数能接收哪种类型的消息</strong>。在 DObserver 类中，我们通过 @Subscribe 注解了两个函数 f1()、f2()。具体的使用代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DObserver </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(PMsg event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Subscribe</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">(QMsg event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当通过 register() 函数将 DObserver 类对象注册到 EventBus 的时候，EventBus 会根据 @Subscribe 注解找到 f1() 和 f2()，并且<strong>将两个函数能接收的消息类型记录下来（PMsg-&gt;f1, QMsg-&gt;f2）</strong>。当我们通过 post() 函数发送消息（比如 QMsg 消息）的时候，EventBus 会通过之前的记录（QMsg-&gt;f2），调用相应的函数（f2）。</p><h2 id="手把手实现一个-EventBus-框架"><a href="#手把手实现一个-EventBus-框架" class="headerlink" title="手把手实现一个 EventBus 框架"></a>手把手实现一个 EventBus 框架</h2><p>我们重点来看，EventBus 中两个核心函数 <code>register()</code> 和 <code>post()</code> 的实现原理。弄懂了它们，基本上就弄懂了整个 EventBus 框架。下面两张图是这两个函数的实现原理图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/19.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/20.png" alt></p><p>从图中我们可以看出，<strong>最关键的一个数据结构是 Observer 注册表，记录了消息类型和可接收消息函数的对应关系</strong>。当调用 register() 函数注册观察者的时候，EventBus 通过解析 @Subscribe 注解，生成 Observer 注册表。当调用 post() 函数发送消息的时候，EventBus 通过注册表找到相应的可接收消息的函数，然后通过 Java 的<code>反射语法</code>来动态地创建对象、执行函数。<strong>对于同步阻塞模式，EventBus 在一个线程内依次执行相应的函数。对于异步非阻塞模式，EventBus 通过一个线程池来执行相应的函数</strong>。</p><h3 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h3><p>Subscribe 是一个注解，用于标明观察者中的哪个函数可以接收消息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Beta</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Subscribe &#123;&#125;</span><br></pre></td></tr></table></figure><h3 id="ObserverAction"><a href="#ObserverAction" class="headerlink" title="ObserverAction"></a>ObserverAction</h3><p>ObserverAction 类用来表示 @Subscribe 注解的方法，其中，<strong>target 表示观察者类，method 表示方法</strong>。它主要用在 ObserverRegistry 观察者注册表中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverAction</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="keyword">private</span> Method method;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ObserverAction</span><span class="params">(Object target, Method method)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = Preconditions.checkNotNull(target);</span><br><span class="line">        <span class="keyword">this</span>.method = method;</span><br><span class="line">        <span class="keyword">this</span>.method.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Object event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// event 是 method 方法的参数</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            method.invoke(target, event);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (InvocationTargetException | IllegalAccessException e) </span><br><span class="line">        &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ObserverRegistry"><a href="#ObserverRegistry" class="headerlink" title="ObserverRegistry"></a>ObserverRegistry</h3><p>ObserverRegistry 类就是前面讲到的 Observer 注册表，是最复杂的一个类，<strong>框架中几乎所有的核心逻辑都在这个类中</strong>。这个类大量使用了 Java 的反射语法，不过代码整体来说都不难理解，其中，一个比较有技巧的地方是 <code>CopyOnWriteArraySet</code> 的使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverRegistry</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentMap&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; registry = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object observer)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = findAllObserverActions(observer);</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; entry : observerActions.entrySet()) </span><br><span class="line">        &#123;</span><br><span class="line">            Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">            Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">            CopyOnWriteArraySet&lt;ObserverAction&gt; registeredEventActions = registry.get(eventType);</span><br><span class="line">            <span class="keyword">if</span> (registeredEventActions == <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                registry.putIfAbsent(eventType, <span class="keyword">new</span> CopyOnWriteArraySet&lt;&gt;());</span><br><span class="line">                registeredEventActions = registry.get(eventType);</span><br><span class="line">            &#125;</span><br><span class="line">            registeredEventActions.addAll(eventActions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ObserverAction&gt; <span class="title">getMatchedObserverActions</span><span class="params">(Object event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ObserverAction&gt; matchedObservers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; postedEventType = event.getClass();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, CopyOnWriteArraySet&lt;ObserverAction&gt;&gt; entry : registry.entrySet()) </span><br><span class="line">        &#123;</span><br><span class="line">            Class&lt;?&gt; eventType = entry.getKey();</span><br><span class="line">            Collection&lt;ObserverAction&gt; eventActions = entry.getValue();</span><br><span class="line">            <span class="keyword">if</span> (postedEventType.isAssignableFrom(eventType)) </span><br><span class="line">            &#123;</span><br><span class="line">                matchedObservers.addAll(eventActions);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> matchedObservers;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; findAllObserverActions(Object observer) </span><br><span class="line">    &#123;</span><br><span class="line">        Map&lt;Class&lt;?&gt;, Collection&lt;ObserverAction&gt;&gt; observerActions = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Class&lt;?&gt; clazz = observer.getClass();</span><br><span class="line">        <span class="keyword">for</span> (Method method : getAnnotatedMethods(clazz)) </span><br><span class="line">        &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">if</span> (!observerActions.containsKey(eventType)) </span><br><span class="line">            &#123;</span><br><span class="line">                observerActions.put(eventType, <span class="keyword">new</span> ArrayList&lt;&gt;());</span><br><span class="line">            &#125;</span><br><span class="line">            observerActions.get(eventType).add(<span class="keyword">new</span> ObserverAction(observer, method));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> observerActions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;Method&gt; <span class="title">getAnnotatedMethods</span><span class="params">(Class&lt;?&gt; clazz)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Method&gt; annotatedMethods = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Method method : clazz.getDeclaredMethods()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (method.isAnnotationPresent(Subscribe<span class="class">.<span class="keyword">class</span>)) </span></span><br><span class="line"><span class="class">            </span>&#123;</span><br><span class="line">                Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">                Preconditions.checkArgument(parameterTypes.length == <span class="number">1</span>, <span class="string">"Method %s has @Subscribe annotation but has %s parameters."</span> + <span class="string">"Subscriber methods must have exactly 1 parameter."</span>, method, parameterTypes.length);</span><br><span class="line">                annotatedMethods.add(method);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> annotatedMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="EventBus"><a href="#EventBus" class="headerlink" title="EventBus"></a>EventBus</h3><p>EventBus 实现的是阻塞同步的观察者模式。看代码你可能会有些疑问，这明明就用到了线程池 Executor 啊。实际上，MoreExecutors.directExecutor() 是 Google Guava 提供的工具类，看似是多线程，实际上是单线程。之所以要这么实现，主要还是<strong>为了跟 AsyncEventBus 统一代码逻辑，做到代码复用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EventBus</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Executor executor;</span><br><span class="line">    <span class="keyword">private</span> ObserverRegistry registry = <span class="keyword">new</span> ObserverRegistry();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(MoreExecutors.directExecutor());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">EventBus</span><span class="params">(Executor executor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.executor = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object object)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        registry.register(object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;ObserverAction&gt; observerActions = registry.getMatchedObserverActions(event);</span><br><span class="line">        <span class="keyword">for</span> (ObserverAction observerAction : observerActions) </span><br><span class="line">        &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">                </span>&#123;</span><br><span class="line">                    observerAction.execute(event);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AsyncEventBus"><a href="#AsyncEventBus" class="headerlink" title="AsyncEventBus"></a>AsyncEventBus</h3><p>有了 EventBus，AsyncEventBus 的实现就非常简单了。只是需要在构造函数中，由调用者注入线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncEventBus</span> <span class="keyword">extends</span> <span class="title">EventBus</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AsyncEventBus</span><span class="params">(Executor executor)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(executor);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，我们用了不到 200 行代码，就实现了一个还算凑活能用的 EventBus，从功能上来讲，它跟 Google Guava EventBus 几乎一样。很多人觉得做业务开发没有技术挑战，实际上，做业务开发也会涉及很多非业务功能的开发，比如今天讲到的 EventBus。在平时的业务开发中，我们要<strong>善于抽象这些非业务的、可复用的功能，并积极地把它们实现成通用的框架</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Flyweight Design Pattern</title>
      <link href="2020/12/09/Flyweight-Design-Pattern/"/>
      <url>2020/12/09/Flyweight-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="享元模式原理与实现"><a href="#享元模式原理与实现" class="headerlink" title="享元模式原理与实现"></a>享元模式原理与实现</h2><p>所谓<code>享元</code>，顾名思义就是被共享的单元。享元模式的意图是<strong>复用对象，节省内存，前提是享元对象是不可变对象</strong>。</p><p>具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，<strong>对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元</strong>，让这些大量相似对象引用这些享元。</p><p>这里我稍微解释一下，定义中的<code>不可变对象</code>指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，<strong>不可变对象不能暴露任何 set() 等修改内部状态的方法</strong>。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。</p><p>假设我们在开发一个棋牌游戏（比如象棋）。一个游戏厅中有成千上万个“房间”，每个房间对应一个棋局。棋局要保存每个棋子的数据，比如：棋子类型（将、相、士、炮等）、棋子颜色（红方、黑方）、棋子在棋局中的位置。利用这些数据，我们就能显示一个完整的棋盘给玩家。其中，ChessPiece 类表示棋子，ChessBoard 类表示一个棋局，里面保存了象棋中 30 个棋子的信息：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPiece</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 棋子</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPiece</span><span class="params">(<span class="keyword">int</span> id, String text, Color color, <span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">        <span class="keyword">this</span>.positionX = positionX;</span><br><span class="line">        <span class="keyword">this</span>.positionY = positionX;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Color </span><br><span class="line">    &#123;</span><br><span class="line">        RED, BLACK</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略其他属性和 getter/setter 方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessBoard</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 棋局</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessBoard</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPiece(<span class="number">1</span>, <span class="string">"車"</span>, ChessPiece.Color.BLACK, <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        chessPieces.put(<span class="number">2</span>, <span class="keyword">new</span> ChessPiece(<span class="number">2</span>, <span class="string">"馬"</span>, ChessPiece.Color.BLACK, <span class="number">0</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> chessPieceId, <span class="keyword">int</span> toPositionX, <span class="keyword">int</span> toPositionY)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了记录每个房间当前的棋局情况，我们需要给每个房间都创建一个 ChessBoard 棋局对象。因为游戏大厅中有成千上万的房间，那<strong>保存这么多棋局对象就会消耗大量的内存</strong>。</p><p>像刚刚的实现方式，在内存中会有大量的相似对象。这些相似对象的 id、text、color 都是相同的，唯独 positionX、positionY 不同。实际上，我们可以<strong>将棋子的 id、text、color 属性拆分出来，设计成独立的类</strong>，并且作为享元供多个棋盘复用。这样，棋盘只需要记录每个棋子的位置信息就可以了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnit</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String text;</span><br><span class="line">    <span class="keyword">private</span> Color color;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPieceUnit</span><span class="params">(<span class="keyword">int</span> id, String text, Color color)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.text = text;</span><br><span class="line">        <span class="keyword">this</span>.color = color;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Color </span><br><span class="line">    &#123;</span><br><span class="line">        RED, BLACK</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略其他属性和 getter 方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPieceUnitFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Integer, ChessPieceUnit&gt; pieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        pieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">1</span>, <span class="string">"車"</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        pieces.put(<span class="number">2</span>, <span class="keyword">new</span> ChessPieceUnit(<span class="number">2</span>, <span class="string">"馬"</span>, ChessPieceUnit.Color.BLACK));</span><br><span class="line">        <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ChessPieceUnit <span class="title">getChessPiece</span><span class="params">(<span class="keyword">int</span> chessPieceId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pieces.get(chessPieceId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessPiece</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ChessPieceUnit chessPieceUnit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionX;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> positionY;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessPiece</span><span class="params">(ChessPieceUnit unit, <span class="keyword">int</span> positionX, <span class="keyword">int</span> positionY)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.chessPieceUnit = unit;</span><br><span class="line">        <span class="keyword">this</span>.positionX = positionX;</span><br><span class="line">        <span class="keyword">this</span>.positionY = positionY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略 getter、setter 方法</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ChessBoard</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;Integer, ChessPiece&gt; chessPieces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ChessBoard</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPiece(ChessPieceUnitFactory.getChessPiece(<span class="number">1</span>), <span class="number">0</span>, <span class="number">0</span>));</span><br><span class="line">        chessPieces.put(<span class="number">1</span>, <span class="keyword">new</span> ChessPiece(ChessPieceUnitFactory.getChessPiece(<span class="number">2</span>), <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="comment">//...省略摆放其他棋子的代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> chessPieceId, <span class="keyword">int</span> toPositionX, <span class="keyword">int</span> toPositionY)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，我们利用工厂类来缓存 ChessPieceUnit 信息（也就是 id、text、color）。通过工厂类获取到的 ChessPieceUnit 就是享元。所有的 ChessBoard 对象共享这 30 个 ChessPieceUnit 对象。在使用享元模式之前，记录 1 万个棋局，我们要创建 30 万个棋子的 ChessPieceUnit 对象。利用享元模式，我们只需要创建 30 个享元对象供所有棋局共享使用即可，大大节省了内存。</p><p>实际上，它的代码实现非常简单，主要是<strong>通过工厂模式，在工厂类中，通过一个 Map 来缓存已经创建过的享元对象</strong>，来达到复用的目的。</p><h2 id="享元模式在文本编辑器中的应用"><a href="#享元模式在文本编辑器中的应用" class="headerlink" title="享元模式在文本编辑器中的应用"></a>享元模式在文本编辑器中的应用</h2><p>你可以把这里提到的文本编辑器想象成 Office 的 Word。不过，为了简化需求背景，我们<strong>假设这个文本编辑器只实现了文字编辑功能</strong>，不包含图片、表格等复杂的编辑功能。对于简化之后的文本编辑器，我们要在内存中表示一个文本文件，只需要记录文字和格式两部分信息就可以了，其中，格式又包括文字的字体、大小、颜色等信息。</p><p>尽管在实际的文档编写中，我们一般都是按照文本类型来设置文字的格式，标题是一种格式，正文是另一种格式等等。但是，从理论上讲，我们可以给文本文件中的每个文字都设置不同的格式。为了实现如此灵活的格式设置，并且代码实现又不过于太复杂，我们把每个文字都当作一个独立的对象来看待，并且在其中包含它的格式信息：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 文字</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Font font;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> colorRGB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Character</span><span class="params">(<span class="keyword">char</span> c, Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.font = font;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.colorRGB = colorRGB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Character&gt; chars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendCharacter</span><span class="params">(<span class="keyword">char</span> c, Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Character character = <span class="keyword">new</span> Character(c, font, size, colorRGB);</span><br><span class="line">        chars.add(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在文本编辑器中，我们每敲一个文字，都会调用 Editor 类中的 appendCharacter() 方法，创建一个新的 Character 对象，保存到 chars 数组中。如果一个文本文件中，有上万、十几万、几十万的文字，那我们就要在内存中存储这么多 Character 对象。</p><p>实际上，在一个文本文件中，用到的字体格式不会太多，毕竟不大可能有人把每个文字都设置成不同的格式。所以，<strong>对于字体格式，我们可以将它设计成享元</strong>，让不同的文字共享使用。按照这个设计思路，我们对上面的代码进行重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterStyle</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Font font;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> colorRGB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">CharacterStyle</span><span class="params">(Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.font = font;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        <span class="keyword">this</span>.colorRGB = colorRGB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CharacterStyle otherStyle = (CharacterStyle) o;</span><br><span class="line">        <span class="keyword">return</span> font.equals(otherStyle.font) &amp;&amp; size == otherStyle.size &amp;&amp; colorRGB == otherStyle.colorRGB;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CharacterStyleFactory</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;CharacterStyle&gt; styles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CharacterStyle <span class="title">getStyle</span><span class="params">(Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        CharacterStyle newStyle = <span class="keyword">new</span> CharacterStyle(font, size, colorRGB);</span><br><span class="line">        <span class="keyword">for</span> (CharacterStyle style : styles) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (style.equals(newStyle)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> style;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        styles.add(newStyle);</span><br><span class="line">        <span class="keyword">return</span> newStyle;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Character</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">char</span> c;</span><br><span class="line">    <span class="keyword">private</span> CharacterStyle style;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Character</span><span class="params">(<span class="keyword">char</span> c, CharacterStyle style)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.c = c;</span><br><span class="line">        <span class="keyword">this</span>.style = style;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Character&gt; chars = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">appendCharacter</span><span class="params">(<span class="keyword">char</span> c, Font font, <span class="keyword">int</span> size, <span class="keyword">int</span> colorRGB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Character character = <span class="keyword">new</span> Character(c, CharacterStyleFactory.getStyle(font, size, colorRGB));</span><br><span class="line">        chars.add(character);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="享元模式-vs-单例、缓存、对象池"><a href="#享元模式-vs-单例、缓存、对象池" class="headerlink" title="享元模式 vs. 单例、缓存、对象池"></a>享元模式 vs. 单例、缓存、对象池</h2><p>在上面的讲解中，我们多次提到“共享”、“缓存”、“复用”这些字眼，那它跟单例、缓存、对象池这些概念有什么区别呢？</p><h3 id="享元-vs-单例"><a href="#享元-vs-单例" class="headerlink" title="享元 vs. 单例"></a>享元 vs. 单例</h3><p>在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：<code>多例</code>。</p><p>我们前面也多次提到，区别两种设计模式，<strong>不能光看代码实现，而是要看设计意图，也就是要解决的问题</strong>。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的。应用享元模式是为了对象复用，节省内存，而<strong>应用多例模式是为了限制对象的个数</strong>。</p><h3 id="享元-vs-缓存"><a href="#享元-vs-缓存" class="headerlink" title="享元 vs. 缓存"></a>享元 vs. 缓存</h3><p>在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”、“CPU 缓存”、“MemCache 缓存”是两回事。我们平时所讲的<strong>缓存，主要是为了提高访问效率，而非复用</strong>。</p><h3 id="享元-vs-对象池"><a href="#享元-vs-对象池" class="headerlink" title="享元 vs. 对象池"></a>享元 vs. 对象池</h3><p>像 C++ 这样的编程语言，内存的管理是由程序员负责的。为了避免频繁地进行对象创建和释放导致内存碎片，我们可以<strong>预先申请一片连续的内存空间，也就是这里说的对象池</strong>。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。</p><p><strong>池化技术中的“复用”可以理解为“重复使用”，主要目的是节省时间</strong>。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者独占，当使用完成之后，放回到池中，再由其他使用者重复利用。<strong>享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者共享的，主要目的是节省空间</strong>。</p><h2 id="享元模式在-Java-Integer-中的应用"><a href="#享元模式在-Java-Integer-中的应用" class="headerlink" title="享元模式在 Java Integer 中的应用"></a>享元模式在 Java Integer 中的应用</h2><p>我们先来看下面这样一段代码。你可以先思考下，这段代码会输出什么样的结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Integer i1 = <span class="number">56</span>;</span><br><span class="line">Integer i2 = <span class="number">56</span>;</span><br><span class="line">Integer i3 = <span class="number">129</span>;</span><br><span class="line">Integer i4 = <span class="number">129</span>;</span><br><span class="line">System.out.println(i1 == i2);</span><br><span class="line">System.out.println(i3 == i4);</span><br></pre></td></tr></table></figure><p>如果不熟悉 Java 语言，你可能会觉得，i1 和 i2 值都是 56，i3 和 i4 值都是 129，i1 跟 i2 值相等，i3 跟 i4 值相等，所以输出结果应该是两个 true。这样的分析是不对的，主要还是因为你对 Java 语法不熟悉。要正确地分析上面的代码，我们需要弄清楚下面两个问题：</p><ul><li>如何判定两个 Java 对象是否相等；</li><li>什么是<code>自动装箱</code>（Autoboxing）和<code>自动拆箱</code>（Unboxing）；</li></ul><p>Java 为基本数据类型提供了对应的包装器类型。具体如下所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/16.png" alt></p><p>所谓的自动装箱，就是自动将基本数据类型转换为<strong>包装器类型</strong>。所谓的自动拆箱，也就是自动将包装器类型转化为基本数据类型。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">56</span>; <span class="comment">// 自动装箱</span></span><br><span class="line"><span class="keyword">int</span> j = i; <span class="comment">// 自动拆箱</span></span><br></pre></td></tr></table></figure><p>数值 56 是基本数据类型 int，当赋值给包装器类型（Integer）变量的时候，触发自动装箱操作，创建一个 Integer 类型的对象，并且赋值给变量 i。其底层相当于执行了下面这条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer i = <span class="number">56</span>；<span class="comment">// 底层执行了：Integer i = Integer.valueOf(56);</span></span><br></pre></td></tr></table></figure><p>反过来，当把包装器类型的变量 i，赋值给基本数据类型变量 j 的时候，触发自动拆箱操作，将 i 中的数据取出，赋值给 j。其底层相当于执行了下面这条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> j = i; <span class="comment">// 底层执行了：int j = i.intValue();</span></span><br></pre></td></tr></table></figure><p>弄清楚了自动装箱和自动拆箱，我们再来看，如何判定两个对象是否相等？不过，在此之前，我们先要搞清楚，<strong>Java 对象在内存中是如何存储的</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">User a = <span class="keyword">new</span> User(<span class="number">123</span>, <span class="number">23</span>); <span class="comment">// id=123, age=23</span></span><br></pre></td></tr></table></figure><p>针对这条语句，我画了一张内存存储结构图。a 存储的值是 User 对象的内存地址，在图中就表现为 a 指向 User 对象。当我们通过“==”来判定两个对象是否相等的时候，实际上是在判断两个局部变量存储的地址是否相同，换句话说，是在<strong>判断两个局部变量是否指向相同的对象</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/17.png" alt></p><p>Integer 用到了享元模式来复用对象。当我们通过自动装箱，也就是调用 valueOf() 来创建 Integer 对象的时候，如果要创建的 Integer 对象的值在 -128 到 127 之间，会从 IntegerCache 类中直接返回，否则才调用 new 方法创建。看代码更加清晰一些，Integer 类的 valueOf() 函数的具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这里的 <strong>IntegerCache 相当于生成享元对象的工厂类</strong>，只不过名字不叫 xxxFactory 而已。我们来看它的具体代码实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Cache to support the object identity semantics of autoboxing for values between</span></span><br><span class="line"><span class="comment"> * -128 and 127 (inclusive) as required by JLS.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The cache is initialized on first usage.  The size of the cache</span></span><br><span class="line"><span class="comment"> * may be controlled by the &#123;<span class="doctag">@code</span> -XX:AutoBoxCacheMax=&lt;size&gt;&#125; option.</span></span><br><span class="line"><span class="comment"> * During VM initialization, java.lang.Integer.IntegerCache.high property</span></span><br><span class="line"><span class="comment"> * may be set and saved in the private system properties in the</span></span><br><span class="line"><span class="comment"> * sun.misc.VM class.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// high value may be configured by property</span></span><br><span class="line">        <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">        String integerCacheHighPropValue = sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">        <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">try</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">catch</span> ( NumberFormatException nfe) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        high = h;</span><br><span class="line"></span><br><span class="line">        cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> j = low;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">        <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 IntegerCache 的代码实现中，当这个类被加载的时候，缓存的享元对象会被集中一次性创建好（-128~127）。实际上，<strong>JDK 也提供了方法来让我们可以自定义缓存的最大值</strong>，如果你通过分析应用的 JVM 内存占用情况，发现 -128 到 255 之间的数据占用的内存比较多，你就可以用如下方式，将缓存的最大值从 127 调整到 255：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一：</span></span><br><span class="line">-Djava.lang.Integer.IntegerCache.high=<span class="number">255</span></span><br><span class="line"><span class="comment">// 方法二：</span></span><br><span class="line">-XX:AutoBoxCacheMax=<span class="number">255</span></span><br></pre></td></tr></table></figure><p>因为 56 处于 -128 和 127 之间，i1 和 i2 会指向相同的享元对象，所以 i1==i2 返回 true。而 129 大于 127，并不会被缓存，每次都会创建一个全新的对象，也就是说，i3 和 i4 指向不同的 Integer 对象，所以 i3==i4 返回 false。</p><p>在我们平时的开发中，对于下面这样三种创建整型对象的方式，我们优先使用后两种：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="keyword">new</span> Integer(<span class="number">123</span>);</span><br><span class="line">Integer a = <span class="number">123</span>;</span><br><span class="line">Integer a = Integer.valueOf(<span class="number">123</span>);</span><br></pre></td></tr></table></figure><p>第一种创建方式并不会使用到 IntegerCache，而后面两种创建方法可以利用 IntegerCache 缓存，返回共享的对象，以<strong>达到节省内存的目的</strong>。举一个极端一点的例子，假设程序需要创建 1 万个 -128 到 127 之间的 Integer 对象。使用第一种创建方式，我们需要分配 1 万个 Integer 对象的内存空间；使用后两种创建方式，我们最多只需要分配 256 个 Integer 对象的内存空间。</p><h2 id="享元模式在-Java-String-中的应用"><a href="#享元模式在-Java-String-中的应用" class="headerlink" title="享元模式在 Java String 中的应用"></a>享元模式在 Java String 中的应用</h2><p>同样，我们还是先来看一段代码，你觉得这段代码输出的结果是什么呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="string">"小争哥"</span>;</span><br><span class="line">String s2 = <span class="string">"小争哥"</span>;</span><br><span class="line">String s3 = <span class="keyword">new</span> String(<span class="string">"小争哥"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(s1 == s2);</span><br><span class="line">System.out.println(s1 == s3);</span><br></pre></td></tr></table></figure><p>上面代码的运行结果是：一个 true，一个 false。跟 Integer 类的设计思路相似，String 类利用享元模式来复用相同的字符串常量（也就是代码中的“小争哥”）。JVM 会专门开辟一块存储区来存储字符串常量，这块存储区叫作<code>字符串常量池</code>。上面代码对应的内存存储结构如下所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/18.png" alt></p><p>不过，String 类的享元模式的设计，跟 Integer 类稍微有些不同。Integer 类中要共享的对象，是<strong>在类加载的时候，就集中一次性创建好</strong>的。但是，对于字符串来说，我们没法事先知道要共享哪些字符串常量，所以没办法事先创建好，只能<strong>在某个字符串常量第一次被用到的时候，存储到常量池中</strong>，当之后再用到的时候，直接引用常量池中已经存在的即可，就不需要再重新创建了。</p><p>实际上，<strong>享元模式对 JVM 的垃圾回收并不友好</strong>。因为享元工厂类一直保存了对享元对象的引用，这就导致享元对象在没有任何代码使用的情况下，也并不会被 JVM 垃圾回收机制自动回收掉。因此，在某些情况下，如果对象的生命周期很短，也不会被密集使用，利用享元模式反倒可能会浪费更多的内存。所以，<strong>除非经过线上验证，利用享元模式真的可以大大节省内存，否则，就不要过度使用这个模式</strong>，为了一点点内存的节省而引入一个复杂的设计模式，得不偿失。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Composite Design Pattern</title>
      <link href="2020/12/08/Composite-Design-Pattern/"/>
      <url>2020/12/08/Composite-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="组合模式的原理与实现"><a href="#组合模式的原理与实现" class="headerlink" title="组合模式的原理与实现"></a>组合模式的原理与实现</h2><p><code>组合模式</code>（Composite Design Pattern）是这样定义的：</p><blockquote><p>Compose objects into tree structure to represent part-whole hierarchies. Composite lets client treat individual objects and compositions of objects uniformly.</p></blockquote><p>翻译成中文就是：<strong>将一组对象组织（Compose）成树形结构，以表示一种“部分-整体”的层次结构</strong>。组合让客户端可以统一单个对象和组合对象的处理逻辑。</p><p>假设我们有这样一个需求：设计一个类来表示文件系统中的目录，能方便地实现下面这些功能：</p><ul><li>动态地添加、删除某个目录下的子目录或文件；</li><li>统计指定目录下的文件个数；</li><li>统计指定目录下的文件总大小；</li></ul><p>我们把文件和目录统一用 FileSystemNode 类来表示，并且通过 isFile 属性来区分。我这里给出了这个类的骨架代码，如下所示：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isFile;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemNode</span><span class="params">(String path, <span class="keyword">boolean</span> isFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">        <span class="keyword">this</span>.isFile = isFile;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        subNodes.add(fileOrDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = subNodes.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; size; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size) </span><br><span class="line">        &#123;</span><br><span class="line">            subNodes.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于文件，我们直接返回文件的个数（返回 1）或大小。对于目录，我们遍历目录中每个子目录或者文件，<code>递归</code>计算它们的个数或大小，然后求和，就是这个目录下的文件个数和文件大小：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFile) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> numOfFiles = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) </span><br><span class="line">    &#123;</span><br><span class="line">        numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numOfFiles;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isFile) </span><br><span class="line">    &#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> file.length();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> sizeofFiles = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) </span><br><span class="line">    &#123;</span><br><span class="line">        sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单纯从功能实现角度来说，上面的代码没有问题，已经实现了我们想要的功能。但是，如果我们开发的是一个大型系统，从扩展性（文件或目录可能会对应不同的操作）、业务建模（文件和目录从业务上是两个概念）、代码的可读性（文件和目录区分对待更加符合人们对业务的认知）的角度来说，我们<strong>最好对文件和目录进行区分设计</strong>，定义为 File 和 Directory 两个类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">FileSystemNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String path;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileSystemNode</span><span class="params">(String path)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> path;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">File</span> <span class="keyword">extends</span> <span class="title">FileSystemNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String path)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        java.io.File file = <span class="keyword">new</span> java.io.File(path);</span><br><span class="line">        <span class="keyword">if</span> (!file.exists()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> file.length();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Directory</span> <span class="keyword">extends</span> <span class="title">FileSystemNode</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;FileSystemNode&gt; subNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Directory</span><span class="params">(String path)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">countNumOfFiles</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfFiles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) </span><br><span class="line">        &#123;</span><br><span class="line">            numOfFiles += fileOrDir.countNumOfFiles();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numOfFiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">countSizeOfFiles</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> sizeofFiles = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (FileSystemNode fileOrDir : subNodes) </span><br><span class="line">        &#123;</span><br><span class="line">            sizeofFiles += fileOrDir.countSizeOfFiles();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sizeofFiles;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        subNodes.add(fileOrDir);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeSubNode</span><span class="params">(FileSystemNode fileOrDir)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> size = subNodes.size();</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (; i &lt; size; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; size) </span><br><span class="line">        &#123;</span><br><span class="line">            subNodes.remove(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>文件和目录类都设计好了，我们来看，如何用它们来表示一个文件系统中的目录树结构。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * /</span></span><br><span class="line"><span class="comment">         * /wz/</span></span><br><span class="line"><span class="comment">         * /wz/a.txt</span></span><br><span class="line"><span class="comment">         * /wz/b.txt</span></span><br><span class="line"><span class="comment">         * /wz/movies/</span></span><br><span class="line"><span class="comment">         * /wz/movies/c.avi</span></span><br><span class="line"><span class="comment">         * /xzg/</span></span><br><span class="line"><span class="comment">         * /xzg/docs/</span></span><br><span class="line"><span class="comment">         * /xzg/docs/d.txt</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Directory fileSystemTree = <span class="keyword">new</span> Directory(<span class="string">"/"</span>);</span><br><span class="line">        Directory node_wz = <span class="keyword">new</span> Directory(<span class="string">"/wz/"</span>);</span><br><span class="line">        Directory node_xzg = <span class="keyword">new</span> Directory(<span class="string">"/xzg/"</span>);</span><br><span class="line">        fileSystemTree.addSubNode(node_wz);</span><br><span class="line">        fileSystemTree.addSubNode(node_xzg);</span><br><span class="line"></span><br><span class="line">        File node_wz_a = <span class="keyword">new</span> File(<span class="string">"/wz/a.txt"</span>);</span><br><span class="line">        File node_wz_b = <span class="keyword">new</span> File(<span class="string">"/wz/b.txt"</span>);</span><br><span class="line">        Directory node_wz_movies = <span class="keyword">new</span> Directory(<span class="string">"/wz/movies/"</span>);</span><br><span class="line">        node_wz.addSubNode(node_wz_a);</span><br><span class="line">        node_wz.addSubNode(node_wz_b);</span><br><span class="line">        node_wz.addSubNode(node_wz_movies);</span><br><span class="line"></span><br><span class="line">        File node_wz_movies_c = <span class="keyword">new</span> File(<span class="string">"/wz/movies/c.avi"</span>);</span><br><span class="line">        node_wz_movies.addSubNode(node_wz_movies_c);</span><br><span class="line"></span><br><span class="line">        Directory node_xzg_docs = <span class="keyword">new</span> Directory(<span class="string">"/xzg/docs/"</span>);</span><br><span class="line">        node_xzg.addSubNode(node_xzg_docs);</span><br><span class="line"></span><br><span class="line">        File node_xzg_docs_d = <span class="keyword">new</span> File(<span class="string">"/xzg/docs/d.txt"</span>);</span><br><span class="line">        node_xzg_docs.addSubNode(node_xzg_docs_d);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"/ files num:"</span> + fileSystemTree.countNumOfFiles());</span><br><span class="line">        System.out.println(<span class="string">"/wz/ files num:"</span> + node_wz.countNumOfFiles());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们对照着这个例子，再重新看一下组合模式的定义：将一组对象（文件和目录）组织成树形结构，以表示一种“部分-整体”的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。</p><p>实际上，刚才讲的这种组合模式的设计思路，与其说是一种设计模式，倒不如说是<strong>对业务场景的一种数据结构和算法的抽象</strong>。其中，数据可以表示成树这种数据结构，业务需求可以通过在树上的递归遍历算法来实现。</p><h2 id="组合模式的应用场景举例"><a href="#组合模式的应用场景举例" class="headerlink" title="组合模式的应用场景举例"></a>组合模式的应用场景举例</h2><p>假设我们在开发一个 OA 系统（办公自动化系统）。公司的组织结构包含部门和员工两种数据类型。其中，部门又可以包含子部门和员工。在数据库中的表结构如下所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/15.png" alt></p><p>我们希望在内存中构建整个公司的人员架构图（部门、子部门、员工的隶属关系），并且提供接口计算出部门的薪资成本（隶属于这个部门的所有员工的薪资和）。<strong>部门包含子部门和员工，这是一种嵌套结构，可以表示成树这种数据结构。计算每个部门的薪资开支这样一个需求，也可以通过在树上的遍历算法来实现</strong>。所以，从这个角度来看，这个应用场景可以使用组合模式来设计和实现。</p><p>HumanResource 是部门类（Department）和员工类（Employee）抽象出来的父类，为的是能统一薪资的处理逻辑。Demo 中的代码负责<strong>从数据库中读取数据并在内存中构建组织架构图</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HumanResource</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">long</span> id;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> salary;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">HumanResource</span><span class="params">(<span class="keyword">long</span> id)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">double</span> <span class="title">calculateSalary</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Employee</span> <span class="keyword">extends</span> <span class="title">HumanResource</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Employee</span><span class="params">(<span class="keyword">long</span> id, <span class="keyword">double</span> salary)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">        <span class="keyword">this</span>.salary = salary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateSalary</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> salary;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Department</span> <span class="keyword">extends</span> <span class="title">HumanResource</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;HumanResource&gt; subNodes = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Department</span><span class="params">(<span class="keyword">long</span> id)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateSalary</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> totalSalary = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (HumanResource hr : subNodes) </span><br><span class="line">        &#123;</span><br><span class="line">            totalSalary += hr.calculateSalary();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.salary = totalSalary;</span><br><span class="line">        <span class="keyword">return</span> totalSalary;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSubNode</span><span class="params">(HumanResource hr)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        subNodes.add(hr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构建组织架构的代码</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> ORGANIZATION_ROOT_ID = <span class="number">1001</span>;</span><br><span class="line">    <span class="keyword">private</span> DepartmentRepo departmentRepo; <span class="comment">// 依赖注入</span></span><br><span class="line">    <span class="keyword">private</span> EmployeeRepo employeeRepo; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buildOrganization</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Department rootDepartment = <span class="keyword">new</span> Department(ORGANIZATION_ROOT_ID);</span><br><span class="line">        buildOrganization(rootDepartment);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">buildOrganization</span><span class="params">(Department department)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;Long&gt; subDepartmentIds = departmentRepo.getSubDepartmentIds(department.getId());</span><br><span class="line">        <span class="keyword">for</span> (Long subDepartmentId : subDepartmentIds) </span><br><span class="line">        &#123;</span><br><span class="line">            Department subDepartment = <span class="keyword">new</span> Department(subDepartmentId);</span><br><span class="line">            department.addSubNode(subDepartment);</span><br><span class="line">            buildOrganization(subDepartment);</span><br><span class="line">        &#125;</span><br><span class="line">        List&lt;Long&gt; employeeIds = employeeRepo.getDepartmentEmployeeIds(department.getId());</span><br><span class="line">        <span class="keyword">for</span> (Long employeeId : employeeIds) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> salary = employeeRepo.getEmployeeSalary(employeeId);</span><br><span class="line">            department.addSubNode(<span class="keyword">new</span> Employee(employeeId, salary));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们再拿组合模式的定义跟这个例子对照一下：将一组对象（员工和部门）组织成树形结构，以表示一种”部分-整体”的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Facade Design Pattern</title>
      <link href="2020/12/07/Facade-Design-Pattern/"/>
      <url>2020/12/07/Facade-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="门面模式的原理与实现"><a href="#门面模式的原理与实现" class="headerlink" title="门面模式的原理与实现"></a>门面模式的原理与实现</h2><p><code>门面模式</code>（Facade Design Pattern）是这样定义的：</p><blockquote><p>Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.</p></blockquote><p>翻译成中文就是：门面模式为子系统提供一组统一的接口，<strong>定义一组高层接口让子系统更易用</strong>。除此之外，我还要强调一下，门面模式定义中的“子系统（subsystem）”也可以有多种理解方式。它<strong>既可以是一个完整的系统，也可以是更细粒度的类或者模块</strong>。</p><h2 id="门面模式的应用场景举例"><a href="#门面模式的应用场景举例" class="headerlink" title="门面模式的应用场景举例"></a>门面模式的应用场景举例</h2><p>实际上，它除了解决易用性问题之外，还能解决其他很多方面的问题。</p><h3 id="解决易用性问题"><a href="#解决易用性问题" class="headerlink" title="解决易用性问题"></a>解决易用性问题</h3><p>门面模式可以用来<strong>封装系统的底层实现，隐藏系统的复杂性</strong>，提供一组更加简单易用、更高层的接口。比如，Linux <code>系统调用函数</code>就可以看作一种“门面”。它是 Linux 操作系统暴露给开发者的一组“特殊”的编程接口，它封装了底层更基础的 Linux 内核调用。再比如，Linux 的 <code>Shell 命令</code>，实际上也可以看作一种门面模式的应用。它继续封装系统调用，提供更加友好、简单的命令，让我们可以直接通过执行命令来跟操作系统交互。</p><p>我们知道，类、模块、系统之间的“通信”，一般都是通过接口调用来完成的。接口设计的好坏，直接影响到类、模块、系统是否好用。所以，我们要多花点心思在接口设计上。我经常说，<strong>完成接口设计，就相当于完成了一半的开发任务</strong>。只要接口设计得好，那代码就差不到哪里去。</p><p>接口粒度设计得太大，太小都不好。太大会导致接口不可复用，太小会导致接口不易用。在实际的开发中，<strong>接口的可复用性和易用性需要微妙的权衡</strong>。针对这个问题，我的一个基本的处理原则是，尽量保持接口的可复用性，但针对特殊情况，允许提供冗余的门面接口，来提供更易用的接口。</p><a id="more"></a><h3 id="解决性能问题"><a href="#解决性能问题" class="headerlink" title="解决性能问题"></a>解决性能问题</h3><p>我们通过<strong>将多个接口调用替换为一个门面接口调用，减少网络通信成本</strong>，提高 App 客户端的响应速度。假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个包裹 a、b、d 接口调用的门面接口 x，给系统 B 直接使用。</p><p>假设我们刚刚提到的系统 A 是一个后端服务器，系统 B 是 App 客户端。App 客户端通过后端服务器提供的接口来获取数据。我们知道，App 和服务器之间是通过移动网络通信的，网络通信耗时比较多，为了提高 App 的响应速度，我们要尽量减少 App 与服务器之间的网络通信次数。</p><p>如果我们现在发现 App 客户端的响应速度比较慢，排查之后发现，是因为过多的接口调用过多的网络通信。针对这种情况，我们就可以利用门面模式，让后端服务器提供一个包裹 a、b、d 三个接口调用的接口 x。App 客户端调用一次接口 x，来获取到所有想要的数据，将网络通信的次数从 3 次减少到 1 次，也就提高了 App 的响应速度。</p><h3 id="解决分布式事务问题"><a href="#解决分布式事务问题" class="headerlink" title="解决分布式事务问题"></a>解决分布式事务问题</h3><p>在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。对于这样一个简单的业务需求，我们可以通过依次调用用户的创建接口和钱包的创建接口来完成。但是，用户注册需要支持事务，也就是说，<strong>创建用户和钱包的两个操作，要么都成功，要么都失败</strong>，不能一个成功、一个失败。</p><p>要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过<strong>引入分布式事务框架或者事后补偿的机制</strong>来解决，但代码实现都比较复杂。而最简单的解决方案是，利用数据库事务或者 Spring 框架提供的事务，在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求<strong>两个 SQL 操作要在一个接口中完成</strong>，所以，我们可以借鉴门面模式的思想，再设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Adapter Design Pattern</title>
      <link href="2020/12/05/Adapter-Design-Pattern/"/>
      <url>2020/12/05/Adapter-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="适配器模式的原理与实现"><a href="#适配器模式的原理与实现" class="headerlink" title="适配器模式的原理与实现"></a>适配器模式的原理与实现</h2><p><code>适配器模式</code>（Adapter Design Pattern）是用来做适配的，它将不兼容的接口转换为可兼容的接口，<strong>让原本由于接口不兼容而不能一起工作的类可以一起工作</strong>。对于这个模式，有一个经常被拿来解释它的例子，就是 USB 转接头充当适配器，把两种不兼容的接口，通过转接变得可以一起工作。</p><p>适配器模式有两种实现方式：类适配器和对象适配器。其中，<strong>类适配器使用继承关系来实现，对象适配器使用组合关系来实现</strong>。具体的代码实现如下所示。其中，ITarget 表示要转化成的接口定义。Adaptee 是一组不兼容 ITarget 接口定义的接口，Adaptor 将 Adaptee 转化成一组符合 ITarget 接口定义的接口：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类适配器: 基于继承</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fb</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;   </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.fa();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...重新实现 f2()...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里 fc() 不需要实现，直接继承自 Adaptee，这是跟对象适配器最大的不同点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对象适配器：基于组合</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fb</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptor</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adaptor</span><span class="params">(Adaptee adaptee)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adaptee.fa(); <span class="comment">// 委托给 Adaptee</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...重新实现 f2()...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fc</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        adaptee.fc();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对这两种实现方式，选择的标准主要有两个，一个是 Adaptee 接口的个数，另一个是 Adaptee 和 ITarget 的契合程度：</p><ul><li>如果 Adaptee 接口并不多，那两种实现方式都可以；</li><li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，<strong>比起对象适配器的实现方式，Adaptor 的代码量要少一些</strong>；</li><li>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为<strong>组合结构相对于继承更加灵活</strong>；</li></ul><h2 id="适配器模式应用场景总结"><a href="#适配器模式应用场景总结" class="headerlink" title="适配器模式应用场景总结"></a>适配器模式应用场景总结</h2><p>一般来说，<strong>适配器模式可以看作一种“补偿模式”，用来补救设计上的缺陷</strong>。应用这种模式算是“无奈之举”。如果在设计初期，我们就能协调规避接口不兼容的问题，那这种模式就没有应用的机会了。</p><h3 id="封装有缺陷的接口设计"><a href="#封装有缺陷的接口设计" class="headerlink" title="封装有缺陷的接口设计"></a>封装有缺陷的接口设计</h3><p>假设我们依赖的外部系统在接口设计方面有缺陷（比如包含大量静态方法），引入之后会影响到我们自身代码的可测试性。为了隔离设计上的缺陷，我们希望<strong>对外部系统提供的接口进行二次封装，抽象出更好的接口设计</strong>，这个时候就可以使用适配器模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CD</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 这个类来自外部 SDK，我们无权修改它的代码</span></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticFunction1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uglyNamingFunction2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tooManyParamsFunction3</span><span class="params">(<span class="keyword">int</span> paramA, <span class="keyword">int</span> paramB, ...)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lowPerformanceFunction4</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行重构</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ITarget</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">function4</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 注意：适配器类的命名不一定非得末尾带 Adaptor</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CDAdaptor</span> <span class="keyword">extends</span> <span class="title">CD</span> <span class="keyword">implements</span> <span class="title">ITarget</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function1</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.staticFunction1();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function2</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.uglyNamingFunction2();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function3</span><span class="params">(ParamsWrapperDefinition paramsWrapper)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.tooManyParamsFunction3(paramsWrapper.getParamA(), ...);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">function4</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...replacement it...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="统一多个类的接口设计"><a href="#统一多个类的接口设计" class="headerlink" title="统一多个类的接口设计"></a>统一多个类的接口设计</h3><p>某个功能的实现依赖多个外部系统（或者说类）。<strong>通过适配器模式，将它们的接口适配为统一的接口定义</strong>，然后我们就可以使用多态的特性来复用代码逻辑。</p><p>假设我们的系统要对用户输入的文本内容做敏感词过滤，为了提高过滤的召回率，我们引入了多款第三方敏感词过滤系统，依次对用户输入的内容进行过滤，过滤掉尽可能多的敏感词。但是，每个系统提供的过滤接口都是不同的。这就意味着我们没法复用一套逻辑来调用各个系统。这个时候，我们就可以使用适配器模式，将所有系统的接口适配为统一的接口定义，这样我们可以复用调用敏感词过滤的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASensitiveWordsFilter</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// A 敏感词过滤系统提供的接口</span></span><br><span class="line">    <span class="comment">// text 是原始文本，函数输出用 *** 替换敏感词之后的文本</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterSexyWords</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterPoliticalWords</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BSensitiveWordsFilter</span>  </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// B 敏感词过滤系统提供的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CSensitiveWordsFilter</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// C 敏感词过滤系统提供的接口</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String text, String mask)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 未使用适配器模式之前的代码：代码的可测试性、扩展性不好</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RiskManagement</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ASensitiveWordsFilter aFilter = <span class="keyword">new</span> ASensitiveWordsFilter();</span><br><span class="line">    <span class="keyword">private</span> BSensitiveWordsFilter bFilter = <span class="keyword">new</span> BSensitiveWordsFilter();</span><br><span class="line">    <span class="keyword">private</span> CSensitiveWordsFilter cFilter = <span class="keyword">new</span> CSensitiveWordsFilter();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterSensitiveWords</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String maskedText = aFilter.filterSexyWords(text);</span><br><span class="line">        maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">        maskedText = bFilter.filter(maskedText);</span><br><span class="line">        maskedText = cFilter.filter(maskedText, <span class="string">"***"</span>);</span><br><span class="line">        <span class="keyword">return</span> maskedText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用适配器模式进行改造</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISensitiveWordsFilter</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 统一接口定义</span></span><br><span class="line">    <span class="function">String <span class="title">filter</span><span class="params">(String text)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ASensitiveWordsFilterAdaptor</span> <span class="keyword">implements</span> <span class="title">ISensitiveWordsFilter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ASensitiveWordsFilter aFilter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filter</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String maskedText = aFilter.filterSexyWords(text);</span><br><span class="line">        maskedText = aFilter.filterPoliticalWords(maskedText);</span><br><span class="line">        <span class="keyword">return</span> maskedText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...省略 BSensitiveWordsFilterAdaptor、CSensitiveWordsFilterAdaptor...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 扩展性更好，更加符合开闭原则，如果添加一个新的敏感词过滤系统，</span></span><br><span class="line"><span class="comment">// 这个类完全不需要改动；而且基于接口而非实现编程，代码的可测试性更好</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RiskManagement</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> List&lt;ISensitiveWordsFilter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSensitiveWordsFilter</span><span class="params">(ISensitiveWordsFilter filter)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        filters.add(filter);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterSensitiveWords</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String maskedText = text;</span><br><span class="line">        <span class="keyword">for</span> (ISensitiveWordsFilter filter : filters) </span><br><span class="line">        &#123;</span><br><span class="line">            maskedText = filter.filter(maskedText);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maskedText;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="替换依赖的外部系统"><a href="#替换依赖的外部系统" class="headerlink" title="替换依赖的外部系统"></a>替换依赖的外部系统</h3><p>当我们把项目中依赖的一个外部系统替换为另一个外部系统的时候，<strong>利用适配器模式，可以减少对代码的改动</strong>。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 外部系统 A</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在我们的项目中，外部系统 A 的使用示例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IA a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(IA a)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line">Demo d = <span class="keyword">new</span> Demo(<span class="keyword">new</span> A());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将外部系统 A 替换成外部系统 B</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BAdaptor</span> <span class="keyword">implements</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> B b;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BAdaptor</span><span class="params">(B b)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.b= b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fa</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        b.fb();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 借助 BAdaptor，Demo 的代码中，调用 IA 接口的地方都无需改动，</span></span><br><span class="line"><span class="comment">// 只需要将 BAdaptor 如下注入到 Demo 即可</span></span><br><span class="line">Demo d = <span class="keyword">new</span> Demo(<span class="keyword">new</span> BAdaptor(<span class="keyword">new</span> B()));</span><br></pre></td></tr></table></figure><h3 id="兼容老版本接口"><a href="#兼容老版本接口" class="headerlink" title="兼容老版本接口"></a>兼容老版本接口</h3><p>在做版本升级的时候，对于一些要废弃的接口，我们不直接将其删除，而是暂时保留，并且标注为 <code>deprecated</code>，并<strong>将内部实现逻辑委托为新的接口实现</strong>。这样做的好处是，让使用它的项目有个过渡期，而不是强制进行代码修改。这也可以粗略地看作适配器模式的一个应用场景。</p><p>JDK1.0 中包含一个遍历集合容器的类 Enumeration。JDK2.0 对这个类进行了重构，将它改名为 Iterator 类，并且对它的代码实现做了优化。但是考虑到如果将 Enumeration 直接从 JDK2.0 中删除，那使用 JDK1.0 的项目如果切换到 JDK2.0，代码就会编译不通过。这就是我们经常所说的不兼容升级。为了做到兼容使用低版本 JDK 的老代码，我们可以暂时保留 Enumeration 类，并将其实现替换为直接调用 Iterator：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Collections</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Enumeration <span class="title">enumeration</span><span class="params">(<span class="keyword">final</span> Collection c)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Enumeration() </span><br><span class="line">        &#123;</span><br><span class="line">            Iterator i = c.iterator();</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasMoreElements</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i.hashNext();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">nextElement</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> i.next():</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="适配不同格式的数据"><a href="#适配不同格式的数据" class="headerlink" title="适配不同格式的数据"></a>适配不同格式的数据</h3><p>前面我们讲到，适配器模式主要用于接口的适配，实际上，它<strong>还可以用在不同格式的数据之间的适配</strong>。比如，把从不同征信系统拉取的不同格式的征信数据，统一为相同的格式，以方便存储和使用。再比如，Java 中的 Arrays.asList() 也可以看作一种数据适配器，将数组类型的数据转化为集合容器类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;String&gt; stooges = Arrays.asList(<span class="string">"Larry"</span>, <span class="string">"Moe"</span>, <span class="string">"Curly"</span>);</span><br></pre></td></tr></table></figure><h2 id="剖析适配器模式在-Java-日志中的应用"><a href="#剖析适配器模式在-Java-日志中的应用" class="headerlink" title="剖析适配器模式在 Java 日志中的应用"></a>剖析适配器模式在 Java 日志中的应用</h2><p>Java 中有很多日志框架，在项目开发中，我们常常用它们来打印日志信息。其中，比较常用的有 Log4j、Logback，以及 JDK 提供的 JUL(java.util.logging) 和 Apache 的 JCL(Jakarta Commons Logging) 等。</p><p>如果你是做 Java 开发的，那 <code>SLF4J</code> 这个日志框架你肯定不陌生，它相当于 JDBC 规范，提供了一套打印日志的统一接口规范。不过，它只定义了接口，并没有提供具体的实现，需要配合其他日志框架来使用。</p><p>不仅如此，SLF4J 的出现晚于 JUL、JCL、Log4j 等日志框架，所以，这些日志框架也不可能牺牲掉版本兼容性，将接口改造成符合 SLF4J 接口规范。SLF4J 也事先考虑到了这个问题，所以，它<strong>不仅仅提供了统一的接口定义，还提供了针对不同日志框架的适配器</strong>。对不同日志框架的接口进行二次封装，适配成统一的 SLF4J 接口定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// SLF4J 统一的接口定义</span></span><br><span class="line"><span class="keyword">package</span> org.slf4j;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isTraceEnabled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String format, Object arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String format, Object arg1, Object arg2)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String format, Object[] argArray)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trace</span><span class="params">(String msg, Throwable t)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String msg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object arg)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object arg1, Object arg2)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object[] argArray)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String msg, Throwable t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...省略 info、warn、error 等一堆接口</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Log4j 日志框架的适配器</span></span><br><span class="line"><span class="comment">// Log4jLoggerAdapter 实现了 LocationAwareLogger 接口，</span></span><br><span class="line"><span class="comment">// 其中 LocationAwareLogger 继承自 Logger 接口，</span></span><br><span class="line"><span class="comment">// 也就相当于 Log4jLoggerAdapter 实现了 Logger 接口</span></span><br><span class="line"><span class="keyword">package</span> org.slf4j.impl;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Log4jLoggerAdapter</span> <span class="keyword">extends</span> <span class="title">MarkerIgnoringBase</span> <span class="keyword">implements</span> <span class="title">LocationAwareLogger</span>, <span class="title">Serializable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">transient</span> org.apache.log4j.Logger logger; <span class="comment">// Log4j</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDebugEnabled</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> logger.isDebugEnabled();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String msg)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        logger.log(FQCN, Level.DEBUG, msg, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object arg)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) </span><br><span class="line">        &#123;</span><br><span class="line">            FormattingTuple ft = MessageFormatter.format(format, arg);</span><br><span class="line">            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object arg1, Object arg2)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) </span><br><span class="line">        &#123;</span><br><span class="line">            FormattingTuple ft = MessageFormatter.format(format, arg1, arg2);</span><br><span class="line">            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String format, Object[] argArray)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (logger.isDebugEnabled()) </span><br><span class="line">        &#123;</span><br><span class="line">            FormattingTuple ft = MessageFormatter.arrayFormat(format, argArray);</span><br><span class="line">            logger.log(FQCN, Level.DEBUG, ft.getMessage(), ft.getThrowable());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">debug</span><span class="params">(String msg, Throwable t)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        logger.log(FQCN, Level.DEBUG, msg, t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略一堆接口的实现...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，你可能会说，如果一些老的项目没有使用 SLF4J，而是直接使用比如 JCL 来打印日志，那如果想要替换成其他日志框架，比如 log4j，该怎么办呢？实际上，SLF4J 不仅仅提供了从其他日志框架到 SLF4J 的适配器，<strong>还提供了反向适配器，也就是从 SLF4J 到其他日志框架的适配</strong>。我们可以先将 JCL 切换为 SLF4J，然后再将 SLF4J 切换为 Log4j。经过两次适配器的转换，我们就能成功将 Log4j 切换为了 Logback。</p><h2 id="代理、桥接、装饰器、适配器设计模式的区别"><a href="#代理、桥接、装饰器、适配器设计模式的区别" class="headerlink" title="代理、桥接、装饰器、适配器设计模式的区别"></a>代理、桥接、装饰器、适配器设计模式的区别</h2><p>代理、桥接、装饰器、适配器，这 4 种模式是比较常用的结构型设计模式。它们的代码结构非常相似。笼统来说，它们<strong>都可以称为 Wrapper 模式，也就是通过 Wrapper 类二次封装原始类</strong>。尽管代码结构相似，但这 4 种设计模式的用意完全不同，也就是说要解决的问题、应用场景不同，这也是它们的主要区别：</p><ul><li><strong>代理模式</strong>：代理模式在不改变原始类接口的条件下，为原始类定义一个代理类，主要目的是控制访问，而非加强功能，这是它跟装饰器模式最大的不同；</li><li><strong>桥接模式</strong>：桥接模式的目的是将接口部分和实现部分分离，从而让它们可以较为容易、也相对独立地加以改变；</li><li><strong>装饰器模式</strong>：装饰者模式在不改变原始类接口的情况下，对原始类功能进行增强，并且支持多个装饰器的嵌套使用；</li><li><strong>适配器模式</strong>：适配器模式是一种事后的补救策略。适配器提供跟原始类不同的接口，而代理模式、装饰器模式提供的都是跟原始类相同的接口；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Decorator Design Pattern</title>
      <link href="2020/12/05/Decorator-Design-Pattern/"/>
      <url>2020/12/05/Decorator-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="Java-IO-类的“奇怪”用法"><a href="#Java-IO-类的“奇怪”用法" class="headerlink" title="Java IO 类的“奇怪”用法"></a>Java IO 类的“奇怪”用法</h2><p>Java IO 类库非常庞大和复杂，有几十个类，负责 IO 数据的读取和写入。如果对 Java IO 类做一下分类，我们可以从下面两个维度将它划分为四类：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/13.png" alt></p><p>针对不同的读取和写入场景，Java IO 又在这四个父类基础之上，扩展出了很多子类。具体如下所示：</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/14.png" alt></p><p>在我初学 Java 的时候，曾经对 Java IO 的一些用法产生过很大疑惑。比如下面这样一段代码，其中，InputStream 是一个抽象类，FileInputStream 是专门用来读取文件流的子类。BufferedInputStream 是一个支持带缓存功能的数据读取类，可以提高数据读取的效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"/user/wangzheng/test.txt"</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>初看上面的代码，我们会觉得 Java IO 的用法比较麻烦，需要先创建一个 FileInputStream 对象，然后再传递给 BufferedInputStream 对象来使用。我在想，Java IO 为什么不设计一个继承 FileInputStream 并且支持缓存的 BufferedFileInputStream 类呢？这样我们就可以像下面的代码中这样，直接创建一个 BufferedFileInputStream 类对象，打开文件读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">InputStream bin = <span class="keyword">new</span> BufferedFileInputStream(<span class="string">"/user/wangzheng/test.txt"</span>);</span><br><span class="line"><span class="keyword">byte</span>[] data = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">128</span>];</span><br><span class="line"><span class="keyword">while</span> (bin.read(data) != -<span class="number">1</span>) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="基于继承的设计方案"><a href="#基于继承的设计方案" class="headerlink" title="基于继承的设计方案"></a>基于继承的设计方案</h2><p>如果 InputStream 只有一个子类 FileInputStream 的话，那我们在 FileInputStream 基础之上，再设计一个孙子类 BufferedFileInputStream，也算是可以接受的，毕竟继承结构还算简单。但实际上，继承 InputStream 的子类有很多。我们需要给每一个 InputStream 的子类，再继续派生支持缓存读取的子类。</p><p>除了支持缓存读取之外，如果我们还需要对功能进行其他方面的增强，比如下面的 DataInputStream 类，支持按照基本数据类型（int、boolean、long 等）来读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FileInputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"/user/wangzheng/test.txt"</span>);</span><br><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(in);</span><br><span class="line"><span class="keyword">int</span> data = din.readInt();</span><br></pre></td></tr></table></figure><p>在这种情况下，如果我们继续按照继承的方式来实现的话，就需要再继续派生出 DataFileInputStream、DataPipedInputStream 等类。如果我们还需要既支持缓存、又支持按照基本类型读取数据的类，那就要再继续派生出 BufferedDataFileInputStream、BufferedDataPipedInputStream 等 n 多类。这还只是附加了两个增强功能，如果我们需要附加更多的增强功能，那就会导致组合爆炸，<strong>类继承结构变得无比复杂，代码既不好扩展，也不好维护</strong>。</p><h2 id="基于装饰器模式的设计方案"><a href="#基于装饰器模式的设计方案" class="headerlink" title="基于装饰器模式的设计方案"></a>基于装饰器模式的设计方案</h2><p>针对刚刚的继承结构过于复杂的问题，我们可以通过<strong>将继承关系改为组合关系</strong>来解决。下面的代码展示了 Java IO 的这种设计思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">InputStream</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readLimit)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Mark/reset not supported."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...实现基于缓存的读数据接口...  </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">DataInputStream</span><span class="params">(InputStream in)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...实现读取基本类型数据的接口</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 Java IO 的设计来看，装饰器模式相对于简单的组合关系，还有两个比较特殊的地方：</p><ol><li><p>装饰器类和原始类继承同样的父类，这样我们<strong>可以对原始类“嵌套”多个装饰器类</strong>。<br>比如，下面这样一段代码，我们对 FileInputStream 嵌套了两个装饰器类：BufferedInputStream 和 DataInputStream，让它既支持缓存读取，又支持按照基本数据类型来读取数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">InputStream in = <span class="keyword">new</span> FileInputStream(<span class="string">"/user/wangzheng/test.txt"</span>);</span><br><span class="line">InputStream bin = <span class="keyword">new</span> BufferedInputStream(in);</span><br><span class="line">DataInputStream din = <span class="keyword">new</span> DataInputStream(bin);</span><br><span class="line"><span class="keyword">int</span> data = din.readInt();</span><br></pre></td></tr></table></figure></li><li><p><strong>装饰器类是对功能的增强</strong>，这也是装饰器模式应用场景的一个重要特点。<br>实际上，符合“组合关系”这种代码结构的设计模式有很多，比如之前讲过的代理模式、桥接模式，还有现在的装饰器模式。尽管它们的代码结构很相似，但是每种设计模式的意图是不同的。就拿比较相似的代理模式和装饰器模式来说吧，<strong>代理模式中，代理类附加的是跟原始类无关的功能，而在装饰器模式中，装饰器类附加的是跟原始类相关的增强功能</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 代理模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AProxy</span> <span class="keyword">implements</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IA a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AProxy</span><span class="params">(IA a)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">        a.f();</span><br><span class="line">        <span class="comment">// 新添加的代理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 装饰器模式的代码结构(下面的接口也可以替换成抽象类)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ADecorator</span> <span class="keyword">implements</span> <span class="title">IA</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> IA a;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ADecorator</span><span class="params">(IA a)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 功能增强代码</span></span><br><span class="line">        a.f();</span><br><span class="line">        <span class="comment">// 功能增强代码</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>实际上，如果去查看 JDK 的源码，你会发现，<strong>BufferedInputStream、DataInputStream 并非继承自 InputStream，而是另外一个叫 FilterInputStream 的类</strong>。因为对于即便是不需要增加缓存功能的函数来说，BufferedInputStream 还是必须把它重新实现一遍，简单包裹对 InputStream 对象的函数调用。如果不重新实现，那 BufferedInputStream 类就无法将最终读取数据的任务，委托给传递进来的 InputStream 对象来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferedInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// f() 函数不需要增强，只是重新调用一下 InputStream in 对象的 f()</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">f</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        in.f();</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，DataInputStream 也存在跟 BufferedInputStream 同样的问题。<strong>为了避免代码重复，Java IO 抽象出了一个装饰器父类 FilterInputStream</strong>。InputStream 的所有的装饰器类都继承自这个装饰器父类。这样，装饰器类只需要实现它需要增强的方法就可以了，其他方法继承装饰器父类的默认实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FilterInputStream</span> <span class="keyword">extends</span> <span class="title">InputStream</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">volatile</span> InputStream in;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">FilterInputStream</span><span class="params">(InputStream in)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.in = in;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.read();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[])</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> read(b, <span class="number">0</span>, b.length);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.read(b, off, len);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.skip(n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">available</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.available();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        in.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">mark</span><span class="params">(<span class="keyword">int</span> readLimit)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        in.mark(readLimit);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        in.reset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">markSupported</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> in.markSupported();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Bridge Design Pattern</title>
      <link href="2020/12/05/Bridge-Design-Pattern/"/>
      <url>2020/12/05/Bridge-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="桥接模式的原理解析"><a href="#桥接模式的原理解析" class="headerlink" title="桥接模式的原理解析"></a>桥接模式的原理解析</h2><p><code>桥接模式</code>（Bridge Design Pattern）的定义：</p><blockquote><p>Decouple an abstraction from its implementation so that the two can vary independently. – GoF</p></blockquote><p>翻译成中文就是：<strong>将抽象和实现解耦，让它们可以独立变化</strong>。GoF 给出的定义非常的简短，单凭这一句话，估计没几个人能看懂是什么意思。所以，我们通过 JDBC 驱动的例子来解释一下。<strong>JDBC 驱动是桥接模式的经典应用</strong>。我们先来看一下，如何利用 JDBC 驱动来查询数据库。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>); <span class="comment">// 加载及注册 JDBC 驱动程序</span></span><br><span class="line">String url = <span class="string">"jdbc:mysql://localhost:3306/sample_db?user=root&amp;password=your_password"</span>;</span><br><span class="line">Connection con = DriverManager.getConnection(url);</span><br><span class="line">Statement stmt = con.createStatement()；</span><br><span class="line">String query = <span class="string">"select * from test"</span>;</span><br><span class="line">ResultSet rs = stmt.executeQuery(query);</span><br><span class="line"><span class="keyword">while</span>(rs.next()) </span><br><span class="line">&#123;</span><br><span class="line">    rs.getString(<span class="number">1</span>);</span><br><span class="line">    rs.getInt(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想要把 MySQL 数据库换成 Oracle 数据库，只需要把第一行代码中的 com.mysql.jdbc.Driver 换成 oracle.jdbc.driver.OracleDriver 就可以了。当然，也有更灵活的实现方式，我们可以把需要加载的 Driver 类写到配置文件中，<strong>当程序启动的时候，自动从配置文件中加载</strong>，这样在切换数据库的时候，我们都不需要修改代码，只需要修改配置文件就可以了。</p><p>如此优雅的数据库切换是如何实现的呢？源码之下无秘密，我们先从 com.mysql.jdbc.Driver 这个类的代码看起：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.mysql.jdbc;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span> <span class="keyword">extends</span> <span class="title">NonRegisteringDriver</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">sql</span>.<span class="title">Driver</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            java.sql.DriverManager.registerDriver(<span class="keyword">new</span> Driver());</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (SQLException E) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can't register driver!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Construct a new driver and register it with DriverManager</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> SQLException if a database error occurs.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Driver</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Required for Class.forName().newInstance()</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结合 com.mysql.jdbc.Driver 的代码实现，我们可以发现，当执行 Class.forName(“com.mysql.jdbc.Driver”) 这条语句的时候，实际上是做了两件事情：</p><ol><li>要求 JVM 查找并加载指定的 Driver 类；</li><li>执行该类的静态代码，也就是将 MySQL Driver 注册到 DriverManager 类中；</li></ol><p>当我们把具体的 Driver 实现类（比如，com.mysql.jdbc.Driver）注册到 DriverManager 之后，后续所有对 JDBC 接口的调用，都会委派到对具体的 Driver 实现类来执行。而 <strong>Driver 实现类都实现了相同的接口（java.sql.Driver ）</strong>，这也是可以灵活切换 Driver 的原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DriverManager</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> CopyOnWriteArrayList&lt;DriverInfo&gt; registeredDrivers = <span class="keyword">new</span> CopyOnWriteArrayList&lt;DriverInfo&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        loadInitialDrivers();</span><br><span class="line">        println(<span class="string">"JDBC DriverManager initialized"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">registerDriver</span><span class="params">(java.sql.Driver driver)</span> <span class="keyword">throws</span> SQLException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (driver != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            registeredDrivers.addIfAbsent(<span class="keyword">new</span> DriverInfo(driver));</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">(String url, String user, String password)</span> <span class="keyword">throws</span> SQLException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        java.util.Properties info = <span class="keyword">new</span> java.util.Properties();</span><br><span class="line">        <span class="keyword">if</span> (user != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            info.put(<span class="string">"user"</span>, user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            info.put(<span class="string">"password"</span>, password);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (getConnection(url, info, Reflection.getCallerClass()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，JDBC 本身就相当于“抽象”。注意，这里所说的“抽象”，指的并非“抽象类”或“接口”，而是跟具体的数据库无关的、被抽象出来的一套“类库”。具体的 Driver（比如，com.mysql.jdbc.Driver）就相当于“实现”。注意，这里所说的“实现”，也并非指“接口的实现类”，而是跟具体数据库相关的一套“类库”。<strong>JDBC 和 Driver 独立开发，通过对象之间的组合关系，组装在一起</strong>。JDBC 的所有逻辑操作，最终都委托给 Driver 来执行：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/12.png" alt></p><h2 id="桥接模式的应用举例"><a href="#桥接模式的应用举例" class="headerlink" title="桥接模式的应用举例"></a>桥接模式的应用举例</h2><p>一个 API 接口监控告警的例子：根据不同的告警规则，触发不同类型的告警。告警支持多种通知渠道，包括：邮件、短信、微信、自动语音电话。通知的紧急程度有多种类型，包括：SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要）。不同的紧急程度对应不同的通知渠道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> NotificationEmergencyLevel </span><br><span class="line">&#123;</span><br><span class="line">    SEVERE, URGENCY, NORMAL, TRIVIAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; emailAddresses;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; telephones;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; wechatIds;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setEmailAddress</span><span class="params">(List&lt;String&gt; emailAddress)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.emailAddresses = emailAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTelephones</span><span class="params">(List&lt;String&gt; telephones)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.telephones = telephones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWechatIds</span><span class="params">(List&lt;String&gt; wechatIds)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.wechatIds = wechatIds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(NotificationEmergencyLevel level, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (level.equals(NotificationEmergencyLevel.SEVERE)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...自动语音电话</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (level.equals(NotificationEmergencyLevel.URGENCY)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...发微信</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (level.equals(NotificationEmergencyLevel.NORMAL)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...发邮件</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (level.equals(NotificationEmergencyLevel.TRIVIAL)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...发邮件</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在 API 监控告警的例子中，我们如下方式来使用 Notification 类：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(rule, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) </span><br><span class="line">        &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Notification 类的代码实现有一个最明显的问题，那就是有很多 if-else 分支逻辑。实际上，<strong>如果每个分支中的代码都不复杂，后期也没有无限膨胀的可能</strong>，那这样的设计问题并不大，没必要非得一定要摒弃 if-else 分支逻辑。不过，Notification 的代码显然不符合这个条件。因为每个 if-else 分支中的代码逻辑都比较复杂，发送通知的所有逻辑都扎堆在 Notification 类中。很多设计模式都是试图<strong>将庞大的类拆分成更细小的类，然后再通过某种更合理的结构组装在一起</strong>。</p><p>针对 Notification 的代码，我们将不同渠道的发送逻辑剥离出来，形成独立的消息发送类 – MsgSender。其中，<strong>Notification 类相当于抽象，MsgSender 类相当于实现</strong>，两者可以独立开发，通过组合关系（也就是桥梁）任意组合在一起。所谓任意组合的意思就是，不同紧急程度的消息和发送渠道之间的对应关系，不是在代码中固定写死的，我们可以动态地去指定：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MsgSender</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TelephoneMsgSender</span> <span class="keyword">implements</span> <span class="title">MsgSender</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; telephones;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TelephoneMsgSender</span><span class="params">(List&lt;String&gt; telephones)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.telephones = telephones;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EmailMsgSender</span> <span class="keyword">implements</span> <span class="title">MsgSender</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 与 TelephoneMsgSender 代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WechatMsgSender</span> <span class="keyword">implements</span> <span class="title">MsgSender</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 与 TelephoneMsgSender 代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> MsgSender msgSender;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MsgSender msgSender)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.msgSender = msgSender;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SevereNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SevereNotification</span><span class="params">(MsgSender msgSender)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(msgSender);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notify</span><span class="params">(String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        msgSender.send(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UrgencyNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 与 SevereNotification 代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NormalNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 与 SevereNotification 代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TrivialNotification</span> <span class="keyword">extends</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 与 SevereNotification 代码结构类似，所以省略...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Proxy Design Pattern</title>
      <link href="2020/12/02/Proxy-Design-Pattern/"/>
      <url>2020/12/02/Proxy-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="代理模式的原理解析"><a href="#代理模式的原理解析" class="headerlink" title="代理模式的原理解析"></a>代理模式的原理解析</h2><p><code>代理模式</code>（Proxy Design Pattern）的原理和代码实现都不难掌握。它在不改变原始类（或叫被代理类）代码的情况下，通过<strong>引入代理类来给原始类附加功能</strong>。</p><p>我们开发了一个性能计数器 – MetricsCollector 类，在业务系统中，我们采用如下方式来使用这个 MetricsCollector 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="keyword">private</span> MetricsCollector metricsCollector; <span class="comment">// 依赖注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...省略 login 逻辑...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">        RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"login"</span>, responseTime, startTimestamp);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...返回 UserVo 数据...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...省略 register 逻辑...</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">        RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"register"</span>, responseTime, startTimestamp);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...返回 UserVo 数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面的写法有两个问题：</p><ol><li>性能计数器框架代码侵入到业务代码中，跟业务代码高度耦合。如果未来需要替换这个框架，那替换的成本会比较大；</li><li>收集接口请求的代码跟业务代码无关，本就不应该放到一个类中。业务类最好职责更加单一，只聚焦业务处理；</li></ol><p>为了<strong>将框架代码和业务代码解耦</strong>，代理模式就派上用场了。代理类 UserControllerProxy 和原始类 UserController 实现相同的接口 IUserController。UserController 类只负责业务功能。代理类 UserControllerProxy 负责在业务代码执行前后附加其他逻辑代码，并通过<code>委托</code>的方式调用原始类来执行业务代码。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IUserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">    <span class="function">UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略 login 逻辑...</span></span><br><span class="line">        <span class="comment">//...返回 UserVo 数据...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略 register 逻辑...</span></span><br><span class="line">        <span class="comment">//...返回 UserVo 数据...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">implements</span> <span class="title">IUserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line">    <span class="keyword">private</span> UserController userController;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">(UserController userController)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userController = userController;</span><br><span class="line">        <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 委托</span></span><br><span class="line">        UserVo userVo = userController.login(telephone, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">        RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"login"</span>, responseTime, startTimestamp);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 委托</span></span><br><span class="line">        UserVo userVo = userController.register(telephone, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">        RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"register"</span>, responseTime, startTimestamp);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// UserControllerProxy 使用举例</span></span><br><span class="line"><span class="comment">// 因为原始类和代理类实现相同的接口，是基于接口而非实现编程</span></span><br><span class="line"><span class="comment">// 将 UserController 类对象替换为 UserControllerProxy 类对象，不需要改动太多代码</span></span><br><span class="line">IUserController userController = <span class="keyword">new</span> UserControllerProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>但是，如果<strong>原始类并没有定义接口，并且原始类代码并不是我们开发维护的</strong>（比如它来自一个第三方的类库），我们也没办法直接修改原始类，给它重新定义一个接口。对于这种外部类的扩展，我们一般都是采用<code>继承</code>的方式。这里也不例外。我们让代理类继承原始类，然后扩展附加功能。具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserControllerProxy</span> <span class="keyword">extends</span> <span class="title">UserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">UserControllerProxy</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">login</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        UserVo userVo = <span class="keyword">super</span>.login(telephone, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">        RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"login"</span>, responseTime, startTimestamp);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">register</span><span class="params">(String telephone, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        UserVo userVo = <span class="keyword">super</span>.register(telephone, password);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">        RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(<span class="string">"register"</span>, responseTime, startTimestamp);</span><br><span class="line">        metricsCollector.recordRequest(requestInfo);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// UserControllerProxy 使用举例</span></span><br><span class="line">UserController userController = <span class="keyword">new</span> UserControllerProxy();</span><br></pre></td></tr></table></figure><h2 id="动态代理的原理解析"><a href="#动态代理的原理解析" class="headerlink" title="动态代理的原理解析"></a>动态代理的原理解析</h2><p>刚刚的代码实现还是有点问题：</p><ul><li>我们需要在代理类中，将原始类中的所有的方法，都重新实现一遍，并且为每个方法都附加相似的代码逻辑；</li><li>如果要添加的附加功能的类有不止一个，我们需要针对每个类都创建一个代理类；</li></ul><p>我们可以使用动态代理来解决这个问题。所谓<code>动态代理</code>（Dynamic Proxy），就是我们不事先为每个原始类编写代理类，而是<strong>在运行的时候，动态地创建原始类对应的代理类</strong>，然后在系统中用代理类替换掉原始类。如果你熟悉的是 Java 语言，实现动态代理就是件很简单的事情。因为 Java 语言本身就已经提供了动态代理的语法（实际上，动态代理底层依赖的就是 Java 的<code>反射语法</code>）。其中，MetricsCollectorProxy 作为一个动态代理类，动态地给每个需要收集接口请求信息的类创建代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MetricsCollectorProxy</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MetricsCollector metricsCollector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MetricsCollectorProxy</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.metricsCollector = <span class="keyword">new</span> MetricsCollector();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">createProxy</span><span class="params">(Object proxyObject)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Class&lt;?&gt;[] interfaces = proxyObject.getClass().getInterfaces();</span><br><span class="line">        DynamicProxyHandler handler = <span class="keyword">new</span> DynamicProxyHandler(proxyObject);</span><br><span class="line">        <span class="keyword">return</span> Proxy.newProxyInstance(proxyObject.getClass().getClassLoader(), interfaces, handler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicProxyHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> Object proxyObject;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">DynamicProxyHandler</span><span class="params">(Object proxyObject)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.proxyObject = proxyObject;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">long</span> startTimestamp = System.currentTimeMillis();</span><br><span class="line">            Object result = method.invoke(proxyObject, args);</span><br><span class="line">            <span class="keyword">long</span> endTimeStamp = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">long</span> responseTime = endTimeStamp - startTimestamp;</span><br><span class="line">            String apiName = proxyObject.getClass().getName() + <span class="string">":"</span> + method.getName();</span><br><span class="line">            RequestInfo requestInfo = <span class="keyword">new</span> RequestInfo(apiName, responseTime, startTimestamp);</span><br><span class="line">            metricsCollector.recordRequest(requestInfo);</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// MetricsCollectorProxy 使用举例</span></span><br><span class="line">MetricsCollectorProxy proxy = <span class="keyword">new</span> MetricsCollectorProxy();</span><br><span class="line">IUserController userController = (IUserController) proxy.createProxy(<span class="keyword">new</span> UserController());</span><br></pre></td></tr></table></figure><p>实际上，<strong>Spring AOP 底层的实现原理就是基于动态代理</strong>。用户配置好需要给哪些类创建代理，并定义好在执行原始类的业务代码前后执行哪些附加功能。Spring 为这些类创建动态代理对象，并在 JVM 中替代原始类对象。<strong>原本在代码中执行的原始类的方法，被换作执行代理类的方法</strong>，也就实现了给原始类添加附加功能的目的。</p><h2 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h2><p>代理模式的应用场景非常多，我这里列举一些比较常见的用法。</p><h3 id="业务系统的非功能性需求开发"><a href="#业务系统的非功能性需求开发" class="headerlink" title="业务系统的非功能性需求开发"></a>业务系统的非功能性需求开发</h3><p>代理模式最常用的一个应用场景就是，在业务系统中开发一些非功能性需求，比如：监控、统计、鉴权、限流、事务、幂等、日志。我们<strong>将这些附加功能与业务功能解耦，放到代理类中统一处理</strong>，让程序员只需要关注业务方面的开发。</p><h3 id="代理模式在-RPC、缓存中的应用"><a href="#代理模式在-RPC、缓存中的应用" class="headerlink" title="代理模式在 RPC、缓存中的应用"></a>代理模式在 RPC、缓存中的应用</h3><p>实际上，<strong>RPC 框架也可以看作一种代理模式</strong>。客户端在使用 RPC 服务的时候，就像使用本地函数一样，无需了解跟服务器交互的细节。除此之外，RPC 服务的开发者也只需要开发业务逻辑，就像开发本地使用的函数一样，不需要关注跟客户端的交互细节。</p><p>我们再来看代理模式在缓存中的应用。假设我们要开发一个接口请求的缓存功能，对于某些接口请求，如果入参相同，在设定的过期时间内，直接返回缓存结果，而不用重新进行逻辑处理。比如，针对获取用户个人信息的需求，我们可以<strong>开发两个接口，一个支持缓存，一个支持实时查询</strong>。对于需要实时数据的需求，我们让其调用实时查询接口，对于不需要实时数据的需求，我们让其调用支持缓存的接口。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Prototype Design Pattern</title>
      <link href="2020/11/29/Prototype-Design-Pattern/"/>
      <url>2020/11/29/Prototype-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="原型模式的原理与应用"><a href="#原型模式的原理与应用" class="headerlink" title="原型模式的原理与应用"></a>原型模式的原理与应用</h2><p>如果<strong>对象的创建成本比较大，而同一个类的不同对象之间差别不大</strong>（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作<code>原型设计模式</code>（Prototype Design Pattern），简称原型模式。</p><p>实际上，<strong>创建对象包含的申请内存、给成员变量赋值这一过程</strong>，本身并不会花费太多时间，或者说对于大部分业务系统来说，这点时间完全是可以忽略的。应用一个复杂的模式，只得到一点点的性能提升，这就是所谓的过度设计，得不偿失。但是，如果<strong>对象中的数据需要经过复杂的计算才能得到</strong>（比如排序、计算哈希值），或者需要从 RPC、网络、数据库、文件系统等非常慢速的 IO 中读取，这种情况下，我们就可以利用原型模式，从其他已有对象中直接拷贝得到，而不用每次在创建新对象的时候，都重复执行这些耗时的操作。</p><p>假设数据库中存储了大约 10 万条“搜索关键词”信息，每条信息包含关键词、关键词被搜索的次数、信息最近被更新的时间等。系统 A 在启动的时候会加载这份数据到内存中，用于处理某些其他的业务需求。为了方便快速地查找某个关键词对应的信息，我们<strong>给关键词建立一个散列表索引</strong>。如果你熟悉的是 Java 语言，可以直接使用语言中提供的 HashMap 容器来实现。其中，HashMap 的 key 为搜索关键词，value 为关键词详细信息（比如搜索次数）。我们只需要将数据从数据库中读取出来，放入 HashMap 就可以了。</p><p>不过，我们还有另外一个系统 B，专门用来分析搜索日志，定期（比如间隔 10 分钟）批量地更新数据库中的数据，并且标记为新的数据版本。比如，在下面的示例图中，我们对 v2 版本的数据进行更新，得到 v3 版本的数据。这里我们假设只有更新和新添关键词，没有删除关键词的行为：</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/08.png" alt></p><p>为了保证系统 A 中数据的实时性（不一定非常实时，但数据也不能太旧），系统 A 需要定期根据数据库中的数据，更新内存中的索引和数据。我们只需要在系统 A 中，记录当前数据的版本 Va 对应的更新时间 Ta，从数据库中捞出更新时间大于 Ta 的所有搜索关键词，也就是<strong>找出 Va 版本与最新版本数据的差集</strong>，然后针对差集中的每个关键词进行处理。如果它已经在散列表中存在了，我们就更新相应的搜索次数、更新时间等信息；如果它在散列表中不存在，我们就将它插入到散列表中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, SearchWord&gt; currentKeywords = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 从数据库中取出更新时间 &gt; lastUpdateTime 的数据，放入到 currentKeywords 中</span></span><br><span class="line">        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">        <span class="keyword">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class="line">        <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) </span><br><span class="line">            &#123;</span><br><span class="line">                maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (currentKeywords.containsKey(searchWord.getKeyword())) </span><br><span class="line">            &#123;</span><br><span class="line">                currentKeywords.replace(searchWord.getKeyword(), searchWord);</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                currentKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">(<span class="keyword">long</span> lastUpdateTime)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间 &gt; lastUpdateTime 的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，现在，我们有一个特殊的要求：任何时刻，系统 A 中的<strong>所有数据都必须是同一个版本的</strong>，要么都是版本 a，要么都是版本 b，不能有的是版本 a，有的是版本 b。那刚刚的更新方式就不能满足这个要求了。除此之外，我们还要求：在更新内存数据的时候，系统 A 不能处于不可用状态，也就是<strong>不能停机更新数据</strong>。</p><p>我们把正在使用的数据的版本定义为“服务版本”，当我们要更新内存中的数据的时候，我们并不是直接在服务版本（假设是版本 a 数据）上更新，而是重新创建另一个版本数据（假设是版本 b 数据），<strong>等新的版本数据建好之后，再一次性地将服务版本从版本 a 切换到版本 b</strong>。这样既保证了数据一直可用，又避免了中间状态的存在：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HashMap&lt;String, SearchWord&gt; newKeywords = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数据库中取出所有的数据，放入到 newKeywords 中</span></span><br><span class="line">        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords();</span><br><span class="line">        <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) </span><br><span class="line">        &#123;</span><br><span class="line">            newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentKeywords = newKeywords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出所有的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，在上面的代码实现中，<strong>newKeywords 构建的成本比较高</strong>。我们需要将这 10 万条数据从数据库中读出，然后计算哈希值，构建 newKeywords。我们拷贝 currentKeywords 数据到 newKeywords 中，然后从数据库中只捞出新增或者有更新的关键词，更新到 newKeywords 中。而相对于 10 万条数据来说，<strong>每次新增或者更新的关键词个数是比较少的</strong>，所以，这种策略大大提高了数据更新的效率：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 原型模式就这么简单，拷贝已有对象的数据，更新少量差值</span></span><br><span class="line">        HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数据库中取出更新时间 &gt; lastUpdateTime 的数据，放入到 newKeywords 中</span></span><br><span class="line">        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">        <span class="keyword">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class="line">        <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) </span><br><span class="line">            &#123;</span><br><span class="line">                maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) </span><br><span class="line">            &#123;</span><br><span class="line">                SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());</span><br><span class="line">                oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">        currentKeywords = newKeywords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">(<span class="keyword">long</span> lastUpdateTime)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间 &gt; lastUpdateTime 的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里我们利用了 Java 中的 clone() 语法来复制一个对象。如果你熟悉的语言没有这个语法，那把数据从 currentKeywords 中一个个取出来，然后再重新计算哈希值，放入到 newKeywords 中也是可以接受的。毕竟，最耗时的还是从数据库中取数据的操作。<strong>相对于数据库的 IO 操作来说，内存操作和 CPU 计算的耗时都是可以忽略的</strong>。</p><h2 id="原型模式的实现方式：深拷贝和浅拷贝"><a href="#原型模式的实现方式：深拷贝和浅拷贝" class="headerlink" title="原型模式的实现方式：深拷贝和浅拷贝"></a>原型模式的实现方式：深拷贝和浅拷贝</h2><p>我们来看，在内存中，用散列表组织的搜索关键词信息是如何存储的。从图中我们可以发现，散列表索引中，每个结点存储的 key 是搜索关键词，value 是 SearchWord 对象的内存地址。<strong>SearchWord 对象本身存储在散列表之外的内存空间中</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/09.png" alt></p><p>浅拷贝和深拷贝的区别在于，浅拷贝只会复制图中的索引（散列表），不会复制数据（SearchWord 对象）本身。相反，<strong>深拷贝不仅仅会复制索引，还会复制数据本身</strong>。浅拷贝得到的对象（newKeywords）跟原始对象（currentKeywords）共享数据，而深拷贝得到的是一份完完全全独立的对象。具体的对比如下图所示：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/10.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/11.png" alt></p><p>在上面的代码中，我们通过调用 HashMap 上的 clone() 浅拷贝方法来实现原型模式。当我们通过 newKeywords 更新 SearchWord 对象的时候，newKeywords 和 currentKeywords 因为指向相同的一组 SearchWord 对象，就会<strong>导致 currentKeywords 中指向的 SearchWord，有的是老版本的，有的是新版本的</strong>，就没法满足我们之前的需求：currentKeywords 中的数据在任何时刻都是同一个版本的，不存在介于老版本与新版本之间的中间状态。</p><p>我们可以将浅拷贝替换为深拷贝。newKeywords 不仅仅复制 currentKeywords 的索引，还把 SearchWord 对象也复制一份出来，这样 newKeywords 和 currentKeywords 就指向不同的 SearchWord 对象，也就不存在更新 newKeywords 的数据会导致 currentKeywords 的数据也被更新的问题了：</p><ul><li><p>递归拷贝对象、对象的引用对象以及引用对象的引用对象…<strong>直到要拷贝的对象只包含基本数据类型数据，没有引用对象为止</strong>。根据这个思路对之前的代码进行重构。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Deep copy</span></span><br><span class="line">        HashMap&lt;String, SearchWord&gt; newKeywords = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (HashMap.Entry&lt;String, SearchWord&gt; e : currentKeywords.entrySet()) </span><br><span class="line">        &#123;</span><br><span class="line">            SearchWord searchWord = e.getValue();</span><br><span class="line">            SearchWord newSearchWord = <span class="keyword">new</span> SearchWord(searchWord.getKeyword(), searchWord.getCount(), searchWord.getLastUpdateTime());</span><br><span class="line">            newKeywords.put(e.getKey(), newSearchWord);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数据库中取出更新时间 &gt; lastUpdateTime 的数据，放入到 newKeywords 中</span></span><br><span class="line">        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">        <span class="keyword">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class="line">        <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) </span><br><span class="line">            &#123;</span><br><span class="line">                maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) </span><br><span class="line">            &#123;</span><br><span class="line">                SearchWord oldSearchWord = newKeywords.get(searchWord.getKeyword());</span><br><span class="line">                oldSearchWord.setCount(searchWord.getCount());</span><br><span class="line">                oldSearchWord.setLastUpdateTime(searchWord.getLastUpdateTime());</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">        currentKeywords = newKeywords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">(<span class="keyword">long</span> lastUpdateTime)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间 &gt; lastUpdateTime 的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>先将对象序列化，然后再反序列化成新的对象</strong>。具体的示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">deepCopy</span><span class="params">(Object object)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ByteArrayOutputStream bo = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    ObjectOutputStream oo = <span class="keyword">new</span> ObjectOutputStream(bo);</span><br><span class="line">    oo.writeObject(object);</span><br><span class="line">    </span><br><span class="line">    ByteArrayInputStream bi = <span class="keyword">new</span> ByteArrayInputStream(bo.toByteArray());</span><br><span class="line">    ObjectInputStream oi = <span class="keyword">new</span> ObjectInputStream(bi);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> oi.readObject();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>这两种实现方法，不管采用哪种，<strong>深拷贝都要比浅拷贝耗时、耗内存空间</strong>。我们可以先采用浅拷贝的方式创建 newKeywords。<strong>对于需要更新的 SearchWord 对象，我们再使用深度拷贝的方式创建一份新的对象</strong>，替换 newKeywords 中的老对象。毕竟需要更新的数据是很少的。这种方式即利用了浅拷贝节省时间、空间的优点，又能保证 currentKeywords 中的中数据都是老版本的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;String, SearchWord&gt; currentKeywords=<span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastUpdateTime = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Shallow copy</span></span><br><span class="line">        HashMap&lt;String, SearchWord&gt; newKeywords = (HashMap&lt;String, SearchWord&gt;) currentKeywords.clone();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从数据库中取出更新时间 &gt; lastUpdateTime 的数据，放入到 newKeywords 中</span></span><br><span class="line">        List&lt;SearchWord&gt; toBeUpdatedSearchWords = getSearchWords(lastUpdateTime);</span><br><span class="line">        <span class="keyword">long</span> maxNewUpdatedTime = lastUpdateTime;</span><br><span class="line">        <span class="keyword">for</span> (SearchWord searchWord : toBeUpdatedSearchWords) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (searchWord.getLastUpdateTime() &gt; maxNewUpdatedTime) </span><br><span class="line">            &#123;</span><br><span class="line">                maxNewUpdatedTime = searchWord.getLastUpdateTime();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (newKeywords.containsKey(searchWord.getKeyword())) </span><br><span class="line">            &#123;</span><br><span class="line">                newKeywords.remove(searchWord.getKeyword());</span><br><span class="line">            &#125;</span><br><span class="line">            newKeywords.put(searchWord.getKeyword(), searchWord);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        lastUpdateTime = maxNewUpdatedTime;</span><br><span class="line">        currentKeywords = newKeywords;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> List&lt;SearchWord&gt; <span class="title">getSearchWords</span><span class="params">(<span class="keyword">long</span> lastUpdateTime)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> 从数据库中取出更新时间 &gt; lastUpdateTime 的数据</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Builder Design Pattern</title>
      <link href="2020/11/29/Builder-Design-Pattern/"/>
      <url>2020/11/29/Builder-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么需要建造者模式？"><a href="#为什么需要建造者模式？" class="headerlink" title="为什么需要建造者模式？"></a>为什么需要建造者模式？</h2><p>假设有这样一道设计面试题：我们需要定义一个资源池配置类 ResourcePoolConfig。这里的资源池，你可以简单理解为<strong>线程池、连接池、对象池等</strong>。在这个资源池配置类中，有以下几个成员变量，也就是可配置项。现在，请你编写代码实现这个 ResourcePoolConfig 类：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/03.png" alt></p><p>只要你稍微有点开发经验，那实现这样一个类对你来说并不是件难事。因为 maxTotal、maxIdle、minIdle 不是必填变量，所以在创建 ResourcePoolConfig 对象的时候，我们<strong>通过往构造函数中，给这几个参数传递 null 值，来表示使用默认值</strong>：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourcePoolConfig</span><span class="params">(String name, Integer maxTotal, Integer maxIdle, Integer minIdle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(name)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name should not be empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxTotal != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxTotal should be positive."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (maxIdle != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxIdle should not be negative."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minIdle != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"minIdle should not be negative."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略 getter 方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，ResourcePoolConfig 只有 4 个可配置项，对应到构造函数中，也只有 4 个参数，参数的个数不多。但是，如果可配置项逐渐增多，变成了 8 个、10 个，甚至更多，那继续沿用现在的设计思路，<strong>构造函数的参数列表会变得很长，代码在可读性和易用性上都会变差</strong>。在使用构造函数的时候，我们就容易<strong>搞错各参数的顺序，传递进错误的参数值</strong>，导致非常隐蔽的 bug：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数太多，导致可读性差、参数可能传递错误</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig(<span class="string">"dbConnectionPool"</span>, <span class="number">16</span>, <span class="keyword">null</span>, <span class="number">8</span>, <span class="keyword">null</span>, <span class="keyword">false</span> , <span class="keyword">true</span>, <span class="number">10</span>, <span class="number">20</span>，<span class="keyword">false</span>， <span class="keyword">true</span>);</span><br></pre></td></tr></table></figure><p>解决这个问题的办法你应该也已经想到了，那就是<strong>用 set() 函数来给成员变量赋值，以替代冗长的构造函数</strong>。其中，配置项 name 是必填的，所以我们把它放到构造函数中设置，强制创建类对象的时候就要填写。其他配置项 maxTotal、maxIdle、minIdle 都不是必填的，所以我们通过 set() 函数来设置，让使用者自主选择填写或者不填写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ResourcePoolConfig</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(name)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"name should not be empty."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxTotal should be positive."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxIdle should not be negative."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"minIdle should not be negative."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略 getter 方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来，我们来看新的 ResourcePoolConfig 类该如何使用。<strong>没有了冗长的函数调用和参数列表</strong>，代码在可读性和易用性上提高了很多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ResourcePoolConfig 使用举例</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig(<span class="string">"dbConnectionPool"</span>);</span><br><span class="line">config.setMaxTotal(<span class="number">16</span>);</span><br><span class="line">config.setMaxIdle(<span class="number">8</span>);</span><br></pre></td></tr></table></figure><p>至此，我们仍然没有用到建造者模式，<strong>通过构造函数设置必填项，通过 set() 方法设置可选配置项</strong>，就能实现我们的设计需求。如果我们把问题的难度再加大点，比如，还需要解决下面这三个问题，那现在的设计思路就不能满足了：</p><ul><li>如果<strong>必填的配置项有很多</strong>，把这些必填配置项都放到构造函数中设置，那构造函数就又会出现参数列表很长的问题。如果我们把必填项也通过 set() 方法设置，那校验这些必填项是否已经填写的逻辑就无处安放了；</li><li>假设<strong>配置项之间有一定的依赖关系</strong>，比如，如果用户设置了 maxTotal、maxIdle、minIdle 其中一个，就必须显式地设置另外两个；或者配置项之间有一定的约束条件，比如，maxIdle 和 minIdle 要小于等于 maxTotal。如果我们继续使用现在的设计思路，那这些配置项之间的依赖关系或者约束条件的校验逻辑就无处安放了；</li><li>如果我们希望 <strong>ResourcePoolConfig 类对象是不可变对象</strong>，也就是说，对象在创建好之后，就不能再修改内部的属性值。要实现这个功能，我们就不能在 ResourcePoolConfig 类中暴露 set() 方法；</li></ul><p>我们可以把校验逻辑放置到 Builder 类中，先创建建造者，并且通过 set() 方法设置建造者的变量值，然后在使用 build() 方法真正创建对象之前，<strong>做集中的校验，校验通过之后才会创建对象</strong>。除此之外，我们<strong>把 ResourcePoolConfig 的构造函数改为 private 私有权限</strong>。这样我们就只能通过建造者来创建 ResourcePoolConfig 类对象。并且，ResourcePoolConfig 没有提供任何 set() 方法，这样我们创建出来的对象就是不可变对象了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ResourcePoolConfig</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxIdle;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> minIdle;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ResourcePoolConfig</span><span class="params">(Builder builder)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = builder.name;</span><br><span class="line">        <span class="keyword">this</span>.maxTotal = builder.maxTotal;</span><br><span class="line">        <span class="keyword">this</span>.maxIdle = builder.maxIdle;</span><br><span class="line">        <span class="keyword">this</span>.minIdle = builder.minIdle;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略 getter 方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 我们将 Builder 类设计成了 ResourcePoolConfig 的内部类</span></span><br><span class="line">    <span class="comment">// 我们也可以将 Builder 类设计成独立的非内部类 ResourcePoolConfigBuilder</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Builder</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_TOTAL = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_IDLE = <span class="number">8</span>;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MIN_IDLE = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxTotal = DEFAULT_MAX_TOTAL;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> maxIdle = DEFAULT_MAX_IDLE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> minIdle = DEFAULT_MIN_IDLE;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ResourcePoolConfig <span class="title">build</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">// 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等</span></span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(name)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (maxIdle &gt; maxTotal) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (minIdle &gt; maxTotal || minIdle &gt; maxIdle) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ResourcePoolConfig(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setName</span><span class="params">(String name)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (StringUtils.isBlank(name)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxTotal</span><span class="params">(<span class="keyword">int</span> maxTotal)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (maxTotal &lt;= <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.maxTotal = maxTotal;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMaxIdle</span><span class="params">(<span class="keyword">int</span> maxIdle)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (maxIdle &lt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.maxIdle = maxIdle;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Builder <span class="title">setMinIdle</span><span class="params">(<span class="keyword">int</span> minIdle)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (minIdle &lt; <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"..."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">this</span>.minIdle = minIdle;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这段代码会抛出 IllegalArgumentException，因为 minIdle &gt; maxIdle</span></span><br><span class="line">ResourcePoolConfig config = <span class="keyword">new</span> ResourcePoolConfig.Builder()</span><br><span class="line">    .setName(<span class="string">"dbConnectionPool"</span>)</span><br><span class="line">    .setMaxTotal(<span class="number">16</span>)</span><br><span class="line">    .setMaxIdle(<span class="number">10</span>)</span><br><span class="line">    .setMinIdle(<span class="number">12</span>)</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure><p>使用建造者模式创建对象，<strong>还能避免对象存在无效状态</strong>。我再举个例子解释一下。比如我们定义了一个长方形类，如果不使用建造者模式，采用先创建后 set 的方式，那就会导致在第一个 set 之后，对象处于无效状态：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Rectangle r = <span class="keyword">new</span> Rectangle(); <span class="comment">// r is invalid</span></span><br><span class="line">r.setWidth(<span class="number">2</span>); <span class="comment">// r is invalid</span></span><br><span class="line">r.setHeight(<span class="number">3</span>); <span class="comment">// r is valid</span></span><br></pre></td></tr></table></figure><p>实际上，如果我们并不是很关心对象是否有短暂的无效状态，也不是太在意对象是否是可变的。比如，对象只是用来映射数据库读出来的数据，那我们直接暴露 set() 方法来设置类的成员变量值是完全没问题的。而且，<strong>使用建造者模式来构建对象，代码实际上是有点重复的</strong>，ResourcePoolConfig 类中的成员变量，要在 Builder 类中重新再定义一遍。</p><h2 id="与工厂模式有何区别？"><a href="#与工厂模式有何区别？" class="headerlink" title="与工厂模式有何区别？"></a>与工厂模式有何区别？</h2><p><strong>工厂模式是用来创建不同但是相关类型的对象</strong>（继承同一父类或者接口的一组子类），由给定的参数来决定创建哪种类型的对象。<strong>建造者模式是用来创建一种类型的复杂对象</strong>，通过设置不同的可选参数，定制化地创建不同的对象。网上有一个经典的例子很好地解释了两者的区别：顾客走进一家餐馆点餐，我们利用工厂模式，根据用户不同的选择，来制作不同的食物，比如披萨、汉堡、沙拉。对于披萨来说，用户又有各种配料可以定制，比如奶酪、西红柿、起司，我们通过建造者模式根据用户选择的不同配料来制作披萨。</p><p>实际上，我们也不要太学院派，非得把工厂模式、建造者模式分得那么清楚，我们需要知道的是，<strong>每个模式为什么这么设计，能解决什么问题</strong>。只有了解了这些最本质的东西，我们才能不生搬硬套，才能灵活应用，甚至可以混用各种模式创造出新的模式，来解决特定场景的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Factory Design Pattern</title>
      <link href="2020/11/22/Factory-Design-Pattern/"/>
      <url>2020/11/22/Factory-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h2><p>在下面这段代码中，我们根据配置文件的后缀（json、xml…），选择不同的解析器（JsonRuleConfigParser、XmlRuleConfigParser…），将存储在文件中的配置解析成内存对象 RuleConfig：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">        IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(ruleConfigFileExtension)) </span><br><span class="line">        &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) </span><br><span class="line">        &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) </span><br><span class="line">        &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(ruleConfigFileExtension)) </span><br><span class="line">        &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String configText = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 从 ruleConfigFilePath 文件中读取配置文本到 configText 中</span></span><br><span class="line">        RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如 rule.json，返回 json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>为了让代码逻辑更加清晰，可读性更好，我们要善于<strong>将功能独立的代码块封装成函数</strong>。按照这个设计思路，我们可以将代码中涉及 parser 创建的部分逻辑剥离出来，抽象成 createParser() 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">    IRuleConfigParser parser = createParser(ruleConfigFileExtension);</span><br><span class="line">    <span class="keyword">if</span> (parser == <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String configText = <span class="string">""</span>;</span><br><span class="line">    <span class="comment">// 从 ruleConfigFilePath 文件中读取配置文本到 configText 中</span></span><br><span class="line">    RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">    <span class="keyword">return</span> ruleConfig;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...解析文件名获取扩展名，比如 rule.json，返回 json</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(configFormat)) </span><br><span class="line">    &#123;</span><br><span class="line">        parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(configFormat)) </span><br><span class="line">    &#123;</span><br><span class="line">        parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(configFormat)) </span><br><span class="line">    &#123;</span><br><span class="line">        parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(configFormat)) </span><br><span class="line">    &#123;</span><br><span class="line">        parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parser;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了让类的职责更加单一、代码更加清晰，我们还可以<strong>进一步将 createParser() 函数剥离到一个独立的类中</strong>，让这个类只负责对象的创建。而这个类就是我们现在要讲的简单工厂模式类。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line">        IRuleConfigParser parser = RuleConfigParserFactory.createParser(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parser == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        String configText = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 从 ruleConfigFilePath 文件中读取配置文本到 configText 中</span></span><br><span class="line">        RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如 rule.json，返回 json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        IRuleConfigParser parser = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(configFormat)) </span><br><span class="line">        &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(configFormat)) </span><br><span class="line">        &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(configFormat)) </span><br><span class="line">        &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(configFormat)) </span><br><span class="line">        &#123;</span><br><span class="line">            parser = <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码实现中，我们每次调用 RuleConfigParserFactory 的 createParser() 的时候，都要创建一个新的 parser。实际上，如果 parser 可以复用，<strong>为了节省内存和对象创建的时间，我们可以将 parser 事先创建好缓存起来</strong>。当调用 createParser() 函数的时候，我们从缓存中取出 parser 对象直接使用。</p><p>这有点<strong>类似单例模式和简单工厂模式的结合</strong>，具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, RuleConfigParser&gt; cachedParsers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        cachedParsers.put(<span class="string">"json"</span>, <span class="keyword">new</span> JsonRuleConfigParser());</span><br><span class="line">        cachedParsers.put(<span class="string">"xml"</span>, <span class="keyword">new</span> XmlRuleConfigParser());</span><br><span class="line">        cachedParsers.put(<span class="string">"yaml"</span>, <span class="keyword">new</span> YamlRuleConfigParser());</span><br><span class="line">        cachedParsers.put(<span class="string">"properties"</span>, <span class="keyword">new</span> PropertiesRuleConfigParser());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParser <span class="title">createParser</span><span class="params">(String configFormat)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (configFormat == <span class="keyword">null</span> || configFormat.isEmpty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// 返回 null 还是 IllegalArgumentException 全凭你自己说了算</span></span><br><span class="line">        &#125;</span><br><span class="line">        IRuleConfigParser parser = cachedParsers.get(configFormat.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> parser;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于上面两种简单工厂模式的实现方法，如果我们要添加新的 parser，那势必要改动到 RuleConfigParserFactory 的代码，那这是不是违反开闭原则呢？实际上，如果<strong>不是需要频繁地添加新的 parser</strong>，只是偶尔修改一下 RuleConfigParserFactory 代码，稍微不符合开闭原则，也是完全可以接受的。</p><p>除此之外，在 RuleConfigParserFactory 的第一种代码实现中，有一组 if 分支判断逻辑，是不是应该用多态或其他设计模式来替代呢？实际上，<strong>如果 if 分支并不是很多，代码中有 if 分支也是完全可以接受的</strong>。应用多态或设计模式来替代 if 分支判断逻辑，也并不是没有任何缺点的，它虽然提高了代码的扩展性，更加符合开闭原则，但也<strong>增加了类的个数，牺牲了代码的可读性</strong>。</p><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><p>如果我们非得要将 if 分支逻辑去掉，那该怎么办呢？比较经典处理方法就是利用<code>多态</code>。按照多态的实现思路，对上面的代码进行重构：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IRuleConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">IRuleConfigParser <span class="title">createParser</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">YamlRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> YamlRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PropertiesRuleConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IRuleConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createParser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PropertiesRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，这就是<strong>工厂方法模式的典型代码实现</strong>。这样当我们新增一种 parser 的时候，只需要新增一个实现了 IRuleConfigParserFactory 接口的 Factory 类即可。所以，<strong>工厂方法模式比起简单工厂模式更加符合开闭原则</strong>。</p><p>从上面的工厂方法的实现来看，一切都很完美，但是实际上存在挺大的问题。<strong>问题存在于这些工厂类的使用上</strong>。接下来，我们看一下，如何用这些工厂类来实现 RuleConfigSource 的 load() 函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">        IRuleConfigParserFactory parserFactory = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"json"</span>.equalsIgnoreCase(ruleConfigFileExtension)) </span><br><span class="line">        &#123;</span><br><span class="line">            parserFactory = <span class="keyword">new</span> JsonRuleConfigParserFactory();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"xml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) </span><br><span class="line">        &#123;</span><br><span class="line">            parserFactory = <span class="keyword">new</span> XmlRuleConfigParserFactory();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"yaml"</span>.equalsIgnoreCase(ruleConfigFileExtension)) </span><br><span class="line">        &#123;</span><br><span class="line">            parserFactory = <span class="keyword">new</span> YamlRuleConfigParserFactory();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"properties"</span>.equalsIgnoreCase(ruleConfigFileExtension)) </span><br><span class="line">        &#123;</span><br><span class="line">            parserFactory = <span class="keyword">new</span> PropertiesRuleConfigParserFactory();</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">        &#125;</span><br><span class="line">        IRuleConfigParser parser = parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">        String configText = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 从 ruleConfigFilePath 文件中读取配置文本到 configText 中</span></span><br><span class="line">        RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如 rule.json，返回 json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码实现来看，工厂类对象的创建逻辑又耦合进了 load() 函数中，跟我们最初的代码版本非常相似，引入工厂方法非但没有解决问题，反倒让设计变得更加复杂了。我们<strong>可以为工厂类再创建一个简单工厂</strong>，也就是工厂的工厂，用来创建工厂类对象。其中，RuleConfigParserFactoryMap 类是创建工厂对象的工厂类，getParserFactory() 返回的是缓存好的单例工厂对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigSource</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> RuleConfig <span class="title">load</span><span class="params">(String ruleConfigFilePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);</span><br><span class="line"></span><br><span class="line">        IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);</span><br><span class="line">        <span class="keyword">if</span> (parserFactory == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidRuleConfigException(<span class="string">"Rule config file format is not supported: "</span> + ruleConfigFilePath);</span><br><span class="line">        &#125;</span><br><span class="line">        IRuleConfigParser parser = parserFactory.createParser();</span><br><span class="line"></span><br><span class="line">        String configText = <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 从 ruleConfigFilePath 文件中读取配置文本到 configText 中</span></span><br><span class="line">        RuleConfig ruleConfig = parser.parse(configText);</span><br><span class="line">        <span class="keyword">return</span> ruleConfig;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">getFileExtension</span><span class="params">(String filePath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...解析文件名获取扩展名，比如 rule.json，返回 json</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"json"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 因为工厂类只包含方法，不包含成员变量，完全可以复用，</span></span><br><span class="line"><span class="comment">// 不需要每次都创建新的工厂类对象，所以，简单工厂模式的第二种实现思路更加合适</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuleConfigParserFactoryMap</span> // 工厂的工厂</span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span></span><br><span class="line">    &#123;</span><br><span class="line">        cachedFactories.put(<span class="string">"json"</span>, <span class="keyword">new</span> JsonRuleConfigParserFactory());</span><br><span class="line">        cachedFactories.put(<span class="string">"xml"</span>, <span class="keyword">new</span> XmlRuleConfigParserFactory());</span><br><span class="line">        cachedFactories.put(<span class="string">"yaml"</span>, <span class="keyword">new</span> YamlRuleConfigParserFactory());</span><br><span class="line">        cachedFactories.put(<span class="string">"properties"</span>, <span class="keyword">new</span> PropertiesRuleConfigParserFactory());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IRuleConfigParserFactory <span class="title">getParserFactory</span><span class="params">(String type)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (type == <span class="keyword">null</span> || type.isEmpty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());</span><br><span class="line">        <span class="keyword">return</span> parserFactory;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，对于规则配置文件解析这个应用场景来说，工厂模式需要额外创建诸多 Factory 类，也会增加代码的复杂性，而且，<strong>每个 Factory 类只是做简单的 new 操作，功能非常单薄</strong>，也没必要设计成独立的类，所以，在这个应用场景下，简单工厂模式简单好用，比工厂方法模式更加合适。</p><p>当对象的创建逻辑比较复杂，不只是简单的 new 一下就可以，而是要组合其他类对象，做各种初始化操作的时候，我们推荐使用工厂方法模式，<strong>将复杂的创建逻辑拆分到多个工厂类中，让每个工厂类都不至于过于复杂</strong>。</p><h2 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h2><p>抽象工厂模式的应用场景比较特殊，没有前两种常用。<strong>在简单工厂和工厂方法中，类只有一种分类方式</strong>。比如，在规则配置解析那个例子中，解析器类只会根据配置文件格式（Json、Xml、Yaml…）来分类。但是，如果类有两种分类方式，比如，我们既可以按照配置文件格式来分类，也可以按照解析的对象（Rule 规则配置还是 System 系统配置）来分类，那就会对应下面这 8 个 parser 类：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">针对规则配置的解析器：基于接口 IRuleConfigParser</span><br><span class="line"><span class="keyword">JsonRuleConfigParser</span></span><br><span class="line"><span class="keyword">XmlRuleConfigParser</span></span><br><span class="line"><span class="keyword">YamlRuleConfigParser</span></span><br><span class="line"><span class="keyword">PropertiesRuleConfigParser</span></span><br><span class="line"><span class="keyword"></span></span><br><span class="line"><span class="keyword">针对系统配置的解析器：基于接口 </span>ISystemConfigParser</span><br><span class="line"><span class="keyword">JsonSystemConfigParser</span></span><br><span class="line"><span class="keyword">XmlSystemConfigParser</span></span><br><span class="line"><span class="keyword">YamlSystemConfigParser</span></span><br><span class="line"><span class="keyword">PropertiesSystemConfigParser</span></span><br></pre></td></tr></table></figure><p><strong>过多的类也会让系统难维护，抽象工厂就是针对这种非常特殊的场景而诞生的</strong>。我们可以让一个工厂负责创建多个不同类型的对象（IRuleConfigParser、ISystemConfigParser 等），而不是只创建一种 parser 对象。这样就可以有效地减少工厂类的个数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 此处可以扩展新的 parser 类型，比如 IBizConfigParser</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> JsonSystemConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlConfigParserFactory</span> <span class="keyword">implements</span> <span class="title">IConfigParserFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IRuleConfigParser <span class="title">createRuleParser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XmlRuleConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ISystemConfigParser <span class="title">createSystemParser</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> XmlSystemConfigParser();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 省略 YamlConfigParserFactory 和 PropertiesConfigParserFactory 代码</span></span><br></pre></td></tr></table></figure><h2 id="工厂模式的作用"><a href="#工厂模式的作用" class="headerlink" title="工厂模式的作用"></a>工厂模式的作用</h2><p>工厂模式的作用无外乎下面这四个。这也是判断要不要使用工厂模式的最本质的参考标准：</p><ul><li><strong>封装变化</strong>：创建逻辑有可能变化，封装成工厂类之后，创建逻辑的变更对调用者透明；</li><li><strong>代码复用</strong>：创建代码抽离到独立的工厂类之后可以复用；</li><li><strong>隔离复杂性</strong>：封装复杂的创建逻辑，调用者无需了解如何创建对象；</li><li><strong>控制复杂度</strong>：将创建代码抽离出来，让原本的函数或类职责更单一，代码更简洁；</li></ul><h2 id="工厂模式和-DI-容器有何区别？"><a href="#工厂模式和-DI-容器有何区别？" class="headerlink" title="工厂模式和 DI 容器有何区别？"></a>工厂模式和 DI 容器有何区别？</h2><p>创建对象的“大工程” – 依赖注入框架，或者叫<code>依赖注入容器</code>（Dependency Injection Container），简称 DI 容器。实际上，<strong>DI 容器底层最基本的设计思路就是基于工厂模式的</strong>。DI 容器相当于一个大的工厂类，负责在程序启动的时候，根据配置（要创建哪些类对象，每个类对象的创建需要依赖哪些其他类对象）事先创建好对象。当应用程序需要使用某个类对象的时候，直接从容器中获取即可。<strong>正是因为它持有一堆对象，所以这个框架才被称为“容器”</strong>。</p><p>工厂模式中，一个工厂类只负责某个类对象或者某一组相关类对象（继承自同一抽象类或者接口的子类）的创建，而 <strong>DI 容器负责的是整个应用中所有类对象的创建</strong>。除此之外，DI 容器负责的事情要比单纯的工厂模式要多。比如，它还包括配置的解析、对象生命周期的管理。</p><h2 id="DI-容器的核心功能有哪些？"><a href="#DI-容器的核心功能有哪些？" class="headerlink" title="DI 容器的核心功能有哪些？"></a>DI 容器的核心功能有哪些？</h2><p>一个简单的 DI 容器的核心功能一般有三个：配置解析、对象创建和对象生命周期管理。</p><h3 id="配置解析"><a href="#配置解析" class="headerlink" title="配置解析"></a>配置解析</h3><p>作为一个通用的框架来说，框架代码跟应用代码应该是高度解耦的，DI 容器事先并不知道应用会创建哪些对象，<strong>不可能把某个应用要创建的对象写死在框架代码中</strong>。所以，我们需要通过一种形式，让应用告知 DI 容器要创建哪些对象。</p><p>我们将需要由 DI 容器来创建的类对象和创建类对象的必要信息（使用哪个构造函数以及对应的构造函数参数都是什么等等），放到配置文件中。<strong>容器读取配置文件，根据配置文件提供的信息来创建对象</strong>。</p><p>下面是一个典型的 Spring 容器的配置文件。Spring 容器读取这个配置文件，解析出要创建的两个对象：rateLimiter 和 redisCounter，并且得到两者的依赖关系：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimiter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RedisCounter redisCounter;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RateLimiter</span><span class="params">(RedisCounter redisCounter)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.redisCounter = redisCounter;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Hello World!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisCounter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String ipAddress;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisCounter</span><span class="params">(String ipAddress, <span class="keyword">int</span> port)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.ipAddress = ipAddress;</span><br><span class="line">        <span class="keyword">this</span>.port = port;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">配置文件 beans.xml：</span><br><span class="line">&lt;beans&gt;</span><br><span class="line">    &lt;bean id=<span class="string">"rateLimiter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xzg.RateLimiter"</span>&gt;</span><br><span class="line">        &lt;constructor-arg ref=<span class="string">"redisCounter"</span>/&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;bean id=<span class="string">"redisCounter"</span> <span class="class"><span class="keyword">class</span></span>=<span class="string">"com.xzg.redisCounter"</span>&gt;</span><br><span class="line">        &lt;constructor-arg type=<span class="string">"String"</span> value=<span class="string">"127.0.0.1"</span>&gt;</span><br><span class="line">        &lt;constructor-arg type=<span class="string">"int"</span> value=<span class="number">1234</span>&gt;</span><br><span class="line">    &lt;/bean&gt;</span><br><span class="line">&lt;/beans&gt;</span><br></pre></td></tr></table></figure><h3 id="对象创建"><a href="#对象创建" class="headerlink" title="对象创建"></a>对象创建</h3><p>在 DI 容器中，如果我们给每个类都对应创建一个工厂类，那项目中类的个数会成倍增加，这会增加代码的维护成本。要解决这个问题并不难。我们只需要<strong>将所有类对象的创建都放到一个工厂类中完成</strong>就可以了，比如 BeansFactory。</p><p>借助<code>反射语法</code>，<strong>在程序运行的过程中动态地加载类、创建对象</strong>，不需要事先在代码中写死要创建哪些对象。所以，BeansFactory 中的代码不会线性膨胀（代码量跟创建对象的个数成正比）。</p><h3 id="对象生命周期管理"><a href="#对象生命周期管理" class="headerlink" title="对象生命周期管理"></a>对象生命周期管理</h3><p>简单工厂模式有两种实现方式，一种是每次都返回新创建的对象，另一种是每次都返回同一个事先创建好的对象，也就是所谓的单例对象。在 Spring 框架中，我们可以<strong>通过配置 scope 属性，来区分这两种不同类型的对象</strong>。scope=prototype 表示返回新创建的对象，scope=singleton 表示返回单例对象。</p><p>除此之外，我们还可以<strong>配置对象是否支持懒加载</strong>。如果 lazy-init=true，对象在真正被使用到的时候（比如：BeansFactory.getBean(“userService”)）才被被创建；如果 lazy-init=false，对象在应用启动的时候就事先创建好。</p><p>不仅如此，我们还可以配置对象的 <code>init-method</code> 和 <code>destroy-method</code> 方法，比如 init-method=loadProperties()，destroy-method=updateConfigFile()。DI 容器在创建好对象之后，会主动调用 init-method 属性指定的方法来初始化对象。在对象被最终销毁之前，DI 容器会主动调用 destroy-method 属性指定的方法来做一些清理工作，比如释放数据库连接池、关闭文件。</p><h2 id="如何实现一个简单的-DI-容器？"><a href="#如何实现一个简单的-DI-容器？" class="headerlink" title="如何实现一个简单的 DI 容器？"></a>如何实现一个简单的 DI 容器？</h2><p>用 Java 语言来实现一个简单的 DI 容器，核心逻辑只需要包括这样两个部分：</p><ol><li>配置文件解析；</li><li>根据配置文件，通过反射语法创建对象；</li></ol><h3 id="最小原型设计"><a href="#最小原型设计" class="headerlink" title="最小原型设计"></a>最小原型设计</h3><p>像 Spring 框架这样的 DI 容器，它支持的配置格式非常灵活和复杂。为了<strong>简化代码实现，重点讲解原理</strong>，在最小原型中，我们只支持下面配置文件中涉及的配置语法：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">配置文件 beans.xml</span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"rateLimiter"</span> <span class="attr">class</span>=<span class="string">"com.xzg.RateLimiter"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">ref</span>=<span class="string">"redisCounter"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"redisCounter"</span> <span class="attr">class</span>=<span class="string">"com.xzg.redisCounter"</span> <span class="attr">scope</span>=<span class="string">"singleton"</span> <span class="attr">lazy-init</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"String"</span> <span class="attr">value</span>=<span class="string">"127.0.0.1"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">type</span>=<span class="string">"int"</span> <span class="attr">value</span>=<span class="string">1234</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span></span></span><br></pre></td></tr></table></figure><p>最小原型的使用方式跟 Spring 框架非常类似，示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"beans.xml"</span>);</span><br><span class="line">        RateLimiter rateLimiter = (RateLimiter) applicationContext.getBean(<span class="string">"rateLimiter"</span>);</span><br><span class="line">        rateLimiter.test();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="提供执行入口"><a href="#提供执行入口" class="headerlink" title="提供执行入口"></a>提供执行入口</h3><p><strong>面向对象设计的最后一步是：组装类并提供执行入口</strong>。在这里，执行入口就是一组暴露给外部使用的接口和类。通过刚刚的最小原型使用示例代码，我们可以看出，执行入口主要包含两部分：ApplicationContext 和 ClassPathXmlApplicationContext。其中，ApplicationContext 是接口，ClassPathXmlApplicationContext 是接口的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationContext</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">getBean</span><span class="params">(String beanId)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassPathXmlApplicationContext</span> <span class="keyword">implements</span> <span class="title">ApplicationContext</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> BeansFactory beansFactory;</span><br><span class="line">    <span class="keyword">private</span> BeanConfigParser beanConfigParser;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClassPathXmlApplicationContext</span><span class="params">(String configLocation)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.beansFactory = <span class="keyword">new</span> BeansFactory();</span><br><span class="line">        <span class="keyword">this</span>.beanConfigParser = <span class="keyword">new</span> XmlBeanConfigParser();</span><br><span class="line">        loadBeanDefinitions(configLocation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadBeanDefinitions</span><span class="params">(String configLocation)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InputStream in = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            in = <span class="keyword">this</span>.getClass().getResourceAsStream(<span class="string">"/"</span> + configLocation);</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Can not find config file: "</span> + configLocation);</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;BeanDefinition&gt; beanDefinitions = beanConfigParser.parse(in);</span><br><span class="line">            beansFactory.addBeanDefinitions(beanDefinitions);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (in != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">try</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    in.close();</span><br><span class="line">                &#125; </span><br><span class="line">                <span class="keyword">catch</span> (IOException e) </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> log error</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> beansFactory.getBean(beanId);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看出，ClassPathXmlApplicationContext 负责<strong>组装 BeansFactory 和 BeanConfigParser 两个类，串联执行流程</strong>：从 ClassPath 中加载 XML 格式的配置文件，通过 BeanConfigParser 解析为统一的 BeanDefinition 格式，然后，BeansFactory 根据 BeanDefinition 来创建对象。</p><h3 id="配置文件解析"><a href="#配置文件解析" class="headerlink" title="配置文件解析"></a>配置文件解析</h3><p>配置文件解析主要包含 BeanConfigParser 接口和 XmlBeanConfigParser 实现类，负责将配置文件解析为 BeanDefinition 结构，以便 BeansFactory 根据这个结构来创建对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BeanConfigParser</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">List&lt;BeanDefinition&gt; <span class="title">parse</span><span class="params">(InputStream inputStream)</span></span>;</span><br><span class="line">    <span class="function">List&lt;BeanDefinition&gt; <span class="title">parse</span><span class="params">(String configContent)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XmlBeanConfigParser</span> <span class="keyword">implements</span> <span class="title">BeanConfigParser</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title">parse</span><span class="params">(InputStream inputStream)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String content = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> ...</span></span><br><span class="line">        <span class="keyword">return</span> parse(content);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;BeanDefinition&gt; <span class="title">parse</span><span class="params">(String configContent)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        List&lt;BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> ...</span></span><br><span class="line">        <span class="keyword">return</span> beanDefinitions;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeanDefinition</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> String className;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ConstructorArg&gt; constructorArgs = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> Scope scope = Scope.SINGLETON;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> lazyInit = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 省略必要的 getter/setter/constructors</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSingleton</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> scope.equals(Scope.SINGLETON);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Scope </span><br><span class="line">    &#123;</span><br><span class="line">        SINGLETON,</span><br><span class="line">        PROTOTYPE</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ConstructorArg</span> </span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isRef;</span><br><span class="line">        <span class="keyword">private</span> Class type;</span><br><span class="line">        <span class="keyword">private</span> Object arg;</span><br><span class="line">        <span class="comment">// 省略必要的 getter/setter/constructors</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="核心工厂类设计"><a href="#核心工厂类设计" class="headerlink" title="核心工厂类设计"></a>核心工厂类设计</h3><p><strong>BeansFactory 是 DI 容器最核心的一个类</strong>。它负责根据从配置文件解析得到的 BeanDefinition 来创建对象。如果对象的 scope 属性是 singleton，那对象创建之后会缓存在 singletonObjects 这样一个 map 中，下次再请求此对象的时候，直接从 map 中取出返回，不需要重新创建。如果对象的 scope 属性是 prototype，那每次请求对象，BeansFactory 都会创建一个新的对象返回。</p><p>实际上，BeansFactory 创建对象用到的主要技术点就是 Java 中的<strong>反射语法：一种动态加载类和创建对象的机制</strong>。我们知道，JVM 在启动的时候会根据代码自动地加载类、创建对象。至于都要加载哪些类、创建哪些对象，这些都是在代码中写死的，或者说提前写好的。但是，如果某个对象的创建并不是写死在代码中，而是放到配置文件中，我们需要在程序运行期间，动态地根据配置文件来加载类、创建对象，那<strong>这部分工作就没法让 JVM 帮我们自动完成</strong>了，我们需要利用 Java 提供的反射语法自己去编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, Object&gt; singletonObjects = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> ConcurrentHashMap&lt;String, BeanDefinition&gt; beanDefinitions = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addBeanDefinitions</span><span class="params">(List&lt;BeanDefinition&gt; beanDefinitionList)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.beanDefinitions.putIfAbsent(beanDefinition.getId(), beanDefinition);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (BeanDefinition beanDefinition : beanDefinitionList) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (beanDefinition.isLazyInit() == <span class="keyword">false</span> &amp;&amp; beanDefinition.isSingleton()) </span><br><span class="line">            &#123;</span><br><span class="line">                createBean(beanDefinition);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getBean</span><span class="params">(String beanId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        BeanDefinition beanDefinition = beanDefinitions.get(beanId);</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="string">"Bean is not defined: "</span> + beanId);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> createBean(beanDefinition);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@VisibleForTesting</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(BeanDefinition beanDefinition)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (beanDefinition.isSingleton() &amp;&amp; singletonObjects.containsKey(beanDefinition.getId())) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Object bean = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            Class beanClass = Class.forName(beanDefinition.getClassName());</span><br><span class="line">            List&lt;BeanDefinition.ConstructorArg&gt; args = beanDefinition.getConstructorArgs();</span><br><span class="line">            <span class="keyword">if</span> (args.isEmpty()) </span><br><span class="line">            &#123;</span><br><span class="line">                bean = beanClass.newInstance();</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                Class[] argClasses = <span class="keyword">new</span> Class[args.size()];</span><br><span class="line">                Object[] argObjects = <span class="keyword">new</span> Object[args.size()];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; args.size(); ++i) </span><br><span class="line">                &#123;</span><br><span class="line">                    BeanDefinition.ConstructorArg arg = args.get(i);</span><br><span class="line">                    <span class="keyword">if</span> (!arg.getIsRef()) </span><br><span class="line">                    &#123;</span><br><span class="line">                        argClasses[i] = arg.getType();</span><br><span class="line">                        argObjects[i] = arg.getArg();</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        BeanDefinition refBeanDefinition = beanDefinitions.get(arg.getArg());</span><br><span class="line">                        <span class="keyword">if</span> (refBeanDefinition == <span class="keyword">null</span>) </span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchBeanDefinitionException(<span class="string">"Bean is not defined: "</span> + arg.getArg());</span><br><span class="line">                        &#125;</span><br><span class="line">                        argClasses[i] = Class.forName(refBeanDefinition.getClassName());</span><br><span class="line">                        argObjects[i] = createBean(refBeanDefinition);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                bean = beanClass.getConstructor(argClasses).newInstance(argObjects);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ClassNotFoundException | IllegalAccessException | InstantiationException | NoSuchMethodException | InvocationTargetException e) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BeanCreationFailureException(<span class="string">""</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (bean != <span class="keyword">null</span> &amp;&amp; beanDefinition.isSingleton()) </span><br><span class="line">        &#123;</span><br><span class="line">            singletonObjects.putIfAbsent(beanDefinition.getId(), bean);</span><br><span class="line">            <span class="keyword">return</span> singletonObjects.get(beanDefinition.getId());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> bean;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Singleton Design Pattern</title>
      <link href="2020/11/21/Singleton-Design-Pattern/"/>
      <url>2020/11/21/Singleton-Design-Pattern/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么要使用单例？"><a href="#为什么要使用单例？" class="headerlink" title="为什么要使用单例？"></a>为什么要使用单例？</h2><p>单例设计模式（Singleton Design Pattern）理解起来非常简单。<strong>一个类只允许创建一个对象（或者实例）</strong>，那这个类就是一个单例类，这种设计模式就叫作单例设计模式，简称单例模式。</p><h3 id="实战案例一：处理资源访问冲突"><a href="#实战案例一：处理资源访问冲突" class="headerlink" title="实战案例一：处理资源访问冲突"></a>实战案例一：处理资源访问冲突</h3><p>在这个例子中，我们自定义实现了一个往文件中打印日志的 Logger 类。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/wangzheng/log.txt"</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>); <span class="comment">// true 表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger 类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = <span class="keyword">new</span> Logger();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略业务逻辑代码...</span></span><br><span class="line">        logger.log(username + <span class="string">" logged-in!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Logger logger = <span class="keyword">new</span> Logger();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(OrderVo order)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略业务逻辑代码...</span></span><br><span class="line">        logger.log(<span class="string">"Created an order: "</span> + order.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>在上面的代码中，我们注意到，所有的日志都写入到同一个文件 /Users/wangzheng/log.txt 中。在 UserController 和 OrderController 中，我们分别创建两个 Logger 对象。在 Web 容器的 Servlet 多线程环境下，如果两个 Servlet 线程同时分别执行 login() 和 create() 两个函数，并且同时写日志到 log.txt 文件中，那就有<strong>可能存在日志信息互相覆盖</strong>的情况。</p><p>那如何来解决这个问题呢？我们最先想到的就是通过加锁的方式：<strong>给 log() 函数加互斥锁</strong>（Java 中可以通过 <code>synchronized</code> 的关键字），同一时刻只允许一个线程调用执行 log() 函数。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/wangzheng/log.txt"</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>); <span class="comment">// true 表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            writer.write(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，你仔细想想，这真的能解决多线程写入日志时互相覆盖的问题吗？答案是否定的。这是因为，<strong>这种锁是一个对象级别的锁</strong>，一个对象在不同的线程下同时调用 log() 函数，会被强制要求顺序执行。但是，<strong>不同的对象之间并不共享同一把锁</strong>。在不同的线程下，通过不同的对象调用执行 log() 函数，锁并不会起作用，仍然有可能存在写入日志互相覆盖的问题：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/02.png" alt></p><p>我这里稍微补充一下，在刚刚的讲解和给出的代码中，我故意“隐瞒”了一个事实：我们给 log() 函数加不加对象级别的锁，其实都没有关系。因为 <strong>FileWriter 本身就是线程安全的</strong>，它的内部实现中本身就加了对象级别的锁，因此，在外层调用 write() 函数的时候，再加对象级别的锁实际上是多此一举。</p><p>那我们该怎么解决这个问题呢？实际上，要想解决这个问题也不难，我们<strong>只需要把对象级别的锁，换成类级别的锁</strong>就可以了。让所有的对象都共享同一把锁。这样就避免了不同对象之间同时调用 log() 函数，而导致的日志覆盖问题。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/wangzheng/log.txt"</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>); <span class="comment">// true 表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(Logger<span class="class">.<span class="keyword">class</span>) // 类级别的锁</span></span><br><span class="line"><span class="class">        </span>&#123;</span><br><span class="line">            writer.write(message);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除了使用类级别锁之外，实际上，解决资源竞争问题的办法还有很多，<code>分布式锁</code>是最常听到的一种解决方案。不过，实现一个安全可靠、无 bug、高性能的分布式锁，并不是件容易的事情。除此之外，<code>并发队列</code>（比如 Java 中的 BlockingQueue）也可以解决这个问题：多个线程同时往并发队列里写日志，一个单独的线程负责将并发队列中的数据，写入到日志文件。这种方式实现起来也稍微有点复杂。</p><p>相对于这两种解决方案，<strong>单例模式的解决思路就简单一些了</strong>。单例模式相对于之前类级别锁的好处是，不用创建那么多 Logger 对象，一方面节省内存空间，另一方面<strong>节省系统文件句柄</strong>（对于操作系统来说，文件句柄也是一种资源，不能随便浪费）。</p><p>我们将 Logger 设计成一个单例类，<strong>程序中只允许创建一个 Logger 对象</strong>，所有的线程共享使用的这一个 Logger 对象，共享一个 FileWriter 对象，而 FileWriter 本身是对象级别线程安全的，也就避免了多线程情况下写日志会互相覆盖的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> FileWriter writer;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger instance = <span class="keyword">new</span> Logger();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        File file = <span class="keyword">new</span> File(<span class="string">"/Users/wangzheng/log.txt"</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> FileWriter(file, <span class="keyword">true</span>); <span class="comment">// true 表示追加写入</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        writer.write(message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Logger 类的应用示例：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String username, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略业务逻辑代码...</span></span><br><span class="line">        Logger.getInstance().log(username + <span class="string">" logged-in!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">OrderController</span> </span></span><br><span class="line"><span class="class"></span>&#123;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(OrderVo order)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略业务逻辑代码...</span></span><br><span class="line">        Logger.getInstance().log(<span class="string">"Created a order: "</span> + order.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实战案例二：表示全局唯一类"><a href="#实战案例二：表示全局唯一类" class="headerlink" title="实战案例二：表示全局唯一类"></a>实战案例二：表示全局唯一类</h3><p>从业务概念上，<strong>如果有些数据在系统中只应保存一份，那就比较适合设计为单例类</strong>。</p><p>比如，配置信息类。在系统中，我们只有一个配置文件，当配置文件被加载到内存之后，以对象的形式存在，也理所应当只有一份。再比如，唯一递增 ID 号码生成器。如果程序中有两个对象，那就会存在生成重复 ID 的情况，所以，我们应该将 ID 生成器类设计为单例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicLong;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// AtomicLong 是一个 Java 并发库中提供的一个原子变量类型，</span></span><br><span class="line">    <span class="comment">// 它将一些线程不安全需要加锁的复合操作封装为了线程安全的原子操作，</span></span><br><span class="line">    <span class="comment">// 比如下面会用到的 incrementAndGet()</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdGenerator 使用举例</span></span><br><span class="line"><span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br></pre></td></tr></table></figure><h2 id="如何实现一个单例？"><a href="#如何实现一个单例？" class="headerlink" title="如何实现一个单例？"></a>如何实现一个单例？</h2><p>概括起来，要实现一个单例，我们<strong>需要关注的点</strong>无外乎下面几个：</p><ul><li>构造函数需要是 private 访问权限的，这样才能避免外部通过 new 创建实例；</li><li>考虑对象创建时的线程安全问题；</li><li>考虑是否支持延迟加载；</li><li>考虑 getInstance() 性能是否高（是否加锁）；</li></ul><h3 id="饿汉式"><a href="#饿汉式" class="headerlink" title="饿汉式"></a>饿汉式</h3><p>饿汉式的实现方式比较简单。<strong>在类加载的时候，instance 静态实例就已经创建并初始化好了</strong>，所以，instance 实例的创建过程是线程安全的。不过，这样的实现方式<strong>不支持延迟加载</strong>（在真正用到 IdGenerator 的时候，再创建实例），从名字中我们也可以看出这一点。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有人觉得这种实现方式不好，因为不支持延迟加载，如果实例占用资源多（比如占用内存多）或初始化耗时长（比如需要加载各种配置文件），提前初始化实例是一种浪费资源的行为。最好的方法应该在用到的时候再去初始化。不过，我个人并<strong>不认同这样的观点</strong>。</p><p>如果初始化耗时长，那我们最好不要等到真正要用它的时候，才去执行这个耗时长的初始化过程，这会影响到系统的性能（比如，在响应客户端接口请求的时候，做这个初始化操作，会导致此请求的响应时间变长，甚至超时）。采用饿汉式实现方式，<strong>将耗时的初始化操作，提前到程序启动的时候完成</strong>，这样就能避免在程序运行的时候，再去初始化导致的性能问题。</p><p>如果实例占用资源多，按照 <code>fail-fast</code> 的设计原则，那我们也希望在程序启动时就将这个实例初始化好。<strong>如果资源不够，就会在程序启动的时候触发报错</strong>（比如 Java 中的 PermGen Space OOM），我们可以立即去修复。这样也能避免在程序运行一段时间后，突然因为初始化这个实例占用资源过多，导致系统崩溃，影响系统的可用性。</p><h3 id="懒汉式"><a href="#懒汉式" class="headerlink" title="懒汉式"></a>懒汉式</h3><p>懒汉式相对于饿汉式的优势是支持延迟加载。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过懒汉式的缺点也很明显，我们给 getInstance() 这个方法加了一把大锁（synchronized），导致这个函数的并发度很低。量化一下的话，并发度是 1，也就<strong>相当于串行操作</strong>了。而这个函数是在单例使用期间，一直会被调用。如果这个单例类偶尔会被用到，那这种实现方式还可以接受。但是，如果频繁地用到，那<strong>频繁加锁、释放锁及并发度低等问题，会导致性能瓶颈</strong>，这种实现方式就不可取了。</p><h3 id="双重检测"><a href="#双重检测" class="headerlink" title="双重检测"></a>双重检测</h3><p>饿汉式不支持延迟加载，懒汉式有性能问题，不支持高并发。那我们再来看一种<strong>既支持延迟加载、又支持高并发的单例实现方式</strong>，也就是双重检测实现方式。在这种实现方式中，只要 instance 被创建之后，即便再调用 getInstance() 函数也不会再进入到加锁逻辑中了。所以，这种实现方式解决了懒汉式并发度低的问题。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(IdGenerator<span class="class">.<span class="keyword">class</span>) // 此处为类级别的锁</span></span><br><span class="line"><span class="class">            </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">                &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>网上有人说，这种实现方式有些问题。因为指令重排序，可能会导致 IdGenerator 对象被 new 出来，并且赋值给 instance 之后，还没来得及初始化（执行构造函数中的代码逻辑），就被另一个线程使用了。我们现在用的高版本的 Java 已经在 JDK 内部实现中解决了这个问题（解决的方法很简单，<strong>只要把对象 new 操作和初始化操作设计为原子操作，就自然能禁止重排序</strong>）。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>我们再来看一种比双重检测更加简单的实现方法，那就是<strong>利用 Java 的静态内部类</strong>。它有点类似饿汉式，但又能做到了延迟加载：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> IdGenerator instance = <span class="keyword">new</span> IdGenerator();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.instance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>SingletonHolder 是一个静态内部类，当外部类 IdGenerator 被加载的时候，并不会创建 SingletonHolder 实例对象。<strong>只有当调用 getInstance() 方法时，SingletonHolder 才会被加载</strong>，这个时候才会创建 instance。<strong>instance 的唯一性、创建过程的线程安全性，都由 JVM 来保证</strong>。所以，这种实现方法既保证了线程安全，又能做到延迟加载。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><p>我们介绍一种最简单的实现方式，基于枚举类型的单例实现。这种实现方式<strong>通过 Java 枚举类型本身的特性</strong>，保证了实例创建的线程安全性和实例的唯一性。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> IdGenerator </span><br><span class="line">&#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单例存在哪些问题？"><a href="#单例存在哪些问题？" class="headerlink" title="单例存在哪些问题？"></a>单例存在哪些问题？</h2><p>大部分情况下，我们在项目中使用单例，都是用它来表示一些全局唯一类，比如<strong>配置信息类、连接池类、ID 生成器类</strong>。单例模式书写简洁、使用方便，在代码中，我们不需要创建对象，直接通过类似 IdGenerator.getInstance().getId() 这样的方法来调用就可以了。但是，这种使用方法有点类似 hard code，会带来诸多问题。</p><h3 id="单例对-OOP-特性的支持不友好"><a href="#单例对-OOP-特性的支持不友好" class="headerlink" title="单例对 OOP 特性的支持不友好"></a>单例对 OOP 特性的支持不友好</h3><p>我们知道，OOP 的四大特性是封装、抽象、继承、多态。单例这种设计模式对于其中的抽象、继承、多态都支持得不好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IdGenerator 的使用方式<strong>违背了基于接口而非实现的设计原则</strong>，也就违背了广义上理解的 OOP 的抽象特性。如果未来某一天，我们希望针对不同的业务采用不同的 ID 生成算法。比如，订单 ID 和用户 ID 采用不同的 ID 生成器来生成。为了应对这个需求变化，我们需要修改所有用到 IdGenerator 类的地方：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">        <span class="keyword">long</span> id = OrderIdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">create</span><span class="params">(...)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">        <span class="comment">// 需要将上面一行代码，替换为下面一行代码</span></span><br><span class="line">        <span class="keyword">long</span> id = UserIdGenerator.getInstance().getId();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>除此之外，单例对继承、多态特性的支持也不友好。这里我之所以会用“不友好”这个词，而非“完全不支持”，是因为从理论上来讲，单例类也可以被继承、也可以实现多态，只是<strong>实现起来会非常奇怪，会导致代码的可读性变差</strong>。不明白设计意图的人，看到这样的设计，会觉得莫名其妙。所以，一旦你选择将某个类设计成到单例类，也就意味着放弃了继承和多态这两个强有力的面向对象特性，也就<strong>相当于损失了可以应对未来需求变化的扩展性</strong>。</p><h3 id="单例会隐藏类之间的依赖关系"><a href="#单例会隐藏类之间的依赖关系" class="headerlink" title="单例会隐藏类之间的依赖关系"></a>单例会隐藏类之间的依赖关系</h3><p>我们知道，代码的可读性非常重要。在阅读代码的时候，我们希望<strong>一眼就能看出类与类之间的依赖关系</strong>，搞清楚这个类依赖了哪些外部类。</p><p>通过构造函数、参数传递等方式声明的类之间的依赖关系，我们通过查看函数的定义，就能很容易识别出来。但是，<strong>单例类不需要显示创建、不需要依赖参数传递，在函数中直接调用就可以了</strong>。如果代码比较复杂，这种调用关系就会非常隐蔽。在阅读代码的时候，我们就需要仔细查看每个函数的代码实现，才能知道这个类到底依赖了哪些单例类。</p><h3 id="单例对代码的扩展性不友好"><a href="#单例对代码的扩展性不友好" class="headerlink" title="单例对代码的扩展性不友好"></a>单例对代码的扩展性不友好</h3><p>我们知道，<strong>单例类只能有一个对象实例</strong>。如果未来某一天，我们需要在代码中创建两个实例或多个实例，那就要对代码有比较大的改动。我们拿数据库连接池来举例解释一下，在系统设计初期，我们觉得系统中只应该有一个数据库连接池，这样能方便我们控制对数据库连接资源的消耗。所以，我们把数据库连接池类设计成了单例类。但之后我们发现，系统中有些 SQL 语句运行得非常慢。这些 SQL 语句在执行的时候，长时间占用数据库连接资源，导致其他 SQL 请求无法响应。</p><p>为了解决这个问题，我们希望将慢 SQL 与其他 SQL 隔离开来执行。为了实现这样的目的，我们可以在系统中创建两个数据库连接池，慢 SQL 独享一个数据库连接池，其他 SQL 独享另外一个数据库连接池，这样就能避免慢 SQL 影响到其他 SQL 的执行。如果我们将数据库连接池设计成单例类，显然就无法适应这样的需求变更，也就是说，单例类在某些情况下会影响代码的扩展性、灵活性。所以，<strong>数据库连接池、线程池这类的资源池，最好还是不要设计成单例类</strong>。</p><h3 id="单例对代码的可测试性不友好"><a href="#单例对代码的可测试性不友好" class="headerlink" title="单例对代码的可测试性不友好"></a>单例对代码的可测试性不友好</h3><p>单例模式的使用会影响到代码的可测试性。如果单例类依赖比较重的外部资源，比如 DB，我们在写单元测试的时候，希望能通过 mock 的方式将它替换掉。而<strong>单例类这种硬编码式的使用方式，导致无法实现 mock 替换</strong>。</p><p>除此之外，如果单例类持有成员变量（比如 IdGenerator 中的 id 成员变量），那它实际上相当于一种<code>全局变量</code>，被所有的代码共享。如果这个全局变量是一个可变全局变量，也就是说，它的成员变量是可以被修改的，那我们在编写单元测试的时候，还<strong>需要注意不同测试用例之间，修改了单例类中的同一个成员变量的值</strong>，从而导致测试结果互相影响的问题。</p><h3 id="单例不支持有参数的构造函数"><a href="#单例不支持有参数的构造函数" class="headerlink" title="单例不支持有参数的构造函数"></a>单例不支持有参数的构造函数</h3><p>单例<strong>不支持有参数的构造函数</strong>，比如我们创建一个连接池的单例对象，我们没法通过参数来指定连接池的大小。针对这个问题，我们来看下都有哪些解决方案。</p><ol><li><p>创建完实例之后，再调用 init() 函数传递参数。需要注意的是，我们在使用这个单例类的时候，要<strong>先调用 init() 方法，然后才能调用 getInstance() 方法</strong>，否则代码会抛出异常。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(<span class="keyword">int</span> paramA, <span class="keyword">int</span> paramB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.paramA = paramA;</span><br><span class="line">        <span class="keyword">this</span>.paramB = paramB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Run init() first."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">init</span><span class="params">(<span class="keyword">int</span> paramA, <span class="keyword">int</span> paramB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance != <span class="keyword">null</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Singleton has been created!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        instance = <span class="keyword">new</span> Singleton(paramA, paramB);</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton.init(<span class="number">10</span>, <span class="number">50</span>); <span class="comment">// 先 init，再使用</span></span><br><span class="line">Singleton singleton = Singleton.getInstance();</span><br></pre></td></tr></table></figure></li><li><p>将参数放到 getInstance() 方法中。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">(<span class="keyword">int</span> paramA, <span class="keyword">int</span> paramB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.paramA = paramA;</span><br><span class="line">        <span class="keyword">this</span>.paramB = paramB;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">(<span class="keyword">int</span> paramA, <span class="keyword">int</span> paramB)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(paramA, paramB);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Singleton singleton = Singleton.getInstance(<span class="number">10</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure><p> 不知道你有没有发现，上面的代码实现稍微有点问题。如果我们如下两次执行 getInstance() 方法，那获取到的 singleton1 和 singleton2 的 paramA 和 paramB 都是 10 和 50。也就是说，第二次的参数（20，30）没有起作用，而构建的过程也没有给与提示，这样就会误导用户：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Singleton singleton1 = Singleton.getInstance(<span class="number">10</span>, <span class="number">50</span>);</span><br><span class="line">Singleton singleton2 = Singleton.getInstance(<span class="number">20</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure></li><li><p>将参数放到另外一个全局变量中。具体的代码实现如下。Config 是一个存储了 paramA 和 paramB 值的全局变量。里面的值<strong>既可以通过静态常量来定义，也可以从配置文件中加载得到</strong>。实际上，这种方式是最值得推荐的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Config</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PARAM_A = <span class="number">123</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PARAM_B = <span class="number">245</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramA;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> paramB;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.paramA = Config.PARAM_A;</span><br><span class="line">        <span class="keyword">this</span>.paramB = Config.PARAM_B;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h2 id="有何替代解决方案？"><a href="#有何替代解决方案？" class="headerlink" title="有何替代解决方案？"></a>有何替代解决方案？</h2><p>为了<strong>保证全局唯一</strong>，除了使用单例，我们还可以用静态方法来实现。这也是项目开发中经常用到的一种实现思路：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 静态方法实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用举例</span></span><br><span class="line"><span class="keyword">long</span> id = IdGenerator.getId();</span><br></pre></td></tr></table></figure><p>不过，静态方法这种实现思路，并不能解决我们之前提到的问题。实际上，它<strong>比单例更加不灵活</strong>，比如，它无法支持延迟加载。实际上，单例除了我们之前讲到的使用方法之外，还有另外一种使用方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. 老的使用方式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">demoFunction</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">long</span> id = IdGenerator.getInstance().getId();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 新的使用方式：依赖注入</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">demoFunction</span><span class="params">(IdGenerator idGenerator)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> id = idGenerator.getId();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 外部调用 demoFunction() 的时候，传入 idGenerator</span></span><br><span class="line">IdGenerator idGenerator = IdGenerator.getInstance();</span><br><span class="line">demoFunction(idGenerator);</span><br></pre></td></tr></table></figure><p>基于新的使用方式，我们将单例生成的对象，<strong>作为参数传递给函数（也可以通过构造函数传递给类的成员变量）</strong>，可以解决单例隐藏类之间依赖关系的问题。不过，对于单例存在的其他问题，比如对 OOP 特性、扩展性、可测性不友好等问题，还是无法解决。</p><p>实际上，<strong>类对象的全局唯一性可以通过多种不同的方式来保证</strong>。我们既可以通过单例模式来强制保证，也可以通过工厂模式、IoC 容器（比如 Spring IoC 容器）来保证，还可以通过程序员自己来保证（自己在编写代码的时候自己保证不要创建两个类对象）。这就<strong>类似 Java 中内存对象的释放由 JVM 来负责，而 C++ 中由程序员自己负责</strong>，道理是一样的。</p><h2 id="如何理解单例模式中的唯一性？"><a href="#如何理解单例模式中的唯一性？" class="headerlink" title="如何理解单例模式中的唯一性？"></a>如何理解单例模式中的唯一性？</h2><p>我们编写的代码，通过编译、链接，组织在一起，就构成了一个操作系统可以执行的文件，也就是我们平时所说的“可执行文件”（比如 Windows 下的 exe 文件）。<strong>可执行文件实际上就是代码被翻译成操作系统可理解的一组指令</strong>，你完全可以简单地理解为就是代码本身。</p><p>当我们使用命令行或者双击运行这个可执行文件的时候，<strong>操作系统会启动一个进程，将这个执行文件从磁盘加载到自己的进程地址空间（可以理解操作系统为进程分配的内存存储区，用来存储代码和数据）</strong>。接着，进程就一条一条地执行可执行文件中包含的代码。比如，当进程读到代码中的 User user = new User(); 这条语句的时候，它就在自己的地址空间中创建一个 user 临时变量和一个 User 对象。</p><p><strong>进程之间是不共享地址空间的</strong>，如果我们在一个进程中创建另外一个进程（比如，代码中有一个 fork() 语句，进程执行到这条语句的时候会创建一个新的进程），操作系统会给新进程分配新的地址空间，并且将老进程地址空间的所有内容，重新拷贝一份到新进程的地址空间中，这些内容包括代码、数据（比如 user 临时变量、User 对象）。</p><p>所以，单例类在老进程中存在且只能存在一个对象，在新进程中也会存在且只能存在一个对象。而且，这两个对象并不是同一个对象，这也就说，<strong>单例类中对象的唯一性的作用范围是进程内的，在进程间是不唯一的</strong>。</p><h2 id="如何实现线程唯一的单例？"><a href="#如何实现线程唯一的单例？" class="headerlink" title="如何实现线程唯一的单例？"></a>如何实现线程唯一的单例？</h2><p>“进程唯一”指的是进程内唯一，进程间不唯一。类比一下，“线程唯一”指的是线程内唯一，线程间可以不唯一。实际上，<strong>“进程唯一”还代表了线程内、线程间都唯一</strong>，这也是“进程唯一”和“线程唯一”的区别之处。</p><p>假设 IdGenerator 是一个线程唯一的单例类。在线程 A 内，我们可以创建一个单例对象 a。因为线程内唯一，在线程 A 内就不能再创建新的 IdGenerator 对象了，而线程间可以不唯一，所以，在另外一个线程 B 内，我们还可以重新创建一个新的单例对象 b。</p><p><strong>线程唯一单例的代码实现很简单</strong>，如下所示。在代码中，我们通过一个 HashMap 来存储对象，其中 key 是线程 ID，value 是对象。这样我们就可以做到，不同的线程对应不同的对象，同一个线程只能对应一个对象。实际上，Java 语言本身提供了 ThreadLocal 工具类，可以更加轻松地实现线程唯一单例（底层实现原理也是基于 HashMap）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;Long, IdGenerator&gt; instances</span><br><span class="line">        = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Long currentThreadId = Thread.currentThread().getId();</span><br><span class="line">        instances.putIfAbsent(currentThreadId, <span class="keyword">new</span> IdGenerator());</span><br><span class="line">        <span class="keyword">return</span> instances.get(currentThreadId);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何实现集群环境下的单例？"><a href="#如何实现集群环境下的单例？" class="headerlink" title="如何实现集群环境下的单例？"></a>如何实现集群环境下的单例？</h2><p>集群相当于多个进程构成的一个集合，“集群唯一”就相当于是<strong>进程内唯一、进程间也唯一</strong>。也就是说，不同的进程间共享同一个对象，不能创建同一个类的多个对象。</p><p>具体来说，我们<strong>需要把这个单例对象序列化并存储到外部共享存储区</strong>（比如文件）。进程在使用这个单例对象的时候，需要先从外部共享存储区中将它读取到内存，并反序列化成对象，然后再使用，使用完成之后还需要再存储回外部共享存储区。</p><p>为了保证任何时刻，在进程间都只有一份对象存在，<strong>一个进程在获取到对象之后，需要对对象加锁</strong>，避免其他进程再将其获取。在进程使用完这个对象之后，还需要显式地将对象从内存中删除，并且释放对对象的加锁：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IdGenerator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AtomicLong id = <span class="keyword">new</span> AtomicLong(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> IdGenerator instance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SharedObjectStorage storage = FileSharedObjectStorage(<span class="comment">/*入参省略，比如文件地址*/</span>);</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DistributedLock lock = <span class="keyword">new</span> DistributedLock();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">IdGenerator</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> IdGenerator <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            instance = storage.load(IdGenerator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">freeInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        storage.save(<span class="keyword">this</span>, IdGenerator<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        instance = <span class="keyword">null</span>; <span class="comment">// 释放对象</span></span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> id.incrementAndGet();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// IdGenerator 使用举例</span></span><br><span class="line">IdGenerator idGenerator = IdGenerator.getInstance();</span><br><span class="line"><span class="keyword">long</span> id = idGenerator.getId();</span><br><span class="line">IdGenerator.freeInstance();</span><br></pre></td></tr></table></figure><h2 id="如何实现一个多例模式？"><a href="#如何实现一个多例模式？" class="headerlink" title="如何实现一个多例模式？"></a>如何实现一个多例模式？</h2><p>“单例”指的是，一个类只能创建一个对象。对应地，<strong>“多例”指的就是，一个类可以创建多个对象</strong>，但是个数是有限制的，比如只能创建 3 个对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BackendServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> serverNo;</span><br><span class="line">    <span class="keyword">private</span> String serverAddress;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SERVER_COUNT = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Long, BackendServer&gt; serverInstances = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> </span><br><span class="line">    &#123;</span><br><span class="line">        serverInstances.put(<span class="number">1L</span>, <span class="keyword">new</span> BackendServer(<span class="number">1L</span>, <span class="string">"192.134.22.138:8080"</span>));</span><br><span class="line">        serverInstances.put(<span class="number">2L</span>, <span class="keyword">new</span> BackendServer(<span class="number">2L</span>, <span class="string">"192.134.22.139:8080"</span>));</span><br><span class="line">        serverInstances.put(<span class="number">3L</span>, <span class="keyword">new</span> BackendServer(<span class="number">3L</span>, <span class="string">"192.134.22.140:8080"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">BackendServer</span><span class="params">(<span class="keyword">long</span> serverNo, String serverAddress)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serverNo = serverNo;</span><br><span class="line">        <span class="keyword">this</span>.serverAddress = serverAddress;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BackendServer <span class="title">getInstance</span><span class="params">(<span class="keyword">long</span> serverNo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serverInstances.get(serverNo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> BackendServer <span class="title">getRandomInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">int</span> num = r.nextInt(SERVER_COUNT) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> serverInstances.get(num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，对于多例模式，还有一种理解方式：<strong>同一类型的只能创建一个对象，不同类型的可以创建多个对象</strong>。在代码中，loggerName 就是刚刚说的“类型”，同一个 loggerName 获取到的对象实例是相同的，不同的 loggerName 获取到的对象实例是不同的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ConcurrentHashMap&lt;String, Logger&gt; instances = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Logger</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Logger <span class="title">getInstance</span><span class="params">(String loggerName)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        instances.putIfAbsent(loggerName, <span class="keyword">new</span> Logger());</span><br><span class="line">        <span class="keyword">return</span> instances.get(loggerName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// l1==l2, l1!=l3</span></span><br><span class="line">Logger l1 = Logger.getInstance(<span class="string">"User.class"</span>);</span><br><span class="line">Logger l2 = Logger.getInstance(<span class="string">"User.class"</span>);</span><br><span class="line">Logger l3 = Logger.getInstance(<span class="string">"Order.class"</span>);</span><br></pre></td></tr></table></figure><p>这种多例模式的理解方式有点类似工厂模式。它跟工厂模式的不同之处是，<strong>多例模式创建的对象都是同一个类的对象，而工厂模式创建的是不同子类的对象</strong>。除此之外，<strong>枚举类型也相当于多例模式</strong>，一个类型只能对应一个对象，一个类可以创建多个对象。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程技巧</title>
      <link href="2020/11/17/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/"/>
      <url>2020/11/17/%E7%BC%96%E7%A8%8B%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="把代码分割成更小的单元块"><a href="#把代码分割成更小的单元块" class="headerlink" title="把代码分割成更小的单元块"></a>把代码分割成更小的单元块</h2><p>大部分人阅读代码的习惯都是，<strong>先看整体再看细节</strong>。所以，我们要有模块化和抽象思维，善于将大块的复杂逻辑提炼成类或者函数，屏蔽掉细节，让阅读代码的人不至于迷失在细节中，这样能极大地提高代码的可读性。不过，<strong>只有代码逻辑比较复杂的时候，我们其实才建议提炼类或者函数</strong>。毕竟如果提炼出的函数只包含两三行代码，在阅读代码的时候，还得跳过去看一下，这样反倒增加了阅读成本。</p><p>这里我举一个例子来进一步解释一下。重构前，在 invest() 函数中，最开始的那段关于时间处理的代码，是不是很难看懂？重构之后，我们将这部分逻辑抽象成一个函数，并且命名为 isLastDayOfMonth，从名字就能清晰地了解它的功能，判断今天是不是当月的最后一天。这里，我们就是通过将复杂的逻辑代码提炼成函数，<strong>大大提高了代码的可读性</strong>。代码具体如下所示：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invest</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> financialProductId)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.setTime(date);</span><br><span class="line">    calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码：提炼函数之后逻辑更加清晰</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invest</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> financialProductId)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isLastDayOfMonth(<span class="keyword">new</span> Date())) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLastDayOfMonth</span><span class="params">(Date date)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Calendar calendar = Calendar.getInstance();</span><br><span class="line">    calendar.setTime(date);</span><br><span class="line">    calendar.set(Calendar.DATE, (calendar.get(Calendar.DATE) + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">if</span> (calendar.get(Calendar.DAY_OF_MONTH) == <span class="number">1</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="避免函数参数过多"><a href="#避免函数参数过多" class="headerlink" title="避免函数参数过多"></a>避免函数参数过多</h2><p>函数包含 3、4 个参数的时候还是能接受的，<strong>大于等于 5 个的时候，我们就觉得参数有点过多了</strong>，会影响到代码的可读性，使用起来也不方便。针对参数过多的情况，一般有 2 种处理方法：</p><ul><li><p>考虑函数是否职责单一，是否能通过<strong>拆分成多个函数</strong>的方式来减少参数。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(String username, String telephone, String email)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成多个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByTelephone</span><span class="params">(String telephone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span></span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>将函数的参数封装成对象</strong>。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postBlog</span><span class="params">(String title, String summary, String keywords, String content, String category, <span class="keyword">long</span> authorId)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将参数封装成对象</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Blog</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String title;</span><br><span class="line">    <span class="keyword">private</span> String summary;</span><br><span class="line">    <span class="keyword">private</span> String keywords;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line">    <span class="keyword">private</span> String category;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> authorId;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postBlog</span><span class="params">(Blog blog)</span></span>;</span><br></pre></td></tr></table></figure></li></ul><p>除此之外，如果函数是对外暴露的远程接口，<strong>将参数封装成对象，还可以提高接口的兼容性</strong>。在往接口中添加新的参数的时候，老的远程接口调用者有可能就不需要修改代码来兼容新的接口了。</p><h2 id="勿用函数参数来控制逻辑"><a href="#勿用函数参数来控制逻辑" class="headerlink" title="勿用函数参数来控制逻辑"></a>勿用函数参数来控制逻辑</h2><p>不要在函数中<strong>使用布尔类型的标识参数来控制内部逻辑</strong>，true 的时候走这块逻辑，false 的时候走另一块逻辑。这明显违背了单一职责原则和接口隔离原则。我建议将其拆成两个函数，可读性上也要更好：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourse</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId, <span class="keyword">boolean</span> isVip)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将其拆分成两个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourse</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">buyCourseForVip</span><span class="params">(<span class="keyword">long</span> userId, <span class="keyword">long</span> courseId)</span></span>;</span><br></pre></td></tr></table></figure><p>不过，如果函数是 <strong>private 私有函数，影响范围有限</strong>，或者拆分之后的<strong>两个函数经常同时被调用</strong>，我们可以酌情考虑保留标识参数。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拆分成两个函数的调用方式</span></span><br><span class="line"><span class="keyword">boolean</span> isVip = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//...省略其他逻辑...</span></span><br><span class="line"><span class="keyword">if</span> (isVip) </span><br><span class="line">&#123;</span><br><span class="line">    buyCourseForVip(userId, courseId);</span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    buyCourse(userId, courseId);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 保留标识参数的调用方式更加简洁</span></span><br><span class="line"><span class="keyword">boolean</span> isVip = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//...省略其他逻辑...</span></span><br><span class="line">buyCourse(userId, courseId, isVip);</span><br></pre></td></tr></table></figure><p>除了布尔类型作为标识参数来控制逻辑的情况外，还有一种<strong>根据参数是否为 null 来控制逻辑</strong>的情况。针对这种情况，我们也应该将其拆分成多个函数。拆分之后的函数职责更明确，不容易用错。具体代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (startDate != <span class="keyword">null</span> &amp;&amp; endDate != <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询两个时间区间的 transactions</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startDate != <span class="keyword">null</span> &amp;&amp; endDate == <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询 startDate 之后的所有 transactions</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startDate == <span class="keyword">null</span> &amp;&amp; endDate != <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询 endDate 之前的所有 transactions</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (startDate == <span class="keyword">null</span> &amp;&amp; endDate == <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 查询所有的 transactions</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成多个 public 函数，更加清晰、易用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> List&lt;Transaction&gt; <span class="title">selectTransactions</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsBetween</span><span class="params">(Long userId, Date startDate, Date endDate)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> selectTransactions(userId, startDate, endDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsStartWith</span><span class="params">(Long userId, Date startDate)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> selectTransactions(userId, startDate, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectTransactionsEndWith</span><span class="params">(Long userId, Date endDate)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> selectTransactions(userId, <span class="keyword">null</span>, endDate);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;Transaction&gt; <span class="title">selectAllTransactions</span><span class="params">(Long userId)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> selectTransactions(userId, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="函数设计要职责单一"><a href="#函数设计要职责单一" class="headerlink" title="函数设计要职责单一"></a>函数设计要职责单一</h2><p>对于函数的设计来说，<strong>更要满足单一职责原则</strong>。相对于类和模块，函数的粒度比较小，代码行数少，所以在应用单一职责原则的时候，没有像应用到类或者模块那样模棱两可，能多单一就多单一。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExisting</span><span class="params">(String telephone, String username, String email)</span>  </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isBlank(telephone)) </span><br><span class="line">    &#123;</span><br><span class="line">        User user = userRepo.selectUserByTelephone(telephone);</span><br><span class="line">        <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isBlank(username)) </span><br><span class="line">    &#123;</span><br><span class="line">        User user = userRepo.selectUserByUsername(username);</span><br><span class="line">        <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!StringUtils.isBlank(email)) </span><br><span class="line">    &#123;</span><br><span class="line">        User user = userRepo.selectUserByEmail(email);</span><br><span class="line">        <span class="keyword">return</span> user != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拆分成三个函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByTelephone</span><span class="params">(String telephone)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByUsername</span><span class="params">(String username)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkUserIfExistingByEmail</span><span class="params">(String email)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="移除过深的嵌套层次"><a href="#移除过深的嵌套层次" class="headerlink" title="移除过深的嵌套层次"></a>移除过深的嵌套层次</h2><p>代码嵌套层次过深往往是因为 if-else、switch-case、for 循环过度嵌套导致的。我个人建议，<strong>嵌套最好不超过两层</strong>，超过两层之后就要思考一下是否可以减少嵌套。过深的嵌套本身理解起来就比较费劲，除此之外，嵌套过深很容易因为代码多次缩进，<strong>导致嵌套内部的语句超过一行的长度而折成两行</strong>，影响代码的整洁。解决嵌套过深的方法也比较成熟，有下面 4 种常见的思路：</p><ul><li><p><strong>去掉多余的 if 或 else 语句</strong>。代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calculateTotalAmount</span><span class="params">(List&lt;Order&gt; orders)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (orders == <span class="keyword">null</span> || orders.isEmpty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> <span class="comment">// 此处的 else 可以去掉</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> amount = <span class="number">0.0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Order order : orders) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (order != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                amount += (order.getCount() * order.getPrice());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> amount;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList, String subStr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (strList != <span class="keyword">null</span> &amp;&amp; subStr != <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (String str : strList) </span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) <span class="comment">// 跟下面的 if 语句可以合并在一起</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.contains(subStr)) </span><br><span class="line">            &#123;</span><br><span class="line">                matchedStrings.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用编程语言提供的 <strong>continue、break、return 关键字</strong>，提前退出嵌套。代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList, String subStr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (strList != <span class="keyword">null</span> &amp;&amp; subStr != <span class="keyword">null</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> (String str : strList) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str != <span class="keyword">null</span> &amp;&amp; str.contains(subStr)) </span><br><span class="line">            &#123;</span><br><span class="line">                matchedStrings.add(str);</span><br><span class="line">                <span class="comment">// 此处还有 10 行代码...</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码：使用 continue 提前退出</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList, String subStr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (strList != <span class="keyword">null</span> &amp;&amp; subStr != <span class="keyword">null</span>)</span><br><span class="line">    &#123; </span><br><span class="line">        <span class="keyword">for</span> (String str : strList) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str == <span class="keyword">null</span> || !str.contains(subStr)) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">continue</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            matchedStrings.add(str);</span><br><span class="line">            <span class="comment">// 此处还有 10 行代码...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>调整执行顺序</strong>来减少嵌套。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList, String subStr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span> (strList != <span class="keyword">null</span> &amp;&amp; subStr != <span class="keyword">null</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (String str : strList) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str.contains(subStr)) </span><br><span class="line">                &#123;</span><br><span class="line">                    matchedStrings.add(str);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码：先执行判空逻辑，再执行正常逻辑</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">matchStrings</span><span class="params">(List&lt;String&gt; strList, String subStr)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strList == <span class="keyword">null</span> || subStr == <span class="keyword">null</span>) <span class="comment">// 先判空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; matchedStrings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String str : strList) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str != <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str.contains(subStr)) </span><br><span class="line">            &#123;</span><br><span class="line">                matchedStrings.add(str);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> matchedStrings;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将部分嵌套逻辑<strong>封装成函数调用</strong>，以此来减少嵌套。具体的代码示例如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 重构前的代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">appendSalts</span><span class="params">(List&lt;String&gt; passwords)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (passwords == <span class="keyword">null</span> || passwords.isEmpty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    List&lt;String&gt; passwordsWithSalt = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String password : passwords) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (password == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (password.length() &lt; <span class="number">8</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passwordsWithSalt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重构后的代码：将部分逻辑抽成函数</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">appendSalts</span><span class="params">(List&lt;String&gt; passwords)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (passwords == <span class="keyword">null</span> || passwords.isEmpty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.emptyList();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;String&gt; passwordsWithSalt = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (String password : passwords) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (password == <span class="keyword">null</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        passwordsWithSalt.add(appendSalt(password));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passwordsWithSalt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">appendSalt</span><span class="params">(String password)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    String passwordWithSalt = password;</span><br><span class="line">    <span class="keyword">if</span> (password.length() &lt; <span class="number">8</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> passwordWithSalt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>除此之外，常用的还有通过<strong>使用多态来替代 if-else、switch-case 条件判断</strong>的方法。这个思路涉及代码结构的改动。</p><h2 id="学会使用解释性变量"><a href="#学会使用解释性变量" class="headerlink" title="学会使用解释性变量"></a>学会使用解释性变量</h2><p>常用的用解释性变量来<strong>提高代码的可读性</strong>的情况有下面 2 种：</p><ul><li><p><strong>常量取代魔法数字</strong>。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="number">3.1415</span>) * radius * radius;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常量替代魔法数字</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Double PI = <span class="number">3.1415</span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">CalculateCircularArea</span><span class="params">(<span class="keyword">double</span> radius)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> PI * radius * radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用解释性变量来解释复杂表达式</strong>。示例代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END)) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 引入解释性变量后逻辑更加清晰</span></span><br><span class="line"><span class="keyword">boolean</span> isSummer = date.after(SUMMER_START) &amp;&amp; date.before(SUMMER_END);</span><br><span class="line"><span class="keyword">if</span> (isSummer) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">else</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码风格</title>
      <link href="2020/11/17/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/"/>
      <url>2020/11/17/%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<h2 id="类、函数多大才合适？"><a href="#类、函数多大才合适？" class="headerlink" title="类、函数多大才合适？"></a>类、函数多大才合适？</h2><p>总体上来讲，<strong>类或函数的代码行数不能太多，但也不能太少</strong>。类或函数的代码行数太多，一个类上千行，一个函数几百行，逻辑过于繁杂，阅读代码的时候，很容易就会看了后面忘了前面。相反，类或函数的代码行数太少，在代码总量相同的情况下，被分割成的类和函数就会相应增多，调用关系就会变得更复杂，阅读某个代码逻辑的时候，需要频繁地在 n 多类或者 n 多函数之间跳来跳去，阅读体验也不好。</p><p>对于函数代码行数的最大限制，网上有一种说法，那就是<strong>不要超过一个显示屏的垂直高度</strong>。比如，在我的电脑上，如果要让一个函数的代码完整地显示在 IDE 中，那最大代码行数不能超过 50。这个说法我觉得挺有道理的。因为超过一屏之后，在阅读代码的时候，为了串联前后的代码逻辑，就可能需要频繁地上下滚动屏幕，阅读体验不好不说，还容易出错。</p><p>对于类的代码行数的最大限制，这个就更难给出一个确切的值了。有一个间接的判断标准 – 当一个类的代码读起来让你感觉头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（<strong>类中包含很多无关此功能实现的函数</strong>）的时候，这就说明类的行数过多了。</p><h2 id="一行代码多长最合适？"><a href="#一行代码多长最合适？" class="headerlink" title="一行代码多长最合适？"></a>一行代码多长最合适？</h2><p>不同的编程语言、不同的规范、不同的项目团队，对此的限制可能都不相同。不管这个限制是多少，总体上来讲我们要遵循的一个原则是：<strong>一行代码最长不能超过 IDE 显示的宽度</strong>。需要滚动鼠标才能查看一行的全部代码，显然不利于代码的阅读。当然，这个限制也不能太小，太小会导致很多稍长点的语句被折成两行，也会影响到代码的整洁，不利于阅读。</p><a id="more"></a><h2 id="善用空行分割单元块"><a href="#善用空行分割单元块" class="headerlink" title="善用空行分割单元块"></a>善用空行分割单元块</h2><p>对于比较长的函数，如果逻辑上可以分为几个独立的代码块，在不方便将这些独立的代码块抽取成小函数的情况下，为了让逻辑更加清晰，<strong>除了用总结性注释的方法之外，我们还可以使用空行来分割各个代码块</strong>。</p><p>除此之外，在类的成员变量与函数之间、静态成员变量与普通成员变量之间、各函数之间、甚至各成员变量之间，我们都可以通过添加空行的方式，让这些不同模块的代码之间，界限更加明确。<strong>写代码就类似写文章，善于应用空行</strong>，可以让代码的整体结构看起来更加有清晰、有条理。</p><h2 id="四格缩进还是两格缩进？"><a href="#四格缩进还是两格缩进？" class="headerlink" title="四格缩进还是两格缩进？"></a>四格缩进还是两格缩进？</h2><p>有一个选择的标准，那就是<strong>跟业内推荐的风格统一、跟著名开源项目统一</strong>。当我们需要拷贝一些开源的代码到项目里的时候，能够让引入的代码跟我们项目本身的代码，保持风格统一。</p><p>除此之外，值得强调的是，不管是用两格缩进还是四格缩进，<strong>一定不要用 tab 键缩进</strong>。因为在不同的 IDE 下，tab 键的显示宽度不同，有的显示为四格缩进，有的显示为两格缩进。</p><h2 id="大括号是否要另起一行？"><a href="#大括号是否要另起一行？" class="headerlink" title="大括号是否要另起一行？"></a>大括号是否要另起一行？</h2><p>左大括号是否要另起一行呢？这个也有争论：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// PHP</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassName</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> function <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Java</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassName</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// method body</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，还是那句话，大括号跟上一条语句在同一行，还是另起新的一行，只要团队统一、业内统一、跟开源项目看齐就好了，<strong>没有绝对的优劣之分</strong>。</p><h2 id="类中成员的排列顺序"><a href="#类中成员的排列顺序" class="headerlink" title="类中成员的排列顺序"></a>类中成员的排列顺序</h2><p>在 Java 类文件中，<strong>先要书写类所属的包名，然后再罗列 import 引入的依赖类</strong>。在 Google 编码规范中，<strong>依赖类按照字母序从小到大排列</strong>。</p><p>在类中，<strong>成员变量排在函数的前面</strong>。成员变量之间或函数之间，都是按照<strong>先静态（静态函数或静态成员变量）、后普通（非静态函数或非静态成员变量）</strong>的方式来排列的。除此之外，成员变量之间或函数之间，还会按照作用域范围从大到小的顺序来排列，<strong>先写 public 成员变量或函数，然后是 protected 的，最后是 private 的</strong>。</p><p>实际上，还有另外一种排列习惯，那就是<strong>把有调用关系的函数放到一块</strong>。比如，一个 public 函数调用了另外一个 private 函数，那就把这两者放到一块。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命名与注释</title>
      <link href="2020/11/17/%E5%91%BD%E5%90%8D%E4%B8%8E%E6%B3%A8%E9%87%8A/"/>
      <url>2020/11/17/%E5%91%BD%E5%90%8D%E4%B8%8E%E6%B3%A8%E9%87%8A/</url>
      
        <content type="html"><![CDATA[<h2 id="命名"><a href="#命名" class="headerlink" title="命名"></a>命名</h2><p>大到项目名、模块名、包名、对外暴露的接口，小到类名、函数名、变量名、参数名，只要是做开发，我们就逃不过“起名字”这一关。命名的好坏，对于代码的可读性来说非常重要，甚至可以说是起决定性作用的。除此之外，<strong>命名能力也体现了一个程序员的基本编程素养</strong>。这也是我把“命名”放到第一个来讲解的原因。</p><p>实际上，命名这件事说难也不难，关键还是看你重不重视，愿不愿意花时间。对于影响范围比较大的命名，比如包名、接口、类名，我们一定<strong>要反复斟酌、推敲</strong>。实在想不到好名字的时候，可以去 GitHub 上用相关的关键词联想搜索一下，看看类似的代码是怎么命名的。</p><h3 id="命名多长最合适？"><a href="#命名多长最合适？" class="headerlink" title="命名多长最合适？"></a>命名多长最合适？</h3><p>尽管长的命名可以包含更多的信息，更能准确直观地表达意图，但是，如果函数、变量的命名很长，那由它们组成的语句就会很长。在代码列长度有限制的情况下，就会<strong>经常出现一条语句被分割成两行的情况</strong>，这其实会影响代码可读性。</p><p>实际上，<strong>在足够表达其含义的情况下，命名当然是越短越好</strong>。但是，大部分情况下，短的命名都没有长的命名更能达意。所以，很多书籍或者文章都不推荐在命名时使用缩写。对于一些默认的、大家都比较熟知的词，我比较推荐用缩写。这样一方面能让命名短一些，另一方面又不影响阅读理解，比如，sec 表示 second、str 表示 string、num 表示 number、doc 表示 document。除此之外，对于作用域比较小的变量，我们可以使用相对短的命名，比如一些函数内的临时变量。相反，<strong>对于类名这种作用域比较大的，我更推荐用长的命名方式</strong>。</p><p>总之，命名的一个原则就是以能准确达意为目标。不过，对于代码的编写者来说，自己对代码的逻辑很清楚，总感觉用什么样的命名都可以达意，实际上，对于不熟悉你代码的同事来讲，可能就不这么认为了。所以，命名的时候，我们一定<strong>要学会换位思考</strong>，假设自己不熟悉这块代码，从代码阅读者的角度去考量命名是否足够直观。</p><a id="more"></a><h3 id="利用上下文简化命名"><a href="#利用上下文简化命名" class="headerlink" title="利用上下文简化命名"></a>利用上下文简化命名</h3><p>先来看一个简单的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String userName;</span><br><span class="line">    <span class="keyword">private</span> String userPassword;</span><br><span class="line">    <span class="keyword">private</span> String userAvatarUrl;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 User 类这样一个上下文中，我们没有必要在成员变量的命名中重复添加“user”这样一个前缀单词，而是直接命名为 name、password、avatarUrl。在使用这些属性时候，我们能<strong>借助对象这样一个上下文，表意也足够明确</strong>。具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.getName(); <span class="comment">// 借助 user 对象这个上下文</span></span><br></pre></td></tr></table></figure><p>除了类之外，函数参数也可以借助函数这个上下文来简化命名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadUserAvatarImageToAliyun</span><span class="params">(String userAvatarImageUri)</span></span>;</span><br><span class="line"><span class="comment">// 利用上下文简化</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">uploadUserAvatarImageToAliyun</span><span class="params">(String imageUri)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="命名要可读、可搜索"><a href="#命名要可读、可搜索" class="headerlink" title="命名要可读、可搜索"></a>命名要可读、可搜索</h3><p>首先，我们来看，什么是命名可读。先解释一下，我这里所说的“可读”，指的是<strong>不要用一些特别生僻、难发音的英文单词来命名</strong>。过去我曾参加过两个项目，一个叫 plateaux，另一个叫 eyrie，从项目立项到结束，自始至终都没有几个人能叫对这两个项目的名字。在沟通的时候，每当有人提到这两个项目的名字的时候，都会尴尬地卡顿一下。虽然我们并不排斥一些独特的命名方式，但起码得让大部分人看一眼就能知道怎么读。</p><p>我们再来讲一下命名可搜索。我们在 IDE 中编写代码的时候，经常会用“关键词联想”的方法来自动补全和搜索。比如，键入某个对象“.get”，希望 IDE <strong>返回这个对象的所有 get 开头的方法</strong>。再比如，通过在 IDE 搜索框中输入“Array”，搜索 JDK 中数组相关的类。所以，我们在命名的时候，最好能符合整个项目的命名习惯。大家都用“selectXXX”表示查询，你就不要用“queryXXX”；大家都用“insertXXX”表示插入一条数据，你就要不用“addXXX”，<strong>统一规约是很重要的，能减少很多不必要的麻烦</strong>。</p><h3 id="如何命名接口和抽象类？"><a href="#如何命名接口和抽象类？" class="headerlink" title="如何命名接口和抽象类？"></a>如何命名接口和抽象类？</h3><p>实际上，对于接口和抽象类，选择哪种命名方式都是可以的，<strong>只要项目里能够统一就行</strong>。</p><p>对于<strong>接口的命名</strong>，一般有两种比较常见的方式：</p><ul><li>加前缀“I”，表示一个 Interface。比如 IUserService，对应的实现类命名为 UserService；</li><li>不加前缀，比如 UserService，对应的实现类加后缀“Impl”，比如 UserServiceImpl；</li></ul><p>对于<strong>抽象类的命名</strong>，也有两种方式：</p><ul><li>带上前缀“Abstract”，比如 AbstractConfiguration；</li><li>不带前缀“Abstract”；</li></ul><h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>命名很重要，注释跟命名同等重要。命名再好，毕竟有长度限制，不可能足够详尽，而这个时候，<strong>注释就是一个很好的补充</strong>。</p><h3 id="注释到底该写什么？"><a href="#注释到底该写什么？" class="headerlink" title="注释到底该写什么？"></a>注释到底该写什么？</h3><p>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：<strong>做什么、为什么、怎么做</strong>。我来举一个例子给你具体解释一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * (what) Bean factory to create beans. </span></span><br><span class="line"><span class="comment"> * </span></span><br><span class="line"><span class="comment"> * (why) The class likes Spring IoC framework, but is more lightweight. </span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * (how) Create objects from different sources sequentially:</span></span><br><span class="line"><span class="comment"> * user specified object &gt; SPI &gt; configuration &gt; default object.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BeansFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注释比代码承载的信息更多<br>命名的主要目的是解释“做什么”。比如，void increaseWalletAvailableBalance(BigDecimal amount) 表明这个函数用来增加钱包的可用余额。函数和变量如果命名得好，确实可以不用再在注释中解释它是做什么的。但是，<strong>对于类来说，包含的信息比较多，一个简单的命名就不够全面详尽了</strong>。这个时候，在注释中写明“做什么”就合情合理了；</li><li>注释起到总结性作用、文档的作用<br>代码之下无秘密。阅读代码可以明确地知道代码是“怎么做”的，也就是知道代码是如何实现的，那注释中是不是就不用写“怎么做”了？实际上也可以写。在注释中，关于具体的代码实现思路，我们可以写一些<strong>总结性的说明、特殊情况的说明</strong>。对于有些比较复杂的类或者接口，我们可能还需要在注释中写清楚“如何用”，<strong>举一些简单的 quick start 的例子</strong>，让使用者在不阅读代码的情况下，快速地知道该如何使用；</li><li>一些总结性注释能让代码结构更清晰<br>对于逻辑比较复杂的代码或者比较长的函数，如果不好提炼、不好拆分成小的函数调用，那我们可以借助总结性的注释来让代码结构更清晰、更有条理：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidPassword</span><span class="params">(String password)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// check if password is null or empty</span></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(password)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// check if the length of password is between 4 and 64</span></span><br><span class="line">    <span class="keyword">int</span> length = password.length();</span><br><span class="line">    <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">// check if password contains only a~z, 0~9, dot</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = password.charAt(i);</span><br><span class="line">        <span class="keyword">if</span> (!((c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="注释是不是越多越好？"><a href="#注释是不是越多越好？" class="headerlink" title="注释是不是越多越好？"></a>注释是不是越多越好？</h3><p><strong>注释太多和太少都有问题</strong>。太多，有可能意味着代码写得不够可读，需要写很多注释来补充。除此之外，注释太多也会对代码本身的阅读起到干扰。而且，后期的维护成本也比较高，有时候代码改了，注释忘了同步修改，就会让代码阅读者更加迷惑；当然，如果代码中一行注释都没有，那只能说明这个程序员很懒，我们要适当督促一下，让他注意添加一些必要的注释。</p><p>按照我的经验来说，<strong>类和函数一定要写注释</strong>，而且要写得尽可能全面、详细，而<strong>函数内部的注释要相对少一些</strong>，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码的可读性。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解耦</title>
      <link href="2020/11/17/%E8%A7%A3%E8%80%A6/"/>
      <url>2020/11/17/%E8%A7%A3%E8%80%A6/</url>
      
        <content type="html"><![CDATA[<h2 id="解耦为何如此重要？"><a href="#解耦为何如此重要？" class="headerlink" title="解耦为何如此重要？"></a>解耦为何如此重要？</h2><p>软件设计与开发最重要的工作之一就是<code>应对复杂性</code>。人处理复杂性的能力是有限的。过于复杂的代码往往在可读性、可维护性上都不友好。那如何来控制代码的复杂性呢？手段有很多，我个人认为，最关键的就是解耦，保证代码松耦合、高内聚。如果说<strong>重构是保证代码质量不至于腐化到无可救药地步的有效手段</strong>，那么利用解耦的方法对代码重构，就是<strong>保证代码不至于复杂到无法控制的有效手段</strong>。</p><p>实际上，“高内聚、松耦合”是一个比较通用的设计思想，不仅可以指导细粒度的类和类之间关系的设计，还能指导粗粒度的系统、架构、模块的设计。相对于编码规范，它<strong>能够在更高层次上提高代码的可读性和可维护性</strong>。</p><p>除此之外，代码“高内聚、松耦合”，也就意味着，代码结构清晰、分层和模块化合理、依赖关系简单、模块或类之间的耦合小，那<strong>代码整体的质量就不会差</strong>。即便某个具体的类或者模块设计得不怎么合理，代码质量不怎么高，影响的范围是非常有限的。我们可以<strong>聚焦于这个模块或者类，做相应的小型重构</strong>。而相对于代码结构的调整，这种改动范围比较集中的小型重构的难度就容易多了。</p><h2 id="代码是否需要解耦？"><a href="#代码是否需要解耦？" class="headerlink" title="代码是否需要解耦？"></a>代码是否需要解耦？</h2><p>间接的衡量标准有很多，前面我们讲到了一些，比如，<strong>看修改代码会不会牵一发而动全身</strong>。除此之外，还有一个直接的衡量标准，也是我在阅读源码的时候经常会用到的，那就是把模块与模块之间、类与类之间的依赖关系画出来，<strong>根据依赖关系图的复杂性来判断是否需要解耦重构</strong>。</p><p>当然，这种判断还是有<strong>比较强的主观色彩</strong>，但是可以作为一种参考和梳理依赖的手段，配合间接的衡量标准一块来使用。</p><a id="more"></a><h2 id="如何给代码解耦？"><a href="#如何给代码解耦？" class="headerlink" title="如何给代码解耦？"></a>如何给代码解耦？</h2><h3 id="封装与抽象"><a href="#封装与抽象" class="headerlink" title="封装与抽象"></a>封装与抽象</h3><p>封装和抽象作为两个非常通用的设计思想，可以应用在很多设计场景中，比如系统、模块、lib、组件、接口、类等等的设计。封装和抽象可以<strong>有效地隐藏实现的复杂性，隔离实现的易变性</strong>，给依赖的模块提供稳定且易用的抽象接口。</p><p>比如，Unix 系统提供的 open() 文件操作函数，我们用起来非常简单，但是底层实现却非常复杂，涉及权限控制、并发控制、物理存储等等。我们通过将其封装成一个抽象的 open() 函数，能够有效控制代码复杂性的蔓延，将复杂性封装在局部代码中。除此之外，因为 open() 函数基于抽象而非具体的实现来定义，所以我们在<strong>改动 open() 函数的底层实现的时候，并不需要改动依赖它的上层代码</strong>，也符合我们前面提到的“高内聚、松耦合”代码的评判标准。</p><h3 id="中间层"><a href="#中间层" class="headerlink" title="中间层"></a>中间层</h3><p>引入中间层能<strong>简化模块或类之间的依赖关系</strong>。下面这张图是引入中间层前后的依赖关系对比图。在引入数据存储中间层之前，A、B、C 三个模块都要依赖内存一级缓存、Redis 二级缓存、DB 持久化存储三个模块。在引入中间层之后，三个模块只需要依赖数据存储一个模块即可。从图上可以看出，中间层的引入明显地简化了依赖关系，让代码结构更加清晰：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/01.png" alt></p><p>除此之外，我们在进行重构的时候，<strong>引入中间层可以起到过渡的作用</strong>，能够让开发和重构同步进行，不互相干扰。比如，某个接口设计得有问题，我们需要修改它的定义，同时，所有调用这个接口的代码都要做相应的改动。如果新开发的代码也用到这个接口，那开发就跟重构冲突了。为了让重构能小步快跑，我们可以分下面四个阶段来完成接口的修改：</p><ol><li>引入一个中间层，包裹老的接口，提供新的接口定义；</li><li>新开发的代码依赖中间层提供的新接口；</li><li>将依赖老接口的代码改为调用新接口；</li><li>确保所有的代码都调用新接口之后，删除掉老的接口；</li></ol><p>这样，每个阶段的开发工作量都不会很大，都可以在很短的时间内完成。<strong>重构跟开发冲突的概率也变小了</strong>。</p><h3 id="模块化"><a href="#模块化" class="headerlink" title="模块化"></a>模块化</h3><p>模块化是<strong>构建复杂系统常用的手段</strong>。不仅在软件行业，在建筑、机械制造等行业，这个手段也非常有用。对于一个大型复杂系统来说，没有人能掌控所有的细节。之所以我们能搭建出如此复杂的系统，并且能维护得了，最主要的原因就是将系统划分成各个独立的模块，让不同的人负责不同的模块，这样即便在不了解全部细节的情况下，管理者也能协调各个模块，让整个系统有效运转。</p><p>实际上，模块化的思想无处不在，像 SOA、微服务、lib 库、系统内模块划分，甚至是类、函数的设计，都体现了模块化思想。如果追本溯源，<strong>模块化思想更加本质的东西就是分而治之</strong>。</p><h3 id="其他设计思想和原则"><a href="#其他设计思想和原则" class="headerlink" title="其他设计思想和原则"></a>其他设计思想和原则</h3><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。很多设计原则都以实现代码的“高内聚、松耦合”为目的。我们来一块总结回顾一下都有哪些原则：</p><ul><li>单一职责原则<br>内聚性和耦合性并非独立的。高内聚会让代码更加松耦合，而<strong>实现高内聚的重要指导原则就是单一职责原则</strong>。模块或者类的职责设计得单一，而不是大而全，那依赖它的类和它依赖的类就会比较少，代码耦合也就相应的降低了；</li><li>基于接口而非实现编程<br><strong>通过接口这样一个中间层，隔离变化和具体的实现</strong>。这样做的好处是，在有依赖关系的两个模块或类之间，一个模块或者类的改动，不会影响到另一个模块或类。实际上，这就相当于<strong>将一种强依赖关系（强耦合）解耦为了弱依赖关系（弱耦合）</strong>；</li><li>依赖注入<br>依赖注入也是将代码之间的强耦合变为弱耦合。尽管依赖注入无法将本应该有依赖关系的两个类，解耦为没有依赖关系，但可以<strong>让耦合关系没那么紧密，容易做到插拔替换</strong>；</li><li>多用组合少用继承<br>继承是一种强依赖关系，父类与子类高度耦合，且这种耦合关系非常脆弱，牵一发而动全身，父类的每一次改动都会影响所有的子类。相反，组合关系是一种弱依赖关系，这种关系更加灵活，所以，对于继承结构比较复杂的代码，<strong>利用组合来替换继承，也是一种解耦的有效手段</strong>；</li><li>迪米特法则<br>迪米特法则讲的是，<strong>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口</strong>。从定义上，我们明显可以看出，这条原则的目的就是为了实现代码的松耦合；</li></ul><p>除了上面讲到的这些设计思想和原则之外，还有一些设计模式也是为了解耦依赖，比如<code>观察者模式</code>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>代码的可测试性</title>
      <link href="2020/11/15/%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7/"/>
      <url>2020/11/15/%E4%BB%A3%E7%A0%81%E7%9A%84%E5%8F%AF%E6%B5%8B%E8%AF%95%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="编写可测试代码案例实战"><a href="#编写可测试代码案例实战" class="headerlink" title="编写可测试代码案例实战"></a>编写可测试代码案例实战</h2><p>其中，Transaction 是经过我抽象简化之后的一个电商系统的交易类，用来记录每笔订单交易的情况。Transaction 类中的 execute() 函数负责执行转账操作，将钱从买家的钱包转到卖家的钱包中。真正的转账操作是通过调用 WalletRpcService RPC 服务来完成的。除此之外，代码中还涉及一个分布式锁 DistributedLock 单例类，用来避免 Transaction 并发执行，导致用户的钱被重复转出。具体的被测试代码如下所示：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> Long buyerId;</span><br><span class="line">    <span class="keyword">private</span> Long sellerId;</span><br><span class="line">    <span class="keyword">private</span> Long productId;</span><br><span class="line">    <span class="keyword">private</span> String orderId;</span><br><span class="line">    <span class="keyword">private</span> Long createTimestamp;</span><br><span class="line">    <span class="keyword">private</span> Double amount;</span><br><span class="line">    <span class="keyword">private</span> STATUS status;</span><br><span class="line">    <span class="keyword">private</span> String walletTransactionId;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...get() methods...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (preAssignedId != <span class="keyword">null</span> &amp;&amp; !preAssignedId.isEmpty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = preAssignedId;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = IdGenerator.generateTransactionId();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.id.startWith(<span class="string">"t_"</span>)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.id = <span class="string">"t_"</span> + preAssignedId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.buyerId = buyerId;</span><br><span class="line">        <span class="keyword">this</span>.sellerId = sellerId;</span><br><span class="line">        <span class="keyword">this</span>.productId = productId;</span><br><span class="line">        <span class="keyword">this</span>.orderId = orderId;</span><br><span class="line">        <span class="keyword">this</span>.status = STATUS.TO_BE_EXECUTED;</span><br><span class="line">        <span class="keyword">this</span>.createTimestamp = System.currentTimestamp();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> InvalidTransactionException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ((buyerId == <span class="keyword">null</span> || (sellerId == <span class="keyword">null</span> || amount &lt; <span class="number">0.0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidTransactionException(...);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (status == STATUS.EXECUTED) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isLocked = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            isLocked = RedisDistributedLock.getSingletonInstance().lockTransaction(id);</span><br><span class="line">            <span class="keyword">if</span> (!isLocked) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// 锁定未成功，返回 false，job 兜底执行</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (status == STATUS.EXECUTED) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>; <span class="comment">// double check</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">long</span> executionInvokedTimestamp = System.currentTimestamp();</span><br><span class="line">            <span class="keyword">if</span> (executionInvokedTimestamp - createdTimestamp &gt; <span class="number">14</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = STATUS.EXPIRED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            WalletRpcService walletRpcService = <span class="keyword">new</span> WalletRpcService();</span><br><span class="line">            String walletTransactionId = walletRpcService.moveMoney(id, buyerId, sellerId, amount);</span><br><span class="line">            <span class="keyword">if</span> (walletTransactionId != <span class="keyword">null</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.walletTransactionId = walletTransactionId;</span><br><span class="line">                <span class="keyword">this</span>.status = STATUS.EXECUTED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">this</span>.status = STATUS.FAILED;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLocked) </span><br><span class="line">            &#123;</span><br><span class="line">                RedisDistributedLock.getSingletonInstance().unlockTransaction(id);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在 Transaction 类中，主要逻辑集中在 execute() 函数中，所以它是我们测试的重点对象。为了尽可能全面覆盖各种正常和异常情况，针对这个函数，我设计了下面 6 个测试用例：</p><ol><li>正常情况下，交易执行成功，回填用于对账（交易与钱包的交易流水）用的 walletTransactionId，交易状态设置为 EXECUTED，函数返回 true；</li><li>buyerId、sellerId 为 null、amount 小于 0，返回 InvalidTransactionException；</li><li>交易已过期（createTimestamp 超过 14 天），交易状态设置为 EXPIRED，返回 false；</li><li>交易已经执行了（status==EXECUTED），不再重复执行转钱逻辑，返回 true；</li><li>钱包（WalletRpcService）转钱失败，交易状态设置为 FAILED，函数返回 false；</li><li>交易正在执行着，不会被重复执行，函数直接返回 false；</li></ol><p>测试用例设计完了。现在看起来似乎一切进展顺利。但是，事实是，当我们将测试用例落实到具体的代码实现时，你就会发现有很多行不通的地方。我们来看测试用例 1 的代码实现。具体如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Long buyerId = <span class="number">123L</span>;</span><br><span class="line">    Long sellerId = <span class="number">234L</span>;</span><br><span class="line">    Long productId = <span class="number">345L</span>;</span><br><span class="line">    Long orderId = <span class="number">456L</span>;</span><br><span class="line">    Transaction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId);</span><br><span class="line">    <span class="keyword">boolean</span> executedResult = transaction.execute();</span><br><span class="line">    assertTrue(executedResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>execute() 函数的执行依赖两个外部的服务</strong>，一个是 RedisDistributedLock，一个 WalletRpcService。这就导致上面的单元测试代码存在下面几个问题：</p><ul><li>如果要让这个单元测试能够运行，我们需要搭建 Redis 服务和 Wallet RPC 服务。搭建和维护的成本比较高；</li><li>我们还需要保证将伪造的 transaction 数据发送给 Wallet RPC 服务之后，能够正确返回我们期望的结果，然而 Wallet RPC 服务有可能是第三方（另一个团队开发维护的）的服务，并不是我们可控的。换句话说，并不是我们想让它返回什么数据就返回什么；</li><li>Transaction 的执行跟 Redis、RPC 服务通信，需要走网络，耗时可能会比较长，对单元测试本身的执行性能也会有影响；</li><li>网络的中断、超时、Redis、RPC 服务的不可用，都会影响单元测试的执行；</li></ul><p>我们回到单元测试的定义上来看一下。单元测试主要是测试程序员自己编写的代码逻辑的正确性，<strong>并非是端到端的集成测试</strong>，它不需要测试所依赖的外部系统（分布式锁、Wallet RPC 服务）的逻辑正确性。所以，如果代码中依赖了外部系统或者不可控组件，比如，需要依赖数据库、网络通信、文件系统等，那我们就<strong>需要将被测代码与外部系统解依赖</strong>，而这种解依赖的方法就叫作<code>mock</code>。所谓的 mock 就是用一个“假”的服务替换真正的服务。mock 的服务完全在我们的控制之下，模拟输出我们想要的数据。</p><blockquote><p>mock 的方式主要有两种：手动 mock 和利用框架 mock。</p></blockquote><p>我们通过继承 WalletRpcService 类，并且重写其中的 moveMoney() 函数的方式来实现 mock。通过 mock 的方式，我们可以让 moveMoney() 返回任意我们想要的数据，完全在我们的控制范围内，并且不需要真正进行网络通信。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWalletRpcServiceOne</span> <span class="keyword">extends</span> <span class="title">WalletRpcService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">moveMoney</span><span class="params">(Long id, Long fromUserId, Long toUserId, Double amount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"123bac"</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MockWalletRpcServiceTwo</span> <span class="keyword">extends</span> <span class="title">WalletRpcService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">moveMoney</span><span class="params">(Long id, Long fromUserId, Long toUserId, Double amount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们再来看，如何用 MockWalletRpcServiceOne、MockWalletRpcServiceTwo 来替换代码中的真正的 WalletRpcService 呢？因为 WalletRpcService 是在 execute() 函数中<strong>通过 new 的方式创建的，我们无法动态地对其进行替换</strong>。也就是说，Transaction 类中的 execute() 方法的可测试性很差，需要通过重构来让其变得更容易测试。</p><p>我们可以应用<code>依赖注入</code>，将 WalletRpcService 对象的创建反转给上层逻辑，在外部创建好之后，再注入到 Transaction 类中。重构之后的 Transaction 类的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">// 添加一个成员变量及其 set 方法</span></span><br><span class="line">    <span class="keyword">private</span> WalletRpcService walletRpcService;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setWalletRpcService</span><span class="params">(WalletRpcService walletRpcService)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.walletRpcService = walletRpcService;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        <span class="comment">// 删除下面这一行代码</span></span><br><span class="line">        <span class="comment">// WalletRpcService walletRpcService = new WalletRpcService();</span></span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们就可以在单元测试中，非常容易地将 WalletRpcService 替换成 MockWalletRpcServiceOne 或 WalletRpcServiceTwo 了。重构之后的代码对应的单元测试如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Long buyerId = <span class="number">123L</span>;</span><br><span class="line">    Long sellerId = <span class="number">234L</span>;</span><br><span class="line">    Long productId = <span class="number">345L</span>;</span><br><span class="line">    Long orderId = <span class="number">456L</span>;</span><br><span class="line">    Transaction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId);</span><br><span class="line">    <span class="comment">// 使用 mock 对象来替代真正的 RPC 服务</span></span><br><span class="line">    transaction.setWalletRpcService(<span class="keyword">new</span> MockWalletRpcServiceOne()):</span><br><span class="line">    <span class="keyword">boolean</span> executedResult = transaction.execute();</span><br><span class="line">    assertTrue(executedResult);</span><br><span class="line">    assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>WalletRpcService 的 mock 和替换问题解决了，我们再来看 RedisDistributedLock。它的 mock 和替换要复杂一些，主要是因为 RedisDistributedLock 是一个单例类。<strong>单例相当于一个全局变量，我们无法 mock（无法继承和重写方法），也无法通过依赖注入的方式来替换</strong>。</p><p>如果 RedisDistributedLock 是我们自己维护的，可以自由修改、重构，那我们可以<strong>将其改为非单例的模式，或者定义一个接口</strong>，比如 IDistributedLock，让 RedisDistributedLock 实现这个接口。这样我们就可以像前面 WalletRpcService 的替换方式那样，替换 RedisDistributedLock 为 MockRedisDistributedLock 了；但如果 RedisDistributedLock 不是我们维护的，我们无权去修改这部分代码，我们可以<strong>对 transaction 上锁这部分逻辑重新封装一下</strong>。具体代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionLock</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String id)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RedisDistributedLock.getSingletonInstance().lockTransaction(id);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RedisDistributedLock.getSingletonInstance().unlockTransaction(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">private</span> TransactionLock lock;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTransactionLock</span><span class="params">(TransactionLock lock)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lock = lock;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            isLocked = lock.lock();</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">finally</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (isLocked) </span><br><span class="line">            &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对重构过的代码，我们的单元测试代码修改为下面这个样子。这样，我们就能在单元测试代码中隔离真正的 RedisDistributedLock 分布式锁这部分逻辑了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Long buyerId = <span class="number">123L</span>;</span><br><span class="line">    Long sellerId = <span class="number">234L</span>;</span><br><span class="line">    Long productId = <span class="number">345L</span>;</span><br><span class="line">    Long orderId = <span class="number">456L</span>;</span><br><span class="line">    </span><br><span class="line">    TransactionLock mockLock = <span class="keyword">new</span> TransactionLock() </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">lock</span><span class="params">(String id)</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    Transaction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId);</span><br><span class="line">    transaction.setWalletRpcService(<span class="keyword">new</span> MockWalletRpcServiceOne());</span><br><span class="line">    transaction.setTransactionLock(mockLock);</span><br><span class="line">    <span class="keyword">boolean</span> executedResult = transaction.execute();</span><br><span class="line">    assertTrue(executedResult);</span><br><span class="line">    assertEquals(STATUS.EXECUTED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们再来看测试用例 3：交易已过期（createTimestamp 超过 14 天），交易状态设置为 EXPIRED，返回 false。针对这个单元测试用例，我们还是先把代码写出来，然后再来分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute_with_TransactionIsExpired</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Long buyerId = <span class="number">123L</span>;</span><br><span class="line">    Long sellerId = <span class="number">234L</span>;</span><br><span class="line">    Long productId = <span class="number">345L</span>;</span><br><span class="line">    Long orderId = <span class="number">456L</span>;</span><br><span class="line">    Transaction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId);</span><br><span class="line">    transaction.setCreatedTimestamp(System.currentTimestamp() - <span class="number">14</span>);</span><br><span class="line">    <span class="keyword">boolean</span> actualResult = transaction.execute();</span><br><span class="line">    assertFalse(actualResult);</span><br><span class="line">    assertEquals(STATUS.EXPIRED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码看似没有任何问题。我们将 transaction 的创建时间 createdTimestamp 设置为 14 天前，也就是说，当单元测试代码运行的时候，transaction 一定是处于过期状态。实际上，这<strong>违反了类的封装特性</strong>。在 Transaction 类的设计中，createTimestamp 是在交易生成时（也就是构造函数中）自动获取的系统时间，本来就不应该人为地轻易修改，所以，暴露 createTimestamp 的 set 方法，虽然带来了灵活性，但也带来了不可控性。</p><p>实际上，这是一类比较常见的问题，就是<strong>代码中包含跟时间有关的未决行为逻辑</strong>。我们一般的处理方式是将这种未决行为逻辑<code>二次封装</code>。针对 Transaction 类，我们只需要将交易是否过期的逻辑，封装到 isExpired() 函数中即可，具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transaction</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> executionInvokedTimestamp = System.currentTimestamp();</span><br><span class="line">        <span class="keyword">return</span> executionInvokedTimestamp - createdTimestamp &gt; <span class="number">14</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> InvalidTransactionException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">if</span> (isExpired()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">this</span>.status = STATUS.EXPIRED;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对重构之后的代码，测试用例 3 的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testExecute_with_TransactionIsExpired</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Long buyerId = <span class="number">123L</span>;</span><br><span class="line">    Long sellerId = <span class="number">234L</span>;</span><br><span class="line">    Long productId = <span class="number">345L</span>;</span><br><span class="line">    Long orderId = <span class="number">456L</span>;</span><br><span class="line">    Transaction transaction = <span class="keyword">new</span> Transaction(<span class="keyword">null</span>, buyerId, sellerId, productId, orderId) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">boolean</span> actualResult = transaction.execute();</span><br><span class="line">    assertFalse(actualResult);</span><br><span class="line">    assertEquals(STATUS.EXPIRED, transaction.getStatus());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Transaction 类的构造函数的设计还有点不妥。我们发现，构造函数中并非只包含简单赋值操作。<strong>交易 id 的赋值逻辑稍微复杂，我们最好也要测试一下</strong>，以保证这部分逻辑的正确性。为了方便测试，我们可以把 id 赋值这部分逻辑单独抽象到一个函数中，具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Transaction</span><span class="params">(String preAssignedId, Long buyerId, Long sellerId, Long productId, String orderId)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    fillTransactionId(preAssignId);</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">fillTransactionId</span><span class="params">(String preAssignedId)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preAssignedId != <span class="keyword">null</span> &amp;&amp; !preAssignedId.isEmpty()) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = preAssignedId;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = IdGenerator.generateTransactionId();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">this</span>.id.startWith(<span class="string">"t_"</span>)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="string">"t_"</span> + preAssignedId;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>到此为止，我们一步一步将 Transaction 从不可测试代码重构成了测试性良好的代码。不过，你可能还会有疑问，Transaction 类中 isExpired() 函数就不用测试了吗？对于 isExpired() 函数，逻辑非常简单，<strong>肉眼就能判定是否有 bug，是可以不用写单元测试的</strong>。</p><p>实际上，<strong>可测试性差的代码，本身代码设计得也不够好</strong>，很多地方都没有遵守我们之前讲到的设计原则和思想，比如“基于接口而非实现编程”思想、依赖反转原则等。重构之后的代码，不仅可测试性更好，而且从代码设计的角度来说，也遵从了经典的设计原则和思想。</p><blockquote><p>代码的可测试性，可以从侧面上反应代码设计是否合理。</p></blockquote><h2 id="常见的-Anti-Patterns"><a href="#常见的-Anti-Patterns" class="headerlink" title="常见的 Anti-Patterns"></a>常见的 Anti-Patterns</h2><p>刚刚我们通过一个实战案例，讲解了<strong>如何利用依赖注入来提高代码的可测试性</strong>，以及编写单元测试中最复杂的一部分内容：<strong>如何通过 mock、二次封装等方式解依赖外部服务</strong>。现在，我们再来总结一下，有哪些典型的、常见的测试性不好的代码，也就是我们常说的 Anti-Patterns。</p><h3 id="未决行为"><a href="#未决行为" class="headerlink" title="未决行为"></a>未决行为</h3><p>所谓的未决行为逻辑就是，代码的输出是随机或者说不确定的，比如，跟时间、随机数有关的代码。</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>前面我们讲过，<strong>全局变量是一种面向过程的编程风格，有种种弊端</strong>。实际上，滥用全局变量也让编写单元测试变得困难。我举个例子来解释一下。RangeLimiter 表示一个 [-5, 5] 的区间，position 初始在 0 位置，move() 函数负责移动 position。其中，position 是一个静态全局变量。RangeLimiterTest 类是为其设计的单元测试，不过，这里面存在很大的问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RangeLimiter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicInteger position = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_LIMIT = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_LIMIT = -<span class="number">5</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">move</span><span class="params">(<span class="keyword">int</span> delta)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> currentPos = position.addAndGet(delta);</span><br><span class="line">        <span class="keyword">boolean</span> betweenRange = (currentPos &lt;= MAX_LIMIT) &amp;&amp; (currentPos &gt;= MIN_LIMIT);</span><br><span class="line">        <span class="keyword">return</span> betweenRange;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RangeLimiterTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMove_betweenRange</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RangeLimiter rangeLimiter = <span class="keyword">new</span> RangeLimiter();</span><br><span class="line">        assertTrue(rangeLimiter.move(<span class="number">1</span>));</span><br><span class="line">        assertTrue(rangeLimiter.move(<span class="number">3</span>));</span><br><span class="line">        assertTrue(rangeLimiter.move(-<span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testMove_exceedRange</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        RangeLimiter rangeLimiter = <span class="keyword">new</span> RangeLimiter();</span><br><span class="line">        assertFalse(rangeLimiter.move(<span class="number">6</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的单元测试有可能会运行失败。假设单元测试框架顺序依次执行 testMove_betweenRange() 和 testMove_exceedRange() 两个测试用例。在第一个测试用例执行完成之后，position 的值变成了 -1；再执行第二个测试用例的时候，position 变成了 5，move() 函数返回 true，assertFalse 语句判定失败。所以，第二个测试用例运行失败。</p><p>每个单元测试框架执行单元测试用例的方式可能是不同的。<strong>有的是顺序执行，有的是并发执行</strong>。对于并发执行的情况，即便我们每次都把 position 重设为 0，也并不奏效。如果两个测试用例并发执行，可能会影响到 move() 函数的执行结果。</p><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><strong>静态方法跟全局变量一样，也是一种面向过程的编程思维</strong>。在代码中调用静态方法，有时候会导致代码不易测试。主要原因是静态方法也很难 mock。但是，这个要分情况来看。只有在这个静态方法执行耗时太长、依赖外部资源、逻辑复杂、行为未决等情况下，我们才需要在单元测试中 mock 这个静态方法。除此之外，如果只是类似 Math.abs() 这样的<strong>简单静态方法，并不会影响代码的可测试性</strong>，因为本身并不需要 mock。</p><h3 id="复杂继承"><a href="#复杂继承" class="headerlink" title="复杂继承"></a>复杂继承</h3><p>相比组合关系，<strong>继承关系的代码结构更加耦合、不灵活，更加不易扩展、不易维护</strong>。如果父类需要 mock 某个依赖对象才能进行单元测试，那所有的子类、子类的子类…在编写单元测试的时候，都要 mock 这个依赖对象。对于层次很深（在继承关系类图中表现为<code>纵向深度</code>）、结构复杂（在继承关系类图中表现为<code>横向广度</code>）的继承关系，越底层的子类要 mock 的对象可能就会越多，这样就会导致，底层子类在写单元测试的时候，要一个一个 mock 很多依赖对象，而且还需要查看父类代码，去了解该如何 mock 这些依赖对象。</p><p>如果我们利用组合而非继承来组织类之间的关系，<strong>类之间的结构层次比较扁平</strong>，在编写单元测试的时候，只需要 mock 类所组合依赖的对象即可。</p><h3 id="紧耦合代码"><a href="#紧耦合代码" class="headerlink" title="紧耦合代码"></a>紧耦合代码</h3><p>如果一个类职责很重，需要依赖十几个外部对象才能完成工作，代码高度耦合，那我们在编写单元测试的时候，可能需要 mock 这十几个依赖的对象。不管是<strong>从代码设计的角度来说，还是从编写单元测试的角度来说</strong>，这都是不合理的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单元测试</title>
      <link href="2020/11/13/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
      <url>2020/11/13/%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<h2 id="什么是单元测试？"><a href="#什么是单元测试？" class="headerlink" title="什么是单元测试？"></a>什么是单元测试？</h2><p><code>单元测试</code>（Unit Testing）由研发工程师自己来编写，用来测试自己写的代码的正确性。我们常常将它跟<code>集成测试</code>（Integration Testing）放到一块来对比。单元测试相对于集成测试来说，测试的粒度更小一些。集成测试的<strong>测试对象是整个系统或者某个功能模块</strong>，比如测试用户注册、登录功能是否正常，是一种端到端的测试。而单元测试的<strong>测试对象是类或者函数</strong>，用来测试一个类和函数是否都按照预期的逻辑执行，是代码层级的测试。</p><p>这么说比较理论，我举个例子来解释一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Text</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String content;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Text</span><span class="params">(String content)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.content = content;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 将字符串转化成数字，忽略字符串中的首尾空格</span></span><br><span class="line"><span class="comment">     * 如果字符串中包含除首尾空格之外的非数字字符，则返回 null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">toNumber</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (content == <span class="keyword">null</span> || content.isEmpty()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...省略代码实现...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>实际上，写单元测试本身不需要什么高深技术。它更多的是<strong>考验程序员思维的缜密程度</strong>，看能否设计出覆盖各种正常及异常情况的测试用例，来保证代码在任何预期或非预期的情况下都能正确运行。</p><p>为了保证测试的全面性，针对 toNumber() 函数，我们需要设计下面这样几个测试用例：</p><ul><li>如果字符串只包含数字：“123”，toNumber() 函数输出对应的整数：123；</li><li>如果字符串是空或者 null，toNumber() 函数返回：null；</li><li>如果字符串包含首尾空格：“ 123”，“123 ”，“ 123 ”，toNumber() 返回对应的整数：123；</li><li>如果字符串包含多个首尾空格：“ 123 ”，toNumber() 返回对应的整数：123；</li><li>如果字符串包含非数字字符：“123a4”，“123 4”，toNumber() 返回 null；</li></ul><p>当我们设计好测试用例之后，剩下的就是将其翻译成代码了（我们这里没有使用任何测试框架）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Assert</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">assertEquals</span><span class="params">(Integer expectedValue, Integer actualValue)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (actualValue != expectedValue) </span><br><span class="line">        &#123;</span><br><span class="line">            String message = String.format(</span><br><span class="line">                <span class="string">"Test failed, expected: %d, actual: %d."</span>, expectedValue, actualValue);</span><br><span class="line">            System.out.println(message);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test succeeded."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">assertNull</span><span class="params">(Integer actualValue)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> isNull = actualValue == <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (isNull) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test succeeded."</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test failed, the value is not null:"</span> + actualValue);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNull;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCaseRunner</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Run testToNumber()"</span>);</span><br><span class="line">        <span class="keyword">new</span> TextTest().testToNumber();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Run testToNumber_nullOrEmpty()"</span>);</span><br><span class="line">        <span class="keyword">new</span> TextTest().testToNumber_nullOrEmpty();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Run testToNumber_containsLeadingAndTrailingSpaces()"</span>);</span><br><span class="line">        <span class="keyword">new</span> TextTest().testToNumber_containsLeadingAndTrailingSpaces();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Run testToNumber_containsMultiLeadingAndTrailingSpaces()"</span>);</span><br><span class="line">        <span class="keyword">new</span> TextTest().testToNumber_containsMultiLeadingAndTrailingSpaces();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"Run testToNumber_containsInvalidCharacters()"</span>);</span><br><span class="line">        <span class="keyword">new</span> TextTest().testToNumber_containsInvalidCharacters();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text = <span class="keyword">new</span> Text(<span class="string">"123"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">123</span>, text.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber_nullOrEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text1 = <span class="keyword">new</span> Text(<span class="keyword">null</span>);</span><br><span class="line">        Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text2 = <span class="keyword">new</span> Text(<span class="string">""</span>);</span><br><span class="line">        Assert.assertNull(text2.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber_containsLeadingAndTrailingSpaces</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text1 = <span class="keyword">new</span> Text(<span class="string">" 123"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">123</span>, text1.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text2 = <span class="keyword">new</span> Text(<span class="string">"123 "</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">123</span>, text2.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text3 = <span class="keyword">new</span> Text(<span class="string">" 123 "</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">123</span>, text3.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber_containsMultiLeadingAndTrailingSpaces</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text1 = <span class="keyword">new</span> Text(<span class="string">"  123"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">123</span>, text1.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text2 = <span class="keyword">new</span> Text(<span class="string">"123  "</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">123</span>, text2.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text3 = <span class="keyword">new</span> Text(<span class="string">"  123  "</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">123</span>, text3.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber_containsInvalidCharacters</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text1 = <span class="keyword">new</span> Text(<span class="string">"123a4"</span>);</span><br><span class="line">        Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text2 = <span class="keyword">new</span> Text(<span class="string">"123 4"</span>);</span><br><span class="line">        Assert.assertNull(text2.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="为什么要写单元测试？"><a href="#为什么要写单元测试？" class="headerlink" title="为什么要写单元测试？"></a>为什么要写单元测试？</h2><p>单元测试除了能有效地为重构保驾护航之外，也是保证代码质量最有效的两个手段之一（另一个是 <code>Code Review</code>），我总结了以下几点单元测试的好处：</p><ol><li>单元测试能有效地帮你发现代码中的 bug<br>能否写出 bug free 的代码，是判断工程师编码能力的重要标准之一，也是很多大厂面试考察的重点，特别是像 FLAG 这样的外企。即便像我这样代码写了十几年，逻辑还算缜密、清晰的人，<strong>通过单元测试也常常会发现代码中的很多考虑不全面的地方</strong>。它节省了我很多 fix 低级 bug 的时间，能够有时间去做其他更有意义的事情，我也因此在工作上赢得了很多人的认可。可以这么说，坚持写单元测试是保证我的代码质量的一个“杀手锏”，也是<strong>帮助我拉开与其他人差距的一个“小秘密”</strong>。</li><li>写单元测试能帮你发现代码设计上的问题<br>对于一段代码，如果很难为其编写单元测试，或者单元测试写起来很吃力，需要依靠单元测试框架里很高级的特性才能完成，那往往就意味着<strong>代码设计得不够合理</strong>，比如，没有使用依赖注入、大量使用静态函数、全局变量、代码高度耦合等。</li><li>单元测试是对集成测试的有力补充<br>程序运行的 bug 往往出现在一些边界条件、异常情况下，比如，除数未判空、网络超时。而<strong>大部分异常情况都比较难在测试环境中模拟</strong>。而单元测试可以利用 mock 的方式，控制 mock 的对象返回我们需要模拟的异常，来测试代码在这些异常情况的表现。除此之外，对于一些复杂系统来说，<strong>集成测试也无法覆盖得很全面</strong>。复杂系统往往有很多模块。每个模块都有各种输入、输出、异常情况，组合起来，整个系统就有无数测试场景需要模拟，无数的测试用例需要设计，再强大的测试团队也无法穷举完备。</li><li>写单元测试的过程本身就是代码重构的过程<br>写单元测试实际上就是落地执行持续重构的一个有效途径。设计和实现代码的时候，我们很难把所有的问题都想清楚。而编写单元测试就相当于<strong>对代码的一次自我 Code Review</strong>，在这个过程中，我们可以发现一些设计上的问题（比如代码设计的不可测试）以及代码编写方面的问题（比如一些边界条件处理不当）等，然后针对性的进行重构。</li><li>阅读单元测试能帮助你快速熟悉代码<br>阅读代码最有效的手段，就是<strong>先了解它的业务背景和设计思路</strong>，然后再去看代码，这样代码读起来就会轻松很多。在没有文档和注释的情况下，单元测试就起了替代性作用。<strong>单元测试用例实际上就是用户用例</strong>，反映了代码的功能和如何使用。借助单元测试，我们不需要深入的阅读代码，便能知道代码实现了什么功能，有哪些特殊情况需要考虑，有哪些边界条件需要处理。</li><li>单元测试是 TDD 可落地执行的改进方案<br>测试驱动开发（Test-Driven Development，简称 <code>TDD</code>）是一个经常被提及但很少被执行的开发模式。它的核心指导思想就是测试用例先于代码编写。不过，要让程序员能彻底地接受和习惯这种开发模式还是挺难的，毕竟很多程序员连单元测试都懒得写，更何况在编写代码之前先写好测试用例了。<strong>单元测试正好是对 TDD 的一种改进方案</strong>，先写代码，紧接着写单元测试，最后根据单元测试反馈出来问题，再回过头去重构代码。这个开发流程更加容易被接受，更加容易落地执行，而且又兼顾了 TDD 的优点。</li></ol><h2 id="如何编写单元测试？"><a href="#如何编写单元测试？" class="headerlink" title="如何编写单元测试？"></a>如何编写单元测试？</h2><blockquote><p>写单元测试就是针对代码设计覆盖各种输入、异常、边界条件的测试用例，并将这些测试用例翻译成代码的过程。</p></blockquote><p>在把测试用例翻译成代码的时候，我们可以利用单元测试框架，来简化测试代码的编写。比如，Java 中比较出名的单元测试框架有 JUnit、TestNG、Spring Test 等。这些框架提供了<code>通用的执行流程</code>（比如执行测试用例的 TestCaseRunner）和<code>工具类库</code>（比如各种 Assert 判断函数）等。借助它们，我们在编写测试代码的时候，<strong>只需要关注测试用例本身的编写即可</strong>。</p><p>针对 toNumber() 函数的测试用例，我们利用 JUnit 单元测试框架重新实现一下，具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.junit.Assert;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TextTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text = <span class="keyword">new</span> Text(<span class="string">"123"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">123</span>), text.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber_nullOrEmpty</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text1 = <span class="keyword">new</span> Text(<span class="keyword">null</span>);</span><br><span class="line">        Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text2 = <span class="keyword">new</span> Text(<span class="string">""</span>);</span><br><span class="line">        Assert.assertNull(text2.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber_containsLeadingAndTrailingSpaces</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text1 = <span class="keyword">new</span> Text(<span class="string">" 123"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">123</span>), text1.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text2 = <span class="keyword">new</span> Text(<span class="string">"123 "</span>);</span><br><span class="line">        Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">123</span>), text2.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text3 = <span class="keyword">new</span> Text(<span class="string">" 123 "</span>);</span><br><span class="line">        Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">123</span>), text3.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber_containsMultiLeadingAndTrailingSpaces</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text1 = <span class="keyword">new</span> Text(<span class="string">"  123"</span>);</span><br><span class="line">        Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">123</span>), text1.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text2 = <span class="keyword">new</span> Text(<span class="string">"123  "</span>);</span><br><span class="line">        Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">123</span>), text2.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text3 = <span class="keyword">new</span> Text(<span class="string">"  123  "</span>);</span><br><span class="line">        Assert.assertEquals(<span class="keyword">new</span> Integer(<span class="number">123</span>), text3.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testToNumber_containsInvalidCharacters</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Text text1 = <span class="keyword">new</span> Text(<span class="string">"123a4"</span>);</span><br><span class="line">        Assert.assertNull(text1.toNumber());</span><br><span class="line"></span><br><span class="line">        Text text2 = <span class="keyword">new</span> Text(<span class="string">"123 4"</span>);</span><br><span class="line">        Assert.assertNull(text2.toNumber());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于如何使用这些单元测试框架，大部分框架都给出了非常详细的官方文档，你可以自行查阅。关于如何编写单元测试，我更希望传达给你一些我的经验总结。具体包括以下几点：</p><ol><li><p>写单元测试真的是件很耗时的事情吗？<br>尽管单元测试的代码量可能是被测代码本身的 1~2 倍，写的过程很繁琐，但<strong>并不是很耗时</strong>。毕竟我们不需要考虑太多代码设计上的问题，测试代码实现起来也比较简单。不同测试用例之间的代码差别可能并不是很大，简单 copy-paste 改改就行。</p></li><li><p>对单元测试的代码质量有什么要求吗？<br>单元测试毕竟不会在产线上运行，而且每个类的测试代码也比较独立，基本不互相依赖。所以，相对于被测代码，我们对单元测试代码的质量可以放低一些要求。<strong>命名稍微有些不规范，代码稍微有些重复</strong>，也都是没有问题的。</p></li><li><p>单元测试只要覆盖率高就够了吗？<br> <strong>单元测试覆盖率是比较容易量化的指标</strong>，常常作为单元测试写得好坏的评判标准。有很多现成的工具专门用来做覆盖率统计，比如，JaCoCo、Cobertura、Emma、Clover。覆盖率的计算方式有很多种，比较简单的是语句覆盖，稍微高级点的有：条件覆盖、判定覆盖、路径覆盖。<br> 不管覆盖率的计算方式如何高级，<strong>将覆盖率作为衡量单元测试质量的唯一标准是不合理的</strong>。实际上，更重要的是要看测试用例是否覆盖了所有可能的情况，特别是一些 corner case。像下面这段代码，我们只需要一个测试用例就可以做到 100% 覆盖率，比如 cal(10.0, 2.0)，但并不代表测试足够全面了，我们还需要考虑，当除数等于０的情况下，代码执行是否符合预期：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">cal</span><span class="params">(<span class="keyword">double</span> a, <span class="keyword">double</span> b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="number">0</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a / b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 实际上，<strong>过度关注单元测试的覆盖率会导致开发人员为了提高覆盖率，写很多没有必要的测试代码</strong>，比如 get、set 方法非常简单，没有必要测试。从过往的经验上来讲，一个项目的单元测试覆盖率在 60～70% 即可上线。</p></li><li><p>写单元测试需要了解代码的实现逻辑吗？<br>单元测试<strong>不要依赖被测试函数的具体实现逻辑，它只关心被测函数实现了什么功能</strong>。我们切不可为了追求覆盖率，逐行阅读代码，然后针对实现逻辑编写单元测试。否则，一旦对代码进行重构，在代码的外部行为不变的情况下，对代码的实现逻辑进行了修改，那原本的单元测试都会运行失败，也就起不到为重构保驾护航的作用了，也<strong>违背了我们写单元测试的初衷</strong>。</p></li><li><p>如何选择单元测试框架？<br>写单元测试本身不需要太复杂的技术，大部分单元测试框架都能满足。在公司内部，起码<strong>团队内部需要统一单元测试框架</strong>。如果自己写的代码用已经选定的单元测试框架无法测试，那多半是代码写得不够好，代码的可测试性不够好。这个时候，我们要重构自己的代码，让其更容易测试，<strong>而不是去找另一个更加高级的单元测试框架</strong>。</p></li></ol><h2 id="单元测试为何难落地执行？"><a href="#单元测试为何难落地执行？" class="headerlink" title="单元测试为何难落地执行？"></a>单元测试为何难落地执行？</h2><p>写单元测试确实是一件考验耐心的活儿。一般情况下，单元测试的代码量要大于被测试代码量，甚至是要多出好几倍。很多人往往会觉得<strong>写单元测试比较繁琐</strong>，并且没有太多挑战，而不愿意去做。有很多团队和项目在刚开始推行单元测试的时候，还比较认真，执行得比较好。但当开发任务紧了之后，就开始放低对单元测试的要求，<strong>一旦出现破窗效应，慢慢的，大家就都不写了</strong>，这种情况很常见。</p><p>还有一种情况就是，由于历史遗留问题，原来的代码都没有写单元测试，代码已经堆砌了十几万行了，不可能再一个一个去补单元测试。这种情况下，我们首先要<strong>保证新写的代码都要有单元测试</strong>，其次，每次在改动到某个类时，如果没有单元测试就顺便补上，不过这<strong>要求工程师们有足够强的主人翁意识</strong>（ownership），毕竟光靠 leader 督促，很多事情是很难执行到位的。</p><p>除此之外，还有人觉得，有了测试团队，写单元测试就是浪费时间，没有必要。程序员这一行业本该是智力密集型的，但现在很多公司把它搞成劳动密集型的，包括一些大厂，在开发过程中，既没有单元测试，也没有 Code Review 流程。即便有，做的也是差强人意。<strong>写好代码直接提交，然后丢给黑盒测试狠命去测</strong>，测出问题就反馈给开发团队再修改，测不出的问题就留在线上出了问题再修复。在这样的开发模式下，团队往往觉得没有必要写单元测试，但如果我们把单元测试写好、做好 Code Review，<strong>重视起代码质量，其实可以很大程度上减少黑盒测试的投入</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重构</title>
      <link href="2020/11/11/%E9%87%8D%E6%9E%84/"/>
      <url>2020/11/11/%E9%87%8D%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h2 id="重构的目的（Why）"><a href="#重构的目的（Why）" class="headerlink" title="重构的目的（Why）"></a>重构的目的（Why）</h2><p>软件设计大师 Martin Fowler 是这样定义重构的：</p><blockquote><p>重构是一种对软件内部结构的改善，目的是在不改变软件的可见行为的情况下，使其更易理解，修改成本更低。</p></blockquote><p>这个定义中有一个值得强调的点：<strong>重构不改变外部的可见行为</strong>。我们可以把重构理解为，在保持功能不变的前提下，利用设计思想、原则、模式、编程规范等理论来优化代码，<strong>修改设计上的不足，提高代码质量</strong>。</p><p>首先，<strong>重构是时刻保证代码质量的一个极其有效的手段</strong>，不至于让代码腐化到无可救药的地步。项目在演进，代码不停地在堆砌。如果没有人为代码的质量负责任，代码总是会往越来越混乱的方向演进。当混乱到一定程度之后，量变引起质变，<strong>项目的维护成本已经高过重新开发一套新代码的成本</strong>，想要再去重构，已经没有人能做到了。</p><p>其次，优秀的代码或架构不是一开始就能完全设计好的，就像优秀的公司和产品也都是迭代出来的。我们无法 100% 遇见未来的需求，也没有足够的精力、时间、资源为遥远的未来买单，所以，<strong>随着系统的演进，重构代码也是不可避免的</strong>。</p><p>最后，<strong>重构是避免过度设计的有效手段</strong>。在我们维护代码的过程中，真正遇到问题的时候，再对代码进行重构，能有效避免前期投入太多时间做过度的设计，做到有的放矢。</p><a id="more"></a><p>重构实际上是对我们学习的经典设计思想、设计原则、设计模式、编程规范的一种应用。重构实际上就是将这些理论知识，应用到实践的一个很好的场景，<strong>能够锻炼我们熟练使用这些理论知识的能力</strong>。平时堆砌业务逻辑，你可能总觉得没啥成长，而将一个比较烂的代码重构成一个比较好的代码，会让你很有成就感。</p><p>除此之外，重构能力也是衡量一个工程师代码能力的有效手段。所谓“<strong>初级工程师在维护代码，高级工程师在设计代码，资深工程师在重构代码</strong>”，这句话的意思是说，初级工程师在已有代码框架下修改 bug、修改添加功能代码；高级工程师从零开始设计代码结构、搭建代码框架；而资深工程师为代码质量负责，需要发觉代码存在的问题，重构代码，时刻保证代码质量处于一个可控的状态。</p><h2 id="重构的对象（What）"><a href="#重构的对象（What）" class="headerlink" title="重构的对象（What）"></a>重构的对象（What）</h2><p>根据重构的规模，我们可以笼统地分为大规模高层次重构和小规模低层次的重构：</p><ul><li>大型重构：对顶层代码设计的重构，包括：系统、模块、代码结构、类与类之间的关系等的重构，重构的手段有：<strong>分层、模块化、解耦、抽象可复用组件</strong>等等。这类重构的工具就是我们学习过的那些设计思想、原则和模式。这类重构涉及的代码改动会比较多，影响面会比较大，所以难度也较大，耗时会比较长，引入 bug 的风险也会相对比较大；</li><li>小型重构：对代码细节的重构，主要是针对类、函数、变量等代码级别的重构，比如<strong>规范命名、规范注释、消除超大类或函数、提取重复代码</strong>等等。小型重构更多的是利用我们能后面要讲到的编码规范。这类重构要修改的地方比较集中，比较简单，可操作性较强，耗时会比较短，引入 bug 的风险相对来说也会比较小；</li></ul><h2 id="重构的时机（When）"><a href="#重构的时机（When）" class="headerlink" title="重构的时机（When）"></a>重构的时机（When）</h2><p><strong>是代码烂到一定程度之后才去重构吗？当然不是</strong>。因为当代码真的烂到出现“开发效率低，招了很多人，天天加班，出活却不多，线上 bug 频发，领导发飙，中层束手无策，工程师抱怨不断，查找 bug 困难”的时候，基本上重构也无法解决问题了。所以，寄希望于在代码烂到一定程度之后，集中重构解决所有问题是不现实的，我们必须探索一条可持续、可演进的方式。</p><p>我特别提倡的重构策略是<code>持续重构</code>。这也是我在工作中特别喜欢干的事情。平时没有事情的时候，你可以看看项目中有哪些写得不够好的、可以优化的代码，主动去重构一下。或者，在修改、添加某个功能代码的时候，你也可以顺手把不符合编码规范、不好的设计重构一下。总之，就像把单元测试、Code Review 作为开发的一部分，我们如果能把持续重构也作为开发的一部分，成为一种开发习惯，对项目、对自己都会很有好处。</p><p>尽管我们说重构能力很重要，但<strong>持续重构意识更重要</strong>。我们要正确地看待代码质量和重构这件事情。技术在更新、需求在变化、人员在流动，<strong>代码质量总会在下降，代码总会存在不完美</strong>，重构就会持续在进行。时刻具有持续重构意识，才能避免开发初期就过度设计，避免代码维护的过程中质量的下降。</p><h2 id="重构的方法（How）"><a href="#重构的方法（How）" class="headerlink" title="重构的方法（How）"></a>重构的方法（How）</h2><p>在进行大型重构的时候，我们要提前做好完善的重构计划，有条不紊地分阶段来进行。每个阶段完成一小部分代码的重构，然后提交、测试、运行，发现没有问题之后，再继续进行下一阶段的重构，<strong>保证代码仓库中的代码一直处于可运行、逻辑正确的状态</strong>。每个阶段，我们都要控制好重构影响到的代码范围，考虑好如何兼容老的代码逻辑，必要的时候还需要写一些兼容过渡代码。只有这样，我们才能让每一阶段的重构都不至于耗时太长（最好一天就能完成），不至于与新的功能开发相冲突。</p><p>而小规模低层次的重构，因为影响范围小，改动耗时短，所以，<strong>只要你愿意并且有时间，随时都可以去做</strong>。实际上，除了人工去发现低层次的质量问题，我们还可以借助很多成熟的静态代码分析工具（比如 CheckStyle、FindBugs、PMD），来自动发现代码中的问题，然后针对性地进行重构优化。</p><p>对于重构这件事情，资深的工程师、项目 leader 要负起责任来，没事就重构一下代码，时刻保证代码质量处在一个良好的状态。否则，一旦出现<code>破窗效应</code>，一个人往里堆了一些烂代码，之后就会有更多的人往里堆更烂的代码。毕竟往项目里堆砌烂代码的成本太低了。不过，<strong>保持代码质量最好的方法还是打造一种好的技术氛围</strong>，以此来驱动大家主动去关注代码质量，持续重构代码。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迪米特法则（LoD）</title>
      <link href="2020/11/07/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88LoD%EF%BC%89/"/>
      <url>2020/11/07/%E8%BF%AA%E7%B1%B3%E7%89%B9%E6%B3%95%E5%88%99%EF%BC%88LoD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="何为“高内聚、松耦合”？"><a href="#何为“高内聚、松耦合”？" class="headerlink" title="何为“高内聚、松耦合”？"></a>何为“高内聚、松耦合”？</h2><p>“高内聚、松耦合”是一个非常重要的设计思想，能够有效地提高代码的可读性和可维护性，缩小功能改动导致的代码改动范围。实际上，“高内聚、松耦合”是一个比较通用的设计思想，可以用来指导不同粒度代码的设计与开发，比如<strong>系统、模块、类，甚至是函数</strong>，也可以应用到不同的开发场景中，比如<strong>微服务、框架、组件、类库</strong>等。</p><p>为了方便我讲解，接下来我以“类”作为这个设计思想的应用对象来展开讲解，其他应用场景你可以自行类比。在这个设计思想中，<code>高内聚</code>用来指导类本身的设计，<code>松耦合</code>用来指导类与类之间依赖关系的设计。不过，这两者并非完全独立不相干。<strong>高内聚有助于松耦合，松耦合又需要高内聚的支持</strong>。</p><h3 id="高内聚"><a href="#高内聚" class="headerlink" title="高内聚"></a>高内聚</h3><p>所谓高内聚，就是指相近的功能应该放到同一个类中，不相近的功能不要放到同一个类中。相近的功能往往会被同时修改，放到同一个类中，<strong>修改会比较集中，代码容易维护</strong>。</p><h3 id="松耦合"><a href="#松耦合" class="headerlink" title="松耦合"></a>松耦合</h3><p>所谓松耦合是说，在代码中，类与类之间的依赖关系简单清晰。即使两个类有依赖关系，<strong>一个类的代码改动不会或者很少导致依赖类的代码改动</strong>。</p><h3 id="内聚和耦合的关系"><a href="#内聚和耦合的关系" class="headerlink" title="内聚和耦合的关系"></a>内聚和耦合的关系</h3><p>高内聚有助于松耦合，同理，<strong>低内聚也会导致紧耦合</strong>。关于这一点，我画了一张对比图来解释。图中左边部分的代码结构是“高内聚、松耦合”；右边部分正好相反，是“低内聚、紧耦合”：</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/00.png" alt></p><p>从图中我们也可以看出，高内聚、低耦合的代码结构更加简单、清晰，相应地，在可维护性和可读性上确实要好很多。</p><h2 id="迪米特法则理论描述"><a href="#迪米特法则理论描述" class="headerlink" title="迪米特法则理论描述"></a>迪米特法则理论描述</h2><p>迪米特法则的英文翻译是：Law of Demeter，缩写是 LoD。它还有另外一个更加达意的名字，叫作最小知识原则，英文翻译为：</p><blockquote><p>The Least Knowledge Principle.</p></blockquote><p>关于这个设计原则，我们先来看一下它最原汁原味的英文定义：</p><blockquote><p>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit. Or: Each unit should only talk to its friends; Don’t talk to strangers.</p></blockquote><p>我们之前讲过，大部分设计原则和思想都非常抽象，有各种各样的解读，<strong>要想灵活地应用到实际的开发中，需要有实战经验的积累</strong>。迪米特法则也不例外。所以，我结合我自己的理解和经验，对刚刚的定义重新描述一下：</p><blockquote><p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口（也就是定义中的<strong>有限知识</strong>）。</p></blockquote><h3 id="不该有直接依赖关系的类之间，不要有依赖"><a href="#不该有直接依赖关系的类之间，不要有依赖" class="headerlink" title="不该有直接依赖关系的类之间，不要有依赖"></a>不该有直接依赖关系的类之间，不要有依赖</h3><p>这个例子实现了简化版的搜索引擎爬取网页的功能。代码中包含三个主要的类。其中，NetworkTransporter 类负责底层网络通信，根据请求获取数据；HtmlDownloader 类用来通过 URL 获取网页；Document 表示网页文档，后续的网页内容抽取、分词、索引都是以此为处理对象。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkTransporter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(HtmlRequest htmlRequest) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NetworkTransporter transporter; <span class="comment">// 通过构造函数或 IoC 注入</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Html <span class="title">downloadHtml</span><span class="params">(String url)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Byte[] rawHtml = transporter.send(<span class="keyword">new</span> HtmlRequest(url));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Html(rawHtml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Html html;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Document</span><span class="params">(String url)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">        HtmlDownloader downloader = <span class="keyword">new</span> HtmlDownloader();</span><br><span class="line">        <span class="keyword">this</span>.html = downloader.downloadHtml(url);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码虽然“能用”，能实现我们想要的功能，但是它不够“好用”，<strong>有比较多的设计缺陷</strong>。</p><h4 id="NetworkTransporter-类"><a href="#NetworkTransporter-类" class="headerlink" title="NetworkTransporter 类"></a>NetworkTransporter 类</h4><p>作为一个底层网络通信类，我们希望它的功能尽可能通用，而不只是服务于下载 HTML，所以，我们不应该直接依赖太具体的发送对象 HtmlRequest。从这一点上讲，NetworkTransporter 类的设计违背迪米特法则，<strong>依赖了不该有直接依赖关系的 HtmlRequest 类</strong>。</p><p>我这里有个形象的比喻。假如你现在要去商店买东西，你肯定不会直接把钱包给收银员，让收银员自己从里面拿钱，而是你从钱包里把钱拿出来交给收银员。这里的 HtmlRequest 对象就相当于钱包，HtmlRequest 里的 address 和 content 对象就相当于钱。我们<strong>应该把 address 和 content 交给 NetworkTransporter</strong>，而非是直接把 HtmlRequest 交给 NetworkTransporter。根据这个思路，NetworkTransporter 重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkTransporter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略属性和其他方法...</span></span><br><span class="line">    <span class="keyword">public</span> Byte[] send(String address, Byte[] data) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="HtmlDownloader-类"><a href="#HtmlDownloader-类" class="headerlink" title="HtmlDownloader 类"></a>HtmlDownloader 类</h4><p>这个类的设计没有问题。不过，我们修改了 NetworkTransporter 的 send() 函数的定义，而这个类用到了 send() 函数，所以<strong>我们需要对它做相应的修改</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HtmlDownloader</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> NetworkTransporter transporter; <span class="comment">// 通过构造函数或 IoC 注入</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// HtmlDownloader 这里也要有相应的修改</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Html <span class="title">downloadHtml</span><span class="params">(String url)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        HtmlRequest htmlRequest = <span class="keyword">new</span> HtmlRequest(url);</span><br><span class="line">        Byte[] rawHtml = transporter.send(</span><br><span class="line">            htmlRequest.getAddress(), htmlRequest.getContent().getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Html(rawHtml);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Document-类"><a href="#Document-类" class="headerlink" title="Document 类"></a>Document 类</h4><p>这个类的问题比较多，主要有三点：</p><ul><li>构造函数中的 downloader.downloadHtml() 逻辑复杂，耗时长，不应该放到构造函数中，会影响代码的可测试性；</li><li>HtmlDownloader 对象在构造函数中通过 new 来创建，违反了基于接口而非实现编程的设计思想；</li><li>从业务含义上来讲，Document 网页文档没必要依赖 HtmlDownloader 类，违背了迪米特法则；</li></ul><p>虽然 Document 类的问题很多，但修改起来比较简单，只要一处改动就可以解决所有问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Document</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Html html;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Document</span><span class="params">(String url, Html html)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.html = html;</span><br><span class="line">        <span class="keyword">this</span>.url = url;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通过一个工厂方法来创建 Document</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DocumentFactory</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HtmlDownloader downloader;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DocumentFactory</span><span class="params">(HtmlDownloader downloader)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.downloader = downloader;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Document <span class="title">createDocument</span><span class="params">(String url)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Html html = downloader.downloadHtml(url);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Document(url, html);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有依赖关系的类之间，尽量只依赖必要的接口"><a href="#有依赖关系的类之间，尽量只依赖必要的接口" class="headerlink" title="有依赖关系的类之间，尽量只依赖必要的接口"></a>有依赖关系的类之间，尽量只依赖必要的接口</h3><p>下面这段代码非常简单，Serialization 类负责对象的序列化和反序列化：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String serializedResult = ...;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> serializedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object deserializedResult = ...;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">        <span class="keyword">return</span> deserializedResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单看这个类的设计，没有一点问题。不过，<strong>如果我们把它放到一定的应用场景里，那就还有继续优化的空间</strong>。假设在我们的项目中，有些类只用到了序列化操作，而另一些类只用到反序列化操作。只用到序列化操作的那部分类不应该依赖反序列化接口；同理，只用到反序列化操作的那部分类不应该依赖序列化接口。</p><p>根据这个思路，我们应该将 Serialization 类拆分为两个更小粒度的类，一个只负责序列化（Serializer 类），一个只负责反序列化（Deserializer 类）。拆分之后，使用序列化操作的类只需要依赖 Serializer 类，使用反序列化操作的类只需要依赖 Deserializer 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String serializedResult = ...;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> serializedResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object deserializedResult = ...;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> deserializedResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管拆分之后的代码<strong>更能满足迪米特法则，但却违背了高内聚的设计思想</strong>。如果我们修改了序列化的实现方式，比如从 JSON 换成了 XML，那反序列化的实现逻辑也需要一并修改。在未拆分的情况下，我们只需要修改一个类即可。在拆分之后，我们需要修改两个类。显然，<strong>这种设计思路的代码改动范围变大了</strong>。</p><p>通过引入两个接口就能轻松解决这个问题：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">serialize</span><span class="params">(Object object)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Deserializable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">Object <span class="title">deserialize</span><span class="params">(String text)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Deserializable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Object object)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String serializedResult = ...;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> serializedResult;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">deserialize</span><span class="params">(String str)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Object deserializedResult = ...;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">return</span> deserializedResult;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass_1</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Serializable serializer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(Serializable serializer)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.serializer = serializer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DemoClass_2</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Deserializable deserializer;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(Deserializable deserializer)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.deserializer = deserializer;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>尽管我们还是要往 DemoClass_1 的构造函数中，传入包含序列化和反序列化的 Serialization 实现类，但是，我们依赖的 Serializable 接口只包含序列化操作，<strong>DemoClass_1 无法使用 Serialization 类中的反序列化接口，对反序列化操作无感知</strong>，这也就符合了迪米特法则后半部分所说的“依赖有限接口”的要求。</p><p>实际上，上面的的代码实现思路，也体现了“基于接口而非实现编程”的设计原则，结合迪米特法则，我们可以总结出一条新的设计原则，那就是：<strong>基于最小接口而非最大实现编程</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DRY 原则</title>
      <link href="2020/11/03/DRY-%E5%8E%9F%E5%88%99/"/>
      <url>2020/11/03/DRY-%E5%8E%9F%E5%88%99/</url>
      
        <content type="html"><![CDATA[<p>DRY 原则的英文描述为：</p><blockquote><p>Don’t Repeat Yourself.</p></blockquote><p>中文直译为：不要重复自己。今天，我们主要讲<strong>三种典型的代码重复情况</strong>，它们分别是：实现逻辑重复、功能语义重复和代码执行重复。这三种代码重复，有的看似违反 DRY，实际上并不违反；有的看似不违反，实际上却违反了。</p><h2 id="实现逻辑重复"><a href="#实现逻辑重复" class="headerlink" title="实现逻辑重复"></a>实现逻辑重复</h2><p>我们先来看下面这样一段代码是否违反了 DRY 原则：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String username, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValidUsername(username)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidUsernameException...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isValidPassword(password)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidPasswordException...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...省略其他代码...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsername</span><span class="params">(String username)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// check not null, not empty</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(username)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check length: 4~64</span></span><br><span class="line">        <span class="keyword">int</span> length = username.length();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// contains only lowercase characters</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isAllLowerCase(username)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// contains only a~z, 0~9, dot</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = username.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidPassword</span><span class="params">(String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// check not null, not empty</span></span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isBlank(password)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// check length: 4~64</span></span><br><span class="line">        <span class="keyword">int</span> length = password.length();</span><br><span class="line">        <span class="keyword">if</span> (length &lt; <span class="number">4</span> || length &gt; <span class="number">64</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// contains only lowercase characters</span></span><br><span class="line">        <span class="keyword">if</span> (!StringUtils.isAllLowerCase(password)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// contains only a~z, 0~9, dot</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">char</span> c = password.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (!(c &gt;= <span class="string">'a'</span> &amp;&amp; c &lt;= <span class="string">'z'</span>) || (c &gt;= <span class="string">'0'</span> &amp;&amp; c &lt;= <span class="string">'9'</span>) || c == <span class="string">'.'</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码中，有两处非常明显的重复的代码片段：isValidUserName() 函数和 isValidPassword() 函数。<strong>重复的代码被敲了两遍，或者简单 copy-paste 了一下，看起来明显违反 DRY 原则</strong>。为了移除重复的代码，我们对上面的代码做下重构，将 isValidUserName() 函数和 isValidPassword() 函数，合并为一个更通用的函数 isValidUserNameOrPassword()。重构后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAuthenticatorV2</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">authenticate</span><span class="params">(String userName, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValidUsernameOrPassword(userName)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidUsernameException...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!isValidUsernameOrPassword(password)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidPasswordException...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isValidUsernameOrPassword</span><span class="params">(String usernameOrPassword)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//省略实现逻辑</span></span><br><span class="line">        <span class="comment">//跟原来的 isValidUsername() 或 isValidPassword() 的实现逻辑一样...</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>单从名字上看，我们就能发现，合并之后的 isValidUserNameOrPassword() 函数，负责两件事情：验证用户名和验证密码，违反了<code>单一职责原则</code>和<code>接口隔离原则</code>。</p><p>因为 isValidUserName() 和 isValidPassword() 两个函数，虽然<strong>从代码实现逻辑上看起来是重复的，但是从语义上并不重复</strong>。所谓“语义不重复”指的是：从功能上来看，这两个函数干的是完全不重复的两件事情，一个是校验用户名，另一个是校验密码。尽管在目前的设计中，两个校验逻辑是完全一样的，但如果按照第二种写法，<strong>将两个函数的合并，那就会存在潜在的问题</strong>。在未来的某一天，如果我们修改了密码的校验逻辑，比如，允许密码包含大写字符，允许密码的长度为 8 到 64 个字符，那这个时候，isValidUserName() 和 isValidPassword() 的实现逻辑就会不相同。我们就要把合并后的函数，重新拆成合并前的那两个函数。</p><p><strong>尽管代码的实现逻辑是相同的，但语义不同，我们判定它并不违反 DRY 原则</strong>。对于包含重复代码的问题，我们可以<strong>通过抽象成更细粒度函数的方式来解决</strong>。比如将校验只包含 a<del>z、0</del>9、dot 的逻辑封装成 boolean onlyContains(String str, String list) 函数。</p><h2 id="功能语义重复"><a href="#功能语义重复" class="headerlink" title="功能语义重复"></a>功能语义重复</h2><p>现在我们再来看另外一个例子。在同一个项目代码中有下面两个函数：isValidIp() 和 checkIfIpValid()。尽管两个函数的命名不同，实现逻辑不同，但功能是相同的，都是用来判定 IP 地址是否合法的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIp</span><span class="params">(String ipAddress)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String regex = <span class="string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span></span><br><span class="line">        + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">        + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">        + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfIpValid</span><span class="params">(String ipAddress)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] ipUnits = StringUtils.split(ipAddress, <span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ipUnitIntValue;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException e) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这个例子中，尽管两段代码的实现逻辑不重复，但<strong>语义重复，也就是功能重复，我们认为它违反了 DRY 原则</strong>。我们应该在项目中，统一一种实现思路，所有用到判断 IP 地址是否合法的地方，都统一调用同一个函数。</p><p>假设我们不统一实现思路，那有些地方调用了 isValidIp() 函数，有些地方又调用了 checkIfIpValid() 函数，这就会导致代码看起来很奇怪，相当于给代码<strong>埋坑</strong>。</p><h2 id="代码执行重复"><a href="#代码执行重复" class="headerlink" title="代码执行重复"></a>代码执行重复</h2><p>我们再来看第三个例子。其中，UserService 中 login() 函数用来校验用户登录是否成功。如果失败，就返回异常；如果成功，就返回用户信息。具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepo userRepo; <span class="comment">// 通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> existed = userRepo.checkIfUserExisted(email, password);</span><br><span class="line">        <span class="keyword">if</span> (!existed) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw AuthenticationFailureException...</span></span><br><span class="line">        &#125;</span><br><span class="line">        User user = userRepo.getUserByEmail(email);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">checkIfUserExisted</span><span class="params">(String email, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!EmailValidation.validate(email)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidEmailException...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!PasswordValidation.validate(password)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidPasswordException...</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...query db to check if email&amp;password exists...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!EmailValidation.validate(email)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidEmailException...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...query db to get user by email...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码，既没有逻辑重复，也没有语义重复，但仍然违反了 DRY 原则。这是因为<strong>代码中存在执行重复</strong>。</p><p>重复执行最明显的一个地方，就是<strong>在 login() 函数中，email 的校验逻辑被执行了两次</strong>。一次是在调用 checkIfUserExisted() 函数的时候，另一次是调用 getUserByEmail() 函数的时候。这个问题解决起来比较简单，我们只需要将校验逻辑从 UserRepo 中移除，统一放到 UserService 中就可以了。</p><p>实际上，<strong>login() 函数并不需要调用 checkIfUserExisted() 函数</strong>，只需要调用一次 getUserByEmail() 函数，从数据库中获取到用户的 email、password 等信息，然后跟用户输入的 email、password 信息做对比，依次判断是否登录成功。</p><p>这样的优化是很有必要的。因为 checkIfUserExisted() 函数和 getUserByEmail() 函数都需要查询数据库，而数据库这类的 I/O 操作是比较耗时的。<strong>我们在写代码的时候，应当尽量减少这类 I/O 操作</strong>。</p><p>按照刚刚的修改思路，<strong>我们把代码重构一下，移除重复执行的代码</strong>，只校验一次 email 和 password，并且只查询一次数据库。重构之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepo userRepo; <span class="comment">// 通过依赖注入或者IOC框架注入</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">login</span><span class="params">(String email, String password)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!EmailValidation.validate(email)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidEmailException...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!PasswordValidation.validate(password)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw InvalidPasswordException...</span></span><br><span class="line">        &#125;</span><br><span class="line">        User user = userRepo.getUserByEmail(email);</span><br><span class="line">        <span class="keyword">if</span> (user == <span class="keyword">null</span> || !password.equals(user.getPassword()) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...throw AuthenticationFailureException...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUserByEmail</span><span class="params">(String email)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...query db to get user by email...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="代码复用性（Code-Reusability）"><a href="#代码复用性（Code-Reusability）" class="headerlink" title="代码复用性（Code Reusability）"></a>代码复用性（Code Reusability）</h2><p>代码的复用性是评判代码质量的一个非常重要的标准。</p><h3 id="什么是代码的复用性"><a href="#什么是代码的复用性" class="headerlink" title="什么是代码的复用性"></a>什么是代码的复用性</h3><p>我们首先来区分三个概念：<code>代码复用性</code>（Code Reusability）、<code>代码复用</code>（Code Reuse）和 <code>DRY 原则</code>：</p><ul><li>代码复用表示一种<strong>行为</strong>：我们在开发新功能的时候，尽量复用已经存在的代码；</li><li>代码的可复用性表示一段代码可被复用的<strong>特性或能力</strong>：我们在编写代码的时候，让代码尽量可复用；</li><li>DRY 原则是一条原则：不要写重复的代码；</li></ul><h4 id="“不重复”并不代表“可复用”"><a href="#“不重复”并不代表“可复用”" class="headerlink" title="“不重复”并不代表“可复用”"></a>“不重复”并不代表“可复用”</h4><p>在一个项目代码中，可能不存在任何重复的代码，但也并不表示里面有可复用的代码，<strong>不重复和可复用完全是两个概念</strong>。所以，从这个角度来说，DRY 原则跟代码的可复用性讲的是两回事。</p><h4 id="“复用”和“可复用性”关注角度不同"><a href="#“复用”和“可复用性”关注角度不同" class="headerlink" title="“复用”和“可复用性”关注角度不同"></a>“复用”和“可复用性”关注角度不同</h4><p>代码“可复用性”是从代码<strong>开发者</strong>的角度来讲的，“复用”是从代码<strong>使用者</strong>的角度来讲的。比如，A 同事编写了一个 UrlUtils 类，代码的“可复用性”很好。B 同事在开发新功能的时候，直接“复用”A 同事编写的 UrlUtils 类。</p><p>尽管复用、可复用性、DRY 原则这三者从理解上有所区别，但实际上要达到的目的都是类似的，<strong>都是为了减少代码量，提高代码的可读性、可维护性</strong>。除此之外，复用已经经过测试的老代码，bug 会比从零重新开发要少。</p><p>“复用”这个概念不仅可以指导细粒度的模块、类、函数的设计开发，实际上，一些<strong>框架、类库、组件等的产生也都是为了达到复用的目的</strong>。比如，Spring 框架、Google Guava 类库、UI 组件等等。</p><h3 id="怎么提高代码复用性？"><a href="#怎么提高代码复用性？" class="headerlink" title="怎么提高代码复用性？"></a>怎么提高代码复用性？</h3><p>实际上，我们前面已经讲到过很多提高代码可复用性的手段，今天算是集中总结一下，我总结了 7 条，具体如下：</p><ul><li><strong>减少代码耦合</strong>：对于高度耦合的代码，当我们希望复用其中的一个功能，想把这个功能的代码抽取出来成为一个独立的模块、类或者函数的时候，往往会发现牵一发而动全身。移动一点代码，就要牵连到很多其他相关的代码。所以，<strong>高度耦合的代码会影响到代码的复用性</strong>，我们要尽量减少代码耦合；</li><li><strong>满足单一职责原则</strong>：如果职责不够单一，模块、类设计得大而全，那依赖它的代码或者它依赖的代码就会比较多，进而增加了代码的耦合。根据上一点，也就会影响到代码的复用性。相反，<strong>越细粒度的代码，代码的通用性会越好</strong>，越容易被复用；</li><li><strong>模块化</strong>：这里的“模块”，不单单指一组类构成的模块，还可以理解为单个类、函数。我们要善于将功能独立的代码，封装成模块。<strong>独立的模块就像一块一块的积木，更加容易复用</strong>，可以直接拿来搭建更加复杂的系统；</li><li><strong>业务与非业务逻辑分离</strong>：越是跟业务无关的代码越是容易复用，越是针对特定业务的代码越难复用。所以，<strong>为了复用跟业务无关的代码，我们将业务和非业务逻辑代码分离</strong>，抽取成一些通用的框架、类库、组件等；</li><li><strong>通用代码下沉</strong>：从分层的角度来看，越底层的代码越通用、会被越多的模块调用，越应该设计得足够可复用。一般情况下，在代码分层之后，为了避免交叉调用导致调用关系混乱，我们<strong>只允许上层代码调用下层代码及同层代码之间的调用，杜绝下层代码调用上层代码</strong>。所以，通用的代码我们尽量下沉到更下层；</li><li><strong>继承、多态、抽象、封装</strong>：在讲面向对象特性的时候，我们讲到，利用继承，可以<strong>将公共的代码抽取到父类</strong>，子类复用父类的属性和方法。利用多态，我们可以<strong>动态地替换一段代码的部分逻辑</strong>，让这段代码可复用。除此之外，抽象和封装，从更加广义的层面、而非狭义的面向对象特性的层面来理解的话，<strong>越抽象、越不依赖具体的实现</strong>，越容易复用。代码封装成模块，<strong>隐藏可变的细节、暴露不变的接口</strong>，就越容易复用；</li><li><strong>应用模板等设计模式</strong>：一些设计模式，也能提高代码的复用性。比如，模板模式利用了多态来实现，可以灵活地替换其中的部分代码，整个流程模板代码可复用；</li></ul><p>一些跟编程语言相关的特性，也能提高代码的复用性，比如<code>泛型编程</code>等。实际上，除了上面讲到的这些方法之外，<strong>复用意识也非常重要</strong>。在写代码的时候，我们要多去思考一下，这个部分代码是否可以抽取出来，作为一个独立的模块、类或者函数供多处使用。<strong>在设计每个模块、类、函数的时候，要像设计一个外部 API 那样，去思考它的复用性</strong>。</p><h3 id="辩证思考和灵活应用"><a href="#辩证思考和灵活应用" class="headerlink" title="辩证思考和灵活应用"></a>辩证思考和灵活应用</h3><p>如果我们在编写代码的时候，已经有复用的需求场景，那根据复用的需求去开发可复用的代码，可能还不算难。但是，如果当下并没有复用的需求，我们只是希望现在编写的代码具有可复用的特点，能在未来某个同事开发某个新功能的时候复用得上。在这种<strong>没有具体复用需求的情况下，我们就需要去预测将来代码会如何复用，这就比较有挑战了</strong>。</p><p>实际上，<strong>除非有非常明确的复用需求，否则，为了暂时用不到的复用需求</strong>，花费太多的时间、精力，投入太多的开发成本，并不是一个值得推荐的做法。这也违反我们之前讲到的 YAGNI 原则。</p><blockquote><p><code>Rule of Three</code>：第一次编写代码的时候，我们不考虑复用性；第二次遇到复用场景的时候，再进行重构使其复用。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KISS vs. YAGNI</title>
      <link href="2020/11/03/KISS-vs-YAGNI/"/>
      <url>2020/11/03/KISS-vs-YAGNI/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解-KISS-原则"><a href="#如何理解-KISS-原则" class="headerlink" title="如何理解 KISS 原则"></a>如何理解 KISS 原则</h2><p>KISS 原则的英文描述：</p><blockquote><p>Keep It Simple and Stupid.</p></blockquote><p>翻译成中文就是：<strong>尽量保持简单</strong>。KISS 原则算是一个万金油类型的设计原则，可以应用在很多场景中。它不仅经常用来指导软件开发，还经常用来指导更加广泛的系统设计、产品设计等，比如，冰箱、建筑、iPhone 手机的设计等等。</p><p>代码的<code>可读性</code>和<code>可维护性</code>是衡量代码质量非常重要的两个标准。而 KISS 原则就是保持代码可读和可维护的重要手段。<strong>代码足够简单，也就意味着很容易读懂，bug 比较难隐藏</strong>。即便出现 bug，修复起来也比较简单。</p><h2 id="代码行数越少就越“简单”吗？"><a href="#代码行数越少就越“简单”吗？" class="headerlink" title="代码行数越少就越“简单”吗？"></a>代码行数越少就越“简单”吗？</h2><p>下面这三段代码可以实现同样一个功能：检查输入的字符串 ipAddress 是否是合法的 IP 地址。</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种实现方式: 使用正则表达式</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV1</span><span class="params">(String ipAddress)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String regex = <span class="string">"^(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|[1-9])\\."</span> </span><br><span class="line">        + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">        + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)\\."</span></span><br><span class="line">        + <span class="string">"(1\\d&#123;2&#125;|2[0-4]\\d|25[0-5]|[1-9]\\d|\\d)$"</span>;</span><br><span class="line">    <span class="keyword">return</span> ipAddress.matches(regex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种实现方式: 使用现成的工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV2</span><span class="params">(String ipAddress)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isBlank(ipAddress)) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] ipUnits = StringUtils.split(ipAddress, <span class="string">'.'</span>);</span><br><span class="line">    <span class="keyword">if</span> (ipUnits.length != <span class="number">4</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ipUnitIntValue;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            ipUnitIntValue = Integer.parseInt(ipUnits[i]);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span> (NumberFormatException e) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; ipUnitIntValue == <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种实现方式: 不使用任何工具类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidIpAddressV3</span><span class="params">(String ipAddress)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span>[] ipChars = ipAddress.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> length = ipChars.length;</span><br><span class="line">    <span class="keyword">int</span> ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">boolean</span> isFirstUnit = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">int</span> unitsCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> c = ipChars[i];</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'.'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFirstUnit &amp;&amp; ipUnitIntValue == <span class="number">0</span>) </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (isFirstUnit) </span><br><span class="line">            &#123;</span><br><span class="line">                isFirstUnit = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ipUnitIntValue = -<span class="number">1</span>;</span><br><span class="line">            unitsCount++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (c &lt; <span class="string">'0'</span> || c &gt; <span class="string">'9'</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ipUnitIntValue == -<span class="number">1</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            ipUnitIntValue = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ipUnitIntValue = ipUnitIntValue * <span class="number">10</span> + (c - <span class="string">'0'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ipUnitIntValue &lt; <span class="number">0</span> || ipUnitIntValue &gt; <span class="number">255</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (unitsCount != <span class="number">3</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一种实现方式利用的是正则表达式，只用四行代码就把这个问题搞定了。它的代码行数最少，那是不是就最符合 KISS 原则呢？答案是否定的。虽然代码行数最少，<strong>看似最简单，实际上却很复杂</strong>。这正是因为它使用了正则表达式。</p><p>第二种实现方式使用了 StringUtils 类、Integer 类提供的一些现成的工具函数，来处理 IP 地址字符串。第三种实现方式，不使用任何工具函数，而是通过逐一处理 IP 地址中的字符，来判断是否合法。从代码行数上来说，这两种方式差不多。但是，<strong>第三种要比第二种更加有难度，更容易写出 bug</strong>。从可读性上来说，<strong>第二种实现方式的代码逻辑更清晰、更好理解</strong>。所以，在这两种实现方式中，第二种实现方式更加“简单”，更加符合 KISS 原则。</p><p>一般来说，工具类的功能都比较通用和全面，所以，在代码实现上，需要<strong>考虑和处理更多的细节，执行效率就会有所影响</strong>。而第三种实现方式，完全是自己操作底层字符，只针对 IP 地址这一种格式的数据输入来做处理，没有太多多余的函数调用和其他不必要的处理逻辑，所以，在执行效率上，这种类似<strong>定制化的处理代码方式肯定比通用的工具类要高些</strong>。</p><p>不过，尽管第三种实现方式性能更高些，但我还是更倾向于选择第二种实现方法。那是因为第三种实现方式<strong>实际上是一种过度优化</strong>。<strong>除非 isValidIpAddress() 函数是影响系统性能的瓶颈代码</strong>，否则，这样优化的投入产出比并不高，增加了代码实现的难度、牺牲了代码的可读性，性能上的提升却并不明显。</p><h2 id="代码逻辑复杂就违背-KISS-原则吗？"><a href="#代码逻辑复杂就违背-KISS-原则吗？" class="headerlink" title="代码逻辑复杂就违背 KISS 原则吗？"></a>代码逻辑复杂就违背 KISS 原则吗？</h2><p>在回答这个问题之前，我们先来看下面这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// KMP algorithm: a, b 分别是主串和模式串；n, m 分别是主串和模式串的长度</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kmp</span><span class="params">(<span class="keyword">char</span>[] a, <span class="keyword">int</span> n, <span class="keyword">char</span>[] b, <span class="keyword">int</span> m)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = getNext(b, m);</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; a[i] != b[j]) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 一直找到 a[i] 和 b[j]</span></span><br><span class="line">            j = next[j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) </span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (j == m) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// 找到匹配模式串的了</span></span><br><span class="line">            <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b 表示模式串，m 表示模式串的长度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span>[] getNext(<span class="keyword">char</span>[] b, <span class="keyword">int</span> m) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span>[] next = <span class="keyword">new</span> <span class="keyword">int</span>[m];</span><br><span class="line">    next[<span class="number">0</span>] = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> k = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (k != -<span class="number">1</span> &amp;&amp; b[k + <span class="number">1</span>] != b[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            k = next[k];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b[k + <span class="number">1</span>] == b[i]) </span><br><span class="line">        &#123;</span><br><span class="line">            ++k;</span><br><span class="line">        &#125;</span><br><span class="line">        next[i] = k;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>KMP 算法以快速高效著称。当我们需要处理长文本字符串匹配问题（几百 MB 大小文本内容的匹配），或者<strong>字符串匹配是某个产品的核心功能</strong>（比如 Vim、Word 等文本编辑器），又或者字符串匹配算法是系统性能瓶颈的时候，我们就应该选择尽可能高效的 KMP 算法。而 KMP 算法本身具有逻辑复杂、实现难度大、可读性差的特点。<strong>本身就复杂的问题，用复杂的方法解决，并不违背 KISS 原则</strong>。</p><p>不过，平时的项目开发中涉及的字符串匹配问题，大部分都是针对比较小的文本。在这种情况下，直接调用编程语言提供的现成的字符串匹配函数就足够了。如果非得用 KMP 算法、BM 算法来实现字符串匹配，那就真的违背 KISS 原则了。也就是说，<strong>同样的代码，在某个业务场景下满足 KISS 原则，换一个应用场景可能就不满足了</strong>。</p><h2 id="如何写出满足-KISS-原则的代码？"><a href="#如何写出满足-KISS-原则的代码？" class="headerlink" title="如何写出满足 KISS 原则的代码？"></a>如何写出满足 KISS 原则的代码？</h2><p>实际上，我们前面已经讲到了一些方法。这里我稍微总结一下：</p><ul><li><strong>不要使用同事可能不懂的技术来实现代码</strong>。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等；</li><li><strong>不要重复造轮子</strong>，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高；</li><li><strong>不要过度优化</strong>。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性；</li></ul><p>这里我还想多说两句，我们在做开发的时候，一定不要过度设计，不要觉得简单的东西就没有技术含量。实际上，<strong>越是能用简单的方法解决复杂的问题，越能体现一个人的能力</strong>。</p><h2 id="YAGNI-跟-KISS-说的是一回事吗？"><a href="#YAGNI-跟-KISS-说的是一回事吗？" class="headerlink" title="YAGNI 跟 KISS 说的是一回事吗？"></a>YAGNI 跟 KISS 说的是一回事吗？</h2><p>YAGNI 原则的英文全称是：</p><blockquote><p>You Ain’t Gonna Need It.</p></blockquote><p>直译就是：你不会需要它。这条原则也算是万金油了。当用在软件开发中的时候，它的意思是：不要去设计当前用不到的功能；不要去编写当前用不到的代码。实际上，这条原则的核心思想就是：<strong>不要做过度设计</strong>。</p><p>比如，我们的系统暂时只用 Redis 存储配置信息，以后可能会用到 ZooKeeper。根据 YAGNI 原则，在未用到 ZooKeeper 之前，我们没必要提前编写这部分代码。当然，这并不是说我们就不需要考虑代码的扩展性。我们<strong>还是要预留好扩展点</strong>，等到需要的时候，再去实现 ZooKeeper 存储配置信息这部分代码。</p><p>从刚刚的分析我们可以看出，YAGNI 原则跟 KISS 原则并非一回事儿。<strong>KISS 原则讲的是“如何做”的问题</strong>（尽量保持简单），而 <strong>YAGNI 原则说的是“要不要做”的问题</strong>（当前不需要的就不要做）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>复杂度分析</title>
      <link href="2020/11/01/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/"/>
      <url>2020/11/01/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<p>其实，只要讲到数据结构与算法，就一定离不开时间、空间复杂度分析。而且，我个人认为，<strong>复杂度分析是整个算法学习的精髓</strong>，只要掌握了它，数据结构和算法的内容基本上就掌握了一半。</p><h2 id="为什么需要复杂度分析？"><a href="#为什么需要复杂度分析？" class="headerlink" title="为什么需要复杂度分析？"></a>为什么需要复杂度分析？</h2><p>首先，我可以肯定地说，你这种评估算法执行效率的方法是正确的。很多数据结构和算法书籍还给这种方法起了一个名字，叫<code>事后统计法</code>。但是，这种统计方法有非常大的局限性。</p><h3 id="测试结果非常依赖测试环境"><a href="#测试结果非常依赖测试环境" class="headerlink" title="测试结果非常依赖测试环境"></a>测试结果非常依赖测试环境</h3><p>测试环境中<strong>硬件的不同会对测试结果有很大的影响</strong>。比如，我们拿同样一段代码，分别用 Intel Core i9 处理器和 Intel Core i3 处理器来运行，不用说，i9 处理器要比 i3 处理器执行的速度快很多。还有，比如原本在这台机器上 a 代码执行的速度比 b 代码要快，等我们换到另一台机器上时，可能会有截然相反的结果。</p><h3 id="测试结果受数据规模的影响很大"><a href="#测试结果受数据规模的影响很大" class="headerlink" title="测试结果受数据规模的影响很大"></a>测试结果受数据规模的影响很大</h3><p>后面我们会讲排序算法，我们先拿它举个例子。对同一个排序算法，<strong>待排序数据的有序度不一样</strong>，排序的执行时间就会有很大的差别。极端情况下，如果数据已经是有序的，那排序算法不需要做任何操作，执行时间就会非常短。除此之外，<strong>如果测试数据规模太小</strong>，测试结果可能无法真实地反映算法的性能。比如，对于小规模的数据排序，插入排序可能反倒会比快速排序要快！</p><blockquote><p>我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法。</p></blockquote><a id="more"></a><h2 id="大-O-复杂度表示法"><a href="#大-O-复杂度表示法" class="headerlink" title="大 O 复杂度表示法"></a>大 O 复杂度表示法</h2><p>这里有段非常简单的代码，求 1, 2, 3, …, n 的累加和。现在，我就带你一块来估算一下这段代码的执行时间：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">        sum = sum + i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从 CPU 的角度来看，这段代码的每一行都执行着类似的操作：读数据 -&gt; 运算 -&gt; 写数据。尽管每行代码对应的 CPU 执行的个数、执行的时间都不一样，但是，我们这里只是粗略估计，所以可以<strong>假设每行代码执行的时间都一样，为 unit_time</strong>。在这个假设的基础之上，这段代码的总执行时间是多少呢？</p><p>第 2、3 行代码分别需要 1 个 unit_time 的执行时间，第 4、5 行都运行了 n 遍，所以需要 2n*unit_time 的执行时间，所以这段代码总的执行时间就是 (2n+2)*unit_time。可以看出来，<strong>所有代码的执行时间 T(n) 与每行代码的执行次数成正比</strong>。</p><p>按照这个分析思路，我们再来看这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calc</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt;= n; ++i) &#123;</span><br><span class="line">        j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (; j &lt;= n; ++j) &#123;</span><br><span class="line">            sum = sum +  i * j;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第 2、3、4 行代码，每行都需要 1 个 unit_time 的执行时间，第 5、6 行代码循环执行了 n 遍，需要 2n*unit_time 的执行时间，第 7、8 行代码循环执行了 n^2 遍，所以需要 2n^2*unit_time 的执行时间。所以，整段代码总的执行时间 T(n) = (2n^2+2n+3)*unit_time。</p><p>我们可以把这个规律总结成一个公式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/01.png" alt></p><p>我来具体解释一下这个公式。其中，T(n) 我们已经讲过了，它表示代码执行的时间；f(n) 表示每行代码执行的次数总和。公式中的 O，表示代码的执行时间 T(n) 与 f(n) 表达式成正比。</p><p>大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示<strong>代码执行时间随数据规模增长的变化趋势</strong>，所以，也叫作<code>渐进时间复杂度</code>（Asymptotic Time Complexity），简称时间复杂度。</p><p>我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示刚讲的那两段代码的时间复杂度，就可以记为：T(n) = O(n)；T(n) = O(n^2)。</p><h2 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h2><p>三个比较实用的方法：</p><ol><li>只关注循环执行次数最多的一段代码：<br>大 O 这种复杂度表示方法只是表示一种变化趋势。我们通常会<strong>忽略掉公式中的常量、低阶、系数</strong>，只需要记录一个最大阶的量级就可以了。所以，我们在分析一个算法、一段代码的时间复杂度的时候，也只关注循环执行次数最多的那一段代码就可以了；</li><li>加法法则：总复杂度等于量级最大的那段代码的复杂度<br>我们将这个规律抽象成公式就是：如果 T1(n)=O(f(n))，T2(n)=O(g(n))；那么 T(n)=T1(n)+T2(n)=max(O(f(n)), O(g(n))) =O(max(f(n), g(n)))；</li><li>乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积：<br>假设 T1(n)=O(n)，T2(n)=O(n^2)，则 T1(n)*T2(n) = O(n^3)；</li></ol><h2 id="几种常见时间复杂度实例分析"><a href="#几种常见时间复杂度实例分析" class="headerlink" title="几种常见时间复杂度实例分析"></a>几种常见时间复杂度实例分析</h2><p>虽然代码千差万别，但是常见的复杂度量级并不多：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/02.png" alt></p><p>对于刚罗列的复杂度量级，我们可以粗略地分为两类，<code>多项式量级</code>和<code>非多项式量级</code>。其中，非多项式量级只有两个：O(2^n) 和 O(n!)。我们把时间复杂度为非多项式量级的算法问题叫作 <code>NP</code>（Non-Deterministic Polynomial，非确定多项式）问题。当数据规模 n 越来越大时，非多项式量级算法的执行时间会急剧增加，求解问题的执行时间会无限增长。</p><h3 id="O-1"><a href="#O-1" class="headerlink" title="O(1)"></a>O(1)</h3><p><strong>只要代码的执行时间不随 n 的增大而增长，这样代码的时间复杂度我们都记作 O(1)</strong>。或者说，一般情况下，只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)。</p><h3 id="O-logn-、O-nlogn"><a href="#O-logn-、O-nlogn" class="headerlink" title="O(logn)、O(nlogn)"></a>O(logn)、O(nlogn)</h3><p>对数阶时间复杂度非常常见，同时也是<strong>最难分析的一种时间复杂度</strong>。如果一段代码的时间复杂度是 O(logn)，我们循环执行 n 遍，时间复杂度就是 O(nlogn) 了。而且，O(nlogn) 也是一种非常常见的算法时间复杂度。比如，归并排序、快速排序的时间复杂度都是 O(nlogn)。</p><h3 id="O-m-n-、O-m-n"><a href="#O-m-n-、O-m-n" class="headerlink" title="O(m+n)、O(m*n)"></a>O(m+n)、O(m*n)</h3><p>我们再来讲一种跟前面都不一样的时间复杂度，<strong>代码的复杂度由两个数据的规模来决定</strong>。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是 O(m+n)。</p><h2 id="空间复杂度分析"><a href="#空间复杂度分析" class="headerlink" title="空间复杂度分析"></a>空间复杂度分析</h2><p>类比时间复杂度，空间复杂度全称就是<code>渐进空间复杂度</code>（Asymptotic Space Complexity），表示<strong>算法的存储空间与数据规模之间的增长关系</strong>。我们常见的空间复杂度就是 O(1)、O(n)、O(n^2)。</p><h2 id="最好、最坏情况时间复杂度"><a href="#最好、最坏情况时间复杂度" class="headerlink" title="最好、最坏情况时间复杂度"></a>最好、最坏情况时间复杂度</h2><p>你可以用我上节教你的分析技巧，自己先试着分析一下这段代码的时间复杂度：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n 表示数组 array 的长度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span>[] array, <span class="keyword">int</span> n, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> pos = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> (array[i] == x) pos = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果数组中第一个元素正好是要查找的变量 x，那就不需要继续遍历剩下的 n-1 个数据了，那时间复杂度就是 O(1)。但如果数组中不存在变量 x，那我们就需要把整个数组都遍历一遍，时间复杂度就成了 O(n)。所以，<strong>不同的情况下，这段代码的时间复杂度是不一样的</strong>。</p><p>顾名思义，<strong>最好情况时间复杂度就是，在最理想的情况下，执行这段代码的时间复杂度</strong>。就像我们刚刚讲到的，在最理想的情况下，要查找的变量 x 正好是数组的第一个元素，这个时候对应的时间复杂度就是最好情况时间复杂度。</p><p>同理，<strong>最坏情况时间复杂度就是，在最糟糕的情况下，执行这段代码的时间复杂度</strong>。就像刚举的那个例子，如果数组中没有要查找的变量 x，我们需要把整个数组都遍历一遍才行，所以这种最糟糕情况下对应的时间复杂度就是最坏情况时间复杂度。</p><h2 id="平均时间复杂度"><a href="#平均时间复杂度" class="headerlink" title="平均时间复杂度"></a>平均时间复杂度</h2><p>我们知道，要查找的变量 x，要么在数组里，要么就不在数组里。这两种情况对应的概率统计起来很麻烦，为了方便你理解，我们假设在数组中与不在数组中的概率都为 1/2。另外，要查找的数据出现在 0~n-1 这 n 个位置的概率也是一样的，为 1/n。</p><p>如果我们把每种情况发生的概率也考虑进去，那<code>平均时间复杂度</code>的计算过程就变成了这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/03.png" alt></p><p>引入概率之后，前面那段代码的加权平均值为 (3n+1)/4。用大 O 表示法来表示，去掉系数和常量，这段代码的加权平均时间复杂度仍然是 O(n)。</p><p>实际上，在大多数情况下，我们并<strong>不需要区分最好、最坏、平均时间复杂度</strong>三种情况。只有同一块代码在不同的情况下，时间复杂度有量级的差距，我们才会使用这三种复杂度表示法来区分。</p><h2 id="均摊时间复杂度"><a href="#均摊时间复杂度" class="headerlink" title="均摊时间复杂度"></a>均摊时间复杂度</h2><p>老规矩，我还是借助一个具体的例子来帮助你理解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// array 表示一个长度为n的数组</span></span><br><span class="line"><span class="comment">// 代码中的 array.length 就等于 n</span></span><br><span class="line"><span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count == array.length) &#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; array.length; ++i) &#123;</span><br><span class="line">            sum = sum + array[i];</span><br><span class="line">        &#125;</span><br><span class="line">        array[<span class="number">0</span>] = sum;</span><br><span class="line">        count = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    array[count] = val;</span><br><span class="line">    ++count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我先来解释一下这段代码。这段代码实现了一个往数组中插入数据的功能。当数组满了之后，也就是代码中的 count == array.length 时，我们<strong>用 for 循环遍历数组求和，并清空数组</strong>，将求和之后的 sum 值放到数组的第一个位置，然后再将新的数据插入。但如果数组一开始就有空闲空间，则直接将数据插入数组。</p><p>假设数组的长度是 n，根据数据插入的位置的不同，我们可以分为 n 种情况，每种情况的时间复杂度是 O(1)。除此之外，还有一种“额外”的情况，就是在数组没有空闲空间时插入一个数据，这个时候的时间复杂度是 O(n)。而且，这 n+1 种情况发生的概率一样，都是 1/(n+1)。所以，根据加权平均的计算方法，我们求得的平均时间复杂度就是：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/04.png" alt></p><p>针对这种特殊的场景，我们引入了一种更加简单的分析方法：<strong>摊还分析法</strong>，通过摊还分析得到的时间复杂度我们起了一个名字，叫<code>均摊时间复杂度</code>。</p><p>对一个数据结构进行一组连续操作中，大部分情况下时间复杂度都很低，<strong>只有个别情况下时间复杂度比较高，而且这些操作之间存在前后连贯的时序关系</strong>，这个时候，我们就可以将这一组操作放在一块儿分析，看是否能将较高时间复杂度那次操作的耗时，平摊到其他那些时间复杂度比较低的操作上。而且，在能够应用均摊时间复杂度分析的场合，<strong>一般均摊时间复杂度就等于最好情况时间复杂度</strong>。</p><blockquote><p>均摊时间复杂度就是一种特殊的平均时间复杂度</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>学习指导手册</title>
      <link href="2020/11/01/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/"/>
      <url>2020/11/01/%E5%AD%A6%E4%B9%A0%E6%8C%87%E5%AF%BC%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/geek/00.png" alt></p><p>现在，针对每个知识点，我再给你逐一解释一下。我这里先说明一下，下面标记的难易程度、是否重点、掌握程度，都只是针对初学者来说的，如果你已经有一定基础，可以根据自己的情况，安排自己的学习。</p><h2 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h2><p>尽管在专栏中，我只用了两节课的内容，来讲复杂度分析这个知识点。但是，我想说的是，它真的<strong>非常重要</strong>。你必须要牢牢掌握这两节，基本上要做到，简单代码能很快分析出时间、空间复杂度；对于复杂点的代码，比如递归代码，你也要掌握专栏中讲到的两种分析方法：<code>递推公式</code>和<code>递归树</code>。</p><p>对于初学者来说，光看入门篇的两节复杂度分析文章，可能还不足以完全掌握复杂度分析。不过，在后续讲解每种数据结构和算法的时候，我都有详细分析它们的时间、空间复杂度。所以，你可以在学习专栏中其他章节的时候，再<strong>不停地、有意识地去训练自己的复杂度分析能力</strong>。</p><ul><li>难易程度：Medium；</li><li>是否重点：10 分；</li><li>掌握程度：在不看我的分析的情况下，能自行分析专栏中大部分数据结构和算法的时间、空间复杂度；</li></ul><a id="more"></a><h2 id="数组、栈、队列"><a href="#数组、栈、队列" class="headerlink" title="数组、栈、队列"></a>数组、栈、队列</h2><p>这一部分内容非常简单，初学者学起来也不会很难。但是，作为基础的数据结构，数组、栈、队列，是<strong>后续很多复杂数据结构和算法的基础</strong>，所以，这些内容你一定要掌握。</p><ul><li>难易程度：Easy；</li><li>是否重点：8 分；</li><li>掌握程度：能自己实现动态数组、栈、队列；</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><p>链表非常重要！虽然理论内容不多，但<strong>链表上的操作却很复杂</strong>。所以，面试中经常会考察，你一定要掌握。而且，我这里说“掌握”不只是能看懂专栏中的内容，还能将专栏中提到的经典链表题目，比如链表反转、求中间结点等，轻松无 bug 地实现出来。</p><ul><li>难易程度：Medium；</li><li>是否重点：9 分；</li><li>掌握程度：能轻松写出经典链表题目代码；</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>对于初学者来说，<strong>递归代码非常难掌握</strong>，不管是读起来，还是写起来。但是，这道坎你必须要跨过，跨不过就不能算是入门数据结构和算法。我们后面讲到的很多数据结构和算法的代码实现，都要用到递归。</p><p>递归相关的理论知识也不多，所以还是要多练。你可以先在网上<strong>找些简单的题目练手</strong>，比如斐波那契数列、求阶乘等，然后再慢慢过渡到更加有难度的，比如归并排序、快速排序、二叉树的遍历、求高度，最后是回溯八皇后、背包问题等。</p><ul><li>难易程度：Hard；</li><li>是否重点：10 分；</li><li>掌握程度：轻松写出二叉树遍历、八皇后、背包问题、DFS 的递归代码；</li></ul><h2 id="排序、二分查找"><a href="#排序、二分查找" class="headerlink" title="排序、二分查找"></a>排序、二分查找</h2><p>这一部分并不难，你<strong>只需要能看懂我专栏里的内容</strong>即可。</p><ul><li>难易程度：Easy；</li><li>是否重点：7 分；</li><li>掌握程度：能自己把各种排序算法、二分查找及其变体代码写一遍就可以了；</li></ul><h2 id="跳表"><a href="#跳表" class="headerlink" title="跳表"></a>跳表</h2><p>对于初学者来说，并不需要非得掌握跳表，所以，如果没有精力，这一章节<strong>可以先跳过</strong>。</p><ul><li>难易程度：Medium；</li><li>是否重点：6 分；</li><li>掌握程度：初学者可以先跳过。如果感兴趣，看懂专栏内容即可，不需要掌握代码实现；</li></ul><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><p>尽管散列表的内容我讲了很多，有三节课。但是，总体上来讲，这块内容理解起来并不难。但是，作为一种应用非常广泛的数据结构，你还是要<strong>掌握牢固散列表</strong>。</p><ul><li>难易程度：Medium；</li><li>是否重点：8 分；</li><li>掌握程度：对于初学者来说，自己能代码实现一个拉链法解决冲突的散列表即可；</li></ul><h2 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h2><p>这部分纯粹是为了开拓思路，初学者<strong>可以略过</strong>。</p><ul><li>难易程度：Easy；</li><li>是否重点：3 分；</li><li>掌握程度：可以暂时不看；</li></ul><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>这一部分非常重要！二叉树<strong>在面试中经常会被考到</strong>，所以要重点掌握。但是我这里说的二叉树，并不包含专栏中红黑树的内容。红黑树我们待会再讲。</p><ul><li>难易程度：Medium；</li><li>是否重点：9 分；</li><li>掌握程度：能代码实现二叉树的三种遍历算法、按层遍历、求高度等经典二叉树题目；</li></ul><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><p>对于初学者来说，这一节课<strong>完全可以不看</strong>。</p><ul><li>难易程度：Hard；</li><li>是否重点：3 分；</li><li>掌握程度：初学者不用把时间浪费在上面；</li></ul><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+ 树"></a>B+ 树</h2><p>虽然 B+ 树也算是比较高级的一种数据结构了，但是对初学者来说，也不是重点。有时候面试的时候还是会问的，所以这一部分内容，你能<strong>看懂专栏里的讲解</strong>就可以了。</p><ul><li>难易程度：Medium；</li><li>是否重点：5 分；</li><li>掌握程度：可看可不看；</li></ul><h2 id="堆与排序"><a href="#堆与排序" class="headerlink" title="堆与排序"></a>堆与排序</h2><p>这一部分内容<strong>不是很难</strong>，初学者也是要掌握的。</p><ul><li>难易程度：Medium；</li><li>是否重点：8 分；</li><li>掌握程度：能代码实现堆、堆排序，并且掌握堆的三种应用（优先队列、Top K、中位数）；</li></ul><h2 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h2><p>图的内容很多，但是初学者不需要掌握那么多。一般 BAT 等大厂面试，不怎么会面试有关图的内容，因为面试官可能也对这块不会很熟悉。但是，<strong>最基本图的概念、表示方法还是要掌握</strong>的。</p><ul><li>难易程度：Easy；</li><li>是否重点：8 分；</li><li>掌握程度：理解图的三种表示方法（邻接矩阵、邻接表、逆邻接表），能自己代码实现；</li></ul><h2 id="广度、深度优先搜索"><a href="#广度、深度优先搜索" class="headerlink" title="广度、深度优先搜索"></a>广度、深度优先搜索</h2><p>这算是图上最基础的遍历或者说是搜索算法了，所以还是要掌握一下。这两种算法的原理都不难，但是代码实现并不简单，<strong>一个用到了队列，另一个用到了递归</strong>。对于初学者来说，看懂这两个代码实现就是一个挑战！可以等到其他更重要的内容都掌握之后，再来挑战，也是可以的。</p><ul><li>难易程度：Hard；</li><li>是否重点：8 分；</li><li>掌握程度：能代码实现广度优先、深度优先搜索算法；</li></ul><h2 id="拓扑排序、最短路径、A-算法"><a href="#拓扑排序、最短路径、A-算法" class="headerlink" title="拓扑排序、最短路径、A* 算法"></a>拓扑排序、最短路径、A* 算法</h2><p>这几个算法稍微高级点。如果你能轻松实现广度、深度优先搜索，那看懂这三个算法不成问题。不过，这三种算法不是重点，<strong>面试不会考的</strong>。</p><ul><li>难易程度：Hard；</li><li>是否重点：5 分；</li><li>掌握程度：有时间再看，暂时可以不看；</li></ul><h2 id="字符串匹配（BF、RK）"><a href="#字符串匹配（BF、RK）" class="headerlink" title="字符串匹配（BF、RK）"></a>字符串匹配（BF、RK）</h2><p>BF 非常简单，RK 稍微复杂点，但都不难。这个<strong>最好还是掌握下</strong>。</p><ul><li>难易程度：Easy；</li><li>是否重点：7 分；</li><li>掌握程度：能实现 BF 算法，能看懂 RK 算法；</li></ul><h2 id="字符串匹配（BM、KMP、AC-自动机）"><a href="#字符串匹配（BM、KMP、AC-自动机）" class="headerlink" title="字符串匹配（BM、KMP、AC 自动机）"></a>字符串匹配（BM、KMP、AC 自动机）</h2><p>这三个算法都挺难的，对于算法有一定基础的人来说，看懂也不容易。所以，对于初学者来说，千万别浪费时间在这上面。即便有余力，<strong>看懂就好了，不用非得能自己实现</strong>。</p><ul><li>难易程度：Hard；</li><li>是否重点：3 分；</li><li>掌握程度：初学者不用把时间浪费在上面；</li></ul><h2 id="字符串匹配（Trie）"><a href="#字符串匹配（Trie）" class="headerlink" title="字符串匹配（Trie）"></a>字符串匹配（Trie）</h2><p>这个还是要能看懂，不过不需要能代码实现。有些面试官喜欢考这个东西，主要是<strong>结合应用场景来考察</strong>，只是看你知不知道要用 Trie 树这个东西。</p><ul><li>难易程度：Medium；</li><li>是否重点：7 分；</li><li>掌握程度：能看懂，知道特点、应用场景即可，不要求代码实现；</li></ul><h2 id="位图"><a href="#位图" class="headerlink" title="位图"></a>位图</h2><p>位图<strong>不是重点</strong>，如果有余力最好掌握一下。</p><ul><li>难易程度：Easy；</li><li>是否重点：6 分；</li><li>掌握程度：看懂即可，能自己实现一个位图结构最好；</li></ul><h2 id="四种算法思想"><a href="#四种算法思想" class="headerlink" title="四种算法思想"></a>四种算法思想</h2><p>这个是重点，也是难点。<code>贪心</code>、<code>分治</code>、<code>回溯</code>、<code>动态规划</code>，每一个都不简单，其中动态规划又是最难、最烧脑的。要应付 FLAG 这样公司的面试，必须拿下这块内容。但是，学习要循序渐进，这块内容的学习可以放到最后，做个长时间的学习计划来攻克。</p><p>这块内容理论的东西不多，要想真的掌握，<strong>还是要大量刷题</strong>。</p><ul><li>难易程度：Hard；</li><li>是否重点：10 分；</li><li>掌握程度：可以放到最后，但是一定要掌握！做到能实现 LeetCode 上 Medium 难度的题目；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Dependency Inversion Principle (DIP)</title>
      <link href="2020/10/26/Dependency-Inversion-Principle-DIP/"/>
      <url>2020/10/26/Dependency-Inversion-Principle-DIP/</url>
      
        <content type="html"><![CDATA[<h2 id="控制反转（IoC）"><a href="#控制反转（IoC）" class="headerlink" title="控制反转（IoC）"></a>控制反转（IoC）</h2><p>控制反转的英文翻译是 Inversion of Control，缩写为 IoC。我们先通过一个例子来看一下，什么是控制反转：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 这部分逻辑可以放到框架中</span></span><br><span class="line">        <span class="keyword">if</span> (doTest()) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test succeed."</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test failed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，<strong>所有的流程都由程序员来控制</strong>。如果我们抽象出一个下面这样一个框架，我们再来看，如何利用框架来实现同样的功能。具体的代码实现如下所示：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">TestCase</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (doTest()) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test succeed."</span>);</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(<span class="string">"Test failed."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JunitApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;TestCase&gt; testCases = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(TestCase testCase)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        testCases.add(testCase);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (TestCase <span class="keyword">case</span>: testCases) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span>.run();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把这个简化版本的测试框架引入到工程中之后，我们只需要<strong>在框架预留的扩展点，也就是 TestCase 类中的 doTest() 抽象函数中，填充具体的测试代码就可以实现之前的功能</strong>了，完全不需要写负责执行流程的 main() 函数了。 具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceTest</span> <span class="keyword">extends</span> <span class="title">TestCase</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">doTest</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册操作还可以通过配置的方式来实现，不需要程序员显示调用 register()</span></span><br><span class="line">JunitApplication.register(<span class="keyword">new</span> UserServiceTest();</span><br></pre></td></tr></table></figure><p>刚刚举的这个例子，就是典型的通过框架来实现“控制反转”的例子。<strong>框架提供了一个可扩展的代码骨架，用来组装对象、管理整个执行流程</strong>。程序员利用框架进行开发的时候，只需要<strong>往预留的扩展点上，添加跟自己业务相关的代码</strong>，就可以利用框架来驱动整个程序流程的执行。</p><p>这里的<strong>控制指的是对程序执行流程的控制</strong>，而“反转”指的是在没有使用框架之前，程序员自己控制整个程序的执行。在使用框架之后，整个程序的执行流程可以通过框架来控制。<strong>流程的控制权从程序员反转到了框架</strong>。</p><h2 id="依赖注入（DI）"><a href="#依赖注入（DI）" class="headerlink" title="依赖注入（DI）"></a>依赖注入（DI）</h2><p>依赖注入跟控制反转恰恰相反，它是<strong>一种具体的编码技巧</strong>。依赖注入的英文翻译是 Dependency Injection，缩写为 DI。对于这个概念，有一个非常形象的说法，那就是：依赖注入是一个标价 25 美元，实际上只值 5 美分的概念。也就是说，这个概念听起来很“高大上”，实际上，理解、应用起来非常简单。</p><p>那到底什么是依赖注入呢？我们用一句话来概括就是：不通过 new() 的方式在类内部创建依赖类对象，而是<strong>将依赖的类对象在外部创建好之后，通过构造函数、函数参数等方式传递（或注入）给类使用</strong>。我们还是通过一个例子来解释一下。在这个例子中，Notification 类负责消息推送，依赖 MessageSender 类实现推送商品促销、验证码等消息给用户。我们分别用依赖注入和非依赖注入两种方式来实现一下。具体的实现代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非依赖注入实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageSender = <span class="keyword">new</span> MessageSender(); <span class="comment">// 此处有点像 hard code</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">        <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageSender</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 Notification</span></span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 依赖注入的实现方式</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 通过构造函数将 messageSender 传递进来</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MessageSender messageSender)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageSender = messageSender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...省略校验逻辑等...</span></span><br><span class="line">        <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用 Notification</span></span><br><span class="line">MessageSender messageSender = <span class="keyword">new</span> MessageSender();</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(messageSender);</span><br></pre></td></tr></table></figure><p>通过依赖注入的方式来将依赖的类对象传递进来，这样就<strong>提高了代码的扩展性，我们可以灵活地替换依赖的类</strong>。这一点在我们之前讲“开闭原则”的时候也提到过。当然，上面代码还有继续优化的空间，我们还可以<strong>把 MessageSender 定义成接口，基于接口而非实现编程</strong>。改造后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Notification</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageSender messageSender;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Notification</span><span class="params">(MessageSender messageSender)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageSender = messageSender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(String cellphone, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.messageSender.send(cellphone, message);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageSender</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 短信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SmsSender</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 站内信发送类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InboxSender</span> <span class="keyword">implements</span> <span class="title">MessageSender</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">send</span><span class="params">(String cellphone, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用 Notification</span></span><br><span class="line">MessageSender messageSender = <span class="keyword">new</span> SmsSender();</span><br><span class="line">Notification notification = <span class="keyword">new</span> Notification(messageSender);</span><br></pre></td></tr></table></figure><h2 id="依赖注入框架（DI-Framework）"><a href="#依赖注入框架（DI-Framework）" class="headerlink" title="依赖注入框架（DI Framework）"></a>依赖注入框架（DI Framework）</h2><p>在采用依赖注入实现的 Notification 类中，虽然我们不需要用类似 hard code 的方式，在类内部通过 new 来创建 MessageSender 对象，但是，这个<strong>创建对象、组装（或注入）对象的工作仅仅是被移动到了更上层代码而已，还是需要我们程序员自己来实现</strong>。具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        MessageSender sender = <span class="keyword">new</span> SmsSender(); <span class="comment">// 创建对象</span></span><br><span class="line">        Notification notification = <span class="keyword">new</span> Notification(sender); <span class="comment">// 依赖注入</span></span><br><span class="line">        notification.sendMessage(<span class="string">"13918942177"</span>, <span class="string">"短信验证码：2346"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在实际的软件开发中，一些项目可能会涉及几十、上百、甚至几百个类，类对象的创建和依赖注入会变得非常复杂。<strong>如果这部分工作都是靠程序员自己写代码来完成，容易出错且开发成本也比较高</strong>。而对象创建和依赖注入的工作，本身<strong>跟具体的业务无关，我们完全可以抽象成框架来自动完成</strong>。</p><p>你可能已经猜到，这个框架就是“依赖注入框架”。我们只需要<strong>通过依赖注入框架提供的扩展点，简单配置一下所有需要创建的类对象、类与类之间的依赖关系</strong>，就可以实现由框架来自动创建对象、管理对象的生命周期、依赖注入等原本需要程序员来做的事情。实际上，现成的依赖注入框架有很多，比如 Google Guice、Java Spring、Pico Container、Butterfly Container 等。</p><h2 id="依赖反转原则（DIP）"><a href="#依赖反转原则（DIP）" class="headerlink" title="依赖反转原则（DIP）"></a>依赖反转原则（DIP）</h2><p>依赖反转原则的英文翻译是 Dependency Inversion Principle，缩写为 DIP。中文翻译有时候也叫依赖倒置原则。为了追本溯源，我先给出这条原则最原汁原味的英文描述：</p><blockquote><p>High-level modules shouldn’t depend on low-level modules. Both modules should depend on abstractions. In addition, abstractions shouldn’t depend on details. Details depend on abstractions.</p></blockquote><p>我们将它翻译成中文，大概意思就是：高层模块（high-level modules）不要依赖低层模块（low-level modules）。<strong>高层模块和低层模块应该通过抽象（abstractions）来互相依赖</strong>。除此之外，抽象（abstractions）不要依赖具体实现细节（details），具体实现细节（details）依赖抽象（abstractions）。</p><p>所谓高层模块和低层模块的划分，简单来说就是，<strong>在调用链上，调用者属于高层，被调用者属于低层</strong>。在平时的业务代码开发中，高层模块依赖底层模块是没有任何问题的。实际上，<strong>这条原则主要还是用来指导框架层面的设计</strong>，跟前面讲到的控制反转类似。我们拿 Tomcat 这个 Servlet 容器作为例子来解释一下。</p><p>Tomcat 是运行 Java Web 应用程序的容器。我们编写的 Web 应用程序代码只需要部署在 Tomcat 容器下，便可以被 Tomcat 容器调用执行。按照之前的划分原则，Tomcat 就是高层模块，我们编写的 Web 应用程序代码就是低层模块。Tomcat 和应用程序代码之间并没有直接的依赖关系，<strong>两者都依赖同一个“抽象”，也就是 Servlet 规范</strong>。Servlet 规范不依赖具体的 Tomcat 容器和应用程序的实现细节，而 Tomcat 容器和应用程序依赖 Servlet 规范。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interface Segregation Principle (ISP)</title>
      <link href="2020/10/11/Interface-Segregation-Principle-ISP/"/>
      <url>2020/10/11/Interface-Segregation-Principle-ISP/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解-ISP"><a href="#如何理解-ISP" class="headerlink" title="如何理解 ISP"></a>如何理解 ISP</h2><p>接口隔离原则的英文翻译是“ Interface Segregation Principle”，缩写为 ISP。Robert Martin 在 SOLID 原则中是这样定义它的：</p><blockquote><p>Clients should not be forced to depend upon interfaces that they do not use.</p></blockquote><p>直译成中文的话就是：<strong>客户端不应该被强迫依赖它不需要的接口</strong>。其中的“客户端”，可以理解为接口的调用者或者使用者。</p><p>实际上，“接口”这个名词可以用在很多场合中。生活中我们可以用它来指插座接口等。在软件开发中，我们既可以把它看作<strong>一组抽象的约定</strong>，也可以具体指<strong>系统与系统之间的 API 接口</strong>，还可以特指<strong>面向对象编程语言中的接口</strong>等。</p><p>前面我提到，理解接口隔离原则的关键，就是理解其中的<code>接口</code>二字。在这条原则中，我们可以把“接口”理解为下面三种东西：</p><ul><li>一组 API 接口集合；</li><li>单个 API 接口或函数；</li><li>OOP 中的接口概念；</li></ul><a id="more"></a><h3 id="把接口理解为一组-API-接口集合"><a href="#把接口理解为一组-API-接口集合" class="headerlink" title="把接口理解为一组 API 接口集合"></a>把接口理解为一组 API 接口集合</h3><p>我们还是结合一个例子来讲解。微服务用户系统提供了一组跟用户相关的 API 给其他系统使用，比如：注册、登录、获取用户信息等。具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">    <span class="function">UserInfo <span class="title">getUserInfoById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function">UserInfo <span class="title">getUserInfoByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们的后台管理系统要实现删除用户的功能，希望用户系统提供一个删除用户的接口。这个时候我们该如何来做呢？你可能会说，这不是很简单吗，我只需要在 UserService 中新添加一个 deleteUserByCellphone() 或 deleteUserById() 接口就可以了。这个方法可以解决问题，但是也<strong>隐藏了一些安全隐患</strong>。</p><p>删除用户是一个非常慎重的操作，我们只希望通过后台管理系统来执行，所以这个接口只限于给后台管理系统使用。如果我们把它放到 UserService 中，那所有使用到 UserService 的系统，都可以调用这个接口。<strong>不加限制地被其他业务系统调用，就有可能导致误删用户</strong>。</p><p>当然，<strong>最好的解决方案是从架构设计的层面，通过接口鉴权的方式来限制接口的调用</strong>。不过，如果暂时没有鉴权框架来支持，我们还可以<strong>从代码设计的层面，尽量避免接口被误用</strong>。我们参照接口隔离原则，调用者不应该强迫依赖它不需要的接口，将删除接口单独放到另外一个接口 RestrictedUserService 中，然后将 RestrictedUserService 只打包提供给后台管理系统来使用。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">register</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String cellphone, String password)</span></span>;</span><br><span class="line">    <span class="function">UserInfo <span class="title">getUserInfoById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">    <span class="function">UserInfo <span class="title">getUserInfoByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RestrictedUserService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserByCellphone</span><span class="params">(String cellphone)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">deleteUserById</span><span class="params">(<span class="keyword">long</span> id)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span>, <span class="title">RestrictedUserService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略实现代码...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在刚刚的这个例子中，我们把接口隔离原则中的接口，理解为一组接口集合，它可以是某个微服务的接口，也可以是某个类库的接口等等。在设计微服务或者类库接口的时候，<strong>如果部分接口只被部分调用者使用，那我们就需要将这部分接口隔离出来，单独给对应的调用者使用</strong>，而不是强迫其他调用者也依赖这部分不会被用到的接口。</p><h3 id="把接口理解为单个-API-接口或函数"><a href="#把接口理解为单个-API-接口或函数" class="headerlink" title="把接口理解为单个 API 接口或函数"></a>把接口理解为单个 API 接口或函数</h3><p>现在我们再换一种理解方式，把接口理解为单个接口或函数。那接口隔离原则就可以理解为：<strong>函数的设计要功能单一，不要将多个不同的功能逻辑在一个函数中实现</strong>。接下来，我们还是通过一个例子来解释一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Statistics</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long max;</span><br><span class="line">    <span class="keyword">private</span> Long min;</span><br><span class="line">    <span class="keyword">private</span> Long average;</span><br><span class="line">    <span class="keyword">private</span> Long sum;</span><br><span class="line">    <span class="keyword">private</span> Long percentile99;</span><br><span class="line">    <span class="keyword">private</span> Long percentile999;</span><br><span class="line">    <span class="comment">//...省略constructor/getter/setter等方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Statistics <span class="title">count</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Statistics statistics = <span class="keyword">new</span> Statistics();</span><br><span class="line">    <span class="comment">//...省略计算逻辑...</span></span><br><span class="line">    <span class="keyword">return</span> statistics;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的代码中，count() 函数的功能不够单一，<strong>包含很多不同的统计功能，比如，求最大值、最小值、平均值等等</strong>。按照接口隔离原则，我们应该把 count() 函数拆成几个更小粒度的函数，每个函数负责一个独立的统计功能。拆分之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">max</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">min</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125; </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Long <span class="title">average</span><span class="params">(Collection&lt;Long&gt; dataSet)</span> </span>&#123; <span class="comment">//... &#125;</span></span><br><span class="line"><span class="comment">// ...省略其他统计函数...</span></span><br></pre></td></tr></table></figure><p>不过，你可能会说，在某种意义上讲，count() 函数也不能算是职责不够单一，毕竟它做的事情只跟统计相关。我们在讲单一职责原则的时候，也提到过类似的问题。实际上，<strong>判定功能是否单一，除了很强的主观性，还需要结合具体的场景</strong>。</p><p>不过，你应该已经发现，接口隔离原则跟单一职责原则有点类似，不过稍微还是有点区别。<strong>单一职责原则针对的是模块、类、接口的设计</strong>。而接口隔离原则相对于单一职责原则，一方面它<strong>更侧重于接口的设计</strong>，另一方面它的思考的角度不同。它提供了一种判断接口是否职责单一的标准：通过调用者如何使用接口来间接地判定。<strong>如果调用者只使用部分接口或接口的部分功能，那接口的设计就不够职责单一</strong>。</p><h3 id="把接口理解为-OOP-中的接口概念"><a href="#把接口理解为-OOP-中的接口概念" class="headerlink" title="把接口理解为 OOP 中的接口概念"></a>把接口理解为 OOP 中的接口概念</h3><p>除了刚讲过的两种理解方式，我们还可以把接口理解为 OOP 中的接口概念，比如 Java 中的 <code>Interface</code>。</p><p>假设我们的项目中用到了三个外部系统：Redis、MySQL、Kafka。每个系统都对应一系列配置信息，比如地址、端口、访问超时时间等。为了在内存中存储这些配置信息，供项目中的其他模块来使用，我们分别设计实现了三个 Configuration 类：RedisConfig、MysqlConfig、KafkaConfig。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ConfigSource configSource; <span class="comment">// 配置中心（比如 ZooKeeper）</span></span><br><span class="line">    <span class="keyword">private</span> String address;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> timeout;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> maxTotal;</span><br><span class="line">    <span class="comment">// 省略其他配置: maxWaitMillis, maxIdle,minIdle...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RedisConfig</span><span class="params">(ConfigSource configSource)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.configSource = configSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getAddress</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.address;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他get()、init()方法...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 从configSource加载配置到address/timeout/maxTotal...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">//...省略... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">//...省略... </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们有一个新的功能需求，希望支持 Redis 和 Kafka 配置信息的<code>热更新 (hot update)</code>。但是，因为某些原因，我们并不希望对 MySQL 的配置信息进行热更新。</p><p>为了实现这样一个功能需求，我们设计实现了一个 ScheduledUpdater 类，以固定时间频率（periodInSeconds）来调用 RedisConfig、KafkaConfig 的 update() 方法更新配置信息。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Updater</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">//...省略其他属性和方法... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledUpdater</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> initialDelayInSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> periodInSeconds;</span><br><span class="line">    <span class="keyword">private</span> Updater updater;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleUpdater</span><span class="params">(Updater updater, <span class="keyword">long</span> initialDelayInSeconds, <span class="keyword">long</span> periodInSeconds)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.updater = updater;</span><br><span class="line">        <span class="keyword">this</span>.initialDelayInSeconds = initialDelayInSeconds;</span><br><span class="line">        <span class="keyword">this</span>.periodInSeconds = periodInSeconds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        executor.scheduleAtFixedRate(<span class="keyword">new</span> Runnable() </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">            </span>&#123;</span><br><span class="line">                updater.update();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">this</span>.initialDelayInSeconds, <span class="keyword">this</span>.periodInSeconds, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KafkaConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mysqlConfig = <span class="keyword">new</span> MysqlConfig(configSource);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ScheduledUpdater redisConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        ScheduledUpdater kafkaConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚刚的热更新的需求我们已经搞定了。现在，我们又有了一个新的监控功能需求。<strong>通过命令行来查看 Zookeeper 中的配置信息是比较麻烦的</strong>。所以，我们希望能有一种更加方便的配置信息查看方式。不过，出于某些原因，我们只想暴露 MySQL 和 Redis 的配置信息，不想暴露 Kafka 的配置信息。为了实现这样一个功能，我们还需要对上面的代码做进一步改造。改造之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Updater</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Viewer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">outputInPlainText</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span>, <span class="title">Viewer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">outputInPlainText</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Updater</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> <span class="keyword">implements</span> <span class="title">Viewer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">outputInPlainText</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Viewer&gt;&gt; viewers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHttpServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewers</span><span class="params">(String urlDirectory, Viewer viewer)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) </span><br><span class="line">        &#123;</span><br><span class="line">            viewers.put(urlDirectory, <span class="keyword">new</span> ArrayList&lt;Viewer&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.viewers.get(urlDirectory).add(viewer);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KafkaConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mysqlConfig = <span class="keyword">new</span> MySqlConfig(configSource);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ScheduledUpdater redisConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(redisConfig, <span class="number">300</span>, <span class="number">300</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        ScheduledUpdater kafkaConfigUpdater = <span class="keyword">new</span> ScheduledUpdater(kafkaConfig, <span class="number">60</span>, <span class="number">60</span>);</span><br><span class="line">        redisConfigUpdater.run();</span><br><span class="line">        </span><br><span class="line">        SimpleHttpServer simpleHttpServer = <span class="keyword">new</span> SimpleHttpServer(“<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”, <span class="number">2389</span>);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/config"</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/config"</span>, mysqlConfig);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们<strong>设计了两个功能非常单一的接口：Updater 和 Viewer</strong>。ScheduledUpdater 只依赖 Updater 这个跟热更新相关的接口，不需要被强迫去依赖不需要的 Viewer 接口，满足接口隔离原则。同理，SimpleHttpServer 只依赖跟查看信息相关的 Viewer 接口，不依赖不需要的 Updater 接口，也满足接口隔离原则。</p><p>你可能会说，如果我们不遵守接口隔离原则，不设计 Updater 和 Viewer 两个小接口，而是设计一个大而全的 Config 接口，让 RedisConfig、KafkaConfig、MysqlConfig 都实现这个 Config 接口，并且将原来传递给 ScheduledUpdater 的 Updater 和传递给 SimpleHttpServer 的 Viewer，都替换为 Config，那会有什么问题呢？我们先来看一下，按照这个思路来实现的代码是什么样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Config</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">outputInPlainText</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">Map&lt;String, String&gt; <span class="title">output</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> <span class="keyword">implements</span> <span class="title">Config</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaConfig</span> <span class="keyword">implements</span> <span class="title">Config</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MysqlConfig</span> <span class="keyword">implements</span> <span class="title">Config</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...需要实现Config的三个接口update/outputIn.../output</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledUpdater</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法..</span></span><br><span class="line">    <span class="keyword">private</span> Config config;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScheduleUpdater</span><span class="params">(Config config, <span class="keyword">long</span> initialDelayInSeconds, <span class="keyword">long</span> periodInSeconds)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.config = config;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleHttpServer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, List&lt;Config&gt;&gt; viewers = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleHttpServer</span><span class="params">(String host, <span class="keyword">int</span> port)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addViewer</span><span class="params">(String urlDirectory, Config config)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!viewers.containsKey(urlDirectory)) </span><br><span class="line">        &#123;</span><br><span class="line">            viewers.put(urlDirectory, <span class="keyword">new</span> ArrayList&lt;Config&gt;());</span><br><span class="line">        &#125;</span><br><span class="line">        viewers.get(urlDirectory).add(config);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的设计思路也是能工作的，但是对比前后两个设计思路，在同样的代码量、实现复杂度、同等可读性的情况下，第一种设计思路显然要比第二种好很多：</p><ol><li><p>第一种设计思路更加灵活、易扩展、易复用<br>因为 Updater、Viewer 职责更加单一，<strong>单一就意味了通用、复用性好</strong>。比如，我们现在又有一个新的需求，开发一个 Metrics 性能统计模块，并且希望将 Metrics 也通过 SimpleHttpServer 显示在网页上，以方便查看。这个时候，尽管 Metrics 跟 RedisConfig 等没有任何关系，但我们仍然可以让 Metrics 类实现非常通用的 Viewer 接口，复用 SimpleHttpServer 的代码实现。具体的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiMetrics</span> <span class="keyword">implements</span> <span class="title">Viewer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DbMetrics</span> <span class="keyword">implements</span> <span class="title">Viewer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    ConfigSource configSource = <span class="keyword">new</span> ZookeeperConfigSource();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> RedisConfig redisConfig = <span class="keyword">new</span> RedisConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> KafkaConfig kafkaConfig = <span class="keyword">new</span> KafkaConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MySqlConfig mySqlConfig = <span class="keyword">new</span> MySqlConfig(configSource);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> ApiMetrics apiMetrics = <span class="keyword">new</span> ApiMetrics();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> DbMetrics dbMetrics = <span class="keyword">new</span> DbMetrics();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        SimpleHttpServer simpleHttpServer = <span class="keyword">new</span> SimpleHttpServer(“<span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>”, <span class="number">2389</span>);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/config"</span>, redisConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/config"</span>, mySqlConfig);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/metrics"</span>, apiMetrics);</span><br><span class="line">        simpleHttpServer.addViewer(<span class="string">"/metrics"</span>, dbMetrics);</span><br><span class="line">        simpleHttpServer.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>第二种设计思路在代码实现上做了一些无用功<br>因为 <strong>Config 接口中包含两类不相关的接口</strong>，一类是 update()，一类是 output() 和 outputInPlainText()。理论上，KafkaConfig 只需要实现 update() 接口，并不需要实现 output() 相关的接口。同理，MysqlConfig 只需要实现 output() 相关接口，并不需要实现 update() 接口。但第二种设计思路要求 RedisConfig、KafkaConfig、MySqlConfig 必须同时实现 Config 的所有接口函数。除此之外，如果我们要<strong>往 Config 中继续添加一个新的接口，那所有的实现类都要改动</strong>。相反，如果我们的接口粒度比较小，那涉及改动的类就比较少。</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Liskov Substitution Principle (LSP)</title>
      <link href="2020/09/28/Liskov-Substitution-Principle-LSP/"/>
      <url>2020/09/28/Liskov-Substitution-Principle-LSP/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解-LSP"><a href="#如何理解-LSP" class="headerlink" title="如何理解 LSP"></a>如何理解 LSP</h2><p>里式替换原则的英文翻译是：Liskov Substitution Principle，缩写为 LSP。这个原则最早是在 1986 年由 Barbara Liskov 提出，他是这么描述这条原则的：</p><blockquote><p>If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program.</p></blockquote><p>在 1996 年，Robert Martin 在他的 SOLID 原则中，重新描述了这个原则，英文原话是这样的：</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.</p></blockquote><p>我们综合两者的描述，将这条原则用中文描述出来，是这样的：<strong>子类对象能够替换程序中父类对象出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏</strong>。</p><p>这么说还是比较抽象，我们通过一个例子来解释一下。如下代码中，父类 Transporter 使用 org.apache.http 库中的 HttpClient 类来传输网络数据。子类 SecurityTransporter 继承父类 Transporter，增加了额外的功能，支持传输 appId 和 appToken 安全认证信息：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Transporter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HttpClient httpClient;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Transporter</span><span class="params">(HttpClient httpClient)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.httpClient = httpClient;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...use httpClient to send request</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityTransporter</span> <span class="keyword">extends</span> <span class="title">Transporter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String appId;</span><br><span class="line">    <span class="keyword">private</span> String appToken;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecurityTransporter</span><span class="params">(HttpClient httpClient, String appId, String appToken)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(httpClient);</span><br><span class="line">        <span class="keyword">this</span>.appId = appId;</span><br><span class="line">        <span class="keyword">this</span>.appToken = appToken;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">sendRequest</span><span class="params">(Request request)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (StringUtils.isNotBlank(appId) &amp;&amp; StringUtils.isNotBlank(appToken)) </span><br><span class="line">        &#123;</span><br><span class="line">            request.addPayload(<span class="string">"app-id"</span>, appId);</span><br><span class="line">            request.addPayload(<span class="string">"app-token"</span>, appToken);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.sendRequest(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">demoFunction</span><span class="params">(Transporter transporter)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;    </span><br><span class="line">        Request request = <span class="keyword">new</span> Request();</span><br><span class="line">        <span class="comment">//...省略设置request中数据值的代码...</span></span><br><span class="line">        Response response = transporter.sendRequest(request);</span><br><span class="line">        <span class="comment">//...省略其他逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 里式替换原则</span></span><br><span class="line">Demo demo = <span class="keyword">new</span> Demo();</span><br><span class="line">demo.demoFunction(<span class="keyword">new</span> SecurityTransporter(<span class="comment">/*省略参数*/</span>););</span><br></pre></td></tr></table></figure><p>在上面的代码中，子类 SecurityTransporter 的设计完全符合里式替换原则，<strong>可以替换父类出现的任何位置，并且原来代码的逻辑行为不变且正确性也没有被破坏</strong>。</p><p>虽然从定义描述和代码实现上来看，多态和里式替换有点类似，但它们关注的角度是不一样的。<strong>多态是面向对象编程的一大特性</strong>，也是面向对象编程语言的一种语法。它是一种代码实现的思路。而<strong>里式替换是一种设计原则</strong>，是用来指导继承关系中子类该如何设计的，子类的设计要保证在替换父类的时候，不改变原有程序的逻辑以及不破坏原有程序的正确性。</p><h2 id="哪些代码明显违背了-LSP"><a href="#哪些代码明显违背了-LSP" class="headerlink" title="哪些代码明显违背了 LSP"></a>哪些代码明显违背了 LSP</h2><p>实际上，里式替换原则还有另外一个更加能落地、更有指导意义的描述，那就是 <code>Design By Contract</code>，中文翻译就是：<strong>按照协议来设计</strong>。</p><p>看起来比较抽象，我来进一步解读一下。子类在设计的时候，要遵守父类的行为约定（或者叫协议）。父类定义了函数的行为约定，那子类可以改变函数的内部实现逻辑，但不能改变函数原有的行为约定。这里的行为约定包括：函数声明要实现的功能；对输入、输出、异常的约定；甚至包括注释中所罗列的任何特殊说明。实际上，<strong>定义中父类和子类之间的关系，也可以替换成接口和实现类之间的关系</strong>。</p><h3 id="子类违背父类声明要实现的功能"><a href="#子类违背父类声明要实现的功能" class="headerlink" title="子类违背父类声明要实现的功能"></a>子类违背父类声明要实现的功能</h3><p>父类中提供的 sortOrdersByAmount() 订单排序函数，是按照金额从小到大来给订单排序的，而子类重写这个 sortOrdersByAmount() 订单排序函数之后，是按照创建日期来给订单排序的。那子类的设计就违背里式替换原则。</p><h3 id="子类违背父类对输入、输出、异常的约定"><a href="#子类违背父类对输入、输出、异常的约定" class="headerlink" title="子类违背父类对输入、输出、异常的约定"></a>子类违背父类对输入、输出、异常的约定</h3><p>在父类中，某个函数约定，输入数据可以是任意整数，但子类实现的时候，只允许输入数据是正整数，负数就抛出，也就是说，子类对输入的数据的校验比父类更加严格，那子类的设计就违背了里式替换原则。</p><p>在父类中，某个函数约定，只会抛出 ArgumentNullException 异常，那子类的设计实现中只允许抛出 ArgumentNullException 异常，任何其他异常的抛出，都会导致子类违背里式替换原则。</p><h3 id="子类违背父类注释中所罗列的任何特殊说明"><a href="#子类违背父类注释中所罗列的任何特殊说明" class="headerlink" title="子类违背父类注释中所罗列的任何特殊说明"></a>子类违背父类注释中所罗列的任何特殊说明</h3><p>父类中定义的 withdraw() 提现函数的注释是这么写的：“用户的提现金额不得超过账户余额…”，而子类重写 withdraw() 函数之后，针对 VIP 账号实现了透支提现的功能，也就是提现金额可以大于账户余额，那这个子类的设计也是不符合里式替换原则的。</p><p>以上便是三种典型的违背里式替换原则的情况。除此之外，判断子类的设计实现是否违背里式替换原则，还有一个小窍门，那就是<strong>拿父类的单元测试去验证子类的代码</strong>。如果某些单元测试运行失败，就有可能说明，子类的设计实现没有完全地遵守父类的约定，子类有可能违背了里式替换原则。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Open Closed Principle (OCP)</title>
      <link href="2020/09/18/Open-Closed-Principle-OCP/"/>
      <url>2020/09/18/Open-Closed-Principle-OCP/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解-OCP"><a href="#如何理解-OCP" class="headerlink" title="如何理解 OCP"></a>如何理解 OCP</h2><p>开闭原则的英文全称是 Open Closed Principle，简写为 OCP。它的英文描述是：</p><blockquote><p>Software entities (modules, classes, functions, etc.) should be open for extension, but closed for modification.</p></blockquote><p>我们把它翻译成中文就是：<strong>软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”</strong>。</p><p>这个描述比较简略，如果我们详细表述一下，那就是，添加一个新的功能应该是，<strong>在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）</strong>。</p><p>这是一段 API 接口监控告警的代码。其中，AlertRule 存储告警规则，可以自由设置。Notification 是告警通知类，支持邮件、短信、微信、手机等多种通知渠道。NotificationEmergencyLevel 表示通知的紧急程度，包括 SEVERE（严重）、URGENCY（紧急）、NORMAL（普通）、TRIVIAL（无关紧要），不同的紧急程度对应不同的发送渠道：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AlertRule rule;</span><br><span class="line">    <span class="keyword">private</span> Notification notification;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Alert</span><span class="params">(AlertRule rule, Notification notification)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rule = rule;</span><br><span class="line">        <span class="keyword">this</span>.notification = notification;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String api, <span class="keyword">long</span> requestCount, <span class="keyword">long</span> errorCount, <span class="keyword">long</span> durationOfSeconds)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> tps = requestCount / durationOfSeconds;</span><br><span class="line">        <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) </span><br><span class="line">        &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) </span><br><span class="line">        &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>上面这段代码非常简单，业务逻辑主要集中在 check() 函数中。当接口的 TPS 超过某个预先设置的最大值时，以及当接口请求出错数大于某个最大允许值时，就会触发告警，通知接口的相关负责人或者团队。</p><p>现在，如果我们需要添加一个功能，当每秒钟接口超时请求个数，超过某个预先设置的最大阈值时，我们也要触发告警发送通知。这个时候，我们该如何改动代码呢？主要的改动有两处：第一处是修改 check() 函数的入参，添加一个新的统计数据 timeoutCount，表示超时接口请求数；第二处是在 check() 函数中添加新的告警逻辑。具体的代码改动如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略 AlertRule/Notification 属性和构造函数...</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 改动一：添加参数 timeoutCount</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(String api, <span class="keyword">long</span> requestCount, <span class="keyword">long</span> errorCount, <span class="keyword">long</span> timeoutCount, <span class="keyword">long</span> durationOfSeconds)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> tps = requestCount / durationOfSeconds;</span><br><span class="line">        <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(api).getMaxTps()) </span><br><span class="line">        &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (errorCount &gt; rule.getMatchedRule(api).getMaxErrorCount()) </span><br><span class="line">        &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 改动二：添加接口超时处理逻辑</span></span><br><span class="line">        <span class="keyword">long</span> timeoutTps = timeoutCount / durationOfSeconds;</span><br><span class="line">        <span class="keyword">if</span> (timeoutTps &gt; rule.getMatchedRule(api).getMaxTimeoutTps()) </span><br><span class="line">        &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的代码修改实际上存在挺多问题的。一方面，我们对接口进行了修改，这就意味着<strong>调用这个接口的代码都要做相应的修改</strong>。另一方面，修改了 check() 函数，<strong>相应的单元测试都需要修改</strong>。</p><p>上面的代码改动是基于“修改”的方式来实现新功能的。如果我们遵循开闭原则，也就是“对扩展开放、对修改关闭”。那如何通过“扩展”的方式，来实现同样的功能呢？</p><p>我们先重构一下之前的 Alert 代码，让它的扩展性更好一些。重构的内容主要包含两部分：</p><ul><li>第一部分是将 check() 函数的<strong>多个入参封装成 ApiStatInfo 类</strong>；</li><li>第二部分是引入 handler 的概念，<strong>将 if 判断逻辑分散在各个 handler 中</strong>；</li></ul><p>具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;AlertHandler&gt; alertHandlers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addAlertHandler</span><span class="params">(AlertHandler alertHandler)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.alertHandlers.add(alertHandler);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (AlertHandler handler : alertHandlers) </span><br><span class="line">        &#123;</span><br><span class="line">            handler.check(apiStatInfo);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatInfo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略 constructor/getter/setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> String api;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> requestCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> errorCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> durationOfSeconds;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> AlertRule rule;</span><br><span class="line">    <span class="keyword">protected</span> Notification notification;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.rule = rule;</span><br><span class="line">        <span class="keyword">this</span>.notification = notification;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TpsAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(rule, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> tps = apiStatInfo.getRequestCount() / apiStatInfo.getDurationOfSeconds();</span><br><span class="line">        <span class="keyword">if</span> (tps &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxTps()) </span><br><span class="line">        &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.URGENCY, <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ErrorAlertHandler</span><span class="params">(AlertRule rule, Notification notification)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(rule, notification);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">check</span><span class="params">(ApiStatInfo apiStatInfo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (apiStatInfo.getErrorCount() &gt; rule.getMatchedRule(apiStatInfo.getApi()).getMaxErrorCount()) </span><br><span class="line">        &#123;</span><br><span class="line">            notification.notify(NotificationEmergencyLevel.SEVERE, <span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码是对 Alert 的重构，我们再来看下，重构之后的 Alert 该如何使用呢？其中，ApplicationContext 是一个单例类，负责 Alert 的创建、组装（alertRule 和 notification 的依赖注入）、初始化（添加 handlers）工作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">    <span class="keyword">private</span> Notification notification;</span><br><span class="line">    <span class="keyword">private</span> Alert alert;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeBeans</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        alertRule = <span class="keyword">new</span> AlertRule(<span class="comment">/*省略参数*/</span>); <span class="comment">// 省略一些初始化代码</span></span><br><span class="line">        notification = <span class="keyword">new</span> Notification(<span class="comment">/*省略参数*/</span>); <span class="comment">// 省略一些初始化代码</span></span><br><span class="line">        alert = <span class="keyword">new</span> Alert();</span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> TpsAlertHandler(alertRule, notification));</span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> ErrorAlertHandler(alertRule, notification));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Alert <span class="title">getAlert</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> alert; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 饿汉式单例</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ApplicationContext instance = <span class="keyword">new</span> ApplicationContext();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ApplicationContext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        initializeBeans();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ApplicationContext <span class="title">getInstance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ApiStatInfo apiStatInfo = <span class="keyword">new</span> ApiStatInfo();</span><br><span class="line">        <span class="comment">//...省略设置 apiStatInfo 数据值的代码</span></span><br><span class="line">        ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们再来看下，基于重构之后的代码，如果再添加上面讲到的那个新功能，每秒钟接口超时请求个数超过某个最大阈值就告警，我们又该如何改动代码呢？主要的改动有下面四处：</p><ul><li>在 ApiStatInfo 类中添加新的属性 timeoutCount；</li><li>添加新的 TimeoutAlertHandler 类；</li><li>在 ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中注册新的 timeoutAlertHandler；</li><li>在使用 Alert 类的时候，需要给 check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值；</li></ul><p>改动之后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Alert</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 代码未改动... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApiStatInfo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略 constructor/getter/setter 方法</span></span><br><span class="line">    <span class="keyword">private</span> String api;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> requestCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> errorCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> durationOfSeconds;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> timeoutCount; <span class="comment">// 改动一：添加新字段</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AlertHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 代码未改动... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TpsAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 代码未改动...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ErrorAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 代码未改动...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 改动二：添加新的 handler</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeoutAlertHandler</span> <span class="keyword">extends</span> <span class="title">AlertHandler</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationContext</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> AlertRule alertRule;</span><br><span class="line">    <span class="keyword">private</span> Notification notification;</span><br><span class="line">    <span class="keyword">private</span> Alert alert;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initializeBeans</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        alertRule = <span class="keyword">new</span> AlertRule(<span class="comment">/*省略参数*/</span>); <span class="comment">// 省略一些初始化代码</span></span><br><span class="line">        notification = <span class="keyword">new</span> Notification(<span class="comment">/*省略参数*/</span>); <span class="comment">// 省略一些初始化代码</span></span><br><span class="line">        alert = <span class="keyword">new</span> Alert();</span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> TpsAlertHandler(alertRule, notification));</span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> ErrorAlertHandler(alertRule, notification));</span><br><span class="line">        <span class="comment">// 改动三：注册 handler</span></span><br><span class="line">        alert.addAlertHandler(<span class="keyword">new</span> TimeoutAlertHandler(alertRule, notification));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他未改动代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ApiStatInfo apiStatInfo = <span class="keyword">new</span> ApiStatInfo();</span><br><span class="line">        <span class="comment">//...省略 apiStatInfo 的 set 字段代码</span></span><br><span class="line">        apiStatInfo.setTimeoutCount(<span class="number">289</span>); <span class="comment">// 改动四：设置 timeoutCount 值</span></span><br><span class="line">        ApplicationContext.getInstance().getAlert().check(apiStatInfo);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>重构之后的代码更加灵活和易扩展</strong>。如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。</p><h2 id="修改代码违背-OCP-吗"><a href="#修改代码违背-OCP-吗" class="headerlink" title="修改代码违背 OCP 吗"></a>修改代码违背 OCP 吗</h2><p>看了上面重构之后的代码，你可能还会有疑问：在添加新的告警逻辑的时候，尽管改动二（添加新的 handler 类）是基于扩展而非修改的方式来完成的，但改动一、三、四貌似不是基于扩展而是基于修改的方式来完成的，那改动一、三、四不就违背了开闭原则吗？</p><h3 id="改动一"><a href="#改动一" class="headerlink" title="改动一"></a>改动一</h3><blockquote><p>往 ApiStatInfo 类中，添加新的属性 timeoutCount。</p></blockquote><p>从定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。<strong>同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”</strong>。比如，改动一，添加属性和方法相当于修改类，在类这个层面，这个代码改动可以被认定为“修改”；但这个代码改动并没有修改已有的属性和方法，在方法（及其属性）这一层面，它又可以被认定为“扩展”。</p><p>实际上，我们也没必要纠结某个代码改动是“修改”还是“扩展”，更没必要太纠结它是否违反“开闭原则”。我们回到这条原则的设计初衷：<strong>只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试</strong>，我们就可以说，这是一个合格的代码改动。</p><h3 id="改动三和改动四"><a href="#改动三和改动四" class="headerlink" title="改动三和改动四"></a>改动三和改动四</h3><blockquote><p>在 ApplicationContext 类的 initializeBeans() 方法中，往 alert 对象中注册新的 timeoutAlertHandler；在使用 Alert 类的时候，需要给 check() 函数的入参 apiStatInfo 对象设置 timeoutCount 的值。</p></blockquote><p>我们要认识到，添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是<strong>尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则</strong>。</p><h2 id="如何做到-OCP"><a href="#如何做到-OCP" class="headerlink" title="如何做到 OCP"></a>如何做到 OCP</h2><p>在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要<strong>时刻具备扩展意识、抽象意识、封装意识</strong>。这些“潜意识”可能比任何开发技巧都重要。</p><p>在写代码的时候后，我们要多花点时间往前多思考一下，<strong>这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点</strong>，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上，做到“对扩展开放、对修改关闭”。</p><p>还有，在识别出代码可变部分和不可变部分之后，我们要<strong>将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用</strong>。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。</p><p>实际上，多态、依赖注入、基于接口而非实现编程，以及前面提到的抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。这也体现了“<strong>很多设计原则、思想、模式都是相通的</strong>”这一思想。</p><p>比如，我们代码中通过 Kafka 来发送异步消息。对于这样一个功能的开发，我们要学会将其抽象成一组跟具体消息队列（Kafka）无关的异步消息接口。所有上层系统都依赖这组抽象的接口编程，并且通过依赖注入的方式来调用。当我们要替换新的消息队列的时候，比如将 Kafka 替换成 RocketMQ，可以很方便地拔掉老的消息队列实现，插入新的消息队列实现。具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这一部分体现了抽象意识</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageQueue</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">KafkaMessageQueue</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RocketMQMessageQueue</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageFormatter</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">//... </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonMessageFormatter</span> <span class="keyword">implements</span> <span class="title">MessageFormatter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProtoBufMessageFormatter</span> <span class="keyword">implements</span> <span class="title">MessageFormatter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageQueue msgQueue; <span class="comment">// 基于接口而非实现编程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Demo</span><span class="params">(MessageQueue msgQueue)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">// 依赖注入</span></span><br><span class="line">        <span class="keyword">this</span>.msgQueue = msgQueue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// msgFormatter：多态、依赖注入</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendNotification</span><span class="params">(Notification notification, MessageFormatter msgFormatter)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...    </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="如何灵活应用-OCP"><a href="#如何灵活应用-OCP" class="headerlink" title="如何灵活应用 OCP"></a>如何灵活应用 OCP</h2><p>如果你开发的是一个业务导向的系统，比如金融系统、电商系统、物流系统等，要想识别出尽可能多的扩展点，就要<strong>对业务有足够的了解，能够知道当下以及未来可能要支持的业务需求</strong>。如果你开发的是跟业务无关的、通用的、偏底层的系统，比如，框架、组件、类库，你需要了解“<strong>它们会被如何使用？今后你打算添加哪些功能？使用者未来会有哪些更多的功能需求？</strong>”等问题。</p><p>最合理的做法是，对于一些比较确定的、短期内可能就会扩展，或者需求改动对代码结构影响比较大的情况，或者实现成本不高的扩展点，在编写代码的时候之后，我们就可以事先做些扩展性设计。但对于一些不确定未来是否要支持的需求，或者实现起来比较复杂的扩展点，我们可以<strong>等到有需求驱动的时候，再通过重构代码的方式来支持扩展的需求</strong>。</p><p>在我们之前举的 Alert 告警的例子中，如果告警规则并不是很多、也不复杂，那 check() 函数中的 if 语句就不会很多，代码逻辑也不复杂，代码行数也不多，那最初的<strong>第一种代码实现思路简单易读</strong>，就是比较合理的选择。相反，如果告警规则很多、很复杂，check() 函数的 if 语句、代码逻辑就会很多、很复杂，相应的代码行数也会很多，可读性、可维护性就会变差，那重构之后的第二种代码实现思路就是更加合理的选择了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Single Responsibility Principle (SRP)</title>
      <link href="2020/09/17/Single-Responsibility-Principle-SRP/"/>
      <url>2020/09/17/Single-Responsibility-Principle-SRP/</url>
      
        <content type="html"><![CDATA[<h2 id="如何理解-SRP"><a href="#如何理解-SRP" class="headerlink" title="如何理解 SRP"></a>如何理解 SRP</h2><p><code>单一职责原则</code>的英文是 Single Responsibility Principle，缩写为 SRP。这个原则的英文描述是这样的：</p><blockquote><p>A class or module should have a single responsibility.</p></blockquote><p>如果我们把它翻译成中文，那就是：<strong>一个类或者模块只负责完成一个职责（或者功能）</strong>。</p><p>注意，这个原则描述的对象包含两个，一个是类（class），一个是模块（module）。关于这两个概念，在专栏中，有两种理解方式。一种理解是：<strong>把模块看作比类更加抽象的概念</strong>，类也可以看作模块。另一种理解是：<strong>把模块看作比类更加粗粒度的代码块</strong>，模块中包含多个类，多个类组成一个模块。</p><p>单一职责原则的定义描述非常简单，也不难理解。一个类只负责完成一个职责或者功能。也就是说，<strong>不要设计大而全的类，要设计粒度小、功能单一的类</strong>。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。</p><h2 id="如何判断-SRP"><a href="#如何判断-SRP" class="headerlink" title="如何判断 SRP"></a>如何判断 SRP</h2><p>在一个社交产品中，我们用下面的 UserInfo 类来记录用户的信息。你觉得，UserInfo 类的设计是否满足单一职责原则呢：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserInfo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> userId;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String email;</span><br><span class="line">    <span class="keyword">private</span> String telephone;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> lastLoginTime;</span><br><span class="line">    <span class="keyword">private</span> String avatarUrl;</span><br><span class="line">    <span class="keyword">private</span> String provinceOfAddress; <span class="comment">// 省</span></span><br><span class="line">    <span class="keyword">private</span> String cityOfAddress; <span class="comment">// 市</span></span><br><span class="line">    <span class="keyword">private</span> String regionOfAddress; <span class="comment">// 区 </span></span><br><span class="line">    <span class="keyword">private</span> String detailedAddress; <span class="comment">// 详细地址</span></span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>对于这个问题，有两种不同的观点。一种观点是，UserInfo 类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则；另一种观点是，地址信息在 UserInfo 类中，所占的比重比较高，可以继续拆分成独立的 UserAddress 类，UserInfo 只保留除 Address 之外的其他信息，拆分之后的两个类的职责更加单一。</p><p>哪种观点更对呢？实际上，<strong>要从中做出选择，我们不能脱离具体的应用场景</strong>。如果在这个社交产品中，用户的地址信息跟其他信息一样，只是单纯地用来展示，那 UserInfo 现在的设计就是合理的。但是，如果这个社交产品发展得比较好，之后又在产品中添加了电商的模块，用户的地址信息还会用在电商物流中，那我们最好将地址信息从 UserInfo 中拆分出来，独立成用户物流信息（或者叫地址信息、收货信息等）。</p><p>除此之外，<strong>从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识</strong>。比如，例子中的 UserInfo 类。如果我们从“用户”这个业务层面来看，UserInfo 包含的信息都属于用户，满足职责单一原则。如果我们从更加细分的“用户展示信息”“地址信息”“登录认证信息”等等这些更细粒度的业务层面来看，那 UserInfo 就应该继续拆分。</p><p>综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，我们<strong>可以先写一个粗粒度的类，满足业务需求</strong>。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。</p><p>下面这几条判断原则，比起很主观地去思考类是否职责单一，要更有指导意义、更具有可执行性：</p><ul><li><strong>类中的代码行数、函数或属性过多</strong>，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分；</li><li><strong>类依赖的其他类过多</strong>，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分；</li><li><strong>私有方法过多</strong>，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性；</li><li><strong>比较难给类起一个合适名字</strong>，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰；</li><li><strong>类中大量的方法都是集中操作类中的某几个属性</strong>，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来;</li></ul><p>实际上， 从另一个角度来看，当一个类的代码，读起来让你头大了，实现某个功能时不知道该用哪个函数了，想用哪个函数翻半天都找不到了，只用到一个小功能要引入整个类（类中包含很多无关此功能实现的函数）的时候，这就说明类的行数、函数、属性过多了。实际上，等你做多项目了，代码写多了，在开发中慢慢“品尝”，自然就知道什么是“放盐少许”了，这就是所谓的“专业第六感”。</p><h2 id="类的职责是否越单一越好"><a href="#类的职责是否越单一越好" class="headerlink" title="类的职责是否越单一越好"></a>类的职责是否越单一越好</h2><p>为了满足单一职责原则，是不是把类拆得越细就越好呢？答案是否定的。我们还是通过一个例子来解释一下。Serialization 类实现了一个简单协议的序列化和反序列功能，具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Protocol format: identifier-string;&#123;gson string&#125;</span></span><br><span class="line"><span class="comment"> * For example: UEUEUE;&#123;"a":"A","b":"B"&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serialization</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IDENTIFIER_STRING = <span class="string">"UEUEUE;"</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Serialization</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuilder textBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">        textBuilder.append(gson.toJson(object));</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">deserialize</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        String gsonStr = text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(gsonStr, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们想让类的职责更加单一，我们对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。拆分后的具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Serializer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IDENTIFIER_STRING = <span class="string">"UEUEUE;"</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Serializer</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">serialize</span><span class="params">(Map&lt;String, String&gt; object)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        StringBuilder textBuilder = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        textBuilder.append(IDENTIFIER_STRING);</span><br><span class="line">        textBuilder.append(gson.toJson(object));</span><br><span class="line">        <span class="keyword">return</span> textBuilder.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Deserializer</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String IDENTIFIER_STRING = <span class="string">"UEUEUE;"</span>;</span><br><span class="line">    <span class="keyword">private</span> Gson gson;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Deserializer</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = <span class="keyword">new</span> Gson();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Map&lt;String, String&gt; <span class="title">deserialize</span><span class="params">(String text)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!text.startsWith(IDENTIFIER_STRING)) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> Collections.emptyMap();</span><br><span class="line">        &#125;</span><br><span class="line">        String gsonStr = text.substring(IDENTIFIER_STRING.length());</span><br><span class="line">        <span class="keyword">return</span> gson.fromJson(gsonStr, Map<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然经过拆分之后，Serializer 类和 Deserializer 类的职责更加单一了，但也随之带来了新的问题。如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，<strong>代码的内聚性显然没有原来 Serialization 高了</strong>。而且，如果我们仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，<strong>拆分之后，代码的可维护性变差了</strong>。</p><p>实际上，不管是应用设计原则还是设计模式，<strong>最终的目的还是提高代码的可读性、可扩展性、复用性、可维护性等</strong>。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>贫血模型 vs. 充血模型</title>
      <link href="2020/09/13/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B-vs-%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/"/>
      <url>2020/09/13/%E8%B4%AB%E8%A1%80%E6%A8%A1%E5%9E%8B-vs-%E5%85%85%E8%A1%80%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>据我了解，大部分工程师都是做业务开发的，所以，今天我们讲的这个实战项目也是一个典型的业务系统开发案例。我们都知道，很多业务系统都是基于 MVC 三层架构来开发的。实际上，更确切点讲，这是一种基于<code>贫血模型</code>的 MVC 三层架构开发模式。</p><p>虽然这种开发模式已经成为标准的 Web 项目的开发模式，但它却违反了面向对象编程风格，是一种彻彻底底的面向过程的编程风格，因此而被有些人称为<code>反模式</code>（anti-pattern）。特别是<code>领域驱动设计</code>（Domain Driven Design，简称 DDD）盛行之后，这种基于贫血模型的传统的开发模式就更加被人诟病。而基于<code>充血模型</code>的 DDD 开发模式越来越被人提倡。</p><h2 id="基于贫血模型的传统开发模式"><a href="#基于贫血模型的传统开发模式" class="headerlink" title="基于贫血模型的传统开发模式"></a>基于贫血模型的传统开发模式</h2><p>MVC 三层架构中的 <strong>M 表示 Model，V 表示 View，C 表示 Controller</strong>。它将整个项目分为三层：展示层、逻辑层、数据层。MVC 三层开发架构是一个比较笼统的分层方式，落实到具体的开发层面，很多项目也并不会 100% 遵从 MVC 固定的分层方式，而是会根据具体的项目需求，做适当的调整。</p><p>比如，现在很多 Web 或者 App 项目都是前后端分离的，后端负责暴露接口给前端调用。这种情况下，我们一般就<strong>将后端项目分为 Repository 层、Service 层、Controller 层</strong>。其中，Repository 层负责数据访问，Service 层负责业务逻辑，Controller 层负责暴露接口。当然，这只是其中一种分层和命名方式。不同的项目、不同的团队，可能会对此有所调整。不过，万变不离其宗，只要是依赖数据库开发的 Web 项目，基本的分层思路都大差不差。</p><p>实际上，<strong>你可能一直都在用贫血模型做开发，只是自己不知道而已</strong>。不夸张地讲，据我了解，目前几乎所有的业务后端系统，都是基于贫血模型的。我举一个简单的例子来给你解释一下：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">////////// Controller+VO(View Object) //////////</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserService userService; <span class="comment">// 通过构造函数或者IOC框架注入</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserVo <span class="title">getUserById</span><span class="params">(Long userId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        UserBo userBo = userService.getUserById(userId);</span><br><span class="line">        UserVo userVo = [...convert userBo to userVo...];</span><br><span class="line">        <span class="keyword">return</span> userVo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserVo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// Service+BO(Business Object) //////////</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> UserRepository userRepository; <span class="comment">// 通过构造函数或者IOC框架注入</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserBo <span class="title">getUserById</span><span class="params">(Long userId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        UserEntity userEntity = userRepository.getUserById(userId);</span><br><span class="line">        UserBo userBo = [...convert userEntity to userBo...];</span><br><span class="line">        <span class="keyword">return</span> userBo;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserBo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">////////// Repository+Entity //////////</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserRepository</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserEntity <span class="title">getUserById</span><span class="params">(Long userId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserEntity</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 省略其他属性、get/set/construct方法</span></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> String cellphone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们可以发现，UserBo 是一个纯粹的数据结构，只包含数据，不包含任何业务逻辑。业务逻辑集中在 UserService 中。我们通过 UserService 来操作 UserBo。换句话说，Service 层的数据和业务逻辑，被分割为 BO 和 Service 两个类中。像 UserBo 这样，<strong>只包含数据，不包含业务逻辑的类，就叫作贫血模型（Anemic Domain Model）</strong>。同理，UserEntity、UserVo 都是基于贫血模型设计的。这种<strong>贫血模型将数据与操作分离，破坏了面向对象的封装特性，是一种典型的面向过程的编程风格</strong>。</p><h2 id="基于充血模型的-DDD-开发模式"><a href="#基于充血模型的-DDD-开发模式" class="headerlink" title="基于充血模型的 DDD 开发模式"></a>基于充血模型的 DDD 开发模式</h2><p>在贫血模型中，数据和业务逻辑被分割到不同的类中。<strong>充血模型（Rich Domain Model）正好相反，数据和对应的业务逻辑被封装到同一个类中</strong>。因此，这种充血模型满足面向对象的封装特性，是典型的面向对象编程风格。</p><p>领域驱动设计，即 DDD，主要是<strong>用来指导如何解耦业务系统，划分业务模块，定义业务领域模型及其交互</strong>。领域驱动设计这个概念并不新颖，早在 2004 年就被提出了，到现在已经有十几年的历史了。不过，它被大众熟知，还是基于另一个概念的兴起，那就是<code>微服务</code>。</p><p>实际上，基于充血模型的 DDD 开发模式实现的代码，也是按照 MVC 三层架构分层的。Controller 层还是负责暴露接口，Repository 层还是负责数据存取，Service 层负责核心业务逻辑。它<strong>跟基于贫血模型的传统开发模式的区别主要在 Service 层</strong>。</p><p>在基于贫血模型的传统开发模式中，Service 层包含 Service 类和 BO 类两部分，BO 是贫血模型，只包含数据，不包含具体的业务逻辑。业务逻辑集中在 Service 类中。在基于充血模型的 DDD 开发模式中，Service 层包含 Service 类和 Domain 类两部分。Domain 就相当于贫血模型中的 BO。不过，Domain 与 BO 的区别在于它是基于充血模型开发的，既包含数据，也包含业务逻辑。而 Service 类变得非常单薄。总结一下的话就是，<strong>基于贫血模型的传统的开发模式，重 Service 轻 BO；基于充血模型的 DDD 开发模式，轻 Service 重 Domain</strong>。</p><h2 id="贫血模型流行的原因"><a href="#贫血模型流行的原因" class="headerlink" title="贫血模型流行的原因"></a>贫血模型流行的原因</h2><p>现在几乎所有的 Web 项目，都是基于这种贫血模型的开发模式，甚至连 Java Spring 框架的官方 demo，都是按照这种开发模式来编写的。</p><ol><li><strong>大部分情况下，我们开发的系统业务可能都比较简单</strong>，简单到就是基于 SQL 的 CRUD 操作，所以，我们根本不需要动脑子精心设计充血模型，贫血模型就足以应付这种简单业务的开发工作。除此之外，因为业务比较简单，即便我们使用充血模型，那模型本身包含的业务逻辑也并不会很多，设计出来的领域模型也会比较单薄，跟贫血模型差不多，没有太大意义；</li><li><strong>充血模型的设计要比贫血模型更加有难度</strong>。因为充血模型是一种面向对象的编程风格。我们从一开始就要设计好针对数据要暴露哪些操作，定义哪些业务逻辑。而不是像贫血模型那样，我们只需要定义数据，之后有什么功能开发需求，我们就在 Service 层定义什么操作，不需要事先做太多设计；</li><li><strong>思维已固化，转型有成本</strong>。基于贫血模型的传统开发模式经历了这么多年，已经深得人心、习以为常。你随便问一个旁边的大龄同事，基本上他过往参与的所有 Web 项目应该都是基于这个开发模式的，而且也没有出过啥大问题。如果转向用充血模型、领域驱动设计，那势必有一定的学习成本、转型成本。很多人在没有遇到开发痛点的情况下，是不愿意做这件事情的；</li></ol><h2 id="什么时候使用充血模型"><a href="#什么时候使用充血模型" class="headerlink" title="什么时候使用充血模型"></a>什么时候使用充血模型</h2><p>基于贫血模型的传统的开发模式，比较适合业务比较简单的系统开发。相对应地，<strong>基于充血模型的 DDD 开发模式，更适合业务复杂的系统开发</strong>。比如，包含各种利息计算模型、还款模型等复杂业务的金融系统。</p><p>实际上，除了我们能看到的代码层面的区别之外（一个业务逻辑放到 Service 层，一个放到领域模型中），还有一个非常重要的区别，那就是<strong>两种不同的开发模式会导致不同的开发流程</strong>。</p><p>不夸张地讲，<strong>我们平时的开发，大部分都是 SQL 驱动（SQL-Driven）的开发模式</strong>。我们接到一个后端接口的开发需求的时候，就去看接口需要的数据对应到数据库中，需要哪张表或者哪几张表，然后思考如何编写 SQL 语句来获取数据。之后就是定义 Entity、BO、VO，然后模板式地往对应的 Repository、Service、Controller 类中添加代码。</p><p>业务逻辑包裹在一个大的 SQL 语句中，而 Service 层可以做的事情很少。SQL 都是针对特定的业务功能编写的，复用性差。当我要开发另一个业务功能的时候，只能重新写个满足新需求的 SQL 语句，这就可能导致<strong>各种长得差不多、区别很小的 SQL 语句满天飞</strong>。</p><p>如果我们在项目中，应用基于充血模型的 DDD 的开发模式，那对应的开发流程就完全不一样了。在这种开发模式下，<strong>我们需要事先理清楚所有的业务，定义领域模型所包含的属性和方法</strong>。领域模型相当于可复用的业务中间层。新功能需求的开发，都基于之前定义好的这些领域模型来完成。</p><p>我们知道，越复杂的系统，对代码的复用性、易维护性要求就越高，我们就越应该花更多的时间和精力在前期设计上。而基于充血模型的 DDD 开发模式，正好<strong>需要我们前期做大量的业务调研、领域模型设计，所以它更加适合这种复杂系统的开发</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Simple Strategy for Delivering Better Talks</title>
      <link href="2020/09/12/Simple-Strategy-for-Delivering-Better-Talks/"/>
      <url>2020/09/12/Simple-Strategy-for-Delivering-Better-Talks/</url>
      
        <content type="html"><![CDATA[<p>Giving a talk can open doors to new collaborations, increase your chances of funding success and make it more likely that other people will respond to your ideas. But <strong>scientific presentations are too often confusing, boring and overstuffed</strong>. Here are some suggestions, based on our experience as speakers, audience members and presentation trainers, that could make your next conference talk or seminar more enjoyable, engaging and effective.</p><h2 id="Read-the-Room"><a href="#Read-the-Room" class="headerlink" title="Read the Room"></a>Read the Room</h2><p>People who turn up to a departmental lecture have different levels of interest and expertise compared with colleagues who attend specialist conferences in your field. <strong>If you treat all audiences as if they were the same, many people will leave dissatisfied</strong>.</p><p>Prepare an ‘advance scouting’ report: <strong>before you start work on your talk, make a short appraisal of your audience</strong>. What’s the setting of your presentation and how many people are likely to attend? What do they already know about the topic? Do they hold any preconceptions about your research that you’ll need to work against? The more you know about that particular group, the better your chances of crafting a presentation that will stay with them afterwards.</p><h2 id="Be-Clear-about-Your-Main-Message"><a href="#Be-Clear-about-Your-Main-Message" class="headerlink" title="Be Clear about Your Main Message"></a>Be Clear about Your Main Message</h2><p>Getting the subject of your work across is usually easy. <strong>Homing in on one central point</strong> and making certain the audience will remember it afterwards is vastly harder.</p><p>Before working on your slides, write down the main message you want to communicate in one or two sentences. Then, be ruthless: <strong>include only slides that support your central thread</strong>.</p><a id="more"></a><h2 id="Deliver-Your-Takeaway-at-the-Start"><a href="#Deliver-Your-Takeaway-at-the-Start" class="headerlink" title="Deliver Your Takeaway at the Start"></a>Deliver Your Takeaway at the Start</h2><p>Your audience’s attention will be greatest at the beginning. <strong>Use your opening minute to state the single key message of your talk</strong>. Avoid jargon or technical details — those can come later if necessary — so that everyone can understand what you’re sharing and why it matters.</p><h2 id="Make-a-Plan"><a href="#Make-a-Plan" class="headerlink" title="Make a Plan"></a>Make a Plan</h2><p><strong>Don’t be tempted to exhume and reanimate an old PowerPoint deck</strong>. Doing so often leads to an overflowing presentation hampered by poor organization, too many extraneous slides and a confused or non-existent message.</p><h2 id="Storyboard-Your-Presentation"><a href="#Storyboard-Your-Presentation" class="headerlink" title="Storyboard Your Presentation"></a>Storyboard Your Presentation</h2><p>Film productions use storyboards — sets of illustrations arranged in sequence — to visualize the plot before filming and to help decide which actors, sets or effects are needed to bring it to life. Likewise, <strong>you could plan your talk by drawing rough sketches of possible visual aids in a notebook</strong>, or on sticky notes that you can quickly rearrange. Before you spend time producing slides, determine which visual aids are absolutely essential to telling your story.</p><h2 id="Be-Kind-to-Your-Audience"><a href="#Be-Kind-to-Your-Audience" class="headerlink" title="Be Kind to Your Audience"></a>Be Kind to Your Audience</h2><p>Many scientific conferences last an entire week, with attendees sitting through dozens of talks each day. Mental fatigue is inevitable, and <strong>presenters should do all they can to make content easy to engage with and digest</strong>.</p><h2 id="Allow-Your-Audience-to-Listen-Not-Read"><a href="#Allow-Your-Audience-to-Listen-Not-Read" class="headerlink" title="Allow Your Audience to Listen, Not Read"></a>Allow Your Audience to Listen, Not Read</h2><p>The average adult can read approximately twice as fast as most people speak. So don’t jam slides full of words and then treat them as a script for your talk: your audience will have finished reading long before you can read each slide aloud, and will become bored and impatient while waiting for you to catch up. Too often, audience members are forced to choose between listening to the speaker and reading the on-screen text. Instead, use text sparingly. <strong>Highlight only those few keywords that amplify, not repeat, what you’re saying</strong>.</p><h2 id="Use-Pictures-to-Connect-on-a-Human-Level"><a href="#Use-Pictures-to-Connect-on-a-Human-Level" class="headerlink" title="Use Pictures to Connect on a Human Level"></a>Use Pictures to Connect on a Human Level</h2><p>Photographs of your laboratory, study specimens or field sites will help your audience connect with your work. Remember, <strong>humans are better able to retain information that is seen rather than heard</strong>.</p><h2 id="Create-Visuals-for-the-Back-Row"><a href="#Create-Visuals-for-the-Back-Row" class="headerlink" title="Create Visuals for the Back Row"></a>Create Visuals for the Back Row</h2><p><strong>Avoid complicated graphs and tables</strong>. Speakers who say “I know you can’t see this but…” are implicitly expecting the audience to take their claims on faith rather than evidence. A screen full of numbers will be unreadable to most people in the room. And a slide that displays four, five or six figures (or more!) might perhaps be useful as an eye test, but will not be an effective aid to communication.</p><h2 id="Simplify-and-Enlarge"><a href="#Simplify-and-Enlarge" class="headerlink" title="Simplify and Enlarge"></a>Simplify and Enlarge</h2><p>Use one graphic element per slide. Instead of showing an entire table, highlight only those data that are central to your argument. If someone asks about the underlying details, you have a wonderful opportunity to share the accompanying paper or data set. <strong>Show full-bleed images that take up the entire screen, with no borders or white space</strong>. Make everything — figures, text, photographs — large enough to be read easily by someone sitting at the back of the room.</p><h2 id="Explain-Your-Figures"><a href="#Explain-Your-Figures" class="headerlink" title="Explain Your Figures"></a>Explain Your Figures</h2><p>If you are presenting to an audience of fellow hard-core specialists, it might make sense to skip definitions of jargon, axes and colours. In any other setting, however, <strong>take the time to explain what a figure shows</strong>. In the process, you will be forced to trim extraneous content and further hone your main message.</p><h2 id="Write-“Sentence-Headline”-Titles"><a href="#Write-“Sentence-Headline”-Titles" class="headerlink" title="Write “Sentence Headline” Titles"></a>Write “Sentence Headline” Titles</h2><p>It’s easy to become distracted and miss the speaker’s explanation of a key graphic or argument. <strong>Presenters often use a single word or short phrase as the headline, which provides only a partial explanation of their content</strong>. Instead of simply naming the topic (for instance, ‘El Niño and near-surface winds’), write titles as ‘sentence headlines’ — complete thoughts that state the main assertion of the slide (‘El Niño causes near-surface winds in winter to slow down by 20%’).</p><h2 id="Use-A-Lot-Of-Slides-If-You-Want"><a href="#Use-A-Lot-Of-Slides-If-You-Want" class="headerlink" title="Use A Lot Of Slides If You Want"></a>Use A Lot Of Slides If You Want</h2><p>Abandon the ‘one slide per minute’ rule of thumb. Go ahead, use four slides per minute — but only do so if <strong>the information content of most of them is low</strong>. Think of your talk as a meal with a set number of calories: your audience could digest the same total amount, spread across a couple of hearty courses or 20 micro-courses, but they will not be able to consume a dozen ‘extra-large pizzas’ no matter how large or small the slices.</p><p>Fundamentally, you are <strong>trying to tell an interesting story about what you did and why the findings matter</strong>. Articles in journals or other publications are usually the better place for methodological details, mathematics and the nuances of your uncertainty analysis. Use the presentation to convey a single message — and your excitement for the work — simply and clearly.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SPEAKING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多用组合少用继承</title>
      <link href="2020/09/09/%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF/"/>
      <url>2020/09/09/%E5%A4%9A%E7%94%A8%E7%BB%84%E5%90%88%E5%B0%91%E7%94%A8%E7%BB%A7%E6%89%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="为什么不推荐使用继承"><a href="#为什么不推荐使用继承" class="headerlink" title="为什么不推荐使用继承"></a>为什么不推荐使用继承</h2><p>继承是面向对象的四大特性之一，用来表示类之间的 is-a 关系，可以解决代码复用的问题。虽然继承有诸多作用，但<strong>继承层次过深、过复杂，也会影响到代码的可维护性</strong>。</p><p>假设我们要设计一个关于鸟的类。我们将“鸟类”这样一个抽象的事物概念，定义为一个抽象类 AbstractBird。所有更细分的鸟，比如麻雀、鸽子、乌鸦等，都继承这个抽象类。</p><p>我们知道，大部分鸟都会飞，那我们可不可以在 AbstractBird 抽象类中，定义一个 fly() 方法呢？答案是否定的。尽管大部分鸟都会飞，但也有特例，比如鸵鸟就不会飞。鸵鸟继承具有 fly() 方法的父类，那鸵鸟就具有“飞”这样的行为，这显然不符合我们对现实世界中事物的认识。当然，你可能会说，我在鸵鸟这个子类中重写（override）fly() 方法，让它抛出 UnSupportedMethodException 异常不就可以了吗？具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractBird</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">extends</span> <span class="title">AbstractBird</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 鸵鸟</span></span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnSupportedMethodException(<span class="string">"I can't fly.'"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>这种设计思路虽然可以解决问题，但不够优美。因为除了鸵鸟之外，不会飞的鸟还有很多，比如企鹅。对于这些不会飞的鸟来说，我们都需要重写 fly() 方法，抛出异常。这样的设计，一方面，徒增了编码的工作量；另一方面，也违背了我们之后要讲的<code>最小知识原则</code>（Least Knowledge Principle，也叫迪米特法则），暴露不该暴露的接口给外部，增加了类使用过程中被误用的概率。</p><h2 id="组合的优势"><a href="#组合的优势" class="headerlink" title="组合的优势"></a>组合的优势</h2><p>实际上，我们可以利用<code>组合（composition）</code>、<code>接口（interface）</code>、<code>委托（delegation）</code>三个技术手段，一块儿来解决刚刚继承存在的问题。</p><p>我们前面讲到接口的时候说过，<strong>接口表示具有某种行为特性</strong>。针对“会飞”这样一个行为特性，我们可以定义一个 Flyable 接口，只让会飞的鸟去实现这个接口。对于会叫、会下蛋这些行为特性，我们可以类似地定义 Tweetable 接口、EggLayable 接口。我们将这个设计思路翻译成 Java 代码的话，就是下面这个样子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Tweetable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">EggLayable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">layEgg</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">implements</span> <span class="title">Tweetable</span>, <span class="title">EggLayable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 鸵鸟</span></span><br><span class="line">    <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layEgg</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Sparrow</span> <span class="keyword">implements</span> <span class="title">Flyable</span>, <span class="title">Tweetable</span>, <span class="title">EggLayable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 麻雀</span></span><br><span class="line">    <span class="comment">//... 省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layEgg</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，我们知道，接口只声明方法，不定义实现。也就是说，每个会下蛋的鸟都要实现一遍 layEgg() 方法，并且实现逻辑是一样的，这就<strong>会导致代码重复的问题</strong>。那这个问题又该如何解决呢？</p><p>我们可以针对三个接口再定义三个实现类，它们分别是：实现了 fly() 方法的 FlyAbility 类、实现了 tweet() 方法的 TweetAbility 类、实现了 layEgg() 方法的 EggLayAbility 类。然后，<strong>通过组合和委托来消除代码重复</strong>。具体的代码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Flyable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span>；</span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> class FlyAbility implements Flyable </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">fly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 省略 Tweetable/TweetAbility/EggLayable/EggLayAbility</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ostrich</span> <span class="keyword">implements</span> <span class="title">Tweetable</span>, <span class="title">EggLayable</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// 鸵鸟</span></span><br><span class="line">    <span class="keyword">private</span> TweetAbility tweetAbility = <span class="keyword">new</span> TweetAbility(); <span class="comment">// 组合</span></span><br><span class="line">    <span class="keyword">private</span> EggLayAbility eggLayAbility = <span class="keyword">new</span> EggLayAbility(); <span class="comment">// 组合</span></span><br><span class="line">    <span class="comment">//...省略其他属性和方法...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tweet</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        tweetAbility.tweet(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layEgg</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        eggLayAbility.layEgg(); <span class="comment">// 委托</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们知道继承主要有三个作用：表示 is-a 关系，支持多态特性，代码复用。而这三个作用都可以通过其他技术手段来达成：</p><ul><li>is-a 关系，我们可以通过组合和接口的 has-a 关系来替代；</li><li>多态特性我们可以利用接口来实现；</li><li>代码复用我们可以通过组合和委托来实现；</li></ul><h2 id="组合-or-继承"><a href="#组合-or-继承" class="headerlink" title="组合 or 继承"></a>组合 or 继承</h2><p>如果类之间的继承结构稳定（不会轻易改变），继承层次比较浅（比如，最多有两层继承关系），继承关系不复杂，我们就可以大胆地使用继承。反之，<strong>系统越不稳定，继承层次很深，继承关系复杂，我们就尽量使用组合来替代继承</strong>。</p><p>除此之外，还有一些设计模式会固定使用继承或者组合。比如，<code>装饰者模式</code>（decorator pattern）、<code>策略模式</code>（strategy pattern）、<code>组合模式</code>（composite pattern）等都使用了组合关系，而<code>模板模式</code>（template pattern）使用了继承关系。</p><blockquote><p>组合并不完美，继承也不是一无是处。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于接口而非实现编程</title>
      <link href="2020/09/02/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B/"/>
      <url>2020/09/02/%E5%9F%BA%E4%BA%8E%E6%8E%A5%E5%8F%A3%E8%80%8C%E9%9D%9E%E5%AE%9E%E7%8E%B0%E7%BC%96%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="解读接口"><a href="#解读接口" class="headerlink" title="解读接口"></a>解读接口</h2><p>“基于接口而非实现编程”这条原则的英文描述是：<code>Program to an interface, not an implementation</code>。我们理解这条原则的时候，千万不要一开始就与具体的编程语言挂钩，局限在编程语言的“接口”语法中（比如 Java 中的 interface 接口语法）。这条原则最早出现于 1994 年 GoF 的《设计模式》这本书，它先于很多编程语言而诞生（比如 Java 语言），<strong>是一条比较抽象、泛化的设计思想</strong>。</p><p><strong>这条原则能非常有效地提高代码质量</strong>，之所以这么说，那是因为，应用这条原则，可以将接口和实现相分离，封装不稳定的实现，暴露稳定的接口。上游系统面向接口而非实现编程，不依赖不稳定的实现细节，这样当实现发生变化的时候，上游系统的代码基本上不需要做改动，以此来降低耦合性，提高扩展性。</p><p>在软件开发中，最大的挑战之一就是需求的不断变化，这也是考验代码设计好坏的一个标准。<strong>越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化</strong>。好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。而抽象就是提高代码扩展性、灵活性、可维护性最有效的手段之一。</p><h2 id="实战应用"><a href="#实战应用" class="headerlink" title="实战应用"></a>实战应用</h2><p>假设我们的系统中有很多涉及图片处理和存储的业务逻辑。图片经过处理之后被上传到阿里云上。为了代码复用，我们封装了图片存储相关的代码逻辑，提供了一个统一的 AliyunImageStore 类，供整个系统来使用。具体的代码实现如下所示：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunImageStore</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...创建bucket代码逻辑...</span></span><br><span class="line">        <span class="comment">//...失败会抛出异常..</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">generateAccessToken</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...根据access key/secret key等生成access token</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">uploadToAliyun</span><span class="params">(Image image, String bucketName, String accessToken)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">        <span class="comment">//...返回图片存储在阿里云上的地址(url）...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">downloadFromAliyun</span><span class="params">(String url, String accessToken)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// AliyunImageStore类的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"ai_images_bucket"</span>;</span><br><span class="line">    <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Image image = ...; <span class="comment">// 处理图片，并封装为Image对象</span></span><br><span class="line">        AliyunImageStore imageStore = <span class="keyword">new</span> AliyunImageStore(<span class="comment">/*省略参数*/</span>);</span><br><span class="line">        imageStore.createBucketIfNotExisting(BUCKET_NAME);</span><br><span class="line">        String accessToken = imageStore.generateAccessToken();</span><br><span class="line">        imageStore.uploadToAliyun(image, BUCKET_NAME, accessToken);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整个上传流程包含三个步骤：创建 bucket（你可以简单理解为存储目录）、生成 access token 访问凭证、携带 access token 上传图片到指定的 bucket 中。代码实现非常简单，类中的几个方法定义得都很干净，用起来也很清晰，乍看起来没有太大问题，完全能满足我们将图片存储在阿里云的业务需求。</p><p>不过，<strong>软件开发中唯一不变的就是变化</strong>。过了一段时间后，我们自建了私有云，不再将图片存储到阿里云了，而是将图片存储到自建私有云上。为了满足这样一个需求的变化，我们该如何修改代码呢？</p><p>新的 PrivateImageStore 类需要设计实现哪些方法，才能在尽量最小化代码修改的情况下，替换掉 AliyunImageStore 类呢？这就要求我们必须将 AliyunImageStore 类中所定义的所有 public 方法，在 PrivateImageStore 类中都逐一定义并重新实现一遍。而这样做就会存在一些问题，我总结了下面两点：</p><ul><li><strong>AliyunImageStore 类中有些函数命名暴露了实现细节</strong>，比如，uploadToAliyun() 和 downloadFromAliyun()。如果开发这个功能的同事没有接口意识、抽象思维，那这种暴露实现细节的命名方式就不足为奇了，毕竟最初我们只考虑将图片存储在阿里云上。而我们把这种包含“aliyun”字眼的方法，照抄到 PrivateImageStore 类中，显然是不合适的。如果我们在新类中重新命名 uploadToAliyun()、downloadFromAliyun() 这些方法，那就意味着，我们要修改项目中所有使用到这两个方法的代码，代码修改量可能就会很大；</li><li><strong>将图片存储到阿里云的流程，跟存储到私有云的流程，可能并不是完全一致的</strong>。比如，阿里云的图片上传和下载的过程中，需要生产 access token，而私有云不需要 access token。一方面，AliyunImageStore 中定义的 generateAccessToken() 方法不能照抄到 PrivateImageStore 中；另一方面，我们在使用 AliyunImageStore 上传、下载图片的时候，代码中用到了 generateAccessToken() 方法，如果要改为私有云的上传下载流程，这些代码都需要做调整；</li></ul><p>在编写代码的时候，要遵从“基于接口而非实现编程”的原则，具体来讲，我们需要做到下面这 3 点：</p><ul><li><strong>函数的命名不能暴露任何实现细节</strong>。比如，前面提到的 uploadToAliyun() 就不符合要求，应该改为去掉 aliyun 这样的字眼，改为更加抽象的命名方式，比如：upload()；</li><li><strong>封装具体的实现细节</strong>。比如，跟阿里云相关的特殊上传（或下载）流程不应该暴露给调用者。我们对上传（或下载）流程进行封装，对外提供一个包裹所有上传（或下载）细节的方法，给调用者使用；</li><li><strong>为实现类定义抽象的接口</strong>。具体的实现类都依赖统一的接口定义，遵从一致的上传功能协议。使用者依赖接口，而不是具体的实现类来编程；</li></ul><p>我们按照这个思路，把代码重构一下。重构后的代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ImageStore</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span></span>;</span><br><span class="line">    <span class="function">Image <span class="title">download</span><span class="params">(String url)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AliyunImageStore</span> <span class="keyword">implements</span> <span class="title">ImageStore</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略属性、构造函数等...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        createBucketIfNotExisting(bucketName);</span><br><span class="line">        String accessToken = generateAccessToken();</span><br><span class="line">        <span class="comment">//...上传图片到阿里云...</span></span><br><span class="line">        <span class="comment">//...返回图片在阿里云上的地址(url)...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">download</span><span class="params">(String url)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        String accessToken = generateAccessToken();</span><br><span class="line">        <span class="comment">//...从阿里云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...创建bucket...</span></span><br><span class="line">        <span class="comment">//...失败会抛出异常..</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">generateAccessToken</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...根据access key/secret key等生成access token</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上传下载流程改变：私有云不需要支持access token</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrivateImageStore</span> <span class="keyword">implements</span> <span class="title">ImageStore</span>  </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">upload</span><span class="params">(Image image, String bucketName)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        createBucketIfNotExisting(bucketName);</span><br><span class="line">        <span class="comment">//...上传图片到私有云...</span></span><br><span class="line">        <span class="comment">//...返回图片的url...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">download</span><span class="params">(String url)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...从私有云下载图片...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createBucketIfNotExisting</span><span class="params">(String bucketName)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...创建bucket...</span></span><br><span class="line">        <span class="comment">//...失败会抛出异常..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ImageStore的使用举例</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ImageProcessingJob</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String BUCKET_NAME = <span class="string">"ai_images_bucket"</span>;</span><br><span class="line">    <span class="comment">//...省略其他无关代码...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Image image = ...; <span class="comment">// 处理图片，并封装为Image对象</span></span><br><span class="line">        ImageStore imageStore = <span class="keyword">new</span> PrivateImageStore(...);</span><br><span class="line">        imageStore.upload(image, BUCKET_NAME);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结一下，我们在做软件开发的时候，一定要有抽象意识、封装意识、接口意识。在定义接口的时候，不要暴露任何实现细节。<strong>接口的定义只表明做什么，而不是怎么做</strong>。而且，在设计接口的时候，我们要多思考一下，这样的接口设计是否足够通用，是否能够做到在替换具体的接口实现的时候，不需要任何接口定义的改动。</p><h2 id="接口的权衡"><a href="#接口的权衡" class="headerlink" title="接口的权衡"></a>接口的权衡</h2><p>从设计初衷上来看，如果在我们的业务场景中，某个功能只有一种实现方式，未来也不可能被其他实现方式替换，那我们就没有必要为其设计接口，也没有必要基于接口编程，<strong>直接使用实现类就可以了</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抽象类 vs. 接口</title>
      <link href="2020/08/29/%E6%8A%BD%E8%B1%A1%E7%B1%BB-vs-%E6%8E%A5%E5%8F%A3/"/>
      <url>2020/08/29/%E6%8A%BD%E8%B1%A1%E7%B1%BB-vs-%E6%8E%A5%E5%8F%A3/</url>
      
        <content type="html"><![CDATA[<p>在面向对象编程中，抽象类和接口是两个经常被用到的语法概念，是面向对象四大特性，以及很多设计模式、设计思想、设计原则编程实现的基础。比如，我们可以<strong>使用抽象类来实现面向对象的继承特性和模版设计模式，使用接口来实现面向对象的抽象特性、多态特性和基于接口而非实现的设计原则</strong>。</p><p>不过，并不是所有的面向对象编程语言都支持这两个语法概念，比如，C++ 这种编程语言只支持抽象类，不支持接口；而像 Python 这样的动态编程语言，既不支持抽象类，也不支持接口。尽管有些编程语言没有提供现成的语法来支持接口和抽象类，我们仍然可以<strong>通过一些手段来模拟实现这两个语法概念</strong>。</p><h2 id="什么是抽象类和接口"><a href="#什么是抽象类和接口" class="headerlink" title="什么是抽象类和接口"></a>什么是抽象类和接口</h2><p>Java 这种编程语言，既支持抽象类，也支持接口，所以，为了让你对这两个语法概念有比较直观的认识，我们拿 Java 这种编程语言来举例讲解。</p><h3 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h3><p>下面这段代码是一个比较典型的抽象类的使用场景（<code>模板设计模式</code>）。Logger 是一个记录日志的抽象类，FileLogger 和 MessageQueueLogger 继承 Logger，分别实现两种不同的日志记录方式：记录日志到文件中和记录日志到消息队列中。FileLogger 和 MessageQueueLogger 两个子类复用了父类 Logger 中的 name、enabled、minPermittedLevel 属性和 log() 方法，但因为这两个子类写日志的方式不同，它们又各自重写了父类中的 doLog() 方法：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 抽象类</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.enabled = enabled;</span><br><span class="line">        <span class="keyword">this</span>.minPermittedLevel = minPermittedLevel;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">        <span class="keyword">if</span> (!loggable) <span class="keyword">return</span>;</span><br><span class="line">        doLog(level, message);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String message)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel, String filepath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="keyword">this</span>.fileWriter = <span class="keyword">new</span> FileWriter(filepath); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 格式化level和message, 输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 抽象类的子类: 输出日志到消息中间件(比如kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueueLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, enabled, minPermittedLevel);</span><br><span class="line">        <span class="keyword">this</span>.msgQueueClient = msgQueueClient;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Level level, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 格式化level和message, 输出到消息中间件</span></span><br><span class="line">        msgQueueClient.send(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过上面的这个例子，我们来看一下，抽象类具有哪些特性。我总结了下面三点：</p><ul><li><strong>抽象类不允许被实例化，只能被继承</strong>。也就是说，你不能 new 一个抽象类的对象出来（Logger logger = new Logger(…); 会报编译错误）；</li><li><strong>抽象类可以包含属性和方法</strong>。方法既可以包含代码实现（比如 Logger 中的 log() 方法），也可以不包含代码实现（比如 Logger 中的 doLog() 方法）。不包含代码实现的方法叫作<code>抽象方法</code>；</li><li><strong>子类继承抽象类，必须实现抽象类中的所有抽象方法</strong>。对应到例子代码中就是，所有继承 Logger 抽象类的子类，都必须重写 doLog() 方法；</li></ul><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：鉴权过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AuthenticationFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...鉴权逻辑..</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 接口实现类：限流过滤器</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RateLimitFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(RpcRequest req)</span> <span class="keyword">throws</span> RpcException </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...限流逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 过滤器使用demo</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">// filters.add(new AuthenticationFilter());</span></span><br><span class="line">    <span class="comment">// filters.add(new RateLimitFilter());</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Filter&gt; filters = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleRpcRequest</span><span class="params">(RpcRequest req)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (Filter filter : filters) </span><br><span class="line">            &#123;</span><br><span class="line">                filter.doFilter(req);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">catch</span>(RpcException e) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//...处理过滤结果...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//...省略其他处理逻辑...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码是一个比较典型的接口的使用场景。我们通过 Java 中的 interface 关键字定义了一个 Filter 接口。AuthenticationFilter 和 RateLimitFilter 是接口的两个实现类，分别实现了对 RPC 请求鉴权和限流的过滤功能。</p><p>代码非常简洁。结合代码，我们再来看一下，接口都有哪些特性。我也总结了三点：</p><ul><li>接口<strong>不能包含属性</strong>（也就是成员变量）；</li><li>接口<strong>只能声明方法</strong>，方法不能包含代码实现；</li><li>类实现接口的时候，<strong>必须实现接口中声明的所有方法</strong>；</li></ul><p>从语法特性上对比，这两者有比较大的区别，比如抽象类中可以定义属性、方法的实现，而接口中不能定义属性，方法也不能包含代码实现等等。<strong>除了语法特性，从设计的角度，两者也有比较大的区别</strong>。抽象类实际上就是类，只不过是一种特殊的类，这种类不能被实例化为对象，只能被子类继承。我们知道，继承关系是一种 is-a 的关系，那抽象类既然属于类，也表示一种 is-a 的关系。<strong>相对于抽象类的 is-a 关系来说，接口表示一种 has-a 关系</strong>，表示具有某些功能。对于接口，有一个更加形象的叫法，那就是<code>协议（contract）</code>。</p><h2 id="能解决什么编程问题"><a href="#能解决什么编程问题" class="headerlink" title="能解决什么编程问题"></a>能解决什么编程问题</h2><p>刚刚我们学习了抽象类和接口的定义和区别，现在我们再来学习一下，抽象类和接口存在的意义，让你知其然知其所以然。</p><h3 id="抽象类-1"><a href="#抽象类-1" class="headerlink" title="抽象类"></a>抽象类</h3><p>刚刚我们讲到，抽象类不能实例化，只能被继承。而前面的章节中，我们还讲到，继承能解决代码复用的问题。所以，抽象类也是为代码复用而生的。<strong>多个子类可以继承抽象类中定义的属性和方法，避免在子类中，重复编写相同的代码</strong>。</p><p>不过，既然继承本身就能达到代码复用的目的，而继承也并不要求父类一定是抽象类，那我们不使用抽象类，照样也可以实现继承和复用。从这个角度上来讲，我们貌似并不需要抽象类这种语法呀。那<strong>抽象类除了解决代码复用的问题，还有什么其他存在的意义吗？</strong></p><p>我们还是拿之前那个打印日志的例子来讲解。我们先对上面的代码做下改造。在改造之后的代码中，Logger 不再是抽象类，只是一个普通的父类，删除了 Logger 中 log()、doLog() 方法，新增了 isLoggable() 方法。FileLogger 和 MessageQueueLogger 还是继承 Logger 父类，以达到代码复用的目的。具体的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 父类: 非抽象类, 就是普通的类. 删除了log(), doLog(), 新增了isLoggable()</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> enabled;</span><br><span class="line">    <span class="keyword">private</span> Level minPermittedLevel;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Logger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isLoggable</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> loggable = enabled &amp;&amp; (minPermittedLevel.intValue() &lt;= level.intValue());</span><br><span class="line">        <span class="keyword">return</span> loggable;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类：输出日志到文件</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Writer fileWriter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">FileLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel, String filepath)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化 level 和 message，输出到日志文件</span></span><br><span class="line">        fileWriter.write(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 子类: 输出日志到消息中间件(比如 kafka)</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MessageQueueLogger</span> <span class="keyword">extends</span> <span class="title">Logger</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MessageQueueClient msgQueueClient;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MessageQueueLogger</span><span class="params">(String name, <span class="keyword">boolean</span> enabled, Level minPermittedLevel, MessageQueueClient msgQueueClient)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...构造函数不变，代码省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(Level level, String message)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLoggable()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">// 格式化 level 和 message，输出到消息中间件</span></span><br><span class="line">        msgQueueClient.send(...);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个设计思路虽然达到了代码复用的目的，但是<strong>无法使用多态特性</strong>了。像下面这样编写代码，就会出现编译错误，因为 Logger 中并没有定义 log() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Logger logger = <span class="keyword">new</span> FileLogger(<span class="string">"access-log"</span>, <span class="keyword">true</span>, Level.WARN, <span class="string">"/users/wangzheng/access.log"</span>);</span><br><span class="line">logger.log(Level.ERROR, <span class="string">"This is a test log message."</span>);</span><br></pre></td></tr></table></figure><p>你可能会说，这个问题解决起来很简单啊。我们在 Logger 父类中，定义一个空的 log() 方法，让子类重写父类的 log() 方法，实现自己的记录日志的逻辑，不就可以了吗？这个设计思路能用，但是，它显然没有之前通过抽象类的实现思路优雅。我为什么这么说呢？主要有以下几点原因：</p><ul><li>在 Logger 中定义一个空的方法，<strong>会影响代码的可读性</strong>。如果我们不熟悉 Logger 背后的设计思想，代码注释又不怎么给力，我们在阅读 Logger 代码的时候，就可能对为什么定义一个空的 log() 方法而感到疑惑，需要查看 Logger、FileLogger、MessageQueueLogger 之间的继承关系，才能弄明白其设计意图；</li><li>当创建一个新的子类继承 Logger 父类的时候，我们<strong>有可能会忘记重新实现 log() 方法</strong>。之前基于抽象类的设计思路，编译器会强制要求子类重写 log() 方法，否则会报编译错误。你可能会说，我既然要定义一个新的 Logger 子类，怎么会忘记重新实现 log() 方法呢？我们举的例子比较简单，Logger 中的方法不多，代码行数也很少。但是，如果 Logger 有几百行，有 n 多方法，除非你对 Logger 的设计非常熟悉，否则忘记重新实现 log() 方法，也不是不可能的；</li><li>Logger 可以被实例化，换句话说，我们可以 new 一个 Logger 出来，并且调用空的 log() 方法。这也增加了类被误用的风险。当然，这个问题<strong>可以通过设置私有的构造函数的方式来解决。不过，显然没有通过抽象类来的优雅</strong>；</li></ul><h3 id="接口-1"><a href="#接口-1" class="headerlink" title="接口"></a>接口</h3><p><strong>抽象类更多的是为了代码复用，而接口就更侧重于解耦</strong>。接口是对行为的一种抽象，相当于一组协议或者契约，你可以联想类比一下 API 接口。调用者只需要关注抽象的接口，不需要了解具体的实现，具体的实现代码对调用者透明。接口实现了约定和实现相分离，可以降低代码间的耦合性，提高代码的可扩展性。</p><h2 id="模拟抽象类和接口"><a href="#模拟抽象类和接口" class="headerlink" title="模拟抽象类和接口"></a>模拟抽象类和接口</h2><p>在前面举的例子中，我们使用 Java 的接口语法实现了一个 Filter 过滤器。不过，如果你熟悉的是 C++ 这种编程语言，你可能会说，<strong>C++ 只有抽象类，并没有接口</strong>，那从代码实现的角度上来说，是不是就无法实现 Filter 的设计思路了呢？</p><p>我们先来回忆一下接口的定义：<strong>接口中没有成员变量，只有方法声明，没有方法实现，实现接口的类必须实现接口中的所有方法</strong>。只要满足这样几点，从设计的角度上来说，我们就可以把它叫作接口。实际上，要满足接口的这些语法特性并不难。在下面这段 C++ 代码中，我们就用抽象类模拟了一个接口（下面这段代码实际上是<code>策略模式</code>中的一段代码）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Strategy</span> </span></span><br><span class="line"><span class="class"></span>&#123; </span><br><span class="line">    <span class="comment">// 用抽象类模拟接口</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        ~Strategy();</span><br><span class="line">        <span class="function">virtual <span class="keyword">void</span> <span class="title">algorithm</span><span class="params">()</span></span>=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span>:</span><br><span class="line">        Strategy();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>抽象类 Strategy 没有定义任何属性，并且所有的方法都声明为 virtual 类型（<strong>等同于 Java 中的 abstract 关键字</strong>），这样，所有的方法都不能有代码实现，并且所有继承这个抽象类的子类，都要实现这些方法。从语法特性上来看，这个抽象类就相当于一个接口。</p><h2 id="抽象类-or-接口"><a href="#抽象类-or-接口" class="headerlink" title="抽象类 or 接口"></a>抽象类 or 接口</h2><p>实际上，判断的标准很简单。如果我们要表示一种 <code>is-a</code> 的关系，并且是为了解决代码复用的问题，我们就用抽象类；如果我们要表示一种 <code>has-a</code> 的关系，并且是为了解决抽象而非代码复用的问题，那我们就可以使用接口。</p><p>从类的继承层次上来看，<strong>抽象类是一种自下而上的设计思路</strong>，先有子类的代码重复，然后再抽象成上层的父类（也就是抽象类）。而<strong>接口是一种自上而下的设计思路</strong>，我们在编程的时候，一般都是先设计接口，再去考虑具体的实现。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向过程风格的代码</title>
      <link href="2020/08/24/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E9%A3%8E%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
      <url>2020/08/24/%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E9%A3%8E%E6%A0%BC%E7%9A%84%E4%BB%A3%E7%A0%81/</url>
      
        <content type="html"><![CDATA[<p>下面我就通过三个典型的代码案例，给你展示一下，什么样的代码看似是面向对象风格，实际上是面向过程风格的。</p><h2 id="滥用-getter、setter-方法"><a href="#滥用-getter、setter-方法" class="headerlink" title="滥用 getter、setter 方法"></a>滥用 getter、setter 方法</h2><p>实际上，这样的做法我是非常不推荐的。它违反了面向对象编程的封装特性，相当于将面向对象编程风格退化成了面向过程编程风格。我通过下面这个例子来给你解释一下这句话：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> itemsCount;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">double</span> totalPrice;</span><br><span class="line">    <span class="keyword">private</span> List&lt;ShoppingCartItem&gt; items = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemsCount</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.itemsCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setItemsCount</span><span class="params">(<span class="keyword">int</span> itemsCount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.itemsCount = itemsCount;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTotalPrice</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setTotalPrice</span><span class="params">(<span class="keyword">double</span> totalPrice)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.totalPrice = totalPrice;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title">getItems</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.items;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addItem</span><span class="params">(ShoppingCartItem item)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        items.add(item);</span><br><span class="line">        itemsCount++;</span><br><span class="line">        totalPrice += item.getPrice();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他方法...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们先来看前两个属性，itemsCount 和 totalPrice。虽然我们将它们定义成 private 私有属性，但是<strong>提供了 public 的 getter、setter 方法，这就跟将这两个属性定义为 public 公有属性，没有什么两样了</strong>。外部可以通过 setter 方法随意地修改这两个属性的值。除此之外，任何代码都可以随意调用 setter 方法，来重新设置 itemsCount、totalPrice 属性的值，这也会导致其跟 items 属性的值不一致。</p><p>而面向对象封装的定义是：通过访问权限控制，隐藏内部数据，外部仅能通过类提供的有限的接口访问、修改内部数据。所以，<strong>暴露不应该暴露的 setter 方法，明显违反了面向对象的封装特性</strong>。数据没有访问权限控制，任何代码都可以随意修改它，代码就退化成了面向过程编程风格的了。</p><p>对于 itemsCount 和 totalPrice 这两个属性来说，定义一个 public 的 getter 方法，确实无伤大雅，毕竟 getter 方法不会修改数据。但是，对于 items 属性就不一样了，这是因为 items 属性的 getter 方法，返回的是一个 List 集合容器。<strong>外部调用者在拿到这个容器之后，是可以操作容器内部数据的</strong>，也就是说，外部代码还是能修改 items 中的数据。比如像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ShoppingCart cart = <span class="keyword">new</span> ShoppingCart();</span><br><span class="line">...</span><br><span class="line">cart.getItems().clear(); <span class="comment">// 清空购物车</span></span><br></pre></td></tr></table></figure><p>你可能会说，清空购物车这样的功能需求看起来合情合理啊，上面的代码没有什么不妥啊。你说得没错，需求是合理的，但是这样的代码写法，会导致 itemsCount、totalPrice、items 三者数据不一致。我们<strong>不应该将清空购物车的业务逻辑暴露给上层代码</strong>。正确的做法应该是，在 ShoppingCart 类中定义一个 clear() 方法，将清空购物车的业务逻辑封装在里面，透明地给调用者使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        items.clear();</span><br><span class="line">        itemsCount = <span class="number">0</span>;</span><br><span class="line">        totalPrice = <span class="number">0.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以通过 Java 提供的 <code>Collections.unmodifiableList() 方法</code>，让 getter 方法返回一个不可被修改的 UnmodifiableList 集合容器，而这个容器类<strong>重写了 List 容器中跟修改数据相关的方法</strong>，比如 add()、clear() 等方法。一旦我们调用这些修改数据的方法，代码就会抛出 UnsupportedOperationException 异常，这样就避免了容器中的数据被修改：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShoppingCart</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;ShoppingCartItem&gt; <span class="title">getItems</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.unmodifiableList(<span class="keyword">this</span>.items);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UnmodifiableList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">UnmodifiableCollection</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt; </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他代码...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ShoppingCart cart = <span class="keyword">new</span> ShoppingCart();</span><br><span class="line">List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">items.clear(); <span class="comment">// 抛出 UnsupportedOperationException 异常</span></span><br></pre></td></tr></table></figure><p>不过，这样的实现思路还是有点问题。因为当调用者通过 ShoppingCart 的 getItems() 获取到 items 之后，虽然我们没法修改容器中的数据，但我们仍然可以修改容器中每个对象（ShoppingCartItem）的数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ShoppingCart cart = <span class="keyword">new</span> ShoppingCart();</span><br><span class="line">cart.add(<span class="keyword">new</span> ShoppingCartItem(...));</span><br><span class="line">List&lt;ShoppingCartItem&gt; items = cart.getItems();</span><br><span class="line">ShoppingCartItem item = items.get(<span class="number">0</span>);</span><br><span class="line">item.setPrice(<span class="number">19.0</span>); <span class="comment">// 这里修改了item的价格属性</span></span><br></pre></td></tr></table></figure><h2 id="滥用全局变量和全局方法"><a href="#滥用全局变量和全局方法" class="headerlink" title="滥用全局变量和全局方法"></a>滥用全局变量和全局方法</h2><p>在面向对象编程中，<strong>常见的全局变量有单例类对象、静态成员变量、常量等，常见的全局方法有静态方法</strong>。<code>单例类对象</code>在全局代码中只有一份，所以，它相当于一个全局变量。<code>静态成员变量</code>归属于类上的数据，被所有的实例化对象所共享，也相当于一定程度上的全局变量。而<code>常量</code>是一种非常常见的全局变量，比如一些代码中的配置参数，一般都设置为常量，放到一个 Constants 类中。<code>静态方法</code>一般用来操作静态变量或者外部数据。你可以联想一下我们常用的各种 Utils 类，里面的方法一般都会定义成静态方法，可以在不用创建对象的情况下，直接拿来使用。<strong>静态方法将方法与数据分离，破坏了封装特性，是典型的面向过程风格</strong>。</p><h3 id="Constants-类"><a href="#Constants-类" class="headerlink" title="Constants 类"></a>Constants 类</h3><p>一种常见的 Constants 类的定义方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_ADDR_KEY = <span class="string">"mysql_addr"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_DB_NAME_KEY = <span class="string">"db_name"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_USERNAME_KEY = <span class="string">"mysql_username"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MYSQL_PASSWORD_KEY = <span class="string">"mysql_password"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_DEFAULT_ADDR = <span class="string">"192.168.7.2:7234"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REDIS_DEFAULT_MAX_TOTAL = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REDIS_DEFAULT_MAX_IDLE = <span class="number">50</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REDIS_DEFAULT_MIN_IDLE = <span class="number">20</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String REDIS_DEFAULT_KEY_PREFIX = <span class="string">"rt:"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//...省略更多的常量定义...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，我们把程序中所有用到的常量，都集中地放到这个 Constants 类中。不过，<strong>定义一个如此大而全的 Constants 类，并不是一种很好的设计思路</strong>。为什么这么说呢？原因主要有以下几点：</p><ul><li><strong>影响代码的可维护性</strong>：如果参与开发同一个项目的工程师有很多，在开发过程中，可能都要涉及修改这个类，比如往这个类里添加常量，那这个类就会变得越来越大，成百上千行都有可能，查找修改某个常量也会变得比较费时，而且还会增加提交代码冲突的概率；</li><li><strong>增加代码的编译时间</strong>：当 Constants 类中包含很多常量定义的时候，依赖这个类的代码就会很多。那每次修改 Constants 类，都会导致依赖它的类文件重新编译，因此会浪费很多不必要的编译时间。不要小看编译花费的时间，对于一个非常大的工程项目来说，编译一次项目花费的时间可能是几分钟，甚至几十分钟。而我们在开发过程中，每次运行单元测试，都会触发一次编译的过程，这个编译时间就有可能会影响到我们的开发效率；</li><li><strong>影响代码的复用性</strong>：如果我们要在另一个项目中，复用本项目开发的某个类，而这个类又依赖 Constants 类。即便这个类只依赖 Constants 类中的一小部分常量，我们仍然需要把整个 Constants 类也一并引入，也就引入了很多无关的常量到新的项目中；</li></ul><p>那如何改进 Constants 类的设计呢？我这里有两种思路可以借鉴：</p><ul><li>第一种是将 Constants 类<strong>拆解为功能更加单一的多个类</strong>，比如跟 MySQL 配置相关的常量，我们放到 MysqlConstants 类中；跟 Redis 配置相关的常量，我们放到 RedisConstants 类中；</li><li>还有一种我个人觉得更好的设计思路，那就是并不单独地设计 Constants 常量类，而是<strong>哪个类用到了某个常量，我们就把这个常量定义到这个类中</strong>。比如，RedisConfig 类用到了 Redis 配置相关的常量，那我们就直接将这些常量定义在 RedisConfig 中，这样也提高了类设计的内聚性和代码的复用性；<h3 id="Utils-类"><a href="#Utils-类" class="headerlink" title="Utils 类"></a>Utils 类</h3>实际上，Utils 类的出现是基于这样一个问题背景：如果我们有两个类 A 和 B，它们要用到一块相同的功能逻辑，为了避免代码重复，我们<strong>不应该在两个类中，将这个相同的功能逻辑，重复地实现两遍</strong>。这个时候我们该怎么办呢？</li></ul><p>既然继承不能解决这个问题，我们可以定义一个新的类，实现 URL 拼接和分割的方法。而拼接和分割两个方法，不需要共享任何数据，所以新的类不需要定义任何属性，这个时候，我们就可以<strong>把它定义为只包含静态方法的 Utils 类了</strong>。</p><p>实际上，只包含静态方法不包含任何属性的 Utils 类，<strong>是彻彻底底的面向过程的编程风格</strong>。但这并不是说，我们就要杜绝使用 Utils 类了。实际上，从刚刚讲的 Utils 类存在的目的来看，它在软件开发中还是挺有用的，能解决代码复用问题。所以，这里并不是说完全不能用 Utils 类，而是说，<strong>要尽量避免滥用，不要不加思考地随意去定义 Utils 类</strong>。</p><p>除此之外，类比 Constants 类的设计，我们设计 Utils 类的时候，最好也能细化一下，针对不同的功能，设计不同的 Utils 类，比如 FileUtils、IOUtils、StringUtils、UrlUtils 等，<strong>不要设计一个过于大而全的 Utils 类</strong>。</p><h2 id="定义数据和方法分离的类"><a href="#定义数据和方法分离的类" class="headerlink" title="定义数据和方法分离的类"></a>定义数据和方法分离的类</h2><p>传统的 MVC 结构分为 Model 层、Controller 层、View 层这三层。不过，<strong>在做前后端分离之后，三层结构在后端开发中，会稍微有些调整，被分为 Controller 层、Service 层、Repository 层</strong>。Controller 层负责暴露接口给前端调用，Service 层负责核心业务逻辑，Repository 层负责数据读写。而在每一层中，我们又会定义相应的 VO（View Object）、BO（Business Object）、Entity。一般情况下，<strong>VO、BO、Entity 中只会定义数据，不会定义方法</strong>，所有操作这些数据的业务逻辑都定义在对应的 Controller 类、Service 类、Repository 类中。这就是典型的面向过程的编程风格。</p><p>实际上，这种开发模式叫作<code>基于贫血模型的开发模式</code>，也是我们现在非常常用的一种 Web 项目的开发模式。</p><h3 id="为什么容易写出面向过程风格的代码"><a href="#为什么容易写出面向过程风格的代码" class="headerlink" title="为什么容易写出面向过程风格的代码"></a>为什么容易写出面向过程风格的代码</h3><p>你可以联想一下，在生活中，你去完成一个任务，你一般都会思考，应该先做什么、后做什么，如何一步一步地顺序执行一系列操作，最后完成整个任务。<strong>面向过程编程风格恰恰符合人的这种流程化思维方式</strong>。而<strong>面向对象编程风格正好相反，它是一种自底向上的思考方式</strong>。它不是先去按照执行流程来分解任务，而是将任务翻译成一个一个的小的模块（也就是类），设计类之间的交互，最后按照流程将类组装起来，完成整个任务。</p><h3 id="面向过程真的无用武之地了吗"><a href="#面向过程真的无用武之地了吗" class="headerlink" title="面向过程真的无用武之地了吗"></a>面向过程真的无用武之地了吗</h3><p>前面我们有讲到，如果我们开发的是微小程序，或者是一个数据处理相关的代码，以算法为主，数据为辅，那脚本式的面向过程的编程风格就更适合一些。当然，面向过程编程的用武之地还不止这些。实际上，<strong>面向过程编程是面向对象编程的基础</strong>，面向对象编程离不开基础的面向过程编程。为什么这么说？我们仔细想想，类中每个方法的实现逻辑，不就是面向过程风格的代码吗？</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象 vs. 面向过程</title>
      <link href="2020/08/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-vs-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/"/>
      <url>2020/08/23/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1-vs-%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>那是因为在过往的工作中，我发现很多人搞不清楚面向对象和面向过程的区别，总以为使用面向对象编程语言来做开发，就是在进行面向对象编程了。而实际上，他们只是在用面向对象编程语言，编写面向过程风格的代码而已，并没有发挥面向对象编程的优势。这就相当于手握一把屠龙刀，却只是把它当作一把普通的刀剑来用，相当可惜。</p><h2 id="面向过程编程与面向过程编程语言"><a href="#面向过程编程与面向过程编程语言" class="headerlink" title="面向过程编程与面向过程编程语言"></a>面向过程编程与面向过程编程语言</h2><ul><li>面向过程编程也是一种编程范式或编程风格。它<strong>以过程（可以理解为方法、函数、操作）作为组织代码的基本单元，以数据（可以理解为成员变量、属性）与方法相分离为最主要的特点</strong>。面向过程风格是一种流程化的编程风格，通过拼接一组顺序执行的方法来操作数据完成一项功能；</li><li>面向过程编程语言首先是一种编程语言。它最大的特点是<strong>不支持类和对象两个语法概念</strong>，不支持丰富的面向对象编程特性（比如继承、多态、封装），仅支持面向过程编程；</li></ul><p>定义不是很严格，也比较抽象，所以，我再用一个例子进一步解释一下。假设我们有一个记录了用户信息的文本文件 users.txt，每行文本的格式是 name&amp;age&amp;gender（比如，小王 &amp;28&amp; 男）。我们希望写一个程序，从 users.txt 文件中逐行读取用户信息，然后格式化成 name\tage\tgender（其中，\t 是分隔符）这种文本格式，并且按照 age 从小到大排序之后，重新写入到另一个文本文件 formatted_users.txt 中。</p><p>首先，我们先来看，用面向过程这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 C 语言这种面向过程的编程语言来编写的：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">char</span> name[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">char</span> gender[<span class="number">16</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">struct User <span class="title">parse_to_user</span><span class="params">(<span class="keyword">char</span>* text)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将 text(“小王&amp;28&amp;男”) 解析成结构体 struct User</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">format_to_text</span><span class="params">(struct User user)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 将结构体 struct User 格式化成文本 ("小王\t28\t男"）</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort_users_by_age</span><span class="params">(struct User users[])</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 按照年龄从小到大排序 users</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">format_user_file</span><span class="params">(<span class="keyword">char</span>* origin_file_path, <span class="keyword">char</span>* new_file_path)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// open files...</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">users</span>[1024];</span> <span class="comment">// 假设最大 1024 个用户</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) </span><br><span class="line">    &#123;   <span class="comment">// read until the file is empty</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">User</span> <span class="title">user</span> = <span class="title">parse_to_user</span>(<span class="title">line</span>);</span></span><br><span class="line">        users[count++] = user;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    sort_users_by_age(users);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; ++i) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span>* formatted_user_text = format_to_text(users[i]);</span><br><span class="line">        <span class="comment">// write to new file...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// close files...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">char</span>** args, <span class="keyword">int</span> argv)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  format_user_file(<span class="string">"/home/zheng/user.txt"</span>, <span class="string">"/home/zheng/formatted_users.txt"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们再来看，用面向对象这种编程风格写出来的代码是什么样子的。注意，下面的代码是用 Java 这种面向对象的编程语言来编写的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span></span><br><span class="line"><span class="class"> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> String gender;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">User</span><span class="params">(String name, <span class="keyword">int</span> age, String gender)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.gender = gender;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> User <span class="title">praseFrom</span><span class="params">(String userInfoText)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将text(“小王&amp;28&amp;男”)解析成类User</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">formatToText</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 将类User格式化成文本（"小王\t28\t男"）</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserFileFormatter</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">format</span><span class="params">(String userFile, String formattedUserFile)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// Open files...</span></span><br><span class="line">        List users = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) </span><br><span class="line">        &#123; </span><br><span class="line">            <span class="comment">// read until file is empty </span></span><br><span class="line">            <span class="comment">// read from file into userText...</span></span><br><span class="line">            User user = User.parseFrom(userText);</span><br><span class="line">            users.add(user);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// sort users by age...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; users.size(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            String formattedUserText = user.formatToText();</span><br><span class="line">            <span class="comment">// write to new file...</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// close files...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainApplication</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        UserFileFormatter userFileFormatter = <span class="keyword">new</span> UserFileFormatter();</span><br><span class="line">        userFileFormatter.format(<span class="string">"/home/zheng/users.txt"</span>, <span class="string">"/home/zheng/formatted_users.txt"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码中，我们可以看出，面向过程和面向对象最基本的区别就是，<strong>代码的组织方式不同</strong>。面向过程风格的代码被组织成了一组方法集合及其数据结构（struct User），方法和数据结构的定义是分开的。面向对象风格的代码被组织成一组类，方法和数据结构被绑定一起，定义在类中。</p><h2 id="面向对象的优势"><a href="#面向对象的优势" class="headerlink" title="面向对象的优势"></a>面向对象的优势</h2><p>接下来，我们再来看一下，为什么面向对象编程晚于面向过程编程出现，却能取而代之，成为现在主流的编程范式？</p><h3 id="OOP-更加能够应对大规模复杂程序的开发"><a href="#OOP-更加能够应对大规模复杂程序的开发" class="headerlink" title="OOP 更加能够应对大规模复杂程序的开发"></a>OOP 更加能够应对大规模复杂程序的开发</h3><p>但对于大规模复杂程序的开发来说，整个程序的处理流程错综复杂，并非只有一条主线。如果把整个程序的处理流程画出来的话，会是一个网状结构。如果我们再用面向过程编程这种流程化、线性的思维方式，去翻译这个网状结构，去思考如何把程序拆解为一组顺序执行的方法，就会比较吃力。这个时候，面向对象的编程风格的优势就比较明显了。</p><p><strong>面向对象编程是以类为思考对象</strong>。在进行面向对象编程的时候，我们并不是一上来就去思考，如何将复杂的流程拆解为一个一个方法，而是采用曲线救国的策略，先去思考如何给业务建模，如何将需求翻译为类，如何给类之间建立交互关系，而完成这些工作完全不需要考虑错综复杂的处理流程。当我们有了类的设计之后，然后再像搭积木一样，按照处理流程，将类组装起来形成整个程序。这种开发模式、思考问题的方式，能让我们在应对复杂程序开发的时候，思路更加清晰。</p><p>你可能会说，像 C 语言这种面向过程的编程语言，我们也可以按照功能的不同，把函数和数据结构放到不同的文件里，以达到给函数和数据结构分类的目的，照样可以实现代码的模块化。你说得没错。只不过<strong>面向对象编程本身提供了类的概念，强制你做这件事情，而面向过程编程并不强求</strong>。这也算是面向对象编程相对于面向过程编程的一个微创新吧。</p><h3 id="OOP-风格的代码更易复用、易扩展、易维护"><a href="#OOP-风格的代码更易复用、易扩展、易维护" class="headerlink" title="OOP 风格的代码更易复用、易扩展、易维护"></a>OOP 风格的代码更易复用、易扩展、易维护</h3><p>我们来看下继承特性。<strong>继承特性是面向对象编程相比于面向过程编程所特有的两个特性之一（另一个是多态）</strong>。如果两个类有一些相同的属性和方法，我们就可以将这些相同的代码，抽取到父类中，让两个子类继承父类。这样两个子类也就可以重用父类中的代码，<strong>避免了代码重复写多遍，提高了代码的复用性</strong>。</p><p>我们来看下多态特性。基于这个特性，我们在需要修改一个功能实现的时候，可以通过实现一个新的子类的方式，在子类中重写原来的功能逻辑，用子类替换父类。在实际的代码运行过程中，调用子类新的功能逻辑，而不是在原有代码上做修改。这就<strong>遵从了“对修改关闭、对扩展开放”的设计原则，提高代码的扩展性</strong>。除此之外，利用多态特性，不同的类对象可以传递给相同的方法，执行不同的代码逻辑，提高了代码的复用性。</p><h3 id="OOP-语言更加人性化、更加高级、更加智能"><a href="#OOP-语言更加人性化、更加高级、更加智能" class="headerlink" title="OOP 语言更加人性化、更加高级、更加智能"></a>OOP 语言更加人性化、更加高级、更加智能</h3><p>跟二进制指令、汇编语言、面向过程编程语言相比，面向对象编程语言的编程套路、思考问题的方式，是完全不一样的。前三者是一种计算机思维方式，而面向对象是一种人类的思维方式。我们在用前面三种语言编程的时候，我们是在思考，如何设计一组指令，告诉机器去执行这组指令，操作某些数据，帮我们完成某个任务。而在进行面向对象编程时候，我们是在思考，如何给业务建模，如何将真实的世界映射为类或者对象，这让我们更加能聚焦到业务本身，而不是思考如何跟机器打交道。可以这么说，<strong>越高级的编程语言离机器越“远”，离我们人类越“近”，越“智能”</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>封装、抽象、继承与多态</title>
      <link href="2020/08/20/%E5%B0%81%E8%A3%85%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/"/>
      <url>2020/08/20/%E5%B0%81%E8%A3%85%E3%80%81%E6%8A%BD%E8%B1%A1%E3%80%81%E7%BB%A7%E6%89%BF%E4%B8%8E%E5%A4%9A%E6%80%81/</url>
      
        <content type="html"><![CDATA[<h2 id="封装（Encapsulation）"><a href="#封装（Encapsulation）" class="headerlink" title="封装（Encapsulation）"></a>封装（Encapsulation）</h2><p>首先，我们来看封装特性。<strong>封装也叫作信息隐藏或者数据访问保护。</strong>类通过暴露有限的访问接口，授权外部仅能通过类提供的方式（或者叫函数）来访问内部信息或者数据。这句话怎么理解呢？我们通过一个简单的例子来解释一下。</p><p>下面这段代码是金融系统中一个简化版的虚拟钱包的代码实现：</p><a id="more"></a><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Wallet</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> createTime;</span><br><span class="line">    <span class="keyword">private</span> BigDecimal balance;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> balanceLastModifiedTime;</span><br><span class="line">    <span class="comment">//...省略其他属性...</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Wallet</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.id = IdGenerator.getInstance().generate();</span><br><span class="line">       <span class="keyword">this</span>.createTime = System.currentTimeMillis();</span><br><span class="line">       <span class="keyword">this</span>.balance = BigDecimal.ZERO;</span><br><span class="line">       <span class="keyword">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意：下面对get方法做了代码折叠，是为了减少代码所占文章的篇幅</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getId</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.id; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCreateTime</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.createTime; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> BigDecimal <span class="title">getBalance</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balance; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getBalanceLastModifiedTime</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.balanceLastModifiedTime;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">increaseBalance</span><span class="params">(BigDecimal increasedAmount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (increasedAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidAmountException(<span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.balance.add(increasedAmount);</span><br><span class="line">        <span class="keyword">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">decreaseBalance</span><span class="params">(BigDecimal decreasedAmount)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (decreasedAmount.compareTo(BigDecimal.ZERO) &lt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidAmountException(<span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (decreasedAmount.compareTo(<span class="keyword">this</span>.balance) &gt; <span class="number">0</span>) </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InsufficientAmountException(<span class="string">"..."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.balance.subtract(decreasedAmount);</span><br><span class="line">        <span class="keyword">this</span>.balanceLastModifiedTime = System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从代码中，我们可以发现，<strong>Wallet 类主要有四个属性（也可以叫作成员变量）</strong>，也就是我们前面定义中提到的信息或者数据。其中，id 表示钱包的唯一编号，createTime 表示钱包创建的时间，balance 表示钱包中的余额，balanceLastModifiedTime 表示上次钱包余额变更的时间。</p><p>我们参照封装特性，对钱包的这四个属性的访问方式进行了限制。<strong>调用者只允许通过下面这六个方法来访问或者修改钱包里的数据:</strong></p><ul><li>String getId()</li><li>long getCreateTime()</li><li>BigDecimal getBalance()</li><li>long getBalanceLastModifiedTime()</li><li>void increaseBalance(BigDecimal increasedAmount)</li><li>void decreaseBalance(BigDecimal decreasedAmount)</li></ul><p>之所以这样设计，是因为从业务的角度来说，<strong>id、createTime 在创建钱包的时候就确定好了，之后不应该再被改动</strong>，所以，我们并没有在 Wallet 类中，暴露 id、createTime 这两个属性的任何修改方法，比如 set 方法。而且，这两个属性的初始化设置，对于 Wallet 类的调用者来说，也应该是透明的，所以，我们在 Wallet 类的构造函数内部将其初始化设置好，而不是通过构造函数的参数来外部赋值。</p><p>对于钱包余额 balance 这个属性，从业务的角度来说，<strong>只能增或者减，不会被重新设置</strong>。所以，我们在 Wallet 类中，只暴露了 increaseBalance() 和 decreaseBalance() 方法，并没有暴露 set 方法。对于 balanceLastModifiedTime 这个属性，它完全是跟 balance 这个属性的修改操作绑定在一起的。<strong>只有在 balance 修改的时候，这个属性才会被修改</strong>。所以，我们把 balanceLastModifiedTime 这个属性的修改操作完全封装在了 increaseBalance() 和 decreaseBalance() 两个方法中，不对外暴露任何修改这个属性的方法和业务细节。这样也可以保证 balance 和 balanceLastModifiedTime 两个数据的一致性。</p><p>对于封装这个特性，我们需要编程语言本身提供一定的语法机制来支持。这个语法机制就是<code>访问权限控制</code>。例子中的 private、public 等关键字就是 Java 语言中的访问权限控制语法。private 关键字修饰的属性只能类本身访问，可以保护其不被类之外的代码直接访问。如果 Java 语言没有提供访问权限控制语法，所有的属性默认都是 public 的，那任意外部代码都可以通过类似 wallet.id=123; 这样的方式直接访问、修改属性，也就没办法达到隐藏信息和保护数据的目的了，也就无法支持封装特性了。</p><h3 id="解决的编程问题"><a href="#解决的编程问题" class="headerlink" title="解决的编程问题"></a>解决的编程问题</h3><p>如果我们对类中属性的访问不做限制，那任何代码都可以访问、修改类中的属性，虽然这样看起来更加灵活，但从另一方面来说，过度灵活也意味着不可控，属性可以随意被以各种奇葩的方式修改，而且修改逻辑可能散落在代码中的各个角落，<strong>势必影响代码的可读性、可维护性</strong>。比如某个同事在不了解业务逻辑的情况下，在某段代码中“偷偷地”重设了 wallet 中的 balanceLastModifiedTime 属性，这就会导致 balance 和 balanceLastModifiedTime 两个数据不一致。</p><p>除此之外，<strong>类仅仅通过有限的方法暴露必要的操作，也能提高类的易用性</strong>。如果我们把类属性都暴露给类的调用者，调用者想要正确地操作这些属性，就势必要对业务细节有足够的了解。而这对于调用者来说也是一种负担。相反，如果我们将属性封装起来，暴露少许的几个必要的方法给调用者使用，调用者就不需要了解太多背后的业务细节，用错的概率就减少很多。这就好比，如果一个冰箱有很多按钮，你就要研究很长时间，还不一定能操作正确。相反，如果只有几个必要的按钮，比如开、停、调节温度，你一眼就能知道该如何来操作，而且操作出错的概率也会降低很多。</p><h2 id="抽象（Abstraction）"><a href="#抽象（Abstraction）" class="headerlink" title="抽象（Abstraction）"></a>抽象（Abstraction）</h2><p>讲完了封装特性，我们再来看抽象特性。 封装主要讲的是如何隐藏信息、保护数据，而<strong>抽象讲的是如何隐藏方法的具体实现</strong>，让调用者只需要关心方法提供了哪些功能，并不需要知道这些功能是如何实现的。</p><p>在面向对象编程中，我们常借助编程语言提供的<code>接口类</code>（比如 Java 中的 interface 关键字语法）或者<code>抽象类</code>（比如 Java 中的 abstract 关键字语法）这两种语法机制，来实现抽象这一特性。</p><p>对于抽象这个特性，我举一个例子来进一步解释一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IPictureStorage</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">savePicture</span><span class="params">(Picture picture)</span></span>;</span><br><span class="line">    <span class="function">Image <span class="title">getPicture</span><span class="params">(String pictureId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">deletePicture</span><span class="params">(String pictureId)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PictureStorage</span> <span class="keyword">implements</span> <span class="title">IPictureStorage</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="comment">//...省略其他属性...</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">savePicture</span><span class="params">(Picture picture)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Image <span class="title">getPicture</span><span class="params">(String pictureId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deletePicture</span><span class="params">(String pictureId)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">modifyMetaInfo</span><span class="params">(String pictureId, PictureMetaInfo metaInfo)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="comment">//... </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在上面的这段代码中，我们利用 Java 中的 interface 接口语法来实现抽象特性。调用者在使用图片存储功能的时候，只需要了解 IPictureStorage 这个接口类暴露了哪些方法就可以了，不需要去查看 PictureStorage 类里的具体实现逻辑。</p><p>实际上，抽象这个特性是非常容易实现的，<strong>并不需要非得依靠接口类或者抽象类这些特殊语法机制来支持</strong>。换句话说，并不是说一定要为实现类（PictureStorage）抽象出接口类（IPictureStorage），才叫作抽象。即便不编写 IPictureStorage 接口类，单纯的 PictureStorage 类本身就满足抽象特性。</p><p>抽象这个概念是一个非常通用的设计思想，并不单单用在面向对象编程中，也可以用来指导架构设计等。而且这个特性也并不需要编程语言提供特殊的语法机制来支持，<strong>只需要提供“函数”这一非常基础的语法机制，就可以实现抽象特性</strong>。所以，它没有很强的“特异性”，有时候并不被看作面向对象编程的特性之一。</p><h3 id="解决的编程问题-1"><a href="#解决的编程问题-1" class="headerlink" title="解决的编程问题"></a>解决的编程问题</h3><p>实际上，如果上升一个思考层面的话，<strong>抽象及其前面讲到的封装都是人类处理复杂性的有效手段</strong>。在面对复杂系统的时候，人脑能承受的信息复杂程度是有限的，所以我们必须忽略掉一些非关键性的实现细节。而抽象作为一种只关注功能点不关注实现的设计思路，正好帮我们的大脑过滤掉许多非必要的信息。</p><p>换一个角度来考虑，我们在定义（或者叫命名）类的方法的时候，也要有抽象思维，<strong>不要在方法定义中，暴露太多的实现细节</strong>，以保证在某个时间点需要改变方法的实现逻辑的时候，不用去修改其定义。举个简单例子，比如 getAliyunPictureUrl() 就不是一个具有抽象思维的命名，因为某一天如果我们不再把图片存储在阿里云上，而是存储在私有云上，那这个命名也要随之被修改。相反，如果我们定义一个比较抽象的函数，比如叫作 getPictureUrl()，那即便内部存储方式修改了，我们也不需要修改命名。</p><h2 id="继承（Inheritance）"><a href="#继承（Inheritance）" class="headerlink" title="继承（Inheritance）"></a>继承（Inheritance）</h2><p>学习完了封装和抽象两个特性，我们再来看继承特性。如果你熟悉的是类似 Java、C++ 这样的面向对象的编程语言，那你对继承这一特性，应该不陌生了。<strong>继承是用来表示类之间的 is-a 关系</strong>，比如猫是一种哺乳动物。从继承关系上来讲，继承可以分为两种模式，<code>单继承</code>和<code>多继承</code>。单继承表示一个子类只继承一个父类，多继承表示一个子类可以继承多个父类，比如猫既是哺乳动物，又是爬行动物。</p><p>为了实现继承这个特性，<strong>编程语言需要提供特殊的语法机制来支持</strong>，比如 Java 使用 extends 关键字来实现继承，C++ 使用冒号（class B : public A），Python 使用 paraentheses()，Ruby 使用 &lt;。不过，有些编程语言只支持单继承，不支持多重继承，比如 Java、PHP、C#、Ruby 等，而有些编程语言既支持单重继承，也支持多重继承，比如 C++、Python、Perl 等。</p><h3 id="解决的编程问题-2"><a href="#解决的编程问题-2" class="headerlink" title="解决的编程问题"></a>解决的编程问题</h3><p><strong>继承最大的一个好处就是代码复用</strong>。假如两个类有一些相同的属性和方法，我们就可以将这些相同的部分，抽取到父类中，让两个子类继承父类。这样，两个子类就可以重用父类中的代码，避免代码重复写多遍。不过，这一点也并不是继承所独有的，我们也可以通过其他方式来解决这个代码复用的问题，比如利用组合关系而不是继承关系。</p><p>继承的概念很好理解，也很容易使用。不过，过度使用继承，继承层次过深过复杂，就会导致代码可读性、可维护性变差。为了了解一个类的功能，我们不仅需要查看这个类的代码，还需要按照继承关系一层一层地往上查看“父类、父类的父类……”的代码。还有，<strong>子类和父类高度耦合，修改父类的代码，会直接影响到子类</strong>。</p><h2 id="多态（Polymorphism）"><a href="#多态（Polymorphism）" class="headerlink" title="多态（Polymorphism）"></a>多态（Polymorphism）</h2><p>学习完了封装、抽象、继承之后，我们再来看面向对象编程的最后一个特性，多态。<strong>多态是指，子类可以替换父类，在实际的代码运行过程中，调用子类的方法实现</strong>。对于多态这种特性，纯文字解释不好理解，我们还是看一个具体的例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DynamicArray</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> capacity = DEFAULT_CAPACITY;</span><br><span class="line">    <span class="keyword">protected</span> Integer[] elements = <span class="keyword">new</span> Integer[DEFAULT_CAPACITY];</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.size; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> elements[index];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略n多方法...</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer e)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        elements[size++] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...如果数组满了就扩容...代码省略...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SortedDynamicArray</span> <span class="keyword">extends</span> <span class="title">DynamicArray</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(Integer e)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ensureCapacity();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = size-<span class="number">1</span>; i&gt;=<span class="number">0</span>; --i) </span><br><span class="line">        &#123;   <span class="comment">// 保证数组中的数据有序</span></span><br><span class="line">            <span class="keyword">if</span> (elements[i] &gt; e) </span><br><span class="line">            &#123;</span><br><span class="line">                elements[i+<span class="number">1</span>] = elements[i];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        elements[i+<span class="number">1</span>] = e;</span><br><span class="line">        ++size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Example</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(DynamicArray dynamicArray)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        dynamicArray.add(<span class="number">5</span>);</span><br><span class="line">        dynamicArray.add(<span class="number">1</span>);</span><br><span class="line">        dynamicArray.add(<span class="number">3</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; dynamicArray.size(); ++i) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(dynamicArray.get(i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        DynamicArray dynamicArray = <span class="keyword">new</span> SortedDynamicArray();</span><br><span class="line">        test(dynamicArray); <span class="comment">// 打印结果：1、3、5</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>多态这种特性也需要编程语言提供特殊的语法机制来实现。在上面的例子中，我们用到了三个语法机制来实现多态：</p><ul><li>第一个语法机制是编程语言要<strong>支持父类对象可以引用子类对象</strong>，也就是可以将 SortedDynamicArray 传递给 DynamicArray；</li><li>第二个语法机制是编程语言要<strong>支持继承</strong>，也就是 SortedDynamicArray 继承了 DynamicArray，才能将 SortedDynamicArray 传递给 DynamicArray；</li><li>第三个语法机制是编程语言要<strong>支持子类可以重写（override）父类中的方法</strong>，也就是 SortedDynamicArray 重写了 DynamicArray 中的 add() 方法；</li></ul><p>对于多态特性的实现方式，<strong>除了利用“继承加方法重写”这种实现方式之外，我们还有其他两种比较常见的的实现方式</strong>，一个是利用<code>接口类</code>语法，另一个是利用 <code>duck-typing</code> 语法。不过，并不是每种编程语言都支持接口类或者 duck-typing 这两种语法机制，比如 C++ 就不支持接口类语法，而 duck-typing 只有一些动态语言才支持，比如 Python、JavaScript 等。</p><p>接下来，我们先来看如何利用接口类来实现多态特性。我们还是先来看一段代码:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Iterator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">next</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">remove</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Array</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] data;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他方法...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinkedList</span> <span class="keyword">implements</span> <span class="title">Iterator</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LinkedListNode head;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">next</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">remove</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    </span>&#123; </span><br><span class="line">        ... </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...省略其他方法... </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Demo</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">(Iterator iterator)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (iterator.hasNext()) </span><br><span class="line">        &#123;</span><br><span class="line">            System.out.println(iterator.next());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Iterator arrayIterator = <span class="keyword">new</span> Array();</span><br><span class="line">        print(arrayIterator);</span><br><span class="line">        </span><br><span class="line">        Iterator linkedListIterator = <span class="keyword">new</span> LinkedList();</span><br><span class="line">        print(linkedListIterator);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这段代码中，Iterator 是一个接口类，定义了一个可以遍历集合数据的迭代器。Array 和 LinkedList 都实现了接口类 Iterator。我们通过传递不同类型的实现类（Array、LinkedList）到 print(Iterator iterator) 函数中，<strong>支持动态的调用不同的 next()、hasNext() 实现</strong>。</p><p>刚刚讲的是用接口类来实现多态特性。现在，我们再来看下，如何用 duck-typing 来实现多态特性。我们还是先来看一段代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logger</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(“I write a log into file.”)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DB</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">record</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(“I insert data into db. ”)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">(recorder)</span>:</span></span><br><span class="line">    recorder.record()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span><span class="params">()</span>:</span></span><br><span class="line">    logger = Logger()</span><br><span class="line">    db = DB()</span><br><span class="line">    test(logger)</span><br><span class="line">    test(db)</span><br></pre></td></tr></table></figure><p>也就是说，<strong>只要两个类具有相同的方法，就可以实现多态</strong>，并不要求两个类之间有任何关系，这就是所谓的 duck-typing，是一些动态语言所特有的语法机制。而像 Java 这样的静态语言，<strong>通过继承实现多态特性，必须要求两个类之间有继承关系；通过接口实现多态特性，类必须实现对应的接口</strong>。</p><h3 id="解决的编程问题-3"><a href="#解决的编程问题-3" class="headerlink" title="解决的编程问题"></a>解决的编程问题</h3><p><strong>多态特性能提高代码的可扩展性和复用性</strong>。在第二个例子中，我们利用多态的特性，仅用一个 print() 函数就可以实现遍历打印不同类型（Array、LinkedList）集合的数据。当再增加一种要遍历打印的类型的时候，比如 HashMap，我们只需让 HashMap 实现 Iterator 接口，重新实现自己的 hasNext()、next() 等方法就可以了，完全不需要改动 print() 函数的代码。所以说，多态提高了代码的可扩展性。</p><p>除此之外，多态也是很多设计模式、设计原则、编程技巧的代码实现基础，比如策略模式、基于接口而非实现编程、依赖倒置原则、里式替换原则、利用多态去掉冗长的 if-else 语句等等。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="2020/08/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
      <url>2020/08/20/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h2 id="OOP-与-OOPL"><a href="#OOP-与-OOPL" class="headerlink" title="OOP 与 OOPL"></a>OOP 与 OOPL</h2><p><code>面向对象编程</code>的英文缩写是 OOP，全称是 Object Oriented Programming。对应地，<code>面向对象编程语言</code>的英文缩写是 OOPL，全称是 Object Oriented Programming Language。</p><p>面向对象编程中有两个非常重要、非常基础的概念，那就是<code>类</code>（class）和<code>对象</code>（object）。这两个概念最早出现在 1960 年，在 Simula 这种编程语言中第一次使用。而面向对象编程这个概念第一次被使用是在 Smalltalk 这种编程语言中。Smalltalk 被认为是第一个真正意义上的面向对象编程语言。</p><p>一般来讲， 面向对象编程都是通过使用面向对象编程语言来进行的，但是，不用面向对象编程语言，我们照样可以进行面向对象编程。反过来讲，即便我们使用面向对象编程语言，写出来的代码也不一定是面向对象编程风格的，也有可能是面向过程编程风格的：</p><ul><li>面向对象编程是一种编程范式或编程风格。它以类或对象作为组织代码的基本单元，并将<strong>封装、抽象、继承、多态</strong>四个特性，作为代码设计和实现的基石；</li><li>面向对象编程语言是支持类或对象的语法机制，并有现成的语法机制，能方便地实现面向对象编程四大特性（封装、抽象、继承、多态）的编程语言；</li></ul><p>实际上，我个人觉得，只要某种编程语言支持类或对象的语法概念，并且以此作为组织代码的基本单元，那就可以被粗略地认为它就是面向对象编程语言了。至于是否有现成的语法机制，完全地支持了面向对象编程的四大特性、是否对四大特性有所取舍和优化，可以不作为判定的标准。</p><a id="more"></a><h2 id="OOA-与-OOD"><a href="#OOA-与-OOD" class="headerlink" title="OOA 与 OOD"></a>OOA 与 OOD</h2><p><code>面向对象分析</code>英文缩写是 OOA，全称是 Object Oriented Analysis；<code>面向对象设计</code>的英文缩写是 OOD，全称是 Object Oriented Design。OOA、OOD、OOP 三个连在一起就是面向对象分析、设计、编程（实现），正好是面向对象软件开发要经历的三个阶段。</p><p>之所以在前面加“面向对象”这几个字，是因为我们是围绕着对象或类来做需求分析和设计的。分析和设计两个阶段最终的产出是类的设计，包括程序被拆解为哪些类，每个类有哪些属性方法，类与类之间如何交互等等。它们比其他的分析和设计更加具体、更加落地、更加贴近编码，更能够顺利地过渡到面向对象编程环节。这也是面向对象分析和设计，与其他分析和设计最大的不同点。</p><h2 id="UML"><a href="#UML" class="headerlink" title="UML"></a>UML</h2><p>讲到面向对象分析、设计、编程，我们就不得不提到另外一个概念，那就是 <code>UML</code>（Unified Model Language），统一建模语言。很多讲解面向对象或设计模式的书籍，常用它来画图表达面向对象或设计模式的设计思路。</p><p>所以，从我的开发经验来说，UML 在互联网公司的项目开发中，用处可能并不大。为了文档化软件设计或者方便讨论软件设计，大部分情况下，我们随手画个不那么规范的草图，能够达意，方便沟通就够了，而完全按照 UML 规范来将草图标准化，所付出的代价是不值得的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式学习导读</title>
      <link href="2020/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB/"/>
      <url>2020/08/20/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%AD%A6%E4%B9%A0%E5%AF%BC%E8%AF%BB/</url>
      
        <content type="html"><![CDATA[<blockquote><p>如果说数据结构和算法是教你如何写出高效代码，那设计模式讲的是如何写出可扩展、可读、可维护的高质量代码。</p></blockquote><p>优秀的开源项目、框架、中间件，代码量、类的个数都会比较多，类结构、类之间的关系极其复杂，常常调用来调用去。所以，为了保证代码的扩展性、灵活性、可维护性等，代码中会使用到很多设计模式、设计原则或者设计思想。如果你不懂这些设计模式、原则、思想，在看代码的时候，你可能就会琢磨不透作者的设计思路，对于一些很明显的设计思路，你可能要花费很多时间才能参悟。相反，<strong>如果你对设计模式、原则、思想非常了解，一眼就能参透作者的设计思路、设计初衷</strong>，很快就可以把脑容量释放出来，重点思考其他问题，代码读起来就会变得轻松了。</p><h2 id="代码质量评价标准"><a href="#代码质量评价标准" class="headerlink" title="代码质量评价标准"></a>代码质量评价标准</h2><p>仔细看前面罗列的所有代码质量评价标准，你会发现，有些词语过于笼统、抽象，比较偏向对于整体的描述，比如优雅、好、坏、整洁、清晰等；有些过于细节、偏重方法论，比如模块化、高内聚低耦合、文档详尽、分层清晰等；有些可能并不仅仅局限于编码，跟架构设计等也有关系，比如可伸缩性、可用性、稳定性等。要写出满足这些评价标准的高质量代码，我们<strong>需要掌握一些更加细化、更加能落地的编程方法论</strong>，包括面向对象设计思想、设计原则、设计模式、编程规范、重构技巧等。而所有这些编程方法论的最终目的都是为了编写出高质量的代码。</p><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/04.png" alt></p><a id="more"></a><h3 id="可维护性（Maintainability）"><a href="#可维护性（Maintainability）" class="headerlink" title="可维护性（Maintainability）"></a>可维护性（Maintainability）</h3><p>所以，从正面去分析一个代码是否易维护稍微有点难度。不过，我们可以从侧面上给出一个比较主观但又比较准确的感受。如果 bug 容易修复，修改、添加功能能够轻松完成，那我们就可以主观地认为代码对我们来说易维护。相反，如果修改一个 bug，修改、添加一个功能，需要花费很长的时间，那我们就可以主观地认为代码对我们来说不易维护。</p><h3 id="可读性（Readability）"><a href="#可读性（Readability）" class="headerlink" title="可读性（Readability）"></a>可读性（Readability）</h3><blockquote><p>Any fool can write code that a computer can understand. Good programmers write code that humans can understand. – Martin Fowler</p></blockquote><p>实际上，code review 是一个很好的测验代码可读性的手段。如果你的同事可以轻松地读懂你写的代码，那说明你的代码可读性很好；如果同事在读你的代码时，有很多疑问，那就说明你的代码可读性有待提高了。</p><h3 id="可扩展性（Extensibility）"><a href="#可扩展性（Extensibility）" class="headerlink" title="可扩展性（Extensibility）"></a>可扩展性（Extensibility）</h3><p>代码的可扩展性表示，我们在不修改或少量修改原有代码的情况下，通过扩展的方式添加新的功能代码。说直白点就是，代码预留了一些功能扩展点，你可以把新功能代码，直接插到扩展点上，而不需要因为要添加一个功能而大动干戈，改动大量的原始代码。</p><h3 id="灵活性（Flexibility）"><a href="#灵活性（Flexibility）" class="headerlink" title="灵活性（Flexibility）"></a>灵活性（Flexibility）</h3><p>从刚刚举的场景来看，如果一段代码易扩展、易复用或者易用，我们都可以称这段代码写得比较灵活。所以，灵活这个词的含义非常宽泛，很多场景下都可以使用。</p><h3 id="简洁性（Simplicity）"><a href="#简洁性（Simplicity）" class="headerlink" title="简洁性（Simplicity）"></a>简洁性（Simplicity）</h3><p>不过，很多编程经验不足的程序员会觉得，简单的代码没有技术含量，喜欢在项目中引入一些复杂的设计模式，觉得这样才能体现自己的技术水平。实际上，思从深而行从简，真正的高手能云淡风轻地用最简单的方法解决最复杂的问题。这也是一个编程老手跟编程新手的本质区别之一。</p><h3 id="可复用性（Reusability）"><a href="#可复用性（Reusability）" class="headerlink" title="可复用性（Reusability）"></a>可复用性（Reusability）</h3><p>比如，当讲到面向对象特性的时候，我们会讲到继承、多态存在的目的之一，就是为了提高代码的可复用性；当讲到设计原则的时候，我们会讲到单一职责原则也跟代码的可复用性相关；当讲到重构技巧的时候，我们会讲到解耦、高内聚、模块化等都能提高代码的可复用性。可见，可复用性也是一个非常重要的代码评价标准，是很多设计原则、思想、模式等所要达到的最终效果。</p><h3 id="可测试性（Testability）"><a href="#可测试性（Testability）" class="headerlink" title="可测试性（Testability）"></a>可测试性（Testability）</h3><p>相对于前面六个评价标准，代码的可测试性是一个相对较少被提及，但又非常重要的代码质量评价标准。代码可测试性的好坏，能从侧面上非常准确地反应代码质量的好坏。代码的可测试性差，比较难写单元测试，那基本上就能说明代码设计得有问题。关于代码的可测试性，我们在重构那一部分，会花两节课的时间来详细讲解。现在，你暂时只需要知道，代码的可测试性非常重要就可以了。</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>现在，主流的编程范式或者是编程风格有三种，它们分别是<strong>面向过程、面向对象和函数式编程</strong>。面向对象这种编程风格又是这其中最主流的。现在比较流行的编程语言大部分都是面向对象编程语言。大部分项目也都是基于面向对象编程风格开发的。面向对象编程因为其具有丰富的特性（封装、抽象、继承、多态），可以实现很多复杂的设计思路，是很多设计原则、设计模式编码实现的基础。</p><p>几大知识点：</p><ul><li>面向对象的四大特性：封装、抽象、继承、多态；</li><li>面向对象编程与面向过程编程的区别和联系；</li><li>面向对象分析、面向对象设计、面向对象编程；</li><li>接口和抽象类的区别以及各自的应用场景；</li><li>基于接口而非实现编程的设计思想；</li><li>多用组合少用继承的设计思想；</li><li>面向过程的贫血模型和面向对象的充血模型；</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/05.png" alt></p><h2 id="设计原则"><a href="#设计原则" class="headerlink" title="设计原则"></a>设计原则</h2><p>设计原则是指导我们代码设计的一些经验总结。设计原则这块儿的知识有一个非常大的特点，那就是这些原则听起来都比较抽象，定义描述都比较模糊，不同的人会有不同的解读。所以，如果单纯地去记忆定义，对于编程、设计能力的提高，意义并不大。对于每一种设计原则，我们<strong>需要掌握它的设计初衷，能解决哪些编程问题，有哪些应用场景</strong>。只有这样，我们才能在项目中灵活恰当地应用这些原则。</p><p>几个常用的设计原则：</p><ul><li>SRP 单一职责原则；</li><li>OCP 开闭原则；</li><li>LSP 里式替换原则；</li><li>ISP 接口隔离原则；</li><li>DIP 依赖倒置原则；</li><li>DRY 原则、KISS 原则、YAGNI 原则、LoD 法则；</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/06.png" alt></p><h2 id="规范与重构"><a href="#规范与重构" class="headerlink" title="规范与重构"></a>规范与重构</h2><p><strong>编程规范主要解决的是代码的可读性问题</strong>。编程规范相对于设计原则、设计模式，更加具体、更加偏重代码细节。即便你可能对设计原则不熟悉、对设计模式不了解，但你最起码要掌握基本的编码规范，比如，如何给变量、类、函数命名，如何写代码注释，函数不宜过长、参数不能过多等等。</p><p>在软件开发中，只要软件在不停地迭代，就没有一劳永逸的设计。随着需求的变化，代码的不停堆砌，原有的设计必定会存在这样那样的问题。针对这些问题，我们就需要进行代码重构。重构是软件开发中非常重要的一个环节。<strong>持续重构是保持代码质量不下降的有效手段</strong>，能有效避免代码腐化到无可救药的地步。</p><p>几个知识点：</p><ul><li>重构的目的（why）、对象（what）、时机（when）、方法（how）；</li><li>保证重构不出错的技术手段：单元测试和代码的可测试性；</li><li>大重构（大规模高层次）；</li><li>小重构（小规模低层次）；</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/GoF/07.png" alt></p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><p>设计模式是针对软件开发中经常遇到的一些设计问题，总结出来的一套解决方案或者设计思路。<strong>大部分设计模式要解决的都是代码的可扩展性问题</strong>。设计模式相对于设计原则来说，没有那么抽象，而且大部分都不难理解，代码实现也并不复杂。这一块的学习难点是了解它们都能解决哪些问题，掌握典型的应用场景，并且懂得不过度应用。</p><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><p>创建型设计模式主要解决“对象的创建”问题：</p><ul><li>常用：单例模式、工厂模式、建造者模式；</li><li>不常用：原型模式；</li></ul><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><p>结构型设计模式主要解决“类或对象的组合或组装”问题：</p><ul><li>常用：代理模式、桥接模式、装饰者模式、适配器模式；</li><li>不常用：门面模式、组合模式、享元模式；</li></ul><h3 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h3><p>行为型设计模式主要解决“类或对象之间的交互”问题：</p><ul><li>常用：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式；</li><li>不常用：访问者模式、备忘录模式、命令模式、解释器模式、中介模式；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> GoF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>缓存</title>
      <link href="2020/01/26/%E7%BC%93%E5%AD%98/"/>
      <url>2020/01/26/%E7%BC%93%E5%AD%98/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/07/00.jpg" alt></p><p><code>Cache</code> 可以<strong>提高页面加载速度</strong>，并可以减少服务器和数据库的负载。在这个模型中，<code>Dispatcher</code> 先查看请求之前是否被响应过，如果有则将之前的结果直接返回，来省去真正的处理。</p><p>数据库因分区（<code>Partition</code>）读写而获益，但是热数据会导致<strong>读写不均，造成瓶颈</strong>。如果在数据库前加个缓存，就会减轻不均匀的负载和突发流量对数据库的影响。</p><a id="more"></a><h2 id="客户端缓存"><a href="#客户端缓存" class="headerlink" title="客户端缓存"></a>客户端缓存</h2><p>缓存可以位于客户端（OS or Browser）、服务端或不同的缓存层。</p><h2 id="CDN-缓存"><a href="#CDN-缓存" class="headerlink" title="CDN 缓存"></a>CDN 缓存</h2><p><code>CDN</code> 也被视为一种缓存。</p><h2 id="Web-服务器缓存"><a href="#Web-服务器缓存" class="headerlink" title="Web 服务器缓存"></a>Web 服务器缓存</h2><p><code>Reverse Proxy</code> 和缓存（例如，Varnish）可以<strong>直接提供静态和动态内容</strong>。Web 服务器同样也可以缓存请求，返回响应结果而不必联络应用服务器。</p><h2 id="数据库缓存"><a href="#数据库缓存" class="headerlink" title="数据库缓存"></a>数据库缓存</h2><p>数据库的默认配置中通常包含缓存级别，针对一般用例进行了优化。<strong>针对特定的使用模式调整配置</strong>，可以进一步提高性能。</p><h2 id="应用缓存"><a href="#应用缓存" class="headerlink" title="应用缓存"></a>应用缓存</h2><p>基于内存的缓存，例如：Memcached 和 Redis，是<strong>应用程序和数据存储之间的一种 key-value 存储</strong>。由于数据保存在 RAM 中，它比存储在磁盘上的传统数据库要快多了。RAM 比磁盘限制更多，所以缓存无效算法（例如，LRU）可以将热数据留存在 RAM 中。</p><p>Redis 有下列附加功能：</p><ul><li>持久化选项；</li><li>内置数据结构，例如：有序集合和列表；</li></ul><p>有多个缓存级别，分为两大类：<strong>数据库查询</strong>和<strong>对象</strong>：</p><ul><li>行级别；</li><li>查询级别；</li><li>完整的可序列化对象；</li><li>完全渲染的 HTML；</li></ul><p>一般来说，应该<strong>尽量避免基于文件的缓存</strong>，因为会使得复制和自动缩放变得更困难。</p><h2 id="数据库查询级别的缓存"><a href="#数据库查询级别的缓存" class="headerlink" title="数据库查询级别的缓存"></a>数据库查询级别的缓存</h2><p>无论何时查询数据库，<strong>将查询语句的 hash 值和查询结果存储到缓存中</strong>，这种方法会遇到以下问题：</p><ul><li>很难删除复杂查询语句的缓存结果；</li><li>如果一条数据（例如，表中的一项）改变了，则需要<strong>删除所有可能包含已更改项的缓存结果</strong>；</li></ul><h2 id="对象级别的缓存"><a href="#对象级别的缓存" class="headerlink" title="对象级别的缓存"></a>对象级别的缓存</h2><p>将数据视为对象，像编写应用代码一样：让应用程序将数据从数据库中，组合到类实例或数据结构中：</p><ul><li>如果对象的基础数据已更改，那么从缓存中删除这个对象；</li><li>允许异步处理：使用最新的缓存组装对象；</li></ul><p>建议缓存的内容：</p><ul><li>活动流；</li><li>用户会话；</li><li>用户图数据；</li><li>完全渲染的 Web 界面；</li></ul><h2 id="何时更新缓存"><a href="#何时更新缓存" class="headerlink" title="何时更新缓存"></a>何时更新缓存</h2><p>由于你只能在缓存中存储<code>有限</code>的数据，所以你需要选择一个适用于用例的缓存更新策略。</p><h3 id="缓存模式（Cache-Aside）"><a href="#缓存模式（Cache-Aside）" class="headerlink" title="缓存模式（Cache-Aside）"></a>缓存模式（Cache-Aside）</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/07/01.jpg" alt></p><p>应用从外存读写，缓存<strong>不和外存直接交互</strong>，应用执行以下操作：</p><ol><li>在缓存中查找记录，如果所需数据不在缓存中；</li><li>从数据库中加载所需内容；</li><li>将查找到的结果存储到缓存中；</li><li>返回所需内容；</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_user</span><span class="params">(self, user_id)</span>:</span></span><br><span class="line">    user = cache.get(<span class="string">"user.&#123;0&#125;"</span>, user_id)</span><br><span class="line">    <span class="keyword">if</span> user <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        user = db.query(<span class="string">"SELECT * FROM users WHERE user_id=&#123;0&#125;"</span>, user_id)</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">            key = <span class="string">"user.&#123;0&#125;"</span>.format(user_id)</span><br><span class="line">            cache.set(key, json.dumps(user))</span><br><span class="line">    <span class="keyword">return</span> user</span><br></pre></td></tr></table></figure><blockquote><p>Memcached 通常用这种方式使用。</p></blockquote><p>添加到缓存中的数据读取速度很快，缓存模式也称为延迟加载，<strong>只缓存所请求的数据</strong>。这避免了没有被请求的数据占满缓存空间。</p><h4 id="缺陷：缓存模式"><a href="#缺陷：缓存模式" class="headerlink" title="缺陷：缓存模式"></a>缺陷：缓存模式</h4><ul><li>请求的数据如果不在缓存中，需要经过 3 个步骤来获取数据，会导致明显的延迟；</li><li>如果数据库中的数据更新，会导致缓存中的数据过时。需要设置 TTL（<strong>T</strong>ime <strong>T</strong>o <strong>L</strong>ive）强制更新缓存，或者采用直写模式缓解这种情况；</li><li>当一个节点出现故障时，它会被一个新节点替代，这增加了延迟时间；</li></ul><h3 id="直写模式（Write-Through）"><a href="#直写模式（Write-Through）" class="headerlink" title="直写模式（Write-Through）"></a>直写模式（Write-Through）</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/07/02.jpg" alt></p><p>应用使用缓存作为主要的存储单元，将数据读写到缓存中，而<strong>缓存负责从数据库读写数据</strong>：</p><ul><li>应用向缓存中添加／更新数据；</li><li>缓存同步写入并存储数据；</li><li>返回所需内容；</li></ul><p>应用代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_user(<span class="number">1234</span>, &#123;<span class="string">"foo"</span>:<span class="string">"bar"</span>&#125;)</span><br></pre></td></tr></table></figure><p>缓存代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">set_user</span><span class="params">(user_id, values)</span>:</span></span><br><span class="line">    user = db.query(<span class="string">"UPDATE users WHERE id=&#123;0&#125;"</span>, user_id, values)</span><br><span class="line">    caches.set(user_id, user)</span><br></pre></td></tr></table></figure><p>由于写入操作，直写模式整体是一种很慢的操作，但读取刚写入的数据很快。相比读取数据，<strong>用户通常比较能接受更新数据时速度较慢</strong>；缓存中的数据不会过时。</p><h4 id="缺陷：直写模式"><a href="#缺陷：直写模式" class="headerlink" title="缺陷：直写模式"></a>缺陷：直写模式</h4><ul><li>由于故障或缩放创建的新节点不会有缓存，<strong>直到数据库更新</strong>。缓存模式 + 直写模式可以缓解这个问题；</li><li>写入的大多数数据可能永远不会被读取，使用 TTL 可以最小化这类问题；</li></ul><h3 id="回写模式（Write-Behind）"><a href="#回写模式（Write-Behind）" class="headerlink" title="回写模式（Write-Behind）"></a>回写模式（Write-Behind）</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/07/03.jpg" alt></p><p>在回写模式中，应用执行以下操作：</p><ul><li>在缓存中增加或更新数据；</li><li><strong>异步写入数据</strong>，提高写入性能；</li></ul><h4 id="缺陷：回写模式"><a href="#缺陷：回写模式" class="headerlink" title="缺陷：回写模式"></a>缺陷：回写模式</h4><ul><li>数据可能在其内容成功存储之前丢失；</li><li>实现回写模式比缓存模式、直写模式更复杂；</li></ul><h3 id="刷新模式（Refresh-Ahead）"><a href="#刷新模式（Refresh-Ahead）" class="headerlink" title="刷新模式（Refresh-Ahead）"></a>刷新模式（Refresh-Ahead）</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/07/04.jpg" alt></p><p>你可以将缓存配置成，在<strong>到期之前自动刷新</strong>最近访问过的内容。</p><h4 id="缺陷：刷新模式"><a href="#缺陷：刷新模式" class="headerlink" title="缺陷：刷新模式"></a>缺陷：刷新模式</h4><ul><li>不能准确预测未来需要用到的数据，可能会导致性能不如不使用刷新；</li></ul><h2 id="缺陷：缓存"><a href="#缺陷：缓存" class="headerlink" title="缺陷：缓存"></a>缺陷：缓存</h2><ul><li>需要维护缓存和真实数据源之间的一致性，通过 <code>cache replacement policies</code>;</li><li><code>cache invalidation</code> 以及何时更新缓存是一个复杂的问题；</li><li>需要改变应用程序，比如增加 Redis 或 Memcached;</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步与通讯</title>
      <link href="2020/01/17/%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%80%9A%E8%AE%AF/"/>
      <url>2020/01/17/%E5%BC%82%E6%AD%A5%E4%B8%8E%E9%80%9A%E8%AE%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="异步（Asynchronism）"><a href="#异步（Asynchronism）" class="headerlink" title="异步（Asynchronism）"></a>异步（Asynchronism）</h2><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/08/00.jpg" alt></p><p>异步工作流有助于减少那些原本顺序执行的请求时间。它们可以通过<strong>提前进行一些耗时的工作</strong>来帮助减少请求时间，比如定期汇总数据。</p><h3 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h3><p>消息队列接收、保留和传递消息。如果<strong>按顺序执行操作太慢</strong>的话，你可以使用有以下工作流的消息队列：</p><ul><li>应用程序将作业发布到队列，然后通知用户作业状态；</li><li>一个 worker 从队列中取出该作业，对其进行处理，然后显示该作业完成；</li></ul><p>不去阻塞用户操作，作业在后台处理。在此期间，客户端可能会进行一些处理使得<strong>任务看上去像是已经完成了</strong>。例如，如果要发送一条推文，推文可能会马上出现在你的时间线上，但是可能需要一些时间才能将你的推文推送到你的所有关注者那里去。</p><p><code>Redis</code> 是一个令人满意的简单的消息代理，但是消息有可能会丢失。</p><p><code>RabbitMQ</code> 很受欢迎但是要求你适应 AMQP 协议，并且管理你自己的节点。</p><p><code>Amazon SQS</code> 是被托管的，但可能具有高延迟，并且消息可能会被传送两次。</p><a id="more"></a><h3 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h3><p>任务队列接收任务及其相关数据，运行它们，然后传递其结果。它们可以支持调度，并可用于<strong>在后台运行计算密集型作业</strong>。</p><p><code>Celery</code> 支持调度，主要是用 Python 开发的。</p><h3 id="背压"><a href="#背压" class="headerlink" title="背压"></a>背压</h3><p>如果队列开始明显增长，那么<strong>队列大小可能会超过内存大小</strong>，导致 Cache 未命中，磁盘读取，甚至性能更慢。<code>Back Pressure</code> 可以通过限制队列大小来帮助我们，从而为队列中的作业保持高吞吐率和良好的响应时间。</p><p>一旦队列填满，客户端将得到服务器忙或者 HTTP 503 状态码，以便稍后重试。客户端可以在稍后时间重试该请求，也许是<code>指数退避</code>。</p><h3 id="缺陷：异步"><a href="#缺陷：异步" class="headerlink" title="缺陷：异步"></a>缺陷：异步</h3><p>简单的计算和实时工作流等场景可能更适用于同步操作，因为<strong>引入队列可能会增加延迟和复杂性</strong>。</p><h2 id="通讯"><a href="#通讯" class="headerlink" title="通讯"></a>通讯</h2><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/08/01.jpg" alt></p><h3 id="超文本传输协议（HTTP）"><a href="#超文本传输协议（HTTP）" class="headerlink" title="超文本传输协议（HTTP）"></a>超文本传输协议（HTTP）</h3><p><code>HTTP</code> 是一种在客户端和服务器之间编码和传输数据的方法。它是一个 request/response 协议：客户端和服务端针对相关内容和完成状态信息的请求和响应。</p><p><strong>HTTP 是独立的</strong>，允许请求和响应流经许多执行负载均衡、缓存、加密和压缩的中间路由器和服务器。</p><p>一个基本的 HTTP 请求由一个动词（<code>method</code>）和一个资源（<code>endpoint</code>）组成。 以下是常见的 HTTP 动词：</p><table><thead><tr><th align="left">动词</th><th align="left">描述</th><th align="left">幂等</th><th align="left">安全性</th><th align="left">可缓存</th></tr></thead><tbody><tr><td align="left">GET</td><td align="left">读取资源</td><td align="left">Yes</td><td align="left">Yes</td><td align="left">Yes</td></tr><tr><td align="left">POST</td><td align="left">创建资源或触发处理数据的进程</td><td align="left">No</td><td align="left">No</td><td align="left">Yes，如果 response 包含刷新信息</td></tr><tr><td align="left">PUT</td><td align="left">创建或替换资源</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr><tr><td align="left">PATCH</td><td align="left">部分更新资源</td><td align="left">No</td><td align="left">No</td><td align="left">Yes，如果 response 包含刷新信息</td></tr><tr><td align="left">DELETE</td><td align="left">删除资源</td><td align="left">Yes</td><td align="left">No</td><td align="left">No</td></tr></tbody></table><p>HTTP 是依赖于较低级协议（例如，TCP 和 UDP）的<strong>应用层协议</strong>。</p><h3 id="传输控制协议（TCP）"><a href="#传输控制协议（TCP）" class="headerlink" title="传输控制协议（TCP）"></a>传输控制协议（TCP）</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/08/02.jpg" alt></p><p><code>TCP</code> 是 IP（<strong>I</strong>nternet <strong>P</strong>rotocol）网络上的面向连接协议。 <strong>使用握手</strong>建立和断开连接。 发送的所有数据包保证以原始顺序到达目的地，用以下措施保证数据包不被损坏：</p><ul><li>每个数据包的序列号和校验码（checksum）；</li><li><strong>确认包</strong>和自动重传；</li></ul><p>如果发送者没有收到正确的响应，它将重新发送数据包。如果多次超时，连接就会断开。TCP 实行<code>流量控制</code>和<code>拥塞控制</code>。这些确保措施会导致延迟，而且通常导致<strong>传输效率比 UDP 低</strong>。</p><p>为了确保高吞吐量，Web 服务器需要保持大量的 TCP 连接，这样会<strong>导致高的内存使用</strong>。在 Web 服务器线程间，拥有大量的开放连接开销巨大，<strong>连接池</strong>可以帮助在适当的情况下切换到 UDP。</p><p>TCP 对于<strong>高可靠性、低实时性</strong>的应用很有用。例如，Web 服务器、数据库信息、SMTP、FTP 和 SSH。</p><p>以下情况使用 TCP 代替 UDP：</p><ul><li>你需要数据完好无损；</li><li>你想对网络吞吐量<strong>自动进行最佳评估</strong>；</li></ul><h3 id="用户数据报协议（UDP）"><a href="#用户数据报协议（UDP）" class="headerlink" title="用户数据报协议（UDP）"></a>用户数据报协议（UDP）</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/08/03.jpg" alt></p><p><code>UDP</code> 是无连接的。<strong>数据报（Datagram）类似于数据包（Packet）</strong>，只在数据报级别有保证。数据报可能会无序地到达，也有可能会丢失，UDP 不支持拥塞控制。虽然不如 TCP 那样有保证，但 <strong>UDP 通常效率更高</strong>。</p><p>UDP 可以通过广播将数据报发送至子网内的所有设备。这<strong>对 DHCP 很有用</strong>，因为子网内的设备还没有分配 IP 地址，而 <strong>IP 地址对于 TCP 是必须的</strong>。</p><p>UDP 可靠性更低，但适合网络电话、视频聊天、流媒体和实时多人游戏上。</p><p>以下情况使用 UDP 代替 TCP：</p><ul><li>相对于数据丢失，更糟的是数据延迟；</li><li>你想实现自己的<strong>错误校正方法</strong>；</li></ul><h3 id="远程过程调用（RPC）"><a href="#远程过程调用（RPC）" class="headerlink" title="远程过程调用（RPC）"></a>远程过程调用（RPC）</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/08/04.jpg" alt></p><p>在 <code>RPC</code> 中，客户端会调用另一个地址空间（通常是远程服务器）里的过程。<strong>客户端和服务器交互的具体过程被抽象</strong>，看起来就像是本地调用。</p><p>远程调用相对于本地调用，一般<strong>较慢而且可靠性较差</strong>，很容易区分两者。热门的 RPC 框架包括：<code>Protobuf</code>、<code>Thrift</code> 和 <code>Avro</code>。</p><p>RPC 是一个 request/response 协议（客户端的响应与之相反）：</p><ul><li>客户端程序：调用客户端 stub 过程，就像调用本地过程一样，<strong>参数会被压入栈中</strong>；</li><li>客户端 stub 程序：将过程的 id 和参数打包进请求信息中；</li><li>客户端通信模块：将信息从客户端发送至服务端；</li><li>服务端通信模块：将接收的 packets 传给服务端 stub 程序；</li><li>服务端 stub 程序：<strong>将结果解包</strong>，依据过程 id 调用服务端程序，并将参数传传入；</li></ul><p>RPC 调用示例：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="builtin-name">GET</span> /someOperation?<span class="attribute">data</span>=anID</span><br><span class="line"></span><br><span class="line">POST /anotherOperation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"data"</span>: <span class="string">"anID"</span>;</span><br><span class="line">    <span class="string">"anotherdata"</span>: <span class="string">"anotherValue"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>RPC <strong>专注于暴露行为</strong>。RPC 通常用于<strong>处理内部通讯的性能问题</strong>，这样你可以手动处理本地调用，以更好地适应你的需求。</p><p>当以下情况时选择本地库（AKA SDK）：</p><ul><li>你知道你的目标平台；</li><li>你想控制如何访问你的“逻辑”；</li><li>你想对发生在你的库中的错误进行控制；</li><li><strong>性能和终端用户体验</strong>是你最关心的事；</li></ul><h4 id="缺陷：RPC"><a href="#缺陷：RPC" class="headerlink" title="缺陷：RPC"></a>缺陷：RPC</h4><ul><li>RPC 客户端与服务实现捆绑得很紧密；</li><li>一个新的 API 必须在每一个操作或者用例中定义；</li><li>RPC <strong>很难调试</strong>；</li><li>你可能没办法很方便地去修改现有的技术。例如，如果你希望在 <code>Squid</code> 这样的缓存服务器上，确保 RPC 被正确缓存的话，可能需要一些额外的努力；</li></ul><h3 id="表述性状态转移（REST）"><a href="#表述性状态转移（REST）" class="headerlink" title="表述性状态转移（REST）"></a>表述性状态转移（REST）</h3><p>REST 是一种强制的 client/server 架构设计模型，client 基于 server 管理的一系列资源进行操作。server 提供修改或获取资源的接口，<strong>所有的通信必须是无状态和可缓存的</strong>。</p><p>RESTful 接口有四条特征：</p><ul><li>标志资源（URI）：无论什么操作，都使用同一个 URI；</li><li>带有表述的改变（Verbs）：使用动词、header 和 body；</li><li>可自我描述的错误信息（Status Code）：使用状态码，不要重复造轮子；</li><li>HATEOAS（<strong>H</strong>ypertext <strong>A</strong>s <strong>T</strong>he <strong>E</strong>ngine <strong>O</strong>f <strong>A</strong>pplication <strong>S</strong>tate）：你的 server 应该能够通过浏览器访问；</li></ul><p>REST 调用示例：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET <span class="regexp">/someResources/</span>anID</span><br><span class="line"></span><br><span class="line">PUT <span class="regexp">/someResources/</span>anID</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"anotherData"</span>: <span class="string">"anotherValue"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>REST <strong>专注于暴露数据</strong>。它减少了 client/server 的耦合程度，经常用于设计公共 HTTP APIs。REST 使用更普遍和规范化的方法，借助 URIs 暴露资源，使用 header 来表述，并通过动词进行操作。由于无状态的特性，REST <strong>易于水平扩展和分区</strong>。</p><h4 id="缺陷：REST"><a href="#缺陷：REST" class="headerlink" title="缺陷：REST"></a>缺陷：REST</h4><ul><li>由于 REST 将重点放在暴露数据，所以当资源不是自然组织或结构复杂的时候，它可能无法很好地适应。例如，返回过去 1 小时中与特定事件集匹配的更新记录，这种操作就很难表示为路径。使用 REST，可能会<strong>结合 URI 路径、查询参数和可能的请求体</strong>；</li><li>REST 一般依赖几个动词，但有时候它们<strong>无法满足你的需求</strong>。例如，将过期的文档移动到归档文件夹里去，这样的操作可能没法简单地几个动词来表述；</li><li>为了渲染单个页面，获取被嵌套在层级结构中的复杂资源，需要 client、server 之间多次往返通信。例如，获取博客内容及关联评论，对于使用不确定网络环境的移动应用来说，这些<strong>多次往返通信是非常麻烦的</strong>；</li><li>随着时间的推移，更多的字段可能会被添加到 API 响应中，旧的客户端将会接收到所有新的数据字段。即使是那些它们不需要的字段，结果会<strong>增加负载大小，并引起更大延迟</strong>；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库</title>
      <link href="2020/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
      <url>2020/01/15/%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h2 id="关系型数据库管理系统（RDBMS）"><a href="#关系型数据库管理系统（RDBMS）" class="headerlink" title="关系型数据库管理系统（RDBMS）"></a>关系型数据库管理系统（RDBMS）</h2><p>像 SQL 这样的关系型数据库，是一系列以<code>表</code>的形式组织的<strong>数据项集合</strong>。</p><p><code>ACID</code> 用来描述关系型数据库事务的特性：</p><ul><li>原子性（<strong>A</strong>tomicity）：每个事务内部所有操作要么全部完成，要么全部不完成；</li><li>一致性（<strong>C</strong>onsistency）：任何事务都使数据库从一个有效的状态转换到另一个有效状态；</li><li>隔离性（<strong>I</strong>solation）：并发执行事务的结果与顺序执行事务的结果相同；</li><li>持久性（<strong>D</strong>urability）：事务提交后，对系统的影响是永久的。</li></ul><p>关系型数据库的扩展，包括许多技术：<code>主-从复制</code>、<code>主-主复制</code>、<code>联邦</code>、<code>分片</code>、<code>非规范化</code>和 <code>SQL 调优</code>。</p><h3 id="主-从复制"><a href="#主-从复制" class="headerlink" title="主-从复制"></a>主-从复制</h3><p>主库同时负责读取和写入操作，并复制写入到一个或多个从库中，<strong>从库只负责读操作</strong>。树状形式的从库再将写入复制到更多的从库中去。如果<strong>主库离线，系统可以以只读模式运行</strong>，直到某个从库被提升为主库或有新的主库出现：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/06/00.jpg" alt></p><a id="more"></a><h4 id="缺陷：主-从复制"><a href="#缺陷：主-从复制" class="headerlink" title="缺陷：主-从复制"></a>缺陷：主-从复制</h4><ul><li>将从库提升为主库需要额外的逻辑</li></ul><h3 id="主-主复制"><a href="#主-主复制" class="headerlink" title="主-主复制"></a>主-主复制</h3><p>两个主库都负责读操作和写操作，<strong>写入操作时互相协调</strong>。如果其中一个主库挂机，系统可以继续读取和写入：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/06/01.jpg" alt></p><h4 id="缺陷：主-主复制"><a href="#缺陷：主-主复制" class="headerlink" title="缺陷：主-主复制"></a>缺陷：主-主复制</h4><ul><li>需要添加负载均衡器或者在应用逻辑中做改动，来确定写入哪一个数据库；</li><li>多数主-主系统要么不能保证一致性（违反 ACID），要么因为同步产生了写入延迟；</li><li>随着更多写入节点的加入和延迟的提高，如何解决冲突显得越发重要。</li></ul><h3 id="缺陷：复制"><a href="#缺陷：复制" class="headerlink" title="缺陷：复制"></a>缺陷：复制</h3><ul><li>如果主库在将新写入的数据复制到其他节点前挂掉，则有数据丢失的可能；</li><li>写入会被重放到负责读取操作的副本。副本可能因为<strong>过多写操作阻塞，导致读取功能异常</strong>；</li><li>读取从库越多，需要复制的写入数据就越多，导致更严重的复制延迟；</li><li>在某些数据库系统中，写入主库的操作可以用多个线程并行写入，但写入副本只支持单线程顺序写入；</li><li>复制意味着更多的硬件和额外的复杂度。</li></ul><h3 id="联邦"><a href="#联邦" class="headerlink" title="联邦"></a>联邦</h3><p><code>Federation</code> 将数据库<strong>按对应功能分割</strong>。例如，你可以有三个数据库：论坛、用户和产品，而不仅是一个单体数据库，从而减少每个数据库的读取和写入流量，减少复制延迟。较小的数据库意味着更多适合放入内存的数据，进而意味着<strong>更高的缓存命中几率</strong>。没有只能串行写入的中心化主库，你可以并行写入，<strong>提高负载能力</strong>:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/06/02.jpg" alt></p><h4 id="缺陷：联邦"><a href="#缺陷：联邦" class="headerlink" title="缺陷：联邦"></a>缺陷：联邦</h4><ul><li>如果你的数据库模式需要大量的功能和数据表，联邦的效率并不好；</li><li>你需要<strong>更新应用程序的逻辑</strong>，来确定要读取和写入哪个数据库；</li><li>用 <strong>server link</strong> 从两个库 JOIN 数据更复杂；</li><li>联邦需要更多的硬件和额外的复杂度。</li></ul><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p><code>Sharding</code> 将数据分配在不同的数据库上，使得<strong>每个数据库仅管理整个数据集的一个子集</strong>。以用户数据库为例，随着用户数量的增加，越来越多的分片会被添加到集群中：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/06/03.jpg" alt></p><p>类似联邦的优点，分片可以减少读取和写入流量，减少复制并提高缓存命中率。也<strong>减少了索引</strong>，通常意味着查询更快，性能更好。如果一个分片出问题，其他的仍能运行，你可以使用某种形式的冗余来防止数据丢失。类似联邦，没有只能串行写入的中心化主库，你可以并行写入，提高负载能力。</p><p>常见的做法是：通过用户姓氏的首字母，或者用户的地理位置来分隔用户表。</p><h4 id="缺陷：分片"><a href="#缺陷：分片" class="headerlink" title="缺陷：分片"></a>缺陷：分片</h4><ul><li>你需要修改应用程序的逻辑来实现分片，这会带来复杂的 SQL 查询；</li><li>分片不合理可能导致<strong>数据负载不均衡</strong>。例如，被频繁访问的用户数据会导致其所在分片的负载相对其他分片高：<ul><li>再平衡会引入额外的复杂度（基于<code>一致性哈希</code>的分片算法可以减少这种情况）；</li></ul></li><li>JOIN 多个分片的数据操作更复杂；</li><li>分片需要更多的硬件和额外的复杂度。</li></ul><h3 id="非规范化"><a href="#非规范化" class="headerlink" title="非规范化"></a>非规范化</h3><p><code>Denormalization</code> 试图<strong>以写入性能为代价来换取读取性能</strong>。在多个表中冗余数据副本，以避免高成本的 JOIN 操作。一些关系型数据库，比如 PostgreSQL 和 Oracle 支持<code>物化视图</code>，可以存储冗余信息和保持冗余副本的一致。</p><p>当数据使用诸如联邦和分片等技术被分割，进一步提高了处理跨数据中心的 JOIN 操作的复杂度。<strong>非规范化可以规避这种复杂的 JOIN 操作</strong>。</p><p>在多数系统中，<strong>读取操作的频率远高于写入操作</strong>，比例可达到 100:1，甚至 1000:1。需要复杂的数据库 JOIN 的读取操作成本非常高，在磁盘操作上消耗了大量时间。</p><h4 id="缺陷：非规范化"><a href="#缺陷：非规范化" class="headerlink" title="缺陷：非规范化"></a>缺陷：非规范化</h4><ul><li>数据会冗余；</li><li><code>Constraint</code> 可以帮助冗余的信息副本保持同步，但这样会增加数据库设计的复杂度；</li><li>非规范化的数据库在<strong>高写入负载下</strong>，性能可能比规范化的数据库差；</li></ul><h3 id="SQL-调优"><a href="#SQL-调优" class="headerlink" title="SQL 调优"></a>SQL 调优</h3><p><code>SQL tuning</code> 是一个范围很广的话题，有很多相关的书可以作为参考。</p><p>利用<strong>基准测试</strong>（Benchmark）和<strong>性能分析</strong>（Profiling）来模拟和发现系统瓶颈很重要：</p><ul><li>Benchmark：用 <code>ab</code> 等工具模拟高负载情况；</li><li>Profiling：通过启用如<strong>慢查询日志</strong>等工具来辅助追踪性能问题。</li></ul><p>基准测试和性能分析可能会指引你到如下优化方案：</p><h4 id="改进模式（Schema）"><a href="#改进模式（Schema）" class="headerlink" title="改进模式（Schema）"></a>改进模式（Schema）</h4><ul><li>为了实现快速访问，MySQL 在磁盘上用<strong>连续的块</strong>存储数据；</li><li>使用 CHAR 类型存储固定长度的字段，不要用 VARCHAR：<ul><li><strong>CHAR 在快速、随机访问时效率很高</strong>。使用 VARCHAR 时，如果你想读取下一个字符串，不得不先读取到当前字符串的末尾；</li></ul></li><li>使用 TEXT 类型存储大块的文本（允许<code>布尔检索</code>），例如博客正文。使用 TEXT 字段需要在磁盘上存储一个用于定位文本块的指针；</li><li>使用 INT 类型存储高达 2^32（40 亿）的较大数字；</li><li>使用 DECIMAL 类型存储货币可以<strong>避免浮点数表示错误</strong>；</li><li>避免存储较大的 <code>BLOB</code>，而应存储获取<strong>对象的位置</strong>；</li><li>VARCHAR(255) 是以 8 位数字存储的最大字符数，在某些关系型数据库中，<strong>最大限度地利用字节</strong>；</li><li>在适用场景中设置 <code>NOT NULL</code> 约束，来提高搜索性能；</li></ul><h4 id="使用正确的索引"><a href="#使用正确的索引" class="headerlink" title="使用正确的索引"></a>使用正确的索引</h4><ul><li>查询（SELECT、GROUP BY、ORDER BY、JOIN）的列，如果用了索引会更快；</li><li>索引通常表示为<strong>自平衡的 B-tree</strong>，可以保持数据有序，并允许在对数时间内进行搜索、顺序访问、插入和删除操作；</li><li>设置索引，会将数据存在内存中，<strong>占用更多的内存空间</strong>；</li><li><strong>写入操作会变慢</strong>，因为索引需要被更新；</li><li>加载大量数据时，<strong>禁用索引再加载数据，然后重建索引</strong>，这样也许会更快。</li></ul><h4 id="避免高成本的-JOIN-操作"><a href="#避免高成本的-JOIN-操作" class="headerlink" title="避免高成本的 JOIN 操作"></a>避免高成本的 JOIN 操作</h4><p>若有需要，可以进行非规范化。</p><h4 id="分割数据表"><a href="#分割数据表" class="headerlink" title="分割数据表"></a>分割数据表</h4><p><strong>将热点数据拆分到单独的数据表中</strong>，可以有助于缓存。</p><h4 id="调优查询缓存"><a href="#调优查询缓存" class="headerlink" title="调优查询缓存"></a>调优查询缓存</h4><p>在某些情况下，<code>查询缓存</code>可能会导致性能问题。</p><h2 id="NoSQL"><a href="#NoSQL" class="headerlink" title="NoSQL"></a>NoSQL</h2><p>NoSQL 是采用<code>键-值存储</code>、<code>文档存储</code>、<code>宽列存储</code>和<code>图存储</code>的数据库的统称。数据库是非规范化的，<strong>JOIN 大多在应用程序代码中完成</strong>。大多数 NoSQL 无法完成真正满足 ACID 的事务，<strong>支持最终一致性</strong>。</p><p><code>BASE</code> 通常被用于描述 NoSQL 数据库的特性。相比 CAP 理论，<strong>BASE 强调可用性超过一致性</strong>：</p><ul><li>基本可用（<strong>B</strong>asically <strong>A</strong>vailable）:系统保证可用性；</li><li>软状态（<strong>S</strong>oft state）：即使没有输入，系统状态也可能随着时间变化；</li><li>最终一致性（<strong>E</strong>ventual consistency）：经过一段时间之后，系统最终会变一致，因为系统在此期间没有收到任何输入。</li></ul><p>除了在 SQL 还是 NoSQL 之间做选择，了解哪种类型的 NoSQL 数据库，最适合你的用例也是非常有帮助的。</p><h3 id="键-值存储"><a href="#键-值存储" class="headerlink" title="键-值存储"></a>键-值存储</h3><blockquote><p>抽象类型：Hash table</p></blockquote><p>键-值存储通常可以实现 O(1) 时间的读写，用内存或 SSD 存储数据。数据存储可以按<code>字典序</code>维护键，从而实现键的高效检索。键-值存储可以<strong>用于存储元数据</strong>。</p><p>键-值存储性能很高，通常用于存储简单数据模型或频繁修改的数据，如内存中的缓存。键-值存储提供的操作有限，如需更多操作，<strong>复杂度将转嫁到应用程序层面</strong>。</p><p>键-值存储是<strong>更复杂的存储系统的基础</strong>，如文档存储和图存储。</p><h3 id="文档存储"><a href="#文档存储" class="headerlink" title="文档存储"></a>文档存储</h3><blockquote><p>抽象模型：将文档作为值的键-值存储</p></blockquote><p>文档存储以文档（XML、JSON、二进制文件等）为中心，文档存储了指定对象的全部信息。文档存储根据文档自身的内部结构，<strong>提供 API 或查询语句来实现查询</strong>。注意：许多键-值存储数据库有<strong>用值存储元数据的特性</strong>，这也模糊了这两种存储类型的界限。</p><p>基于底层实现，文档可以根据集合、标签（<code>tag</code>）、元数据（<code>metadata</code>）或文件夹组织。尽管不同文档可以被组织在一起或分成一组，但<strong>相互之间可能具有完全不同的字段</strong>。</p><p><code>MongoDB</code> 和 <code>Apache CouchDB</code> 等一些文档存储数据库，还提供了类似 SQL 的查询语句来实现复杂查询。<code>Amazon DynamoDB</code> 同时支持键-值存储和文档存储。</p><p>文档存储具备高度的灵活性，常<strong>用于处理偶尔变化的数据</strong>。</p><h3 id="宽列存储"><a href="#宽列存储" class="headerlink" title="宽列存储"></a>宽列存储</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/06/04.jpg" alt></p><blockquote><p>抽象模型：Nested map，ColumnFamily&lt;RowKey, Columns&lt;ColKey, Value, Timestamp&gt;&gt;</p></blockquote><p>宽列存储的<strong>基本数据单元是列</strong>（名/值对）。列可以在<code>列簇</code>（类似于 SQL 的数据表）中被分组，超级列簇再分组普通列簇。你可以使用行键独立访问每一列，<strong>具有相同行键值的列组成一行</strong>。每个值都包含时间戳，用于解决版本冲突。</p><p>Google 发布了第一个列型存储数据库 <code>Bigtable</code>，它影响了 Hadoop 生态系统中活跃的开源数据库 <code>HBase</code> 和 Facebook 的 <code>Cassandra</code>。它们将键<strong>以字典序存储，实现高效检索</strong>。</p><p>宽列存储具备高可用性和高可扩展性，常被<strong>用于大数据领域</strong>。</p><h3 id="图存储"><a href="#图存储" class="headerlink" title="图存储"></a>图存储</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/06/05.jpg" alt></p><blockquote><p>抽象模型：Graph</p></blockquote><p>在图数据库中，一个节点对应一条记录，<strong>一条弧对应两个节点之间的关系</strong>。图数据库被优化用于表示外键繁多的复杂关系或多对多关系。</p><p>图数据库为存储复杂关系的数据模型，如社交网络，提供了很高的性能。它们相对较新，尚未广泛应用，查找开发工具和资源相对较难，<strong>许多图只能通过 RESTful API 访问</strong>。</p><h2 id="SQL-or-NoSQL"><a href="#SQL-or-NoSQL" class="headerlink" title="SQL or NoSQL"></a>SQL or NoSQL</h2><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/06/06.jpg" alt></p><h3 id="选择-SQL-的原因"><a href="#选择-SQL-的原因" class="headerlink" title="选择 SQL 的原因"></a>选择 SQL 的原因</h3><ul><li>结构化数据；</li><li>严格的模式；</li><li>关系型数据；</li><li>需要复杂的 JOIN 操作；</li><li>事务；</li><li>清晰的扩展模式；</li><li>既有资源更丰富：开发者、社区、代码库、工具等；</li><li>通过索引进行查询非常快；</li></ul><h3 id="选择-NoSQL-的原因"><a href="#选择-NoSQL-的原因" class="headerlink" title="选择 NoSQL 的原因"></a>选择 NoSQL 的原因</h3><ul><li>半结构化数据；</li><li>动态或灵活的模式；</li><li>非关系型数据；</li><li>不需要复杂的 JOIN 操作；</li><li>存储 TB（甚至 PB）级别的数据；</li><li>高数据密集的工作负载；</li><li>高 <code>Throughput/IOPS</code>；</li></ul><h3 id="适合-NoSQL-的示例数据"><a href="#适合-NoSQL-的示例数据" class="headerlink" title="适合 NoSQL 的示例数据"></a>适合 NoSQL 的示例数据</h3><ul><li>埋点数据和日志数据；</li><li>排行榜或得分数据；</li><li>临时数据，如购物车；</li><li>频繁访问的热表；</li><li>Metadata/Lookup table；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反向代理与应用层</title>
      <link href="2019/12/28/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/"/>
      <url>2019/12/28/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%BA%94%E7%94%A8%E5%B1%82/</url>
      
        <content type="html"><![CDATA[<h2 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h2><p><code>Reverse Proxy</code> 是一种可以<strong>集中调用内部服务，并提供统一公共接口</strong>的 Web 服务器。来自客户端的请求先被反向代理服务器转发到可响应请求的服务器，然后再把服务器的响应结果返回给客户端。</p><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/05/00.jpg" alt></p><p>带来的好处包括：</p><ul><li><strong>增加安全性</strong>：隐藏后端服务器的信息，屏蔽黑名单中的 IP，限制每个客户端的连接数；</li><li><strong>提高可扩展性和灵活性</strong>：客户端只能看到反向代理服务器的 IP，这使你可以增减服务器或修改它们的配置；</li><li>SSL 终结：<strong>解密传入的请求并加密服务器响应</strong>，这样的话后端服务器就不必再执行这些潜在高消耗运算了（不需要再每台服务器上安装 <code>X.509</code>）；</li><li><strong>压缩</strong>：压缩服务器响应；</li><li><strong>缓存</strong>：直接返回命中的缓存结果；</li><li><strong>静态内容</strong>：直接提供静态内容（HTML/CSS/JS、图片、视频等）。</li></ul><h3 id="反向代理与负载均衡"><a href="#反向代理与负载均衡" class="headerlink" title="反向代理与负载均衡"></a>反向代理与负载均衡</h3><ul><li>当你有多个服务器时，部署负载均衡器非常有用。通常，负载均衡器将流量路由给一组<strong>功能相同</strong>的服务器上；</li><li><strong>即使只有一台 Web 服务器或应用服务器</strong>时，反向代理也同样有用；</li><li>Nginx 和 HAProxy 等解决方案，可以<strong>同时支持</strong>七层反向代理和负载均衡。</li></ul><a id="more"></a><h3 id="缺陷：反向代理"><a href="#缺陷：反向代理" class="headerlink" title="缺陷：反向代理"></a>缺陷：反向代理</h3><ul><li>引入反向代理会增加系统的复杂度；</li><li>单独一个反向代理服务器仍<strong>可能发生单点故障</strong>，而配置多台反向代理服务器会进一步增加复杂度。</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p><strong>将 Web 服务层与应用层分离</strong>，可以独立缩放和配置这两层。添加新的 API 时，<strong>只需要添加应用服务器</strong>，而不必添加额外的 Web 服务器。</p><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/05/01.jpg" alt></p><p><code>单一职责原则</code>提倡小型、自治的服务共同合作。小团队通过提供小型的服务，可以更激进地计划增长。</p><p>应用层中的工作进程也可以<strong>实现异步</strong>。</p><h3 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h3><p><code>Microservices</code> 可以被描述为一系列可以独立部署的小型模块化服务。每个服务运行在一个<strong>独立的线程</strong>中，通过明确定义的轻量级机制通讯，共同实现业务目标。</p><p>例如，Pinterest 可能有这些微服务： 用户资料、关注者、Feed 流、搜索、照片上传等。</p><h3 id="服务发现"><a href="#服务发现" class="headerlink" title="服务发现"></a>服务发现</h3><p>像 etcd，Consul 和 ZooKeeper 这样的系统可以通过追踪注册名、地址、端口等信息来<strong>帮助服务互相发现对方</strong>。<code>Health Check</code> 可以帮助确认服务的完整性和是否经常使用一个 HTTP 路径。</p><p>etcd 和 Consul 都有一个<strong>内建的 key-value 存储</strong>，用来存储配置信息和其他的共享信息。</p><h3 id="缺陷：应用层"><a href="#缺陷：应用层" class="headerlink" title="缺陷：应用层"></a>缺陷：应用层</h3><ul><li>添加由<strong>多个松耦合服务组成的应用层</strong>，从架构、运营、流程等层面来讲将非常不同（相对于单层系统）；</li><li>微服务会增加部署和运营的复杂度。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>负载均衡器</title>
      <link href="2019/12/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/"/>
      <url>2019/12/25/%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><code>Load Balancer</code> 将传入的请求分发到应用服务器和数据库等计算资源。无论哪种情况，负载均衡器将来自计算资源的响应，返回给恰当的客户端。负载均衡器的效用在于:</p><ul><li>防止请求进入不好的服务器</li><li>防止资源过载</li><li><strong>帮助消除单一的故障点</strong></li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/04/00.jpg" alt></p><p>负载均衡器可以通过硬件（昂贵）或 HAProxy 等软件来实现。 增加的好处包括：</p><ul><li>SSL 终结：<strong>解密传入的请求并加密服务器响应</strong>，这样的话后端服务器就不必再执行这些潜在高消耗运算了（不需要再每台服务器上安装 <code>X.509</code>）；</li><li>Session 留存：当 <strong>Web 应用程序不追踪 session</strong> 时，发出 <code>cookie</code> 并将特定客户端的请求，路由到同一实例。</li></ul><a id="more"></a><p>通常会设置采用 <code>active-passive</code> 或 <code>active-active</code> 模式的多个负载均衡器，以免发生故障。</p><p>负载均衡器能基于多种方式来路由流量：</p><ul><li>随机</li><li>最少负载</li><li>session/cookie</li><li>（加权）轮询调度算法</li><li>四层负载均衡</li><li>七层负载均衡</li></ul><h2 id="四层负载均衡"><a href="#四层负载均衡" class="headerlink" title="四层负载均衡"></a>四层负载均衡</h2><p>四层负载均衡，通过<strong>监控传输层的信息</strong>来决定如何分发请求。通常，这会涉及来源，目标 IP 地址和请求头中的端口，但不包括数据包（报文）内容。四层负载均衡器，执行<code>NAT</code>来向上游服务器转发网络数据包。</p><h2 id="七层负载均衡"><a href="#七层负载均衡" class="headerlink" title="七层负载均衡"></a>七层负载均衡</h2><p>七层负载均衡，通过<strong>监控应用层的信息</strong>来决定怎样分发请求。这会涉及请求头的内容，消息和 cookie。七层负载均衡器，终结网络流量，读取消息，做出负载均衡判定，然后传送给特定服务器。</p><p>比如，一个七层负载均衡器能直接将视频流量连接到托管视频的服务器，同时，将更敏感的用户账单流量引导到安全性更强的服务器。</p><p><strong>以损失灵活性为代价</strong>，四层负载均衡比七层负载均衡花费更少的时间和计算资源（这对现代商用硬件的性能影响甚微）。</p><h2 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h2><p>负载均衡器还能帮助水平扩展，提高性能和可用性。使用商业硬件的性价比更高，并且比在单台硬件上<code>垂直扩展</code>更贵的硬件具有更高的可用性。<strong>相比招聘特定企业系统人才，招聘商业硬件方面的人才更加容易</strong>。</p><h3 id="缺陷：水平扩展"><a href="#缺陷：水平扩展" class="headerlink" title="缺陷：水平扩展"></a>缺陷：水平扩展</h3><ul><li>水平扩展引入了复杂度并涉及服务器复制：<ul><li>服务器是<strong>无状态的</strong>：它们不应该包含 session 或资料图片等与用户关联的数据；</li><li>session 可以集中存储在持久化缓存（Redis、Memcached）或数据库（SQL、NoSQL）的数据存储区中。</li></ul></li><li>缓存和数据库等下游服务器，需要<strong>随着上游服务器进行扩展</strong>，以处理更多的并发连接。</li></ul><h2 id="缺陷：负载均衡器"><a href="#缺陷：负载均衡器" class="headerlink" title="缺陷：负载均衡器"></a>缺陷：负载均衡器</h2><ul><li>如果没有足够的资源配置或配置错误，负载均衡器会变成一个性能瓶颈；</li><li>引入负载均衡器以帮助消除单点故障，但导致了额外的复杂性；</li><li>单个负载均衡器会导致单点故障，但配置多个负载均衡器会进一步增加复杂性。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名系统与内容分发网络</title>
      <link href="2019/12/21/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/"/>
      <url>2019/12/21/%E5%9F%9F%E5%90%8D%E7%B3%BB%E7%BB%9F%E4%B8%8E%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<h2 id="域名系统"><a href="#域名系统" class="headerlink" title="域名系统"></a>域名系统</h2><p><strong>D</strong>omain <strong>N</strong>ame <strong>S</strong>ystem（DNS）将 <a href="http://www.example.com" target="_blank" rel="noopener">www.example.com</a> 等域名转换成 IP 地址：</p><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/03/00.jpg" alt></p><p>域名系统是分层次的，一些 DNS 服务器位于顶层。当查询（域名）IP 时，路由或 ISP 提供连接 DNS 服务器的信息。<strong>较底层的 DNS 服务器缓存映射</strong>，它可能会因为 DNS 传播延时而失效。DNS 结果可以缓存在浏览器或操作系统中一段时间，时间长短取决于 <code>TTL</code>（Time To Live）：</p><ul><li>NS 记录（域名服务）：指定解析域名或子域名的 DNS 服务器；</li><li>MX 记录（邮件交换）：指定接收信息的邮件服务器；</li><li>A 记录（地址）：指定域名对应的 IP 地址记录；</li><li>CNAME（规范）：一个域名映射到另一个域名，或映射到一个 A 记录。</li></ul><a id="more"></a><p><code>CloudFlare</code> 和 <code>Route 53</code> 等平台提供管理 DNS 的功能。某些 DNS 服务通过<strong>集中方式</strong>来路由流量:</p><ul><li>加权轮询调度：<ul><li>防止流量进入维护中的服务器</li><li>在不同大小集群间负载均衡</li><li>A/B 测试</li></ul></li><li>基于延迟路由</li><li>基于地理位置路由</li></ul><h3 id="缺陷：DNS"><a href="#缺陷：DNS" class="headerlink" title="缺陷：DNS"></a>缺陷：DNS</h3><ul><li>虽说缓存可以减轻 DNS 延迟，但连接 DNS 服务器还是带来了轻微的延迟；</li><li>虽然它们通常由政府、网络服务提供商和大公司管理，但 DNS 服务管理仍可能是复杂的；</li><li>DNS 服务可能遭受 <code>DDoS 攻击</code>，例如：阻止不知道 Twitter IP 地址的用户访问 Twitter。</li></ul><h2 id="内容分发网络"><a href="#内容分发网络" class="headerlink" title="内容分发网络"></a>内容分发网络</h2><p><strong>C</strong>ontent <strong>D</strong>elivery <strong>N</strong>etwork（CDN）是一个<strong>全球性的代理服务器分布式网络</strong>，它从靠近用户的位置提供内容。通常，HTML/CSS/JS，图片和视频等静态内容由 CDN 提供，亚马逊 <code>CloudFront</code> 等也支持动态内容。</p><blockquote><p>CDN 的 DNS 解析会告知客户端连接哪台服务器。</p></blockquote><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/03/01.jpg" alt></p><p>将内容存储在 CDN 上可以从两个方面来提高性能:</p><ul><li>从靠近用户的数据中心提供资源；</li><li>借助 CDN，服务器不必真的处理请求。</li></ul><h3 id="CDN-推送"><a href="#CDN-推送" class="headerlink" title="CDN 推送"></a>CDN 推送</h3><p>当服务器上的<strong>内容发生变动时</strong>，推送 CDN 接受新内容。直接推送给 CDN 并重写 URL 地址，以指向内容的 CDN 地址，可以配置内容的到期时间和更新时间。内容只有在新增或更改时才推送，<strong>流量最小化，但存储最大化</strong>。</p><p>CDN 推送可以很好地处理流量较小或内容不经常更新的站点，内容一次性放置在 CDN 上，而<strong>不是定期重新拉取</strong>。</p><h3 id="CDN-拉取"><a href="#CDN-拉取" class="headerlink" title="CDN 拉取"></a>CDN 拉取</h3><p>CDN 拉取是当第一个用户请求资源时，从服务器上拉取资源。将内容留在服务器上，并重写 URL 指向 CDN 地址。在<strong>内容被缓存在 CDN 上</strong>之前，这都会导致请求变慢。</p><p>内容的缓存时间取决于 TTL。CDN 拉取可以最大程度地减少 CDN 上的存储空间，但如果文件过期，或在文件实际更改之前就被拉取，则<strong>会产生多余的流量</strong>。</p><p>CDN 拉取可以很好地处理高流量的站点，因为<strong>流量分散得更均匀</strong>，只有最近请求的内容保留在 CDN 上。</p><h3 id="缺陷：CDN"><a href="#缺陷：CDN" class="headerlink" title="缺陷：CDN"></a>缺陷：CDN</h3><ul><li>CDN 成本因流量而异，可能在权衡之后你将不会使用 CDN；</li><li>如果在 TTL 过期之前更新内容，CDN 缓存内容可能会过时；</li><li>CDN 需要更改静态内容的 URL 地址以指向 CDN。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高层次的权衡</title>
      <link href="2019/12/21/%E9%AB%98%E5%B1%82%E6%AC%A1%E7%9A%84%E6%9D%83%E8%A1%A1/"/>
      <url>2019/12/21/%E9%AB%98%E5%B1%82%E6%AC%A1%E7%9A%84%E6%9D%83%E8%A1%A1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>Keep in mind that everything is a trade-off.</p></blockquote><p>Next, we’ll look at high-level trade-offs:</p><ul><li>Performance vs. Scalability;</li><li>Latency vs. Throughput;</li><li>Consistency vs. Availability;</li></ul><h2 id="性能与可扩展性"><a href="#性能与可扩展性" class="headerlink" title="性能与可扩展性"></a>性能与可扩展性</h2><p>如果<strong>服务性能的增长与资源的增加是成比例的</strong>，服务就是可扩展的。通常，提高性能意味着服务于更多的工作单元，另一方面，当数据集增长时，同样也可以处理更大的工作单位。</p><p>另一个角度来看待性能与可扩展性:</p><ul><li>如果你的系统有性能问题，对于单个用户来说是缓慢的；</li><li>如果你的系统有可扩展性问题，单个用户较快但在高负载下会变慢；</li></ul><h2 id="延迟与吞吐量"><a href="#延迟与吞吐量" class="headerlink" title="延迟与吞吐量"></a>延迟与吞吐量</h2><p>延迟是执行操作或运算结果所花费的时间。吞吐量是单位时间内（执行）此类操作或运算的数量。通常，你应该<strong>以可接受级延迟下最大化吞吐量为目标</strong>。</p><h2 id="一致性与可用性"><a href="#一致性与可用性" class="headerlink" title="一致性与可用性"></a>一致性与可用性</h2><h3 id="CAP-理论"><a href="#CAP-理论" class="headerlink" title="CAP 理论"></a>CAP 理论</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/02/00.png" alt></p><p>在一个分布式计算系统中，只能同时满足下列的两点:</p><ul><li>一致性：每次访问都能获得最新数据但可能会收到错误响应；</li><li>可用性：每次访问都能收到非错响应，但不保证获取到最新数据；</li><li>分区容错性：在任意分区网络故障的情况下系统仍能继续运行；</li></ul><blockquote><p>网络并不可靠，所以你应要支持分区容错性，并需要在软件一致性和可用性间做出取舍。</p></blockquote><h4 id="CP：一致性和分区容错性"><a href="#CP：一致性和分区容错性" class="headerlink" title="CP：一致性和分区容错性"></a>CP：一致性和分区容错性</h4><p>等待分区节点的响应可能会导致延时错误。如果你的<strong>业务需求需要原子读写</strong>，CP 是一个不错的选择。</p><h4 id="AP：可用性和分区容错性"><a href="#AP：可用性和分区容错性" class="headerlink" title="AP：可用性和分区容错性"></a>AP：可用性和分区容错性</h4><p>响应节点上可用数据的最近版本可能并不是最新的。当分区解析完后，写入（操作）可能需要一些时间来传播。如果<strong>业务需求允许最终一致性，或当有外部故障时要求系统继续运行</strong>，AP 是一个不错的选择。</p><h3 id="一致性模式"><a href="#一致性模式" class="headerlink" title="一致性模式"></a>一致性模式</h3><p>有同一份数据的多份副本，我们面临着怎样同步它们的选择，以便让客户端有一致的显示数据。回想 CAP 理论中的一致性定义 – 每次访问都能获得最新数据但可能会收到错误响应。</p><h4 id="弱一致性"><a href="#弱一致性" class="headerlink" title="弱一致性"></a>弱一致性</h4><p>在写入之后，访问可能看到，也可能看不到（写入数据）。<strong>尽力优化它，让其能访问最新数据</strong>。这种方式可以在 Memcached 等系统中看到。弱一致性在 VoIP，视频聊天和实时多人游戏等真实用例中表现不错。例如：如果你在通话中丢失信号几秒钟时间，当重新连接时，你是听不到这几秒钟所说的话的。</p><h4 id="强一致性"><a href="#强一致性" class="headerlink" title="强一致性"></a>强一致性</h4><p>在写入后，<strong>访问立即可见，数据被同步复制</strong>。文件系统和 RDBMS 使用的是此种方式。强一致性在需要记录的系统中运作良好。</p><h4 id="最终一致性"><a href="#最终一致性" class="headerlink" title="最终一致性"></a>最终一致性</h4><p>在写入后，<strong>访问最终能看到写入数据，数据被异步复制</strong>。DNS 和 Email 等系统使用的是此种方式。最终一致性在 HA 系统中效果不错。</p><h3 id="可用性模式"><a href="#可用性模式" class="headerlink" title="可用性模式"></a>可用性模式</h3><p>有两种支持高可用性的模式：<code>failover</code> 和 <code>replication</code>。</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><ol><li>Active-Passive<br>关于工作到备用的故障转移流程是：<strong>工作服务器发送周期信号给待机中的备用服务器</strong>。如果周期信号中断，备用服务器切换成工作服务器的 IP 地址并恢复服务。宕机时间取决于备用服务器处于“热”待机状态，还是需要从“冷”待机状态进行启动。<strong>只有工作服务器处理流量</strong>。工作到备用的故障转移也被称为<code>主从切换</code>；</li><li>Active-Active<br>在双工作切换中，<strong>双方都在管控流量，在它们之间分散负载</strong>。如果是外网服务器，DNS 将需要对两方都了解；如果是内网服务器，应用程序逻辑将需要对两方都了解。双工作切换也可以称为<code>主主切换</code>；</li></ol><p>故障转移的缺陷：</p><ul><li>故障转移需要添加额外硬件并增加复杂性；</li><li>如果新写入数据在能被复制到备用系统之前，工作系统出现了故障，则有可能会丢失数据；</li></ul><h4 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h4><p>主从复制和主主复制</p><h4 id="How-many-9s-are-enough"><a href="#How-many-9s-are-enough" class="headerlink" title="How many 9s are enough?"></a>How many 9s are enough?</h4><p>Availability is often quantified by uptime (or downtime) as a percentage of time the service is available. Availability is generally measured in <code>number of 9s</code> – a service with 99.99% availability is described as having four 9s.</p><p><strong>99.9% availability – three 9s:</strong></p><table><thead><tr><th align="left">Duration</th><th align="left">Acceptable downtime</th></tr></thead><tbody><tr><td align="left">Downtime per year</td><td align="left">8h 45min 57s</td></tr><tr><td align="left">Downtime per month</td><td align="left">43m 49.7s</td></tr><tr><td align="left">Downtime per week</td><td align="left">10m 4.8s</td></tr><tr><td align="left">Downtime per day</td><td align="left">1m 26.4s</td></tr></tbody></table><p><strong>99.99% availability – four 9s:</strong></p><table><thead><tr><th align="left">Duration</th><th align="left">Acceptable downtime</th></tr></thead><tbody><tr><td align="left">Downtime per year</td><td align="left">52min 35.7s</td></tr><tr><td align="left">Downtime per month</td><td align="left">4m 23s</td></tr><tr><td align="left">Downtime per week</td><td align="left">1m 5s</td></tr><tr><td align="left">Downtime per day</td><td align="left">8.6s</td></tr></tbody></table><h4 id="In-sequence-vs-In-parallel"><a href="#In-sequence-vs-In-parallel" class="headerlink" title="In sequence vs. In parallel"></a>In sequence vs. In parallel</h4><p>If a service consists of multiple components prone to failure, the service’s overall availability depends on <strong>whether the components are in sequence or in parallel</strong>:</p><ul><li>In sequence<br>Overall availability <strong>decreases</strong> when two components with availability &lt; 100% are in sequence:<br>If both Foo and Bar each has 99.9% availability, their total availability in sequence would be 99.8%.<blockquote><p>Availability(Total) = Availability(Foo) * Availability(Bar)</p></blockquote></li><li>In parallel<br>Overall availability <strong>increases</strong> when two components with availability &lt; 100% are in parallel:<br>If both Foo and Bar each has 99.9% availability, their total availability in parallel would be 99.9999%.<blockquote><p>Availability(Total) = 1 - (1 - Availability(Foo)) * (1 - Availability(Bar))</p></blockquote></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scalability for Dummies</title>
      <link href="2019/12/18/Scalability-for-Dummies/"/>
      <url>2019/12/18/Scalability-for-Dummies/</url>
      
        <content type="html"><![CDATA[<p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/01/00.jpg" alt><br>Just recently I was asked what it would take to <strong>make a web service massively scalable</strong>. My answer was lengthy and maybe it is also for other people interesting. So I share it with you here in my blog and split it into parts to make it easier to read. New parts are released on a regular basis. Have fun and your comments are always welcomed!</p><h2 id="Clones"><a href="#Clones" class="headerlink" title="Clones"></a>Clones</h2><p>Public servers of a scalable web service are hidden <strong>behind a load balancer</strong>. This load balancer <strong>evenly distributes</strong> load (requests from your users) onto your group/cluster of application servers. That means that if, for example, user Steve interacts with your service, he may be served at his first request by server 2, then with his second request by server 9 and then maybe again by server 2 on his third request. </p><p>Steve should always get the same results of his request back, independent what server he “landed on”. That leads to the first golden rule for scalability: every server contains exactly the same codebase and <strong>does not store any user-related data</strong>, like sessions or profile pictures, on local disc or memory. </p><p>Sessions need to be stored in a centralized data store which is accessible to all your application servers. It can be an <code>external database</code> or an <code>external persistent cache</code>, like Redis. An external persistent cache will have better performance than an external database. By external I mean that the data store does not reside on the application servers. Instead, it is somewhere in or <strong>near the data center</strong> of your application servers.</p><a id="more"></a><p>But what <strong>about deployment</strong>? How can you make sure that a code change is sent to all your servers without one server still serving old code? This tricky problem is fortunately already solved by the great tool <code>Capistrano</code>. It requires some learning, especially if you are not into <code>Ruby on Rails</code>, but it is definitely both the effort.</p><p>After “outsourcing” your sessions and serving the same codebase from all your servers, you can now create an image file from one of these servers (AWS calls this <code>AMI</code> - <strong>A</strong>mazon <strong>M</strong>achine <strong>I</strong>mage.) Use this AMI as a “super-clone” that all your <strong>new instances are based upon</strong>. Whenever you start a new instance/clone, just do an initial deployment of your latest code and you are ready!</p><h2 id="Database"><a href="#Database" class="headerlink" title="Database"></a>Database</h2><p>After following “Clones”, your servers can now <strong>horizontally scale</strong> and you can already <strong>serve thousands of concurrent requests</strong>. But somewhere down the road your application gets slower and slower and finally breaks down. The reason: your database. It’s MySQL, isn’t it?</p><p>Now the required changes are more radical than just adding more cloned servers and may even require some boldness. In the end, you can choose from 2 paths:</p><h3 id="Path-1"><a href="#Path-1" class="headerlink" title="Path #1"></a>Path #1</h3><p>To stick with MySQL and keep the “beast” running. Hire a <strong>D</strong>ata<strong>B</strong>ase <strong>A</strong>dministrator (<code>DBA</code>), tell him to <strong>do master-slave replication</strong> (read from slaves, write to master) and upgrade your master server by adding RAM, RAM and more RAM. In some months, your DBA will come up with words like “sharding”, “denormalization” and “SQL tuning” and will look worried about the necessary overtime during the next weeks. At that point every new action to keep your database running will be <strong>more expensive and time consuming</strong> than the previous one. You might have been better off if you had chosen Path #2 while your dataset was still small and easy to migrate.</p><h3 id="Path-2"><a href="#Path-2" class="headerlink" title="Path #2"></a>Path #2</h3><p>To denormalize right from the beginning and include no more Joins in any database query. You can stay with MySQL, and use it like a NoSQL database, or you can switch to a better and easier to scale NoSQL database like <code>MongoDB</code> or CouchDB. Joins will now need to be done in your application code. The sooner you do this step the less code you will have to change in the future. But even if you successfully switch to the latest and greatest NoSQL database and <strong>let your app do the dataset-joins</strong>, soon your database requests will again be slower and slower. You will need to introduce a cache.</p><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>After following “Database”, you now have a <strong>scalable database solution</strong>. You have no fear of storing terabytes anymore and the world is looking fine. But just for you. Your users still have to suffer slow page requests when a lot of data is fetched from the database. The solution is the implementation of a cache.</p><p>With “cache” I always mean in-memory caches like <code>Memcached</code> or <code>Redis</code>. Please <strong>never do file-based caching</strong>, it makes cloning and auto-scaling of your servers just a pain. </p><p>But back to in-memory caches. A cache is a simple key-value store and it should reside as <strong>a buffering layer</strong> between your application and your data storage. Whenever your application has to read data it should at first try to retrieve the data from your cache. Only if it’s not in the cache should it then try to get the data from the main data source. Why should you do that? Because a cache is lightning-fast. It holds every dataset in RAM and requests are handled as fast as technically possible. For example, Redis can do <strong>several hundreds of thousands of read operations per second</strong> when being hosted on a standard server. Also writes, especially increments, are very, very fast. Try that with a database!</p><p>There are 2 patterns of caching your data. An old one and a new one:</p><h3 id="Cached-Database-Queries"><a href="#Cached-Database-Queries" class="headerlink" title="Cached Database Queries"></a>Cached Database Queries</h3><p>That’s still the most commonly used caching pattern. Whenever you do a query to your database, you <strong>store the result dataset</strong> in cache. A <strong>hashed version of your query is the cache key</strong>. The next time you run the query, you first check if it is already in the cache. The next time you run the query, you check at first the cache if there is already a result. This pattern has several issues. The main issue is the expiration. It is hard to delete a cached result when you cache a complex query (who has not?). </p><blockquote><p>When one piece of data changes (for example a table cell) you need to delete all cached queries who may include that table cell.</p></blockquote><h3 id="Cached-Objects"><a href="#Cached-Objects" class="headerlink" title="Cached Objects"></a>Cached Objects</h3><p>That’s my strong recommendation and I always prefer this pattern. In general, see your data as an object like you already do in your code (classes, instances, etc.). </p><blockquote><p>Let your class assemble a dataset from your database and then store the complete instance of the class or the assembled dataset in the cache.</p></blockquote><p>Sounds theoretical, I know, but just look how you normally code. You have, for example, a class called “Product” which has a property called “data”. It is an array containing prices, texts, pictures, and customer reviews of your product. The property “data” is filled by several methods in the class doing several database requests which are hard to cache, since many things relate to each other. Now, do the following: when your class has finished the “assembling” of the data array, <strong>directly store the data array</strong>, or better yet the complete instance of the class, in the cache! This allows you to easily get rid of the object whenever something did change and makes the overall operation of your code faster and more logical.</p><p>And the best part: it <strong>makes asynchronous processing possible</strong>! Just imagine an army of worker servers who assemble your objects for you! The application just consumes the latest cached object and nearly <strong>never touches the databases</strong> anymore!</p><p>Some ideas of objects to cache:</p><ul><li>user sessions (never use the database!)</li><li>fully rendered blog articles</li><li>activity streams</li><li>user &lt;-&gt; friend relationships</li></ul><p>As you maybe already realized, I am a huge fan of caching. It is easy to understand, very simple to implement and the result is always breathtaking. In general, I am more a friend of Redis than Memcached, because I love the <strong>extra database-features of Redis</strong> like persistence and the built-in data structures like lists and sets. With Redis, there may be a chance that you even can get completely rid of a database. But if you just need to cache, take Memcached, because it scales like a charm.</p><p>Happy caching!</p><h2 id="Asynchronism"><a href="#Asynchronism" class="headerlink" title="Asynchronism"></a>Asynchronism</h2><p>Start with a picture: please imagine that you want to buy bread at your favorite bakery. So you go into the bakery, ask for a loaf of bread, but there is no bread there! Instead, you are asked to come back in 2 hours when your ordered bread is ready. That’s annoying, isn’t it?</p><p>To avoid such a “please wait a while” - situation, <strong>asynchronism needs to be done</strong>. And what’s good for a bakery, is maybe also good for your web service or web app.</p><p>In general, there are two ways/paradigms asynchronism can be done:</p><h3 id="Async-1"><a href="#Async-1" class="headerlink" title="Async #1"></a>Async #1</h3><p>Let’s stay in the former bakery picture. The first way of async processing is the “bake the breads at night and sell them in the morning” way. No waiting time at the cash register and a happy customer. Referring to a web app this means <strong>doing the time-consuming work in advance</strong> and <strong>serving the finished work with a low request time</strong>.</p><p>Very often this paradigm is used to <strong>turn dynamic content into static content</strong>. Pages of a website, maybe built with a massive framework or CMS (<strong>C</strong>ontent <strong>M</strong>anagement <strong>S</strong>ystem), are pre-rendered and locally stored as static HTML files on every change. Often these computing tasks are done on a regular basis, maybe by a script which is called every hour by a cronjob. This pre-computing of overall general data can extremely improve websites and web apps and makes them very scalable and efficient. Just imagine the scalability of your website if the script would upload these pre-rendered HTML pages to AWS S3 or CloudFront or another Content Delivery Network! Your website would be super responsive and could <strong>handle millions of visitors per hour</strong>!</p><h3 id="Async-2"><a href="#Async-2" class="headerlink" title="Async #2"></a>Async #2</h3><p>Back to the bakery. Unfortunately, sometimes customers has special requests like a birthday cake with “Happy Birthday, Steve!” on it. The bakery can not foresee these kind of customer wishes, so it must start the task when the customer is in the bakery and tell him to come back at the next day. Referring to a web service that means to <strong>handle tasks asynchronously</strong>.</p><p>Here is a typical workflow:</p><p>A user comes to your website and starts a very computing intensive task which would take several minutes to finish. So the frontend of your website sends a job onto a job queue and immediately signals back to the user: your job is in work, please continue to the browse the page. The job queue is constantly checked by a bunch of workers for new jobs. If there is a new job then the worker does the job and after some minutes sends a signal that the job was done. The frontend, which constantly checks for new “job is done” - signals, sees that the job was done and informs the user about it. I know, that was a very simplified example. </p><p>If you now want to dive more into the details and actual technical design, I recommend you take a look at the first 3 tutorials on the RabbitMQ website. <code>RabbitMQ</code> is one of many systems which help to implement async processing. You could also use ActiveMQ or a simple Redis list. The basic idea is <strong>to have a queue of tasks or jobs that a worker can process</strong>. Asynchronism seems complicated, but it is definitely worth your time to learn about it and implement it yourself. Backend becomes nearly infinitely scalable and frontend becomes snappy which is <strong>good for the overall user experience</strong>.</p><blockquote><p>If you do something time-consuming, try to do it always asynchronously.</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scalability</title>
      <link href="2019/12/18/Scalability/"/>
      <url>2019/12/18/Scalability/</url>
      
        <content type="html"><![CDATA[<blockquote><p><a href="https://www.youtube.com/watch?v=-W9F__D3oY4" target="_blank" rel="noopener">CS75 Lecture 9: Scalability</a></p></blockquote><h2 id="Vertical-Scaling"><a href="#Vertical-Scaling" class="headerlink" title="Vertical Scaling"></a>Vertical Scaling</h2><p>Get more RAM, processors, disks for one machine, but you will exhaust the financial resources/state.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/00.jpg" alt></p><h2 id="Horizontal-Scaling"><a href="#Horizontal-Scaling" class="headerlink" title="Horizontal Scaling"></a>Horizontal Scaling</h2><p>Plural number of machines, use multiple servers to build the topology.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/01.jpg" alt></p><a id="more"></a><h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><h3 id="html"><a href="#html" class="headerlink" title=".html"></a>.html</h3><p>Requires a lot of work when want to update/redesign the page.</p><h3 id="MySQL-Query-Cache"><a href="#MySQL-Query-Cache" class="headerlink" title="MySQL Query Cache"></a>MySQL Query Cache</h3><p>query_cache_type = 1</p><h3 id="Memcached"><a href="#Memcached" class="headerlink" title="Memcached"></a>Memcached</h3><p>Store whatever you want in RAM.<br><strong>G</strong>arbage <strong>C</strong>ollection: expire objects based on when they are put in.</p><h2 id="Load-Balancing"><a href="#Load-Balancing" class="headerlink" title="Load Balancing"></a>Load Balancing</h2><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/02.jpg" alt></p><h3 id="Implementation"><a href="#Implementation" class="headerlink" title="Implementation"></a>Implementation</h3><ul><li>Dedicated servers for images, videos… for different host <strong>HTTP header</strong>.</li><li><strong>Round Robin</strong>. The load balancer can be a DNS setup which returns the IP address of server 1 when the first time someone asks for a URL, then return the IP address of server 2 when the second time someone asks for the same url, then server 3, server 4… eventually wrapping up.<ul><li>Downside: one server may get a really computational heavy user.</li></ul></li><li>Based on the load on a server.</li><li>Have a server specifically for storing sessions. But what if that machine breaks down. Lacks redundancy, can add RAID (<strong>R</strong>edundant <strong>A</strong>rray of <strong>I</strong>ndependent <strong>D</strong>isks).</li></ul><h3 id="Load-Balancers"><a href="#Load-Balancers" class="headerlink" title="Load Balancers"></a>Load Balancers</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/03.jpg" alt></p><h2 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h2><h3 id="Master-Slave"><a href="#Master-Slave" class="headerlink" title="Master-Slave"></a>Master-Slave</h3><p><strong>Master</strong>: the main database that you write/read data to/from.<br><strong>Slave</strong>: anytime a query is executed on the master that same query is copied down to one or more slaves and they do the exact same thing.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/04.jpg" alt></p><h4 id="Advantage"><a href="#Advantage" class="headerlink" title="Advantage"></a>Advantage</h4><ul><li>If the <strong>master is down</strong>, promote one of the slaves and do some configuration. (redundancy)</li><li>If there are a lot queries, you could just <strong>load balance across</strong> database servers.</li><li>For read heavy websites, any <code>select</code> can go to all four databases, while any <code>insert/update/delete</code> has to go to server master.</li></ul><h3 id="Master-Master"><a href="#Master-Master" class="headerlink" title="Master-Master"></a>Master-Master</h3><p>You could write to either server one or two and if you happen to write to server 1 that query gets replicated on server 2 and <strong>vice versa</strong>, so now you could keep it simple.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/05.jpg" alt></p><h3 id="Load-Balancing-Replication"><a href="#Load-Balancing-Replication" class="headerlink" title="Load Balancing + Replication"></a>Load Balancing + Replication</h3><p><code>active + passive pair</code> of load balancers, passive promote itself when receives no more packets from the active one, and send packets to each other.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/06.jpg" alt></p><h2 id="Partitioning"><a href="#Partitioning" class="headerlink" title="Partitioning"></a>Partitioning</h2><p>A-M cluster and N-Z cluster:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/07.jpg" alt></p><h3 id="High-Availability"><a href="#High-Availability" class="headerlink" title="High Availability"></a>High Availability</h3><p>One load balancer, two master replicating each other:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SystemDesign/00/08.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> SystemDesign </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Telephoning</title>
      <link href="2019/12/05/Telephoning/"/>
      <url>2019/12/05/Telephoning/</url>
      
        <content type="html"><![CDATA[<h2 id="Cold-calling"><a href="#Cold-calling" class="headerlink" title="Cold calling"></a>Cold calling</h2><blockquote><p>Do you have a moment to speak to me?</p></blockquote><h3 id="USEFUL-TIPS"><a href="#USEFUL-TIPS" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When cold calling (approaching <strong>prospective clients or customers</strong> for the first time), keep the following points in mind:</p><ul><li><strong>Be clear and concise</strong> about who you are and the purpose of the call;</li><li><strong>Use questions</strong> to help and guide the person you are calling;</li><li><strong>Always use titles</strong> (such as Dr., Mr., and Ms.) and never first names;</li><li><strong>Don’t be offended by hostile behavior.</strong> It’s not personal;</li></ul><h3 id="Track-24"><a href="#Track-24" class="headerlink" title="Track 24"></a>Track 24</h3><p>Macey C: This is Macey Chance from Turner &amp; Young Consultants. Am I speaking to Mr. Given?<br>Speaker 1: No.</p><a id="more"></a><p>Mr. H: Trancross Power and Gas, project management office.<br>MC: Good morning. <strong>Am I speaking to</strong> Mr. Harvey?<br>Mr. H: Speaking.<br>MC: Oh hello, Mr. Harvey. <strong>This is Macey Chance from</strong> Turner &amp; Young Consultants.<br>Mr. H: Oh, yes.<br>MC: <strong>Do you have a moment to speak to me?</strong><br>Mr. H: Um… well, yeah.<br>MC: Thank you. <strong>My company specializes in</strong> helping power industry companies manage risk, Mr. Harvey. <strong>Do you think that’s something that might be of interest to you?</strong><br>Mr. H: Er… well, we have risk management plans in place, you know.<br>MC: I’m sure! But <strong>may I ask you a question,</strong> Mr. Harvey? Do you have plans in place for handling risks generated by climate change?<br>Mr. H: Um, it depends on what you mean exactly. Of course, we have plans in place for damage to our power plants from bad weather.<br>MC: Well, managing short-term risk is very important of course. But <strong>would you like to find out about</strong> ways to manage risk caused by long-term adjustments to weather patterns? I’m thinking about global warming and the impact that will have on energy supplies.<br>Mr. H: Um, that’s very unpredictable, isn’t it?<br>MC: Yes, you’re quite right, Mr. Harvey. And very risky. That’s why my company specializes in designing plans that minimize the risks for companies like yours. <strong>Would it be possible to arrange a meeting where I could explain</strong> our services in more detail?<br>Mr. H: Well, it could be interesting.<br>MC: Fine. <strong>When’s a good time for you,</strong> Mr. Harvey?<br>Mr. H: Er, let me just check my appointments. Um, how about Friday this week, 2 PM?</p><h2 id="Confirming-or-rearranging-appointments"><a href="#Confirming-or-rearranging-appointments" class="headerlink" title="Confirming or rearranging appointments"></a>Confirming or rearranging appointments</h2><blockquote><p>I look forward to seeing you then.</p></blockquote><h3 id="USEFUL-TIPS-1"><a href="#USEFUL-TIPS-1" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>Once you have fixed your appointment with a business partner, <strong>telephone a couple of days beforehand</strong> to confirm the details of your meeting. Keep the following points in mind:</p><ul><li>Confirm the <strong>topic, date, time and place</strong>;</li><li>Be ready with <strong>alternative appointment times</strong> if the original time has to be changed;</li><li>Check to see if the customer has <strong>any new requests</strong>;</li></ul><h3 id="Track-29"><a href="#Track-29" class="headerlink" title="Track 29"></a>Track 29</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>Sabine G: Sabine Gerland.<br>Robbie T: Hello, Ms. Gerland. This is Robbie Taylor from Queensfield Ltd. How are you?<br>SG: Fine, thanks. And you?<br>RT: Very well. <strong>I’m just ringing to confirm our appointment for Tuesday afternoon at 3 PM</strong> to discuss our project management services for the Potsdam project.<br>SG: Yes, that’s right. I’m looking forward to it.<br>RT: <strong>Can I just check the address? That’s Quiddestrasse 14, isn’t it?</strong><br>SG: Er, no, Quiddestrasse 40.<br>RT: Right, 40, OK. And <strong>could you spell Quidde for me?</strong><br>SG: Of course. That’s Q-U-I-D-D-E. If you go to our website, you’ll find full directions.<br>RT: Right. Thanks. So, <strong>I look forward to seeing you then</strong>.</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>RT: Queensifield Ltd. Robbie Taylor.<br>Gerhard S: Oh hi, this is Gerhard Schmidt calling from Hipax in Berlin.<br>RT: Oh, hello Mr. Schmidt. How are you?<br>GS: I’m fine, thank you. And you?<br>RT: I’m well, thanks.<br>GS: Good. I’m afraid I have to cancel our meeting next Tuesday morning. I’m going to be away visiting one of our key customers.<br>RT: <strong>No problem. Would Wednesday afternoon be more convenient?</strong><br>GS: Unfortunately not. One colleague I wanted to come to our meeting will be in Paris and I’ll be in Munich.<br>RT: I see. Well, <strong>would you like me to arrange a telephone conference</strong> instead?<br>GS: Mmm, that’s a good idea. We’re both free at 2 PM on Wednesday. Will you email me the details?<br>RT: Of course. Actually, I wanted to call you anyway, Mr. Schmidt. <strong>Would you or your colleagues be interested in any of our other project management services, like logistics, for example?</strong></p><h2 id="Making-a-complaint-on-the-telephone"><a href="#Making-a-complaint-on-the-telephone" class="headerlink" title="Making a complaint on the telephone"></a>Making a complaint on the telephone</h2><blockquote><p>I’m afraid I need to make a complaint.</p></blockquote><h3 id="USEFUL-TIPS-2"><a href="#USEFUL-TIPS-2" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When making a complaint, keep the following points in mind:</p><ul><li>Make sure you are speaking to <strong>the person who is in a position to help you</strong>. Ask questions to check who exactly you are talking to and take notes;</li><li>Stay as unemotional as possible. Blaming the person you are calling will not help. <strong>Separate the problem from the person.</strong> Be firm, but polite;</li><li>State the problem clearly and calmly. <strong>Include as much relevant detail as possible,</strong> including names, times, places, pervious contacts, and so on;</li><li><strong>State exactly what you want</strong> the person you are calling to do;</li><li>Check <strong>when you can expect results/feedback</strong> from the person you are speaking to;</li></ul><h3 id="Track-34"><a href="#Track-34" class="headerlink" title="Track 34"></a>Track 34</h3><p>Receptionist: Alpine Executive Events Ltd, London. Priti Makesch speaking. How can I help you?<br>Andrea K: Good morning, my name is Andrea King. I’m the HR manager for Carabella Hotels. <strong>Could I speak to your supervisor, please?</strong><br>R: Can I ask what it’s regarding?<br>AK: <strong>I need to make a complaint.</strong><br>R: I’ll just put you through to Mr. Mendip. One moment, please.</p><p>George M: Good morning, Ms. King. How can I help?<br>AK: Good morning. <strong>Could you tell me your name and position, please?</strong><br>GM: Of course, my name’s George Mendip and I’m responsible for customer relations.<br>AK: Thank you, Mr. Mendip. <strong>I’ll just make a note of that.</strong> I hope you can help me. I’m currently attending your team-building training course in Wales with a team of our managers.<br>GM: The “Big T” course. Very popular.<br>AK: Well, <strong>I’m afraid I’m not satisfied with</strong> the performance of your trainer, David Llewellyn.<br>GM: Oh dear. What seems to be the problem?<br>AK: He’s very unhelpful and doesn’t explain himself properly.<br>GM: How do you mean?<br>AK: Well, he talks extremely fast and makes all the instructions very complicated. And if you ask him a question, he just says he’s already explained it. I tried to talk to him about the problem, but he didn’t take me seriously at all. The situation is entirely unsatisfactory.<br>GM: I see… Well, I’m sorry to hear that, but I’m not sure what I can do.<br>AK: <strong>I’d like you to</strong> telephone Mr. Llewellyn immediately and explain that we want much clearer explanations and support for tomorrow’s tasks.<br>GM: Well, OK, I could give him a ring.<br>AK: And <strong>could you let me know when you have</strong> spoken to him, please?<br>GM: Yes, I will.<br>AK: <strong>When will you get back to me?</strong> Do you have my number?<br>GM: I think so… Yes, I do. I’ll back to you by, um, the end of today.<br>AK: Many thanks. I really appreciate your help on this.<br>GM: Not at all.</p><h2 id="Dealing-with-a-complaint-on-the-telephone"><a href="#Dealing-with-a-complaint-on-the-telephone" class="headerlink" title="Dealing with a complaint on the telephone"></a>Dealing with a complaint on the telephone</h2><blockquote><p>Oh dear, I’m sorry to hear that.</p></blockquote><h3 id="USEFUL-TIPS-3"><a href="#USEFUL-TIPS-3" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When dealing with a complaint, keep the following points in mind:</p><ul><li>Let the caller express their complaint. <strong>Don’t interrupt,</strong> but try to get all the details. <strong>Take notes</strong>;</li><li>Once they have finished complaining, <strong>summarize the complaint,</strong> clarify any unclear details and show empathy;</li><li>Apologize. <strong>Don’t try to make excuses</strong> but provide an explanation if the customer requests one;</li><li>State <strong>what you are going to do</strong> to resolve the situation;</li><li>Tell the customer <strong>when they can expect results/feedback</strong>;</li><li>Stay calm with the customer at all times. <strong>Separate the problem from the person</strong>;</li></ul><h3 id="Track-39"><a href="#Track-39" class="headerlink" title="Track 39"></a>Track 39</h3><p>Kelly M: Argonaut Mediterranean Cruises Ltd.<br>Tony H: Ah, this is Tony Hopps here. Is that Kelly Masterman, the general manager?<br>KM: Speaking.<br>TH: Ah, right. Well, you listen here. Ms. Masterman. I’ve just arrived home from one of your eastern Mediterranean cruise ships - Queen of the Waves - and I’m not at all happy. I’ve got a whole list of complaints.<br>KM: <strong>Oh dear, I’m sorry to hear that.</strong> Let me just get a pen and I’ll note them down. Right, <strong>can you give me the details?</strong><br>TH: Well, first of all, we booked an expensive cabin on the outside of the ship. But there was a problem with that cabin and there were no others available on the outside. So we had to have one in the middle of the ship and my wife spent 3 days feeling really seasick. Then, for the buffet lunch, it was supposed to be an all-you-can-eat buffet, but when we got there at 2 PM, we found that there were only a few bits of cheese and salad left for us. And then, in the programme for Saturday evening, it said there was a fancy-dress party. So we dressed up, but we found that everybody else was just in jeans and T-shirts. It was so embarrassing!<br>KM: Oh, <strong>you must have felt terrible!</strong><br>TH: Yes, we did. And finally, I sent my costume to the ship’s laundry to be cleaned and it got lost. That really was the last straw!<br>KM: <strong>So, let me just recap.</strong> In a nutshell, you didn’t get the cabin you ordered, the buffet lunch was finished by the time you got there, the fancy-dress party listed in the programme didn’t take place, and your costume was lost.<br>TH: That’s right.<br>KM: Well, first of all, we’re not going to try to pass the buck here, so <strong>we would like to apologize to you for</strong> these problems. This is what I propose: I’m going to call the ship and see if I can find out what was going on. Can I call you back in 20 minutes?<br>TH: Um… yes, that’s fine. Do you have my number? It’s…</p><p>TH: Tony Hopps speaking.<br>KM: Hello, Mr. Hoops. It’s Kelly Masterman. I spoke to the ship’s first officer. It seems that the porthole in your cabin was broken by the previous passenger and water was coming in. But he apologized for not explaining what the problem was to you. <strong>I’m afraid we can’t refund</strong> the whole cost of the trip, but we can refund you the extra cost for the cabin that you didn’t have.<br>TH: Hmm, that doesn’t seem much. And my fancy-dress costume?<br>KM: On our website you can find a document for insurance claims. Send in the form and <strong>we’ll deal with that within a week.</strong> But, as I said, <strong>we are really very sorry for</strong> these difficulties. So, <strong>we would like to offer you</strong> a 10% discount the next time you book an Argonaut holiday <strong>as compensation for</strong> the problems you had. Is that acceptable to you, Mr. Hoops?<br>TH: Well, er, yes, I think that sounds reasonable.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SPEAKING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interviews</title>
      <link href="2019/11/10/Interviews/"/>
      <url>2019/11/10/Interviews/</url>
      
        <content type="html"><![CDATA[<h2 id="The-successful-job-interviewer"><a href="#The-successful-job-interviewer" class="headerlink" title="The successful job interviewer"></a>The successful job interviewer</h2><blockquote><p>What makes you suitable for this job, do you think?</p></blockquote><h3 id="USEFUL-TIPS"><a href="#USEFUL-TIPS" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When interviewing for a job, there are <code>4 main areas</code> to ask about:</p><ul><li>work history;</li><li>personality;</li><li>suitability for the company and the specific job;</li><li>goals and ambitions;</li></ul><p>Note that it is not appropriate to ask the candidate questions about <strong>race, age, marital status, or sexual preferences</strong>. These questions are potentially discriminatory.</p><a id="more"></a><h3 id="Track-83"><a href="#Track-83" class="headerlink" title="Track 83"></a>Track 83</h3><p>Christ H: …and so your online resume was very interesting and that’s why we asked you to come for an interview. I’m responsible for all human resources issues here at Bergerbild and my colleagues here, Georgina Harris, is head of the sales department, which is where we currently have a position free.<br>Georgina H: Hello, nice to meet you.<br>Mansha K: Hi, nice to meet you too.<br>CH: Fine. So Mr. Khan, <strong>what do you know about our company?</strong><br>MK: A lot! You’re involved in big overseas infrastructure projects in South-East Asia, for example, and among other things you are currently bidding for…<br>CH: …and the Kuching metro project was very successful. But coming back to you, Mr Khan, <strong>what do you feel has been your biggest achievement to date?</strong><br>MK: Well, I introduced a new process for prioritizing customer visiting schedules for our department and in 6 months, we managed to increase sales by about 22 percent. My manager was very pleased!<br>CH: Hmm, I can understand why. So, <strong>why would you like to leave your current job?</strong><br>MK: Well, the sales position that you are offering would give me opportunities to work internationally. At the moment I’m just based in Seattle.<br>GH: I see. But <strong>what makes you suitable for this job, do you think?</strong><br>MK: I’ve been very successful so far in sales and I think that I can offer a good service to your customers.<br>CH: Interesting point. <strong>What is good customer service, in your view?</strong><br>MK: Definitely the most important skill is the ability to listen to what…<br>GH: Very true. Now, <strong>what are your weaknesses, would you say?</strong><br>MK: Well, my mom criticizes my untidiness around the house, but I guess you don’t mean that. Hmm, I suppose I’m not very good at making sure all the paperwork involved in sales is completed quickly. You know, I prefer to be out there, going on to the next customer. But of course, I know it has to be done. I’m trying to improve.<br>GH: Well, you are quite young, aren’t you?<br>MK: I’m 26.<br>CH: Right. Now, <strong>what are your goals for the next 5 years?</strong><br>MK: I hope that I can also take on responsibility for organizing other salespeople in the future. I see myself in a management position when I have more experience and can share that experience with other salespeople.<br>GH: OK. Now, <strong>what are your salary expectations?</strong> For this sales position, I mean?<br>MK: Well, I’m sure that a mixture of…</p><h2 id="The-successful-interview-candidate"><a href="#The-successful-interview-candidate" class="headerlink" title="The successful interview candidate"></a>The successful interview candidate</h2><blockquote><p>So, tell me about yourself.</p></blockquote><h3 id="USEFUL-TIPS-1"><a href="#USEFUL-TIPS-1" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><ul><li>Answer questions fully. <strong>Avoid very short answers</strong>;</li><li>Be sure about the details on your resume, and be prepared to talk about your achievements and experience <strong>in depth</strong>;</li><li><strong>Research the background</strong> of the company or organization;</li><li>Listen carefully to the questions you are asked. Answer them with <strong>relevant information</strong>;</li></ul><h3 id="Track-88"><a href="#Track-88" class="headerlink" title="Track 88"></a>Track 88</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>Karl: <strong>I see from your resume</strong> that you have web design experience as well as in sales.<br>Candidate 1: Yes, that’s right.<br>K: Hmm. That could be interesting for the development of our Internet presence in Europe. Our website is very US-oriented at the moment.<br>C1: Well, it’s something I really enjoy doing. In my current job I was part of a team that did a redesign of the company website and I learned a lot.<br>K: What software can you work with?<br>C1: Well, I can use Dreamweaver, which is the classic web design tool of course, but I’ve also got experience of using…</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>K: So, <strong>do you think you can make a useful contribution</strong> to this company?<br>Candidate 2: Oh, yes.<br>K: I see.<br>C2: Yes.<br>K: Is your previous experience suitable for this position?<br>C2: Hmm. Yes. Yes, definitely.<br>K: And you don’t think it would be difficult moving into a management position?<br>C2: No, I don’t think so.<br>K: Really?<br>C2: No, not at all.<br>K: Right.</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>K: Perhaps you could tell me, <strong>what do you know about this company?</strong><br>Candidate 3: Well, I know you have been very active in India over the last 5 years with the Mumbai City Transit System. What was it now? A 2 billion-dollar contract to provide not only the trains but also all the electronic equipment for the system, I think.<br>K: Yes, quite a difficult project. We had a lot of trouble with subcontractors.<br>C3: Yes, I understand it was very challenging. But in the end of the project was completed on time and within budget. So you must have been pleased with the final result.<br>K: That’s true and, of course, it is an excellent reference project for us…</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>K: Now, could you tell me, <strong>what are your greatest strengths and weakness,</strong> in your opinion?<br>Candidate 4: Hmm, that’s an interesting question. Well, I think my greatest strength is that I never give up. In my experience, in order to win a customer you just have to really go on and on looking for a way to give them what they want and then you get the sale.<br>K: True. And what about weaknesses?<br>C4: Well, I need to improve my team player skills. Like many salespeople I don’t like sharing customer information with other salespeople, but sometimes it makes the customer angry when he or she gets a visit from 2 different salespeople with different products from the same company. So, I realize it’s necessary to share information, but it isn’t easy for me to put this into practice.<br>K: Right. Well, here at Bergerbild, teamwork is very important.<br>C4: Yes, yes, I agree. I’m just telling you what I think is my greatest weakness. And I’m working on it.</p><h4 id="5"><a href="#5" class="headerlink" title="5"></a>5</h4><p>K: So, perhaps you could tell me, <strong>what has been your biggest achievement to date?</strong><br>Candidate 5: Oh well, I took part in this quiz competition a few years ago when I was at university. I was the head of the team and we got to the final of the national tournament. And we only just missed out on the top prize. So, there we were in the final round and the other team came from Cambridge…<br>K: Sorry, I meant more in the way of…<br>C5: and we both had eighteen points each and the question came up “What are the main tributaries of the Volga?” Now I knew that.<br>K: I meant what was your biggest achievement at work?<br>C5: Oh, sorry, yes. Um, well, in my current job we have a team which takes part in quiz competitions in pubs and last year we got to the finals. There we were, facing a team from a pub in Cambridge when…</p><h2 id="Carrying-out-performance-reviews"><a href="#Carrying-out-performance-reviews" class="headerlink" title="Carrying out performance reviews"></a>Carrying out performance reviews</h2><blockquote><p>How do you feel about your performance this year?</p></blockquote><h3 id="USEFUL-TIPS-2"><a href="#USEFUL-TIPS-2" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>The purpose of the performance review is for the line manager to review what the employee does, evaluate how well they perform, and discuss objectives for the next year. The line manager should:</p><ul><li><strong>discuss the scope of the job</strong>, for example the job description, the employee’s responsibilities, and any changes to them;</li><li>find out the employee’s opinion of their performance, and then present <strong>their own assessment supported by evidence</strong>;</li><li>set <code>SMART</code> - <strong>S</strong>pecific, <strong>M</strong>easurable, <strong>A</strong>ttainable, <strong>R</strong>elevant, and <strong>T</strong>imed - objects for the coming year.</li></ul><h3 id="Track-92"><a href="#Track-92" class="headerlink" title="Track 92"></a>Track 92</h3><p>Caterina: So, first of all, I’d like to check if we’re on the same page regarding your responsibilities. You supervise the sales staff for the whole south-eastern region, you’re a member of the European sales committee, and you coordinate the cooperation between the production team and marketing. <strong>Have I missed anything?</strong><br>Edward: Don’t forget, I’m captain of the company’s basketball team as well!<br>C: Of course not! Especially after you won the Intercompany Cup in April. <strong>Would you like to add anything else?</strong><br>E: No, I think that’s covered pretty much everything.<br>C: Good. So, <strong>how do you feel about your performance this year?</strong><br>E: Well, quite good. I hit all my sales targets we set in last year’s review.<br>C: Yes, that’s true. <strong>My impression is that</strong> you enjoy that part of your work most.<br>E: Hmm, well that is my main responsibility.<br>C: Quite right. However, working together with the production department is very important and <strong>I’ve observed that</strong> the cooperation between marketing and production hasn’t really improved. We still seem to have the same problems that we had last year.<br>E: I’m not quite sure what you mean.<br>C: Production still complains about lack of advance information from us.<br>E: Well, they are just so inflexible.<br>C: I quite agree. But the bottom line is, we have to work together. So, <strong>I would like you to establish</strong> a job rotation scheme. I want 2 salespeople to spend 6 months in production and 2 people from production to replace them in our sales team. That way, both departments will get a better idea of what needs to be done.<br>E: Oh… but they won’t know any of our customers!<br>C: Well, you’ll have to train them. <strong>I expect you to organize this by</strong> the end of the month.<br>E: The end fo the month?!<br>C: Yes. I’ve spoken to Tom Wilkinson in production and he agrees with me that this is the best way forward. He’ll set up a meeting with you for later this afternoon.<br>E: I see. Well, perhaps it will help.<br>C: Good. Now, let’s move on to discuss your development. <strong>Looking ahead,</strong> I think it would be a good idea if you took part in some project management training.<br>E: Sure. It’s definitely something I’m interested in.<br>C: Good, because <strong>down the line,</strong> project work is going to be where the best opportunities for promotion are in our company. And I feel <strong>you need to develop your leadership skills.</strong><br>E: Definitely. I mean I would really appreciate any opportunities I get to improve on that aspect of my work.</p><h2 id="Persuading-your-manager"><a href="#Persuading-your-manager" class="headerlink" title="Persuading your manager"></a>Persuading your manager</h2><blockquote><p>Would you be willing to support my request?</p></blockquote><h3 id="USEFUL-TIPS-3"><a href="#USEFUL-TIPS-3" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>If you want to ask for something special from your manager, you need to <strong>be well prepared</strong>.</p><ul><li>Be proactive. <strong>Ask your manager for a meeting</strong> to discuss what is on your mind;</li><li>Persuade, don’t threaten. Decide what exactly you want and be prepared to justify your demands <strong>with logical arguments, rather than emotional ones</strong>;</li><li>Be ready to negotiate. Think in advance about <strong>the best alternative</strong> to your preferred solution;</li><li><strong>Remain polite</strong>. Whatever the result, always thank your manager for their time at the end of the meeting. You still have to work with them;</li></ul><h3 id="Track-96"><a href="#Track-96" class="headerlink" title="Track 96"></a>Track 96</h3><p>Candy: Hi John! Do you have a moment?<br>John: Sure, Candy. What can I do for you?<br>C: <strong>I’d like to schedule a meeting with you to talk about my position.</strong> When’s a good time for you?<br>J: Er, well, it’s probably best if you fix a time with my secretary, OK?<br>C: Fine. I’ll do that.</p><p>J: Come in, Candy, take a seat. Now, what can I do for you?<br>C: Well, <strong>I’d like to discuss my compensation package with you.</strong><br>J: Really? I thought you were happy with the increase we gave you last year!<br>C: Yes, but <strong>I hope you’ll agree that</strong> since last year I’ve achieved such a lot and we need to consider these achievements. For example, I was responsible for organizing the conference in Astana last month and… and finally, I managed the IOS 9001 audit, which we successfully completed. So, <strong>wouldn’t you agree that my performance this year has been</strong> very successful?<br>J: Well, yes. But what exactly do you want?<br>C: I understand that this year the pay increase is between 3 and 8 percent. <strong>I would like to ask</strong> for a raise at the top end of that scale.<br>J: Ooh! I don’t know about that, Candy, I mean, what about the others?<br>C: If you look at my responsibilities in comparison to my colleagues, I am currently underpaid. <strong>Wouldn’t you say this should be taken into consideration?</strong><br>J: I’m not sure that is really quite true, Candy.<br>C: Oh, I think so. I checked. Compared to programmers in other companies, I’m earning about 4 percent less than the market average. Here are the figures.<br>J: Are you saying you want to leave?<br>C: No, I just want you to know the background to my request, that’s all. <strong>I’m sure you can see that</strong> it wouldn’t be hard for me to get a better paid job elsewhere.<br>J: I see.<br>C: So, <strong>would you be willing to support my request for</strong> a higher wage increase?<br>J: Well, the problem is also your qualifications. Even though you are a fantastic programmer, you don’t have the qualifications on paper for me to justify to the HR department putting you into a higher salary level.<br>C: <strong>I thought that might be a problem.</strong> So, <strong>wouldn’t it make sense for</strong> the company to invest in sending me on an advanced programming skills course? The company benefits from my improved skills, I have the necessary qualifications on paper and you could then justify to the HR department paying me more. I hope you’ll agree that would be a win-win situation for everybody.<br>J: Hmm. I need to think about this idea.<br>C: Sure. I’ll find a time for another meeting towards the end of the week with your secretary. But <strong>thanks for your time today.</strong> I do appreciate that.</p>]]></content>
      
      
      
        <tags>
            
            <tag> SPEAKING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Presentations and Conferences</title>
      <link href="2019/10/21/Presentations-and-Conferences/"/>
      <url>2019/10/21/Presentations-and-Conferences/</url>
      
        <content type="html"><![CDATA[<h2 id="Presenting-a-product-or-service"><a href="#Presenting-a-product-or-service" class="headerlink" title="Presenting a product or service"></a>Presenting a product or service</h2><blockquote><p>I want to tell you today about…</p></blockquote><h3 id="USEFUL-TIPS"><a href="#USEFUL-TIPS" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When presenting a product or service, an effective way to convince your audience is to follow the <code>FAB</code> approach:</p><ul><li><strong>Feature:</strong> highlight the features of the product or service you want the audience to focus on;</li><li><strong>Advantage:</strong> show how these features make the product or service better than its predecessors or competitors;</li><li><strong>Benefit:</strong> show how this product or service will improve the user’s life;</li></ul><p>This approach can be grouped into a 3-step presentation structure:</p><ol><li><strong>Introduction:</strong> summarize what you are going to tell the audience;</li><li><strong>Main body:</strong> tell them;</li><li><strong>Conclusion:</strong> tell them what they should do next;<a id="more"></a></li></ol><h3 id="Track-64"><a href="#Track-64" class="headerlink" title="Track 64"></a>Track 64</h3><p>Steve: Well, <strong>good afternoon, ladies and gentlemen.</strong> I’m Steve Dunn <strong>and I want to tell you today about</strong> Compix’s new CRM application for your iPhone, the iCustomer. <strong>Firstly, I’ll demonstrate</strong> exactly what this software is capable of doing. <strong>Then, I’ll outline</strong> the advantages this has over conventional CRM systems. <strong>Finally, I’ll show</strong> you how this can help boost the productivity of your salesforce significantly. <strong>So, first of all,</strong> as a salesman I can tell you what we all want is up-to-the-minute information about our customers. iCustomer links your salespeople directly with your central customer database so that at anytime they can check what exactly the… without any time lost. <strong>Moving on to my next point, what are the advantages of</strong> the real-time information provided by iCustomer over other CRM systems? Well, it means that for the first time ever your salespeople always have up-to-date details about your customers. Current credit ratings for example, any problems with recent orders or maybe a new special offer that headquarters wants… of course, because it has a phone function. <strong>So, finally, what are the real benefits</strong> for your salespeople? 2 words: increased productivity. Our research shows that salespeople are able to make at least 15 percent more customer visits per week, leading to an increased sales volume of up to 30 percent and that’s not all. With… <strong>In conclusion,</strong> if you commit to using iCustomer, we are offering a free consultancy service for your business. Our experts will visit your company and… Thank you for listening. <strong>If anyone has any questions, I’d be happy to answer them.</strong><br>Customer: Yes, I do. Do you provide software training for users as part of the package?<br>Steve: <strong>I’m pleased that you asked that question.</strong> We don’t provide training ourselves, but our sister company is responsible for that and I’m sure we could discuss ways that we could incorporate that into the package…</p><h2 id="Working-on-a-stand"><a href="#Working-on-a-stand" class="headerlink" title="Working on a stand"></a>Working on a stand</h2><blockquote><p>Would you be interested in finding out more about this?</p></blockquote><h3 id="USEFUL-TIPS-1"><a href="#USEFUL-TIPS-1" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When working on a stand, <strong>ask questions</strong> rather than simply presenting products. This will give the stand visitor the feeling that the focus is on their interests and needs.</p><ul><li>Find out <strong>what business</strong> the visitor is in and who their customers are;</li><li>Find out what their <strong>customers want</strong>;</li><li>Find out what would <strong>make the visitor’s life easier</strong> and suggest ways to help them achieve that goal;</li></ul><h3 id="Track-67"><a href="#Track-67" class="headerlink" title="Track 67"></a>Track 67</h3><p>Amanda: Hi there. <strong>Can I help you?</strong><br>Colin: What? Oh me? I was just looking at some of these brochures.<br>A: Well, I’m Amanda.<br>C: Ah. I’m Colin.<br>A: <strong>What field of business are you in,</strong> Colin?<br>C: I’m a specialist publisher. I don’t really know much about computer software and hardware, I’m afraid. I publish books about stamp collecting.<br>A: <strong>Really? Who are your customers?</strong><br>C: Well, different types of people. Children, teenagers, adults, people who have retired… most male, of course.<br>A: I see. <strong>And what are your customers looking for?</strong><br>C: Well, information and books about stamps. Particularly prices, trade fairs or articles about the history of particular stamps.<br>A: OK… but <strong>what are the challenges you face in</strong> reaching them?<br>C: Well, there are lots of stamp collectors, but they’re all over the world. It’s very hard to reach them so it’s difficult to sell my company’s books. Normal bookshops won’t take them. So I put advertisements in stamp magazines, but that’s expensive.<br>A: Of course. Well, <strong>would you be interested in something to</strong> help you reach a worldwide audience, 24/7?<br>C: Using the Internet, I suppose I would. But I don’t know anything about programming.<br>A: Ah, but <strong>what would you think about</strong> a tool that does that for you? A tool that lets you just upload the documents that you want into a template? And one that also saves information about customers so you can…<br>C: …but that’s really very interesting. So you think that a free newsletter would help my business?<br>A: Definitely. At Compix, we have one that we send to our customers every quarter with information about new developments in the industry. In fact, <strong>can I add you to our mailing list?</strong><br>C: Hmmm, well yes, of course.<br>A: Great! <strong>Can you give me your card?</strong> Then I have all your details and I’ll make sure that you are kept up-to-date on what we’re doing…<br>C: That sounds great. Can I take one of these demo software packages?<br>A: <strong>Unfortunately, I’m afraid</strong> I can’t give you one today. <strong>I’m so sorry</strong> about that. But I can send you one.<br>C: OK. That’s better. That way I don’t have to carry it around with me all day.</p><h2 id="Closing-a-sale"><a href="#Closing-a-sale" class="headerlink" title="Closing a sale"></a>Closing a sale</h2><blockquote><p>We only have this offer for a short time.</p></blockquote><h3 id="USEFUL-TIPS-2"><a href="#USEFUL-TIPS-2" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When closing a sale, frame the sales pitch as <strong>an open question</strong> so that, if the customer has any questions or objections, it is still possible for the salesperson to respond. Once the request has been made, <strong>be quiet and let the customer decide!</strong><br>These are 3 possible styles for closing a sale:</p><ul><li>Hard close: <strong>assume that the customer wants to buy</strong> the product/service and ask for quantities or delivery dates;</li><li>Emotional close: point out to the customer <strong>the advantages</strong> of having the product or the disadvantages of not having it and appeal to their emotions;</li><li>Urgent close: tell the customer that the product is <strong>only available for a short time</strong> due to scarcity, or that the price will soon rise;</li></ul><h3 id="Track-73"><a href="#Track-73" class="headerlink" title="Track 73"></a>Track 73</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>Amanda: …really does the job, so with our PriceChex product scanner, you just scan the price tag of any product in a shop and it does an automatic Internet search and tells you if the price in the shop is fair. But that’s not all. It can also tell you where you can buy it cheaper! And it only costs $49.99!<br>Customer: Wow! That’s so cool! But I want to have a look around at the other stands first and then…<br>A: Sure. I understand. But I should tell you, <strong>we only have</strong> 10 of these items here at the trade fair…<br>C: Ah, um, I see. And how much did you say it cost?</p><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>Steve: …software performs an automatic Internet search and tells you if the price in the shop is fair. But that’s not all. It can also tell you where you can buy it cheaper! And it only costs $49.99!<br>C: That could be very useful for my team.<br>S: Definitely. So, <strong>how many can I put you down for?</strong><br>C: Um, I’m not quite sure. Well, I think I’ll take 2 for now and try them out with…</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>A: …But that’s not all. It can also tell you where you can buy it cheaper! And it only costs $49.99!<br>C: Really? My brother is always driving me crazy telling me how I paid too much for something.<br>A: Sounds like my mother-in-law. Just think. <strong>What will you feel like when</strong> you can scan something he’s bought and then tell him he could have got it 50 percent cheaper somewhere else?<br>C: That would be awesome! OK, I’ll take 2 and I’ll give him 1 for his birthday…</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>S: …It can also tell you where you can buy it cheaper! And it only costs $49.99!<br>C: I see. I need to think about it. I’ll come back tomorrow.<br>S: No problem. Only I wouldn’t want you to be disappointed. The PriceChex <strong>is only available at this price today! It’s a special promotion for</strong> the trade fair opening…<br>C: Oh dear! Well, could I reserve 1 and come back in a few minutes?</p><h2 id="Saying-“no”-politely"><a href="#Saying-“no”-politely" class="headerlink" title="Saying “no” politely"></a>Saying “no” politely</h2><blockquote><p>Thanks, but I have to say “no”.</p></blockquote><h3 id="USEFUL-TIPS-3"><a href="#USEFUL-TIPS-3" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>Saying “no” is difficult for many people. It is, however, quite possible to <strong>say no without causing offence</strong> by adopting these strategies:</p><ul><li><strong>Include an apology</strong> and, if possible, a brief explanation;</li><li>Suggest that saying no is <strong>not your personal wish</strong> but is imposed by outside circumstances, for example, regulations or another appointment;</li><li>Use emphasizers such as <code>really</code>, <code>so</code> and <code>very</code> with the word “sorry”;</li></ul><h4 id="1-1"><a href="#1-1" class="headerlink" title="1"></a>1</h4><p>Steve: …an automatic Internet search and tells you if the price in the shop is fair. But that’s not all. It can also tell you where you can buy a product cheaper! And it only costs $49.99!<br>Customer 1: That could be useful for my team.<br>S: Definitely. So, would you like to make an order straight away?<br>C1: <strong>I’d rather not, thank you.</strong> Although it is a nice piece of software.<br>S: Exactly! Now, what if I gave you 1 to take away for yourself and then if you like it you can keep that one but order 10 more for your team.<br>C1: <strong>I’m really sorry, but that’s not possible.</strong> Company policy doesn’t allow me to make that kind of deal.<br>S: I see. But let me just show you a couple of extra features that are so cool!<br>C1: <strong>No, I’m sorry,</strong> I have an appointment in 10 minutes. <strong>I don’t really have the time right now.</strong><br>S: But you really need to see the way this program can slice and dice any information that…<br>C1: <strong>Thanks, but I have to say no.</strong> Ah, Terry, there you are, shall we go for that meeting? I was beginning to think that…</p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2"></a>2</h4><p>Amanda: …an automatic Internet search and tells you if the price in the shop is fair. But that’s not all. It can also tell you where you can buy a product cheaper! And it only costs $49.99!<br>Customer 2: Well, that is interesting. I work for a computer magazine, which specializes in comparing different products.<br>A: Well, that’s perfect! And as a journalist we can give you a special discount price if you order 3 licenses. You only need to pay $125!<br>C2: <strong>Unfortunately, that’s just not possible.</strong> I’m a freelance journalist so I really don’t need 3 licenses.<br>A: I understand. But maybe if you wrote a friendly article about us, you could have 1 license for nothing.<br>C2: <strong>Sorry, but that’s out of the question.</strong> I’d lose my job! We have to keep our independence from the computer industry.<br>A: I see. But would it be possible for me to visit your company later this month and maybe I could do a presentation for you and your colleagues?<br>C2: Well, thanks, <strong>I’ll get back to you on that one.</strong> I must go now, but I have your card so I could give you a ring next week, if you like. Now I have to…</p>]]></content>
      
      
      
        <tags>
            
            <tag> SPEAKING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubernetes - 生产级容器集群平台</title>
      <link href="2019/09/04/Kubernetes-%E7%94%9F%E4%BA%A7%E7%BA%A7%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%B9%B3%E5%8F%B0/"/>
      <url>2019/09/04/Kubernetes-%E7%94%9F%E4%BA%A7%E7%BA%A7%E5%AE%B9%E5%99%A8%E9%9B%86%E7%BE%A4%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>Kubernetes 是 Google 团队发起并维护的开源容器集群管理系统，底层<strong>基于 Docker、rkt 等容器技术</strong>，提供强大的应用管理和资源调度能力。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kubernetes 是 Google 公司于 2014 年开源的容器集群管理项目。该项目<strong>基于 Go 语言实现</strong>，遵守 Apache v2 许可，试图为基于容器的应用部署和生产管理打造一套强大并且易用的操作平台。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Kubernetes/01.png" alt><br>目前被云原生计算基金会（Cloud Native Computing Foundation，CNCF）管理，以开源项目形式持续演化。<br>Kubernetes 拥有鲜明的技术优势：</p><ul><li>优秀的 API 设计，以及简洁高效的架构设计；</li><li>基于微服务模式的多层资源抽象模型，兼顾灵活性与可操作性；</li><li><strong>可拓展性好</strong>，模块化容易替换，伸缩能力极佳；</li><li>自动化程度高，真正实现<code>所得即所用</code>；</li><li>部署支持多种环境，包括虚拟机、裸机部署，还很好支持常见云平台；</li><li>支持丰富的运维和配置工具，方便用户对集群进行性能测试、问题检查和状态监控；</li><li>自带控制台、客户端命令等工具。</li></ul><a id="more"></a><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><p>要想深入理解 Kubernetes 的特性和工作机制，首先要掌握 Kubernetes 模型中的<strong>核心概念</strong>。这些核心概念反映了 Kubernetes 设计过程中，对应用容器集群的认知模型。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Kubernetes/02.png" alt><br>Kubernetes 中每种对象都拥有一个对应的<strong>声明式 API</strong>。对象包括<strong>三大属性</strong>：元数据（metadata）、规范（spec）和状态（status）。<br>每个对象可以使用一个外部的 <strong>JSON 或 YAML 模板文件</strong>来定义，通过参数传递给命令或 API。<br>基础的操作对象，主要是指<strong>资源抽象对象</strong>，包括：</p><ul><li>容器组（Pod）：Kubernetes 中<strong>最小的资源单位</strong>。由位于同一节点上的若干容器组成，彼此<strong>共享网络命名空间和存储卷</strong>。Pod 是短暂的，随时可变的，通常<strong>不带有状态</strong>；除了应用容器外，还包括一个初始的 <code>Pause 容器</code>，完成网络和存储空间的初始化；</li><li>服务（Service）：对外提供某个特定功能的一组 Pod 和所关联的访问配置。Kubernetes 通过服务提供<strong>唯一固定的访问地址</strong>，不随后面的 Pod 改变而变化；</li><li>存储卷（Volume）：提供数据的<strong>持久化存储</strong>，并支持更高级的生命周期管理和参数指定功能，支持多种本地和云存储类型；</li><li>命名空间（Namespace）：Kubernetes <strong>通过命名空间来实现虚拟化</strong>，将同一组物理资源虚拟为不同的抽象集群，避免不同租户的资源发生命名冲突。</li></ul><p>为了方便操作这些基础对象，Kubernetes 还引入了高级抽象概念——<strong>控制器（Controller）</strong>。这些控制器面向特定场景提供了自动管理 Pod 功能：</p><ul><li>副本集（ReplicaSet）：使用它可以让集群中始终维持某个 Pod 的指定副本数的健康实例。副本集中的 <strong>Pod 相互并无差异，可以彼此替换</strong>；</li><li>部署（Deployments）：比副本集更高级的抽象，可以<strong>管理 Pod 或副本集</strong>，并且支持升级操作；</li><li>状态集（StatefulSets）：管理带有状态的应用，可以<strong>为 Pod 分配独一无二的身份</strong>，确保在重新调配等操作时也不会相互替换；</li><li>Daemon 集（DaemonSet）：<strong>确保节点上肯定运行某个 Pod</strong>，一般用来采集日志（logstash）、监控节点（collectd）或提供存储（glusterd）使用；</li><li>任务（Job）：适用于<strong>短期处理场景</strong>；</li><li>横向 Pod 扩展器（Horizontal Pod Autoscaler，HPA）：根据 Pod 的使用率自动调整一个部署里面 Pod 的个数，<strong>保障服务可用性</strong>；</li><li>入口控制器（Ingress Controller）：定义外部<strong>访问集群中资源的一组规则</strong>，用来提供七层代理和负载均衡服务。</li></ul><p>此外，还有一些管理资源相关的<strong>辅助概念</strong>：</p><ul><li>标签（Label）：键值对，用来对资源进行分类和筛选；</li><li>选择器（Selector）：正则表达式，可通过标签来筛选出一组资源；</li><li>注解（Annotation）：键值对，用来添加对资源对象的详细说明，可供其他工具处理；</li><li>秘密数据（Secret）：存放敏感数据；</li><li>名字（Name）：用户提供给资源的别名；</li><li>服务账号（Service Accounts）：操作资源的用户账号。</li><li>持久化存储（Persistent Volumes）：确保数据不会丢失；</li><li>安全上下文（Security Context）：应用到容器上的系统安全配置；</li><li>资源限额（Resource Quotas）：用来限制某个命名空间下对资源的使用；</li></ul><h2 id="资源抽象对象"><a href="#资源抽象对象" class="headerlink" title="资源抽象对象"></a>资源抽象对象</h2><p>Kubernetes 对集群中的资源进行了不同级别的抽象，每个资源都是一个 REST 对象，通过 API 进行操作，通过 JSON 或 YAML 格式的<code>模版文件</code>进行定义。</p><blockquote><p>在使用 k8s 的过程中，要注意积累这些模版文件。</p></blockquote><h3 id="容器组"><a href="#容器组" class="headerlink" title="容器组"></a>容器组</h3><p>Kubernetes 并不直接操作容器，最小的管理单位是容器组（Pod）。同一个容器组中，各个容器<strong>共享命名空间、cgroups 限制和存储卷</strong>。<br>可以简单地将一个 Pod 当作是一个抽象的虚拟机，里面运行若干个不同的进程，<strong>每个进程实际上就是一个容器</strong>。<br>实现上，<strong>先创建一个 pause 容器</strong>，创建相关命名空间，然后创建 Pod 中的其他应用容器，并共享 pause 容器的命名空间。<br>组成容器组的若干容器往往是存在共同的应用目的，彼此关联十分紧密。经典应用场景包括：</p><ul><li>内容管理，文件和数据加载，缓存管理等；</li><li>日志处理，状态快照等；</li><li>监控代理，消息发布等；</li><li>代理机制，网桥、网卡等；</li><li>控制器、管理器、配置以及更新等。</li></ul><p>容器组既保持了容器<strong>轻量解耦的特性</strong>，又提供了调度操作的便利性，在实践中提供了比单个容器更为灵活和更有意义的抽象。Pod 生命周期的<code>五种状态值</code>：</p><ul><li>待定（Pending）：已经被系统接受，但容器镜像还未就绪；</li><li>运行（Running）：分配到节点，所有容器都被创建，至少一个容器在运行中；</li><li>成功（Succeeded）：所有容器都正常退出，不需要重启，任务完成；</li><li>失败（Failed）：所有容器都退出，至少一个容器是非正常退出；</li><li>未知（Unknown）：未知状态，例如所在节点无法汇报状态。</li></ul><h3 id="服务"><a href="#服务" class="headerlink" title="服务"></a>服务</h3><p>Service 的提出，主要是解决 Pod 地址可变的问题，分配不随 Pod 位置变化而改变的虚拟访问地址，<strong>符合微服务的理念</strong>，跟负载均衡器实现的功能很相似。<br>组成一个服务的 Pod 可能是属于不同复制控制器的，但服务自身是不知道复制控制器的存在的。<br>每个节点上都会运行一个 <code>kube-proxy 进程</code>，负责将到某个 Service 的访问，代理或者均衡到具体的 Pod 上去；同时，会为每一个服务创建环境变量。<br>Service 支持进行不同类型的健康检查（通过容器 spec 中的 LivenessProbe 或 ReadinessProbe 字段定义）：</p><ul><li>通过 HTTP 获取资源是否成功；</li><li>在容器中执行指定命令，返回值是否为 0；</li><li>打开给定 Socket 端口是否成功。</li></ul><h3 id="存储卷"><a href="#存储卷" class="headerlink" title="存储卷"></a>存储卷</h3><p>Volume <strong>跟 Pod 有一致的生命周期</strong>，Pod 生存过程中，数据卷跟着存在；Pod 退出，则数据卷跟着退出。<br>比较常见的数据卷类型包括：emptyDir、hostPath、gcePersistentDisk、awsElasticBlockStore、nfs、gitRepo、secret 等。<br>持久化的存储以<code>插件</code>的形式提供为 PersistentVolume 资源，用户通过请求某个类型的 PersistentVolumeClaim 资源，来从匹配的持久化存储卷上，获取绑定的存储。</p><h2 id="控制器抽象对象"><a href="#控制器抽象对象" class="headerlink" title="控制器抽象对象"></a>控制器抽象对象</h2><p>控制器抽象对象是对所操控对象的进一步抽象，附加了各种资源的<strong>管理功能</strong>，包括副本集、部署、状态集、Daemon 集、任务等。</p><h3 id="副本集和部署"><a href="#副本集和部署" class="headerlink" title="副本集和部署"></a>副本集和部署</h3><p>ReplicaSet 和 Deployment 都适合<strong>长期运行</strong>的应用类型。即使 Pod 份数是 1，也要使用<code>复制控制器</code>来创建，而不是直接创建 Pod。</p><blockquote><p>Pod 资源是可能随时发生故障的，并不需要保证 Pod 的运行，而是在发生失败后<strong>重新生成</strong>。</p></blockquote><p>可以将副本集类比为进程的监管者（supervisor）的角色，只不过它不光能保持 Pod 的持续运行，还能保持集群中给定类型 Pod，同时<strong>运行的个数为指定值</strong>。<br><code>部署</code>代表用户对集群中应用的一次更新操作。</p><h3 id="状态集"><a href="#状态集" class="headerlink" title="状态集"></a>状态集</h3><p><code>无状态的应用</code>，关心的主要是副本的个数，而不关心名称、位置等；与此对应，某些应用需要关心 Pod 的状态，挂载独立的存储。<br>StatefulSet 正是针对这种需求而设计的，提供比副本集和部署<strong>更稳定可靠的运行支持</strong>。</p><h3 id="Daemon-集"><a href="#Daemon-集" class="headerlink" title="Daemon 集"></a>Daemon 集</h3><p>DaemonSet 适合于<strong>长期运行在后台</strong>的伺服类型应用，例如对节点的日志采集或状态监控等后台支持服务。</p><h3 id="任务"><a href="#任务" class="headerlink" title="任务"></a>任务</h3><p>Job 代表<strong>批处理类型</strong>的应用，任务中应用完成某一类处理即可退出，有头有尾。</p><h3 id="横向-Pod-扩展器"><a href="#横向-Pod-扩展器" class="headerlink" title="横向 Pod 扩展器"></a>横向 Pod 扩展器</h3><p>Horizontal Pod Autoscaler（HPA）解决应用波动的情况，根据 Pod 的使用率，自动调整部署里面 Pod 的个数，保障服务在不同压力情况下，<strong>保证平滑的输出效果</strong>。</p><blockquote><p>控制管理器会定期检查性能指标，在满足条件时触发横向伸缩。</p></blockquote><h2 id="其他抽象对象"><a href="#其他抽象对象" class="headerlink" title="其他抽象对象"></a>其他抽象对象</h2><h3 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h3><p>Label 是一组键值对，用来标记所绑定的对象（典型的就是 Pod）的识别属性，进而可以<code>分类</code>。<br>Label 键支持通过“/”来添加前缀，可以用来标注资源的组织名称等，标签所定义的属性是<strong>不唯一的</strong>，这意味着不同资源可能带有相同的标签键值对。</p><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><p>Annotation 跟标签很相似，也是键值对。不同的是，注解并不是为了分类资源对象，而是为了给对象<strong>增加丰富的描述信息</strong>。</p><blockquote><p>信息是任意的，数据量可以很大。包括结构化、非结构化数据。</p></blockquote><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><p>Selector 可以通过指定标签键值对，来<strong>过滤出一组特定的资源对象</strong>。支持的语法包括基于等式（Equality-based）的，和基于集合（Set-based）的。</p><h3 id="秘密数据"><a href="#秘密数据" class="headerlink" title="秘密数据"></a>秘密数据</h3><p>Secret 资源用来保存一些<strong>敏感的数据</strong>，这些数据往往不希望别的用户看到，但是在启动某个资源（例如 Pod）的时候需要提供。</p><blockquote><p>通常，秘密数据不要超过 1MB。在整个过程中，只有秘密数据的所有人和<strong>最终运行的容器</strong>，能获取原始敏感数据。</p></blockquote><h3 id="UID-和名字"><a href="#UID-和名字" class="headerlink" title="UID 和名字"></a>UID 和名字</h3><p>UID 是<strong>全局唯一的</strong>，并且不能复用；名字仅仅要求，在同一个命名空间内是唯一的，并且当某个资源移除后，其名字可以被新的资源复用。</p><h3 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h3><p>Namespace 用来隔离不同用户的资源，类似租户或项目的概念，相同命名空间中的对象，具有<strong>相同的访问控制策略</strong>。<br>用户在创建资源的时候，可以通过 –namespace=<some_namespace> 来指定所属的命名空间，k8s 集群启动后，会保留两个特殊的命名空间：</some_namespace></p><ul><li>default：资源未指定命名空间情况下，默认属于该空间；</li><li>kube-system：由 Kubernetes 系统自身创建的资源。</li></ul><h3 id="污点和容忍"><a href="#污点和容忍" class="headerlink" title="污点和容忍"></a>污点和容忍</h3><p>Taint 和 Toleration 用于<strong>辅助管理 Pod 到工作节点的调度过程</strong>。<br>可以为一个工作节点注明若干污点，只有对这些污点容忍的 Pod，才可以被调度到这些具有污点的节点上。</p><h2 id="重要组件"><a href="#重要组件" class="headerlink" title="重要组件"></a>重要组件</h2><p>从头设计一套容器集群管理平台，需要考虑如下几个方面的需求：</p><ul><li>要采用<strong>分布式架构</strong>，保证良好的可扩展性；</li><li><strong>控制平面要实现逻辑上的集中，数据平面要实现物理上的分布</strong>；</li><li>得有一套资源调度系统，负责所有的资源调度工作，要<strong>容易插拔</strong>；</li><li><strong>对资源对象要进行抽象</strong>，所有资源要能实现高可用性。</li></ul><p>从架构上看，Kubernetes 集群采用了典型的<code>主从架构</code>：一个集群主要由<strong>管理节点（Master）</strong>和<strong>工作节点（Node）</strong>组件构成。Master 节点负责控制，Node 节点负责干活，各自又通过若干组件来实现：</p><ul><li>etcd：作为数据库，存放所有集群状态和配置相关的数据；</li><li>kube-apiserver：Kubernetes 系统的对外接口，提供 RESTful API 供客户端和其他组件调用，支持水平扩展；</li><li>kube-scheduler：负责对资源进行调度，具体负责分配某个请求的 Pod 到某个节点上；</li><li>controller-manager：对不同资源的管理器，维护集群的状态，包括故障检测、自动扩展、滚动更新等；</li><li>kube-ui：可选，自带的一套用来查看集群状态的 Web 界面；</li><li>kube-dns：可选，记录启动的 Pod 和服务地址。</li></ul><p>这些组件可以任意部署在相同或不同机器上，只要可以通过标准的 HTTP 接口，<strong>相互访问到即可</strong>。<br>Node 节点是实际工作的计算实例，可以是<strong>虚拟机或物理机器</strong>，Node 上至少包括：</p><ul><li>容器引擎：本地的容器依赖，目前支持 Docker 和 rkt；</li><li>kubelet：<strong>跟 Master 节点通信</strong>，节点上最主要的工作代理，汇报节点状态并实现容器组的生命周期管理；</li><li>kube-proxy：<strong>负责网络相关功能</strong>，代理对抽象应用地址的访问，负责匹配正确的服务发现、负载均衡转发规则；</li><li>辅助组件：可选，Supervisord 用来保持 kubelet 和 docker 进程运行，Fluentd 用来转发日志等。</li></ul><p>Node 节点有几个重要属性：</p><ul><li><p><strong>地址信息（Address）</strong>：</p><ul><li>主机名（HostName）：节点所在的系统的主机别名，一般不会用到；</li><li>外部地址（ExternalIP）：集群外部客户端可以通过该地址访问到节点；</li><li>内部地址（InternalIP）：集群内可访问的地址，外部往往无法通过该地址访问节点。</li></ul></li><li><p><strong>状态（Condition）</strong>：</p><ul><li>磁盘不足（OutOfDisk）；</li><li>就绪（Ready）；</li><li>空余内存过低（MemoryPressure）；</li><li>空余磁盘过低（DiskPressure）。</li></ul></li><li><p><strong>资源容量（Capacity）</strong>：</p><ul><li>CPU；</li><li>内存；</li><li>最多存放的 Pod 个数。</li></ul></li><li><p><strong>节点信息（Info）</strong>：</p><ul><li>操作系统内核信息；</li><li>Kubernetes 版本信息；</li><li>Docker 引擎版本信息。</li></ul></li></ul><h2 id="网络设计"><a href="#网络设计" class="headerlink" title="网络设计"></a>网络设计</h2><p>网络是集群十分关键的功能，k8s 在设计上考虑了对网络的需求和模型设计，但<strong>自身并没有重新实现</strong>，而是可以另外嵌入现有的网络管理方案。</p><blockquote><p>Kubernetes 通过<code>插件化</code>的形式，采用 Container Networking Interface（CNI）规范，所有支持 k8s 的网络插件都要遵循该规范。</p></blockquote><h3 id="场景分析"><a href="#场景分析" class="headerlink" title="场景分析"></a>场景分析</h3><p>对于 k8s 集群来说，典型的要考虑如下四种通信场景：</p><ul><li>Pod 内（容器之间）：因为容器共享了网络命名空间，可以通过 <code>lo</code> 直接通信，无须额外支持；</li><li>Pod 之间：<ul><li>同一节点：通过本地网桥通信即可；</li><li>不同节点：在各自绑定的网桥之间通信。</li></ul></li><li>Pod 和服务之间：因为服务是虚拟的 IP，<strong>需要在节点上配置代理机制</strong>（例如基于 iptables）来映射到后端的 Pod；</li><li>外部访问服务：要从外部访问服务，<strong>必须经过负载均衡器</strong>，通过外部可用的地址映射到内部的服务上。</li></ul><p>k8s 在网络方面的设计理念，包括如下几点：</p><ul><li>所有容器之间不使用 <code>NAT</code> 就可以互相通信；</li><li>所有节点跟容器之间不使用 NAT 就可以互相通信；</li><li>容器自己看到的地址，和其他人访问自己使用的地址是一样的。</li></ul><p>这个设计理念与云平台里面的<strong>虚拟机网络</strong>十分类似，意味着基于虚拟机云的项目可以方便地迁移到 Kubernetes 平台上。</p><blockquote><p>现代云计算领域常见的网络实现方式：直接路由和 Overlay 网络。</p></blockquote><h3 id="直接路由"><a href="#直接路由" class="headerlink" title="直接路由"></a>直接路由</h3><p>这种实现的<strong>最大优势是简洁</strong>，可以直接服用底层的物理设备。目前，GCE 和 Azure 都支持这种模式。</p><h3 id="Overlay-路由"><a href="#Overlay-路由" class="headerlink" title="Overlay 路由"></a>Overlay 路由</h3><p>Overlay 网络相对要复杂一些，<strong>支持底层更灵活的转发</strong>。目前包括 Flannel、Open vSwitch、Weave、Calico 等一系列方案都能实现用 Overlay 网络来联通不同节点上的 Pod。</p><blockquote><p>虽然 Kubernetes 自身并没有提出 Paas 或者 DevOps 的理念，但它提供的资源抽象接口和生命周期管理概念，让用户可以<strong>很方便地进行二次开发</strong>，打造生产级别的应用系统。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据抽象</title>
      <link href="2019/08/29/%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/"/>
      <url>2019/08/29/%E6%95%B0%E6%8D%AE%E6%8A%BD%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<p><code>数据类型</code>指的是一组值和一组对这些值的<strong>操作的集合</strong>。原则上所有程序都只需要使用原始数据类型即可，但为了在<strong>更高层次的抽象</strong>上编写程序更加方便，重点学习定义和使用数据类型，这个过程也被称为<code>数据抽象</code>。</p><p>Java 编程的基础主要是使用 class 关键字构造被称为<code>引用类型</code>的数据类型。这种编程风格称为<code>面向对象编程</code>，因为它的核心概念是对象，即<strong>保存了某个数据类型的值的实体</strong>。</p><p>抽象数据类型（ADT）是一种能够对使用者<strong>隐藏数据表示</strong>的数据类型：</p><ul><li>在使用 ADT 时，我们的注意力集中在 API 描述的操作上，而不会去关心数据的表示；</li><li>在实现 ADT 时，我们的注意力集中在数据本身，并将实现对该数据的各种操作；</li></ul><p>在程序设计上，<strong>ADT 支持封装</strong>：</p><ul><li>以适用于各种用途的 API 形式，准确地定义问题；</li><li>用 API 的实现描述算法和数据结构；</li></ul><h2 id="使用抽象数据类型"><a href="#使用抽象数据类型" class="headerlink" title="使用抽象数据类型"></a>使用抽象数据类型</h2><p>要使用一种数据类型<strong>并不一定非得知道它是如何实现的</strong>，所以我们首先来编写一个使用一种名为 Counter 的简单数据类型的程序。</p><p>要使用 Counter 对象，首先需要了解应该如何定义数据类型的操作，以及在 Java 语言中应该如何创建和使用某个数据类型的对象。</p><a id="more"></a><h3 id="抽象数据类型的-API"><a href="#抽象数据类型的-API" class="headerlink" title="抽象数据类型的 API"></a>抽象数据类型的 API</h3><p>我们使用 API 来说明抽象数据类型的行为，列出所有<code>构造函数</code>和<code>实例方法</code>（即操作），并简要描述它们的功用：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/01.jpg" alt></p><p>ADT 和静态方法库之间有许多共同之处：</p><ul><li>两者的实现均为 Java 类；</li><li>实例方法也能接受 0 个或多个指定类型的参数；</li><li>它们可能会返回一个指定类型的值，也可能不会；</li></ul><p>当然，它们也有三个<strong>显著的不同</strong>：</p><ul><li>ADT 中可能会出现若干个名称和类名相同且没有返回值的函数，这些特殊的函数被称为构造函数；</li><li>实例方法不需要 static 关键字，它们不是静态方法；</li><li>某些实例方法的存在是为了<strong>尊重 Java 的习惯</strong>——我们将此类方法称为继承的方法；</li></ul><blockquote><p>ADT 的 API 是和用例之间的一份契约，因此它是开发任何用例代码以及实现任意数据类型的起点。</p></blockquote><h3 id="继承的方法"><a href="#继承的方法" class="headerlink" title="继承的方法"></a>继承的方法</h3><p>根据 Java 的约定，任意数据类型都能通过<strong>在 API 中包含特定的方法</strong>从 Java 的内在机制中获益。</p><p>例如，Java 中的所有数据类型都会继承 toString() 方法来返回用 String 表示的该类型的值。但这种默认实现并不实用，我们常常会提供实现来<strong>重载默认实现</strong>，并在 API 中加上 toString() 方法。</p><h3 id="用例代码"><a href="#用例代码" class="headerlink" title="用例代码"></a>用例代码</h3><p>将程序组织为独立模块的机制可以应用于所有的 Java 类，因此它对基于抽象数据类型的模块化编程与静态函数库一样有效。</p><p>通过将实现某种数据类型的全部代码封装在一个 Java 类中，我们可以将用例代码推向<strong>更高的抽象层次</strong>。这种方式<strong>和原始数据的使用方式非常不同</strong>。</p><h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>可以声明一个变量 heads 并将它通过以下代码和 Counter 类型的数据关联起来：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Counter heads;</span><br></pre></td></tr></table></figure><p>对象是能够承载数据类型的值的实体，所有对象都有三大重要特性：<code>状态</code>、<code>标识</code>和<code>行为</code>：</p><ul><li>对象的状态即数据类型中的值；</li><li>对象的标识能够将一个对象区别于另一个对象，可以认为是<strong>在内存中的位置</strong>；</li><li>对象的行为就是数据类型的操作；</li></ul><p>Java 使用<code>引用类型</code>以示和原始数据类型的区别，可以认为<strong>引用就是内存地址</strong>。</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><p>要实例化一个对象，我们用<strong>关键字 new 并紧跟类名以及 ()</strong> 来触发它的构造函数，或在括号中指定一系列的参数，如果构造函数需要的话。</p><p>每当用例调用了 new()，<strong>系统就会</strong>：</p><ul><li>为新的对象分配内存空间；</li><li>调用构造函数初始化对象中的值；</li><li>返回该对象的一个引用；</li></ul><p>我们一般都会在一条<strong>声明语句中</strong>创建一个对象并通过将它和一个变量关联起来初始化该变量。和原始数据类型不同的是，<strong>变量关联的是指向对象的引用</strong>，而并非数据类型的值本身：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/02.jpg" alt></p><h3 id="调用实例方法"><a href="#调用实例方法" class="headerlink" title="调用实例方法"></a>调用实例方法</h3><p>实例方法的意义在于<strong>操作数据类型中的值</strong>。我们调用一个实例方法的方式是先写出对象的变量名，紧接着是一个句点，然后是实例方法的名称，之后是 0 个或多个<strong>在括号中由逗号分隔的参数</strong>。</p><p>实例方法<strong>参数按值传递</strong>，方法名可以被重载，方法可以有返回值，它们也许还会产生一些副作用。</p><p>实例方法和静态方法的调用方式完全相同，可以通过<strong>语句（void 方法）</strong>，也可以通过<strong>表达式（有返回值的方法）</strong>；静态方法的主要作用是实现函数，非静态方法的主要作用是实现数据类型的操作：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/03.jpg" alt></p><h3 id="使用对象"><a href="#使用对象" class="headerlink" title="使用对象"></a>使用对象</h3><p>要开发某种给定数据类型的用例，我们需要：</p><ul><li>声明该类型的变量，以用来引用对象；</li><li>使用关键字 new 触发能够创建该类型的对象的<strong>构造函数</strong>；</li><li>使用变量名在语句或表达式中调用实例方法；</li></ul><p>除了这些直接用法外，我们可以<strong>和使用原始数据类型的变量一样</strong>使用和对象关联的变量：</p><ul><li>赋值语句；</li><li>向方法传递对象或从方法中返回对象；</li><li>创建并使用对象的数组；</li></ul><blockquote><p>你需要<strong>从引用而非值的角度</strong>去考虑问题才能理解这些用法的行为。</p></blockquote><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p>使用引用类型的赋值语句将会创建该引用的一个<code>副本</code>。赋值语句不会创建新的对象，而只是创建另一个指向某个已经存在的对象的引用。这种情况被称为<code>别名</code>：两个变量同时指向同一个对象。如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Counter c1 = <span class="keyword">new</span> Counter(<span class="string">"ones"</span>);</span><br><span class="line">c1.increment();</span><br><span class="line">Counter c2 = c1;</span><br><span class="line">c2.increment();</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/04.jpg" alt></p><blockquote><p>改变一个对象的状态将会<strong>影响到所有和该对象的别名有关的代码</strong>。</p></blockquote><h3 id="将对象作为参数"><a href="#将对象作为参数" class="headerlink" title="将对象作为参数"></a>将对象作为参数</h3><p>可以<strong>将对象作为参数传递给方法</strong>，这一般都能简化用例代码。</p><p>这将会传递引用的值，也就是传递对象的引用；方法虽然<strong>无法改变原始的引用</strong>，但它能够改变该对象的值。</p><h3 id="将对象作为返回值"><a href="#将对象作为返回值" class="headerlink" title="将对象作为返回值"></a>将对象作为返回值</h3><p>当然也能够<strong>将对象作为方法的返回值</strong>。这种能力非常重要，因为 Java 中的方法只能有一个返回值——有了对象我们的代码实际上就能返回多个值。</p><h3 id="数组也是对象"><a href="#数组也是对象" class="headerlink" title="数组也是对象"></a>数组也是对象</h3><p>在 Java 中，所有非原始数据类型的值都是对象，也就是说，<strong>数组也是对象</strong>。<br>当我们将数据传递给一个方法或是将一个数组变量放在赋值语句的右侧时，我们都是在创建该数组引用的一个副本，<strong>而非数组的副本</strong>。</p><h3 id="对象的数组"><a href="#对象的数组" class="headerlink" title="对象的数组"></a>对象的数组</h3><p>创建一个对象的数组需要以下两个步骤：</p><ul><li>使用方括号语法<strong>调用数组的构造函数创建数组</strong>；</li><li>对于每个数组元素调用它的构造函数创建相应的对象；</li></ul><p>在 Java 中，对象数组即是一个<strong>由对象的引用组成的数组</strong>，而非所有对象本身组成的数组：</p><ul><li>如果对象非常大，那么在移动它们时由于只需要操作引用而非对象本身，这就会大大提高效率；</li><li>如果对象很小，每次获取信息时都需要通过引用反而会降低效率；</li></ul><p>运用数据抽象的思想编写代码（<strong>定义和使用数据类型，将数据类型的值封装在对象中</strong>）的方式称为<code>面向对象编程</code>。</p><p>一个数据类型的实现所支持的操作如下：</p><ul><li><strong>创建对象</strong>：使用 new 关键字触发构造函数并创建对象，初始化对象中值并返回对它的引用；</li><li><strong>操作对象中的值</strong>：使用和对象关联的变量，调用实例方法，来对对象中的值进行操作；</li><li><strong>操作多个对象</strong>：创建对象的数组，像原始数据类型的值一样将它们传递给方法，或是从方法中返回；</li></ul><blockquote><p>这些能力是这种灵活且应用广泛的现代编程方式的基础，也是我们对算法研究的基础。</p></blockquote><h2 id="抽象数据类型举例"><a href="#抽象数据类型举例" class="headerlink" title="抽象数据类型举例"></a>抽象数据类型举例</h2><p>Java 语言内置了上千种抽象数据类型，我们也会为了<strong>辅助算法研究</strong>，创建许多其他抽象数据类型。</p><p>我们将会用到或开发的数据类型，可以被分为以下几类：</p><ul><li>java.lang.* 中的标准系统抽象数据类型，可以被任意 Java 程序调用；</li><li>Java 标准库中的抽象数据类型，如 java.swt、java.net 和 java.io，它们也可以被任意 Java 程序调用，但<strong>需要 import 语句</strong>；</li><li>I/O 处理类抽象数据类型，和 StdIn 和 StdOut 类似，允许我们处理多个输入输出流；</li><li><strong>面向数据的抽象数据类型</strong>，它们的主要作用是通过封装数据的表示，简化数据的组织和处理；</li><li>集合类抽象数据类型，它们的主要用途是简化对同一类型的一组数据的操作；</li><li><strong>面向操作的抽象数据类型</strong>，我们用它们分析各种算法；</li><li>图算法相关的抽象数据类型；</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/05.jpg" alt></p><blockquote><p>从整体上来说，我们使用的抽象数据类型说明，<strong>组织并理解所使用的数据结构</strong>，是现代编程中的重要因素。</p></blockquote><h3 id="几何对象"><a href="#几何对象" class="headerlink" title="几何对象"></a>几何对象</h3><p>面向对象编程的一个典型例子是<strong>为几何对象设计数据类型</strong>：</p><ul><li>Point2D：平面上的点；</li><li>Interval1D：直线上的间隔；</li><li>Interval2D：平面上的二维间隔；</li></ul><p><strong>处理几何对象的程序</strong>在自然世界模型、科学计算、电子游戏、电影等许多应用的计算中有着广泛的应用。此类程序的研发已经发展成了<code>计算机几何学</code>，这门影响深远的研究学科。</p><h3 id="信息处理"><a href="#信息处理" class="headerlink" title="信息处理"></a>信息处理</h3><p>无数应用的核心都是组织和处理信息，抽象数据类型是组织信息的一种自然方式。</p><p>为了简化用例的代码，我们为每个类型都提供了两个构造函数，一个接受适当类型的数据，<strong>另一个则能够解析字符串中的数据</strong>。</p><blockquote><p><strong>每当遇到逻辑上相关的不同类型的数据时</strong>，都应该考虑定义一个抽象数据类型。这么做能够帮助我们组织数据，并在一般应用程序中极大地简化使用者的代码。</p></blockquote><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>Java 的 String 是一种重要而实用的 ADT。一个 String 值是一串<strong>可以由索引访问</strong>的 char 值，String 对象拥有许多实例方法：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/06.jpg" alt></p><p>split() 方法的参数可以是<code>正则表达式</code>，“\s+”表示“一个或多个制表符、空格、换行符或回车”。</p><blockquote><p>为了使代码更加简洁清晰，<strong>不直接使用字符数组代替 String 值</strong>。</p></blockquote><h3 id="再谈输入输出"><a href="#再谈输入输出" class="headerlink" title="再谈输入输出"></a>再谈输入输出</h3><p>我们的标准库定义了数据类型 In、Out 和 Draw。当使用一个 <strong>String 类型的参数</strong>调用它们的构造函数时：</p><ol><li>首先尝试在当前目录下查找指定的文件；</li><li>假设该参数是一个网站的名称，并尝试连接到那个网站；</li><li>抛出一个运行时异常；</li></ol><p>指定的文件或网站都会成为，被创建的输入或输出流对象的来源或目标，<strong>所有 read*() 和 print*() 方法</strong>都会指向那个文件或网站。</p><h2 id="抽象数据类型的实现"><a href="#抽象数据类型的实现" class="headerlink" title="抽象数据类型的实现"></a>抽象数据类型的实现</h2><p>和静态方法库一样，我们也需要使用 class 实现 ADT，并将所有代码放入一个和类名相同并带有 <strong>.java 扩展名</strong>的文件中。</p><p>文件的第一部分语句会定义表示数据类型的值的<code>实例变量</code>。它们之后是实现对数据类型的值的操作的<code>构造函数</code>和<code>实例方法</code>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/07.jpg" alt></p><blockquote><p>单元测试用例 main()，通常在调试和测试中很实用。</p></blockquote><h3 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h3><p>实例变量和局部变量的<strong>关键区别</strong>在于：</p><ul><li>每一时刻，每个局部变量只会有一个值；</li><li>每一时刻，每个实例变量对应着无数值；</li></ul><p>每个实例变量的声明都需要一个<code>可见性修饰符</code>，在 ADT 的实现中，我们会使用 private，也就是使用 Java 语言的机制来保证向使用者<strong>隐藏 ADT 中的数据表示</strong>。</p><p>如果我们使用 public 修饰这些实例变量，那么根据定义，这种数据类型就<strong>不再是抽象的了</strong>。</p><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>每个 Java 类都至少含有一个构造函数，以创建一个对象的<code>标识</code>。</p><p>构造函数的作用是初始化实例变量，每个构造函数都将创建一个对象并向调用者<strong>返回一个该对象的引用</strong>。</p><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/08.jpg" alt></p><p>如果没有定义构造函数，类将会隐式定义一个默认情况下不接受任何参数的构造函数，并将所有实例变量<strong>初始化为默认值</strong>。</p><p>重载构造函数一般用于将实例变量<strong>由默认值初始化为用例提供的值</strong>。</p><h3 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h3><p>每个实例方法都有一个返回值类型、一个签名和一个<code>主体</code>。</p><p>当调用者触发了一个方法时，它的效果就好像调用者代码中的函数调用，<strong>被替换为了这个返回值</strong>。</p><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/09.jpg" alt></p><p>实例方法的所有行为都和静态方法相同，只有一点关键的不同：</p><ul><li>它们可以访问并操作实例变量；</li></ul><p>面向对象编程为 Java 程序增加了<strong>另一种使用变量的重要方式</strong>：通过触发一个实例方法来操作该对象的值。</p><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>实现实例方法的 Java 代码中，使用了三种变量：</p><ul><li><code>参数变量</code>：作用域是整个方法；</li><li><code>局部变量</code>：作用域是当前代码段中，它定义之后的所有语句；</li><li><code>实例变量</code>：作用域是整个类，如果出现二义性，可以使用 this 前缀区分；</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/10.jpg" alt></p><h3 id="API、用例与实现"><a href="#API、用例与实现" class="headerlink" title="API、用例与实现"></a>API、用例与实现</h3><p>每个 ADT 的实现都是一个含有若干私有实例变量、构造函数、实例方法和<strong>一个测试用例</strong>的 Java 类。</p><p>按照下面三步走的方式，用 ADT 满足用例的需求：</p><ul><li>定义一份 API：API 的作用是<strong>将使用和实现分离</strong>；</li><li>用一个 Java 类实现 API 的定义：首先我们选择适当的实例变量，然后再编写构造函数和实例方法；</li><li>实现多个测试用例，<strong>验证前两步做出的设计决定</strong>；</li></ul><h2 id="更多抽象数据类型的实现"><a href="#更多抽象数据类型的实现" class="headerlink" title="更多抽象数据类型的实现"></a>更多抽象数据类型的实现</h2><p>理解抽象数据类型的威力和用法的最好方法，就是仔细研究更多的例子和实现。</p><h3 id="日期"><a href="#日期" class="headerlink" title="日期"></a>日期</h3><p>实现的<code>性能</code>往往是有区别的：实现中保存数据类型的值所需的<strong>空间较小</strong>，代价是在向用例按照约定的格式，提供这些值时花费的<strong>时间更多</strong>。</p><p>在实现中使用数据抽象的一个关键优势是：我们可以将一种实现替换为另一种而<strong>无需改变用例的任何代码</strong>。</p><h3 id="维护多个实现"><a href="#维护多个实现" class="headerlink" title="维护多个实现"></a>维护多个实现</h3><p>同一个 API 的多个实现可能会产生<strong>维护和命名问题</strong>。</p><p>在某些情况下，我们可能只是想将较老的实现替换为改进的实现；而在另一些情况下，我们可能需要维护两种实现，一种适用于某些用例，另一种适用于另一些用例：</p><ul><li>通过<code>前缀</code>的描述性修饰符，区别同一份 API 的不同实现；</li><li>维护一个没有前缀的参考实现，它应该适用于大多数用例的需求；</li></ul><h3 id="累加器"><a href="#累加器" class="headerlink" title="累加器"></a>累加器</h3><p>累加器 API 定义了一种能够为用例计算一组数据的<strong>实时平均值</strong>的抽象数据类型：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/11.jpg" alt></p><p>它的实现很简单：维护一个 int 类型的实例变量，来记录已经处理过的数据值的数量；以及一个 double 类型的实例变量，来记录所有数据值之和，将和除以数据数量即可得到平均值：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/12.jpg" alt></p><blockquote><p>请注意该实现并没有保存数据的值——它可以用于处理大规模的数据，甚至是在一个<strong>无法全部保存</strong>它们的设备上。</p></blockquote><h3 id="可视化的累加器"><a href="#可视化的累加器" class="headerlink" title="可视化的累加器"></a>可视化的累加器</h3><p>可视化累加器的实现继承了 Accumulator 类并展示了一种<strong>实用的副作用</strong>。完成这项任务最简单的办法是<strong>添加一个构造函数</strong>，来指定需要绘出的点数和它们的最大值。</p><blockquote><p>添加一个构造函数来取得某些功能，有时能通过测试用例，因为它对用例的影响和改变类名所产生的变化相同。</p></blockquote><h2 id="数据类型的设计"><a href="#数据类型的设计" class="headerlink" title="数据类型的设计"></a>数据类型的设计</h2><p>抽象数据类型是一种<strong>向用例隐藏内部表示</strong>的数据类型，这种思想强有力地影响了现代编程。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>面向对象编程的特征之一，就是使用数据类型的实现<code>封装</code>数据，以简化实现和隔离用例开发。<strong>封装实现了模块化编程</strong>，它允许我们：</p><ul><li>独立开发用例和实现的代码；</li><li>切换至改进的实现而不会影响用例的代码；</li><li>支持尚未编写的程序（对于后续用例，API 能够起到指南的作用）；</li></ul><p>封装同时也<strong>隔离了数据类型的操作</strong>，这使我们可以：</p><ul><li>限制潜在的错误；</li><li>在实现中添加一致性检查等调试工具；</li><li>确保用例代码更明晰；</li></ul><p>模块化编程成功的关键在于保持模块之间的独立性，我们坚持将 API 作为用例和之间的<strong>唯一的依赖点</strong>。</p><p>我们并不需要知道一个数据类型是如何实现的才能使用它，实现数据类型时也应该假设使用者除了 API 什么也不知道。<strong>封装是获得所有这些优势的关键</strong>。</p><h3 id="设计-API"><a href="#设计-API" class="headerlink" title="设计 API"></a>设计 API</h3><p>构建现代软件最重要也是最有挑战的一项任务就是设计 API，它需要经验、思考和反复的修改，但设计一份优秀的 API 所付出的所有时间，都能<strong>从调试和代码复用所节省的时间中获得回报</strong>。</p><p>为了验证我们的设计，我们会在 API 附近的正文中给出一些用例代码。但这些宏观概述之中也隐藏着每一份 API 设计都可能落入的无数陷阱：</p><ul><li>API 可能会难以实现：实现的开发非常困难，甚至不可能；</li><li>API 可能会难以使用：用例代码甚至比没有 API 时更复杂；</li><li>API 的范围可能太窄：缺少用例所需的方法；</li><li>API 的范围可能太宽：包含许多不会被任何用例调用的方法。API 的大小一般会随着时间而增长，因为向已有的 API 中添加新方法很简单，但在不破坏已有用例程序的前提下，从中<strong>删除方法却很困难</strong>；</li><li>API 可能会太粗略：无法提供有效的抽象；</li><li>API 可能会太详细：抽象过于细致或是发散而无法使用；</li><li>API 可能会过于依赖某种特定的数据表示：用例代码可能会因此无法从数据表示的细节中解脱出来。要避免这种缺陷也是困难的，因为<strong>数据表示显然是 ADT 实现的核心</strong>；</li></ul><blockquote><p>只为用例提供它们所需要的，仅此而已。</p></blockquote><h3 id="算法与抽象数据类型"><a href="#算法与抽象数据类型" class="headerlink" title="算法与抽象数据类型"></a>算法与抽象数据类型</h3><p>数据抽象天生适合算法研究，因为它能够为我们<strong>提供一个框架</strong>，在其中能够准确地说明一个算法的目的，以及其他程序应该如何使用该算法。</p><p>每个 Java 程序都是<strong>一组静态方法和（或）一种数据类型实现</strong>的集合。数据抽象使我们能够：</p><ul><li>准确定义算法能为用例提供什么；</li><li>隔离算法的实现和用例的代码；</li><li>实现多层抽象，用已知算法实现其他算法；</li></ul><p>使用 <strong>Java 的类机制</strong>来支持数据的抽象，将使我们收获良多：我们编写的代码将能够测试算法，并比较各种用例程序的性能。</p><h3 id="接口继承"><a href="#接口继承" class="headerlink" title="接口继承"></a>接口继承</h3><p>Java 语言为定义对象之间的关系提供了支持，称为<code>接口</code>。</p><p>接口继承使得我们的程序能够通过调用接口中的方法，操作<strong>实现该接口的任意类型的对象</strong>（甚至是还未被创建的类型）。</p><p>在某些情况下 Java 的习惯用法鼓励我们使用接口：我们用它们<strong>进行比较和迭代</strong>。</p><h3 id="实现继承"><a href="#实现继承" class="headerlink" title="实现继承"></a>实现继承</h3><p>Java 还支持另一种继承机制，被称为子类。这种非常强大的技术使程序员<strong>不需要重写整个类</strong>，就能改变它的行为或者为它添加新的功能。</p><p>它的主要思想是定义一个新类（子类，或称为<code>派生类</code>），来继承另一个类（父类，或称为<code>基类</code>）的所有实例方法和实例变量。</p><p>每个类都是 Java 的 Object 类的子类：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/13.jpg" alt></p><h3 id="字符串表示的习惯"><a href="#字符串表示的习惯" class="headerlink" title="字符串表示的习惯"></a>字符串表示的习惯</h3><p>当连接运算符的一个操作数是字符串时，Java 会<strong>自动将另一个操作数也转换为字符串</strong>。如果一个对象的数据类型没有实现 toString() 方法，那么转换会调用 Object 的默认实现。</p><p><strong>默认实现一般都没有多大实用价值</strong>，因为它只会返回一个含有该对象内存地址的字符串。因此我们通常会为我们的每个类实现，并重写默认的 toString() 方法。</p><h3 id="封装类型"><a href="#封装类型" class="headerlink" title="封装类型"></a>封装类型</h3><p>Java 提供了一些内置的引用类型，称为<code>封装类型</code>。<strong>每种原始数据类型都有一个对应的封装类型</strong>：Boolean、Byte、Character、Double、Float、Integer、Long 和 Short 分别对应着 boolean、byte、char、double、float、int、long 和 short。</p><blockquote><p>在需要的时候 Java 会自动将原始数据类型转换为封装类型。</p></blockquote><h3 id="等价性"><a href="#等价性" class="headerlink" title="等价性"></a>等价性</h3><p>我们检测的是<code>标识</code>是否相同，即<code>引用</code>是否相同。一般用例希望能够检测数据类型的值（对象的状态）是否相同，或者实现某种针对该类型的规则。</p><p>当我们定义自己的数据类型时，需要重载 equals() 方法，Java 约定 equals() <strong>必须是一种等价性关系</strong>，它必须具有：</p><ul><li>自反性：x.equals(x) 为 true；</li><li>对称性：当且仅当 y.equals(x) 为 true 时，x.equals(y) 返回 true；</li><li>传递性：如果 x.equals(y) 和 y.equals(z) 均为 true，x.equals(z) 也将为 true；</li><li>一致性：当两个对象均未被修改时，反复调用 x.equals(y) 总是会返回相同的值；</li><li>非空性：x.equals(null) 总是返回 false；</li></ul><p>确保这些性质成立并遵守 Java 的约定，同时又避免在实现时做无用功<strong>并不容易</strong>：</p><ul><li>如果该对象的引用和参数对象的引用相同，返回 true。这样测试在成立时，<strong>能够免去其他所有测试工作</strong>；</li><li>如果参数为 null，根据约定返回 false。还可以<strong>避免在下面的代码中使用空引用</strong>；</li><li>如果两个对象的类不同，返回 false。要得到一个对象的类，可以使用 <strong>getClass() 方法</strong>；</li><li>将参数对象的类型从 Object 转换到 Date；</li><li>如果任意实例变量的值不相同，返回 false。对于其他类，<strong>等价性测试方法的定义可能不同</strong>；</li></ul><p>可以使用下面的实现，作为实现任意数据类型的 toString() 和 equals() 方法的模版：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/14.jpg" alt></p><h3 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h3><p>如下所示的三行赋值语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Date a = <span class="keyword">new</span> Date(<span class="number">12</span>, <span class="number">31</span>, <span class="number">1999</span>);</span><br><span class="line">Date b = <span class="keyword">new</span> Date(<span class="number">1</span>, <span class="number">1</span>, <span class="number">2011</span>);</span><br><span class="line">a = b;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/02/15.jpg" alt></p><p>本来该对象的唯一引用就是变量 a，但是<strong>该引用被赋值语句覆盖了</strong>，这样的对象被称为<code>孤儿</code>。</p><p>内存管理对于原始数据类型更容易，因为内存分配所需要的所有信息，<strong>在编译阶段就能够获取</strong>。</p><p>对象的内存管理更加复杂：系统会在创建一个对象时为它分配内存，但是<strong>程序在执行时的动态性</strong>，决定了一个对象何时才会变为孤儿，系统并不能准确地知道应该何时释放一个对象的内存。</p><p>Java 最重要的一个特性就是<strong>自动内存管理</strong>。它通过记录孤儿对象，并将它们的内存释放到内存池中，将程序员从管理内存的责任中解放出来。这种回收内存的方式叫做<code>垃圾回收</code>。</p><blockquote><p>Java 的一个特点就是它<strong>不允许修改引用</strong>的策略，这种策略使 Java 能够高效自动地回收垃圾。</p></blockquote><h3 id="不可变性"><a href="#不可变性" class="headerlink" title="不可变性"></a>不可变性</h3><p>Java 语言通过 final 修饰符来强制保证不可变性。当你将一个变量声明为 final 时，也就<strong>保证了只会对它赋值一次</strong>，可以用赋值语句，也可以用构造函数。试图改变 final 变量的值的代码，将会产生一个<code>编译时错误</code>。</p><p>一般来说，不可变的数据类型比可变的数据类型使用更容易，<strong>误用更困难</strong>，因为能够改变它们的值的方式要少得多。</p><p>不可变性的缺点：</p><ul><li><strong>需要为每个值创建一个新对象</strong>。这种开销一般是可以接受的，因为 Java 的垃圾回收器通常都为此进行了优化；</li><li>final 非常不幸地只能用来保证原始数据类型的实例变量的不可变性，而<strong>无法用于引用类型的变量</strong>；</li></ul><p>任何数据类型的设计都需要考虑到不可变性，而且数据类型是否是不可变的<strong>应该在 API 中说明</strong>，这样使用者才能知道该对象中的值，是无法改变的。</p><h3 id="契约式设计"><a href="#契约式设计" class="headerlink" title="契约式设计"></a>契约式设计</h3><p>Java 语言中能够<strong>在程序运行时检验程序状态</strong>，为此我们将使用两种 Java 的语言特性：</p><ul><li>异常（Exception）：一般用于处理不受我们控制的不可预见的错误；</li><li>断言（Assertion）：验证我们在代码中做出的一些假设；</li></ul><blockquote><p>大量使用异常和断言是很好的编程实践。</p></blockquote><h4 id="异常与错误"><a href="#异常与错误" class="headerlink" title="异常与错误"></a>异常与错误</h4><p>异常和错误都是在程序运行中出现的破坏性事件，Java 采取的行动称为<code>抛出异常</code>或是<code>抛出错误</code>。</p><p>一种叫做<strong>快速出错</strong>的常规编程实践提倡：一旦出错就立刻抛出异常，使定位出错位置更容易。</p><h4 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h4><p>断言是一条需要在程序的某处确认为 true 的布尔表达式。如果表达式的值为 false，<strong>程序将会终止并报告一条出错信息</strong>。我们使用断言来确定程序的正确性，并记录我们的意图。</p><p>默认设置没有启动断言，可以在命令行下使用 -ea 标志启用断言。<strong>断言的作用是调试</strong>：程序在正常操作中不应该依赖断言，因为它们可能会被禁用。</p><p>一种叫做<code>契约式设计</code>的编程模型采用的就是这种思想，数据类型的设计者需要说明：</p><ul><li>前提条件：用例在调用某个方法前必须满足的条件；</li><li>后置条件：实现在方法返回时必须达到的要求；</li><li>副作用：方法可能对对象状态产生的任何其他变更；</li></ul><p>在开发过程中，这些条件可以用断言进行测试。</p>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式处理与大数据平台</title>
      <link href="2019/08/25/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0/"/>
      <url>2019/08/25/%E5%88%86%E5%B8%83%E5%BC%8F%E5%A4%84%E7%90%86%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>分布式系统和大数据处理平台是目前业界关注的热门技术。三大重量级武器：<strong>Hadoop、Spark、Storm</strong>，以及新一代的数据采集和分析引擎 Elasticsearch。<br>实际上，摩尔定律的失效，必将导致越来越多的复杂任务必须<strong>采用分布式架构进行处理</strong>。已有的开源平台提供了很好的实现参考，方便用户将更多的精力放到核心业务的维护上。</p><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><p>Hadoop 是 Apache 软件基金会旗下的一个开源<strong>分布式计算平台</strong>，基于 Java 语言实现，由三个核心子系统组成：<strong>HDFS、YARN、MapReduce</strong>。其中，HDFS 是一套分布式文件系统；YARN 是资源管理系统，MapReduce 是<strong>运行在 YARN 上的应用</strong>，负责分布式处理管理。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/02/01.jpg" alt><br>核心子系统说明如下：</p><ul><li>HDFS：一个<strong>高度容错性的分布式文件系统</strong>，适合部署在大量廉价的机器上，提供高吞吐量的数据访问；</li><li>YARN：<strong>资源管理器</strong>，可为上层应用提供统一的资源管理和调度，兼容多计算框架；</li><li>MapReduce：是一种<strong>分布式编程模型</strong>，把大规模数据集的处理，<code>分发（Map）</code>给网络上的多个节点，之后收集处理结果进行<code>规约（Reduce）</code>。</li></ul><a id="more"></a><p>Hadoop 还包括 HBase（列数据库）、Cassandra（分布式数据库）、Hive（支持 SQL 语句）、Pig（流处理引擎）、Zookeeper（分布式应用协调服务）等相关项目，其<code>生态系统</code>如下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/02/02.jpg" alt></p><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><p>Apache Spark 是一个围绕速度、易用性和复杂分析构建的<strong>大数据处理框架</strong>，基于 Scala 开发。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/02/03.jpg" alt><br>除了 Spark 核心 API 之外，Spark 生态系统中还包括其他附加库，可以在大数据分析和机器学习领域<strong>提供更多的能力</strong>。这些库包括：Spark Streaming（用于构建弹性容错的流处理 App）、Spark SQL（支持 SQL 语句以及结构化数据处理）、Spark MLlib（用于机器学习）、Spark GraphX（用于图数据处理）。<br>包括三个主要组件：驱动程序、集群管理器、工作者节点：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/02/04.jpg" alt></p><h2 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h2><p>Apache Storm 是一个<strong>实时流计算框架</strong>，由 Twitter 在 2014 年正式开源，基于 Clojure 语言实现。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/02/05.jpg" alt><br>与 Hadoop 集群在工作方式上十分相似：</p><ul><li>Hadoop 上运行的是 MapReduce 任务，完成处理即会结束；</li><li>Storm 上运行的是 topology，<strong>永远在等待消息</strong>并处理。</li></ul><p>Storm 集群中有两种节点：主节点和工作节点：</p><ul><li>主节点运行一个叫 <code>Nimbus</code> 的守护进程，负责向集群中分发代码，向各机器分配任务，以及监测故障；</li><li>工作节点运行 <code>Supervisor</code> 守护进程，负责监听 Nimbus 指派到机器的任务，根据指派信息来<strong>管理工作者进程</strong>，执行一个 topology 的任务子集。</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/02/06.jpg" alt></p><blockquote><p>Nimbus 和 Supervisors 之间的所有协调调度通过 Zookeeper 集群来完成。另外，Nimbus 和 Supervisor 都是<strong>快速失败和无状态</strong>的，实现极高的稳定度。</p></blockquote><h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p>Elasticsearch 是基于 Java 的分布式、多租户的<strong>全文搜索引擎</strong>，支持 RESTful 接口。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/02/07.jpg" alt><br>支持实时分布式数据存储和分析查询功能，可以轻松扩展到上百万台服务器，同时支持处理 PB 级<strong>结构化或非结构化数据</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Web 服务与应用</title>
      <link href="2019/08/24/Web-%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%BA%94%E7%94%A8/"/>
      <url>2019/08/24/Web-%E6%9C%8D%E5%8A%A1%E4%B8%8E%E5%BA%94%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<p>Web 服务和应用是目前互联网技术领域的热门技术。重点介绍如何使用 Docker 来运行常见的 Web 服务器（包括 Apache、Nginx、Tomcat 等），以及一些常见应用（包括 <code>LAMP</code> 和 <code>CI/CD</code>）。<br>包括 Web 服务在内的<strong>中间件领域十分适合引入容器技术</strong>：</p><ul><li>中间件服务器是除数据库服务器外的主要计算节点，<strong>很容易成为性能瓶颈</strong>，所以通常需要大批量部署，而 Docker 对于批量部署有着许多先天的优势；</li><li>中间件服务器结构清晰，在剥离了配置文件、日志、代码目录之后，容器几乎可以<strong>处于零增长状态</strong>，这使得容器的迁移更加方便；</li><li>中间服务器很容易实现集群，在使用硬件的 F5、软件的 Nginx 等<strong>负载均衡后</strong>，中间件服务器集群变得非常容易。</li></ul><blockquote><p>需要注意<strong>数据的持久化</strong>。对于程序代码、资源目录、日志、数据库、文件等需要实时更新和保存的数据，一定要启动数据持久化机制，避免发生数据丢失。</p></blockquote><h2 id="Apache"><a href="#Apache" class="headerlink" title="Apache"></a>Apache</h2><p>Apache 是一个高稳定性的、商业级别的开源 Web 服务器，是目前世界使用排名第一的 <strong>Web 服务器软件</strong>。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/01/01.jpg" alt><br>在使用 Dockerfile 创建镜像时，会继承父镜像的开放端口，但却<strong>不会继承启动命令</strong>。因此，需要在 run.sh 脚本中添加启动 sshd 的服务的命令。</p><a id="more"></a><h2 id="Nginx"><a href="#Nginx" class="headerlink" title="Nginx"></a>Nginx</h2><p>Nginx 是一款功能强大的开源<strong>反向代理服务器</strong>，支持 HTTP、HTTPS、SMTP、POP3、IMAP 等协议。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/01/02.jpg" alt><br>特性如下：</p><ul><li><strong>热部署</strong>：采用 master 管理进程与 worker 工作进程的分离设计，支持热部署；</li><li><strong>高并发连接</strong>：Nginx 可以轻松支持超过 100K 的并发，理论上支持的并发连接上限取决于机器内存；</li><li><strong>低内存消耗</strong>：在一般情况下，10K 个非活跃的 HTTP Keep-Alive 连接在 Nginx 中仅消耗 2.5MB 的内存；</li><li><strong>响应快</strong>：在高峰期，Nginx 可以比其他的 Web 服务器更快地响应请求；</li><li><strong>高可靠性</strong>：高可靠性来自其核心框架代码的优秀设计和实现。</li></ul><h2 id="Tomcat"><a href="#Tomcat" class="headerlink" title="Tomcat"></a>Tomcat</h2><p>Tomcat 由 Apache 软件基金会开发，实现了对 Servlet 和 JSP 的支持。同时，它提供了作为 Web 服务器的<strong>一些特有功能</strong>，如 Tomcat 管理和控制平台、安全域管理和 Tomcat 阀等。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/01/03.jpg" alt><br>在实际环境中，可以通过 -v 参数来挂载 Tomcat 的日志文件、程序所在目录，以及相关配置。</p><h2 id="Jetty"><a href="#Jetty" class="headerlink" title="Jetty"></a>Jetty</h2><p>Jetty 是一个优秀的开源 <strong>Servlet 容器</strong>，以其高效、小巧、可嵌入式等优点深得人心，它为基于 Java 的 Web 内容提供运行环境。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/01/04.jpg" alt><br>与相对老牌的 Tomcat 比，Jetty <strong>架构更合理、性能更优</strong>。尤其在启动速度上，让 Tomcat 望尘莫及，目前在国内外互联网企业中应用广泛。</p><h2 id="LAMP"><a href="#LAMP" class="headerlink" title="LAMP"></a>LAMP</h2><p>LAMP 是目前流行的 <strong>Web 工具栈</strong>，其中包括：Linux 操作系统、Apache 网络服务器、MySQL 数据库、PHP 编程语言。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/01/05.jpg" alt></p><ul><li>和 Java/J2EE 架构相比，LAMP 具有 Web 资源丰富、轻量、快速开发等特点；</li><li>和微软的 .NET 架构相比，LAMP 具有通用、跨平台、高性能、低价格的优势。</li></ul><h2 id="持续开发与管理"><a href="#持续开发与管理" class="headerlink" title="持续开发与管理"></a>持续开发与管理</h2><p>持续集成（Continuous Integration，CI）倡导开发团队定期进行集成验证。集成通过自动化的构建来完成，包括自动编译、发布和测试，从而尽快地发现错误。<br>特点包括：</p><ul><li><strong>鼓励自动化的周期性的过程</strong>，从检出代码、编译构建、运行测试、结果记录、测试统计等都是自动完成的，减少人工干预；</li><li><strong>需要有持续集成系统的支持</strong>，包括代码托管机制支持，以及集成服务器等。</li></ul><p>持续交付（Continuous Delivery，CD）是经典的敏捷软件开发方法的自然延伸，它强调产品在修改后到部署上线的流程要敏捷化、自动化。甚至一些<strong>较少的改变也要尽早地部署上线</strong>。</p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p>Jenkins 是一个得到广泛应用的 CI/CD 工具。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/01/06.jpg" alt><br>作为开源软件项目，它旨在提供一个开放易用的持续集成平台。Jenkins 能实时监控集成中存在的错误，<strong>提供详细的日志文件和提醒功能</strong>，并用图表的形式形象地展示项目构建的趋势和稳定性。</p><h3 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h3><p>GitLab 是一款非常强大的开源源码管理系统。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/OpenSource/01/07.jpg" alt><br>它支持基于 Git 的源码管理、代码评审、Issues 跟踪、活动管理、Wiki 页面、<strong>持续集成和测试等功能</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> OpenSource </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基础编程模型</title>
      <link href="2019/08/20/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
      <url>2019/08/20/%E5%9F%BA%E7%A1%80%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<p>我们学习算法的方法是用 Java 编程语言编写的<code>程序</code>来实现算法，这样做是出于以下原因：</p><ul><li>程序是对算法<strong>精确、优雅和完全</strong>的描述；</li><li>可以通过运行程序来学习算法的各种性质；</li><li>可以在应用程序中直接使用这些算法；</li></ul><blockquote><p>缺点：使用特定的编程语言，会使分离算法的思想和实现细节变得困难。</p></blockquote><p>我们把描述和实现算法所用到的<strong>语言特性、软件库和操作系统特性</strong>总称为基础编程模型。</p><h2 id="Java-程序的基本结构"><a href="#Java-程序的基本结构" class="headerlink" title="Java 程序的基本结构"></a>Java 程序的基本结构</h2><p>一段 Java 程序（<code>类</code>）或者是一个静态方法（<code>函数</code>）库，或者定义一个<code>数据类型</code>，会用到下面七种语法，它们是 Java 语言的基础，也是大多数现代语言所共有的：</p><ul><li>原始数据类型：在计算机程序中精确地定义<strong>整数、浮点数和布尔值</strong>等；</li><li>语句：声明、赋值、条件、循环、调用和返回；</li><li>数组：多个同种数据类型的值的集合；</li><li>静态方法：封装并重用代码，使我们可以用独立的模块开发程序；</li><li>字符串：一连串的字符，Java 内置了对它们的一些操作；</li><li>标准输入／输出：程序与外界联系的桥梁；</li><li>数据抽象：使我们可以<strong>定义非原始数据类型</strong>，进而支持面向对象编程；</li></ul><p>要执行一个 Java 程序，首先需要用 javac 命令编译它（*.class），然后再用 java 命令运行它。</p><a id="more"></a><h2 id="原始数据类型与表达式"><a href="#原始数据类型与表达式" class="headerlink" title="原始数据类型与表达式"></a>原始数据类型与表达式</h2><p>首先考虑以下四种 Java 语言最基本的原始数据类型：</p><ul><li>整型，及其算术运算符（<code>int</code>）；</li><li>双精度实数类型，及其算术运算符（<code>double</code>）；</li><li>布尔型，它的值 {true, false} 及其逻辑操作（<code>boolean</code>）；</li><li>字符型，它的值是你能够输入的英文字母数字字符和符号（<code>char</code>）；</li></ul><p>指明这些类型的值和对这些类型的操作：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/01.jpg" alt></p><blockquote><p>注意：+、-、*、／ 都是被重载过的——根据上下文，同样的运算符对不同类型会执行不同的操作。</p></blockquote><h3 id="表达式"><a href="#表达式" class="headerlink" title="表达式"></a>表达式</h3><p>Java 语言规范约定了如下的运算符<strong>优先级</strong>：* 和 ／（以及 %）的优先级高于 + 和 -；在逻辑运算中，! 拥有最高优先级，之后是 &amp;&amp;，接下来是 ||。</p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>如果不会损失信息，数值会被<strong>自动提升</strong>为高级的数据类型。应该小心并尽量少使用类型转换，最好是在表达式中只使用同一类型的字面量和变量。</p><h3 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h3><p>==、!=、&lt;、&lt;=、&gt; 和 &gt;= 被称为<strong>混合类型运算符</strong>，因为它们的结果是布尔型，而不是参与比较的数据类型。</p><h3 id="其他原始类型"><a href="#其他原始类型" class="headerlink" title="其他原始类型"></a>其他原始类型</h3><p>Java 的 int 型能够<strong>表示 2^32 个不同的值</strong>，用一个字长 32 位的机器字即可表示；与此相似，double 型的标准规定为 64 位。<br>为了提供更大的灵活性，Java 还提供了其他五种原始数据类型：</p><ul><li>64 位整数，及其算术运算符（<code>long</code>）；</li><li>16 位整数，及其算术运算符（<code>short</code>）；</li><li>16 位字符，及其算术运算符（<code>char</code>）；</li><li>8 位整数，及其算术运算符（<code>byte</code>）；</li><li>32 位单精度实数，及其算术运算符（<code>float</code>）；</li></ul><h2 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h2><p>Java 程序是由<code>语句</code>组成的，语句通常会被组织成代码段，即花括号中的一系列语句：</p><ul><li>声明语句：创建某种类型的变量并用标识符为其命名；</li><li>赋值语句：将由表达式产生的某种类型的数值赋予一个变量；</li><li>条件语句：能够<strong>简单地</strong>改变执行流程——根据指定的条件执行两个代码段之一；</li><li>循环语句：更<strong>彻底地</strong>改变执行流程——只要条件为真就不断地反复执行代码中的语句；</li><li>调用和返回语句：和静态方法有关，是改变执行流程和代码组织的另一种方式；</li></ul><h3 id="声明语句"><a href="#声明语句" class="headerlink" title="声明语句"></a>声明语句</h3><p><code>声明</code>语句将一个变量名和一个类型在编译时关联起来。Java 是一种<code>强类型</code>的语言，因为 Java 编译器会检查类型的一致性。</p><h3 id="赋值语句"><a href="#赋值语句" class="headerlink" title="赋值语句"></a>赋值语句</h3><p><code>赋值</code>语句将某个数据类型的值和一个变量关联起来。</p><h3 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h3><p>大多数运算都需要用不同的操作来处理不同的输入。在 Java 中<strong>表达这种差异</strong>的一种方法是 if 语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (&lt;<span class="keyword">boolean</span> expression&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;block statements&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这种描述方式是一种叫做<code>模版</code>的形式记法，&lt;&gt; 中的是我们已经定义过的语法。</p></blockquote><h3 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h3><p>许多运算都需要重复：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (&lt;<span class="keyword">boolean</span> expression&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;block statements&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只要布尔表达式的值为真，就<strong>继续执行</strong>代码段。</p><h3 id="break-和-continue-语句"><a href="#break-和-continue-语句" class="headerlink" title="break 和 continue 语句"></a>break 和 continue 语句</h3><p>Java 支持<strong>在 while 循环中</strong>使用另外两条语句：</p><ul><li>break 语句，立即从循环中退出；</li><li>continue 语句，立即开始下一轮循环；</li></ul><h2 id="简便记法"><a href="#简便记法" class="headerlink" title="简便记法"></a>简便记法</h2><p>程序有很多种写法，我们追求清晰、优雅和高效的代码。</p><h3 id="声明并初始化"><a href="#声明并初始化" class="headerlink" title="声明并初始化"></a>声明并初始化</h3><p>可以将声明语句和赋值语句结合起来。最好在接近首次使用变量的地方声明它并将其初始化（为了<strong>限制作用域</strong>）。</p><h3 id="隐式赋值"><a href="#隐式赋值" class="headerlink" title="隐式赋值"></a>隐式赋值</h3><p>当希望一个变量的值<strong>相对于其当前值</strong>变化时，可以使用一些简便的写法：</p><ul><li>递增／递减运算符，++i 等价于 i=i+1；</li><li>其他复合运算符，i/=2 等价于 i=i/2；</li></ul><h3 id="单语句代码段"><a href="#单语句代码段" class="headerlink" title="单语句代码段"></a>单语句代码段</h3><p>即使条件或循环语句的代码段只有一条语句，代码段的花括号也<strong>不要省略</strong>。</p><h3 id="for-语句"><a href="#for-语句" class="headerlink" title="for 语句"></a>for 语句</h3><p>很多<strong>循环的模式</strong>都是这样的：初始化一个索引变量，然后使用 while 循环并将包含索引变量的表达式作为循环的条件，while 循环的最后一条语句会将索引变量加 1。<br>使用 for 语句可以<strong>更紧凑地</strong>表达这种循环：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (&lt;initialize&gt;; &lt;<span class="keyword">boolean</span> expression&gt;; &lt;increment&gt;)</span><br><span class="line">&#123;</span><br><span class="line">    &lt;block statements&gt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码一般等价于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;initialize&gt;;</span><br><span class="line"><span class="keyword">while</span> (&lt;<span class="keyword">boolean</span> expression&gt;) </span><br><span class="line">&#123;</span><br><span class="line">    &lt;block statements&gt;</span><br><span class="line">    &lt;increment&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p><code>数组</code>能够顺序存储<strong>相同类型</strong>的多个数据。除了存储数据，我们也希望能够访问数据。访问数组中的某个元素的方法是将其编号然后<code>索引</code>。</p><h3 id="创建并初始化数组"><a href="#创建并初始化数组" class="headerlink" title="创建并初始化数组"></a>创建并初始化数组</h3><p>在 Java 程序中创建一个数组需要三步：</p><ul><li><strong>声明</strong>数组的名字和类型；</li><li><strong>创建</strong>数组，需要指定数组的长度（元素的个数）；</li><li><strong>初始化</strong>数组元素；</li></ul><p>完整模式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>[] a;</span><br><span class="line">a = <span class="keyword">new</span> <span class="keyword">double</span>[N];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    a[i] = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第二条语句中的关键字 <code>new</code> 使 Java 创建了这个数组。我们需要在<strong>运行时</strong>明确地创建数组的原因是编译器在编译时无法知道应该为数组预留多少空间（对于原始类型则可以）。</p><blockquote><p>使用数组时，一定要依次声明、创建并初始化数组。</p></blockquote><h3 id="简化写法"><a href="#简化写法" class="headerlink" title="简化写法"></a>简化写法</h3><p>常常会利用 Java 对数组<strong>默认的初始化</strong>来将三个步骤合为一条语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span>[] a = <span class="keyword">new</span> <span class="keyword">double</span>[N];</span><br></pre></td></tr></table></figure><p>等号的左侧声明了数组，等号的右侧创建了数组。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>&#125;;</span><br></pre></td></tr></table></figure><p>第三种方式用花括号将一列由逗号分隔的值，在<strong>编译时</strong>将数组初始化。</p><h3 id="使用数组"><a href="#使用数组" class="headerlink" title="使用数组"></a>使用数组</h3><p>在声明并创建数组之后，在代码的任何地方都能通过数组名之后的方括号中的索引来访问其中的元素。数组一经创建，它的大小就是<strong>固定的</strong>。</p><h3 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h3><p>数组名表示的是整个数组——如果我们将一个数组变量赋予另一个变量，那么两个变量将会<strong>指向同一个数组</strong>。例如以下这段代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">a[i] = <span class="number">1234</span>;</span><br><span class="line"><span class="keyword">int</span>[] b = a;</span><br><span class="line">b[i] = <span class="number">5678</span>; <span class="comment">// a[i] 的值也会变成 5678</span></span><br></pre></td></tr></table></figure><p>这种情况叫做<code>起别名</code>。如果想将数组复制一份，那么应该声明、创建并初始化一个新的数组，然后将原数组中的元素值挨个复制到新数组。</p><h3 id="二维数组"><a href="#二维数组" class="headerlink" title="二维数组"></a>二维数组</h3><p>在 Java 中<code>二维数组</code>就是一维数组的数组。二维数组可以是参差不齐的（元素数组的<strong>长度可以不一致</strong>）。<br>默认的初始化对二维数组更有用，因为可以节约更多的代码。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><p>所有 Java 程序要么是<code>数据类型</code>的定义，要么是一个<code>静态方法库</code>。修饰符 static 将这类方法和<code>实例方法</code>区别开来。</p><h3 id="静态方法-1"><a href="#静态方法-1" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>方法</code>封装了由一系列语句所描述的运算。需要参数并根据参数计算出某种数据类型的<code>返回值</code>或者产生某种<code>副作用</code>。<br>每个静态方法都是由<code>签名</code>和<code>函数体</code>组成的。</p><h3 id="调用静态方法"><a href="#调用静态方法" class="headerlink" title="调用静态方法"></a>调用静态方法</h3><p>调用静态方法的方法是写出方法名并在后面的括号中列出参数值，用逗号分隔。<br>仅由一个方法调用和一个分号组成的语句，一般用于<strong>产生副作用</strong>。</p><blockquote><p>返回语句将结束静态方法并将控制权交还给调用者。</p></blockquote><h3 id="方法的性质"><a href="#方法的性质" class="headerlink" title="方法的性质"></a>方法的性质</h3><ul><li>方法的参数按值传递：在方法中参数变量的<strong>使用方法和局部变量相同</strong>，唯一不同的是参数变量的初始值是由调用方提供的。方法处理的是参数的值，<strong>而非参数本身</strong>；</li><li>方法名可以被重载：常见用法是为函数定义两个版本，其中一个需要参数而另一个则为该参数<strong>提供默认值</strong>；</li><li>方法只能返回一个值，但可以包含多个返回语句：Java 方法只能返回一个值，它的类型是方法签名中<strong>声明的类型</strong>；</li><li>方法可以产生副作用：我们称 void 类型的静态方法会产生副作用，接受输入、产生输出、修改数组或者改变系统状态；</li></ul><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>我们会经常使用递归，因为递归代码比相应的非递归代码更加<strong>简洁优雅、易懂</strong>。<br>编写递归代码时，最重要的有以下三点：</p><ul><li>递归总有一个<strong>最简单的情况</strong>——方法的第一条语句总是一个包含 return 的条件语句；</li><li>递归调用总是去尝试解决一个<strong>规模更小</strong>的子问题，这样递归才能收敛到最简单的情况；</li><li>递归调用的父问题和尝试解决的子问题之间不应该有<strong>交集</strong>；</li></ul><h3 id="基础编程模型"><a href="#基础编程模型" class="headerlink" title="基础编程模型"></a>基础编程模型</h3><p>静态方法库是定义在一个 Java 类中的一组静态方法。类的声明是 public class 加上类名，存放类的文件的文件名和类名相同，扩展名是 <code>.java</code>。</p><blockquote><p>Java 开发的基本模式是：编写一个静态方法库来完成一个任务。</p></blockquote><h3 id="模块化编程"><a href="#模块化编程" class="headerlink" title="模块化编程"></a>模块化编程</h3><p>通过静态方法库实现了模块化编程。我们可以构造许多个静态方法库（<code>模块</code>），一个库的静态方法也能够调用另一库中定义的静态方法，这样能够带来许多好处：</p><ul><li>程序整体的代码量很大时，每次处理的模块大小仍然适中；</li><li>可以共享和重用代码而无需重新实现；</li><li>很容易用改进的实现替换老的实现；</li><li>可以为解决编程问题建立合适的抽象模型；</li><li><strong>缩小调试范围</strong>；</li></ul><h3 id="单元编程"><a href="#单元编程" class="headerlink" title="单元编程"></a>单元编程</h3><p>Java 编程的最佳实践之一就是每个静态方法库中<strong>都包含一个 main() 函数</strong>来测试库中的所有方法。<br>每个模块的 main() 方法至少应该调用模块的其他代码并在某种程度上保证它的正确性。</p><h3 id="外部库"><a href="#外部库" class="headerlink" title="外部库"></a>外部库</h3><p>重用每种库代码的方式都稍有不同，它们大多都是静态方法库：</p><ul><li><strong>系统标准库 java.lang.*</strong>：例如 Math 库，实现了常用的数学函数；</li><li>导入的系统库：例如 java.util.Arrays；</li></ul><p>要调用另一库中的方法（存放在相同或指定的目录中，或是一个系统标准库，或是在类定义前用 import 语句导入的库），我们需要<strong>在方法前指定库的名称</strong>。</p><blockquote><p>我们自己及他人使用模块化方式编写的方法库，能够极大地扩展我们的编程模型。</p></blockquote><h2 id="API"><a href="#API" class="headerlink" title="API"></a>API</h2><p>模块化编程的一个重要组成部分就是记录库方法的用法并供其他人参考的<code>文档</code>。我们会使用<code>应用程序编程接口</code>（API）的方式列出每个库方法名称、签名和简短的描述。</p><h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><p>用 java.lang 中 Math 库常用的静态方法说明 API 的文档格式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/02.jpg" alt></p><h3 id="Java-库"><a href="#Java-库" class="headerlink" title="Java 库"></a>Java 库</h3><p>Arrays 库不在 java.lang 中，因此我们需要用 import 语句导入后才能使用它。<br>为了避免混淆，我们一般会<strong>使用自己的实现</strong>，但对于你已经掌握的算法使用高度优化的库实现当然也没有任何问题。</p><h3 id="我们的标准库"><a href="#我们的标准库" class="headerlink" title="我们的标准库"></a>我们的标准库</h3><p>为了介绍 Java 编程、为了科学计算以及算法的开发、学习和应用，我们也开发了若干库来提供一些实用的功能。这些库大多<strong>用于处理输入输出</strong>。<br>第一个库扩展了 Math.random() 方法，以根据不同的概率密度函数得到随机值；第二个库则支持各种统计计算：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/03.jpg" alt><br>设计良好的方法库：</p><ul><li>这些方法所实现的抽象层有助于我们<strong>将精力集中在实现和测试算法</strong>，而非生成随机数或是统计计算；</li><li>方法库会经过大量测试，<strong>覆盖极端和罕见的情况</strong>，是我们可以信任的。这样的实现需要大量的代码；</li></ul><h3 id="自己编写的库"><a href="#自己编写的库" class="headerlink" title="自己编写的库"></a>自己编写的库</h3><p>将自己编写的每一个程序都当作一个日后可以重用的库：</p><ul><li><strong>编写用例</strong>，在实现中将计算过程分解成可控的部分；</li><li>明确静态方法库和与之对应的 API；</li><li>实现 API 和一个能够对方法进行独立测试的 main() 函数；</li></ul><p>API 的目的是<strong>将调用和实现分离</strong>：除了 API 给出的信息，调用者不需要知道实现的其他细节，而实现也不应考虑特殊的应用场景。<br>相应地，程序员也可以将 API 看作调用和实现之间的一份契约，它详细说明了每个方法的作用。<strong>实现的目标就是能够遵守这份契约</strong>。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>一个 String 类型的字面量包括一对双引号和其中的字符（char）。String 类型是 Java 的一个数据类型，但并<strong>不是原始数据类型</strong>。</p><h3 id="字符串拼接"><a href="#字符串拼接" class="headerlink" title="字符串拼接"></a>字符串拼接</h3><p>Java 内置了一个串联 String 类型字符串的运算符：“+”。</p><h3 id="类型转换-1"><a href="#类型转换-1" class="headerlink" title="类型转换"></a>类型转换</h3><p>字符串的两个主要用途：</p><ul><li>将用户从键盘输入的内容转换成相应数据类型的值；</li><li>将各种数据类型的值转化成能够在屏幕上显示的内容；</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/04.jpg" alt></p><h3 id="自动转换"><a href="#自动转换" class="headerlink" title="自动转换"></a>自动转换</h3><p>我们<strong>很少明确使用 toString() 方法</strong>，因为 Java 在连接字符串的时候会自动将任意数据类型的值转换为字符串：<br>如果“+”的一个参数是字符串，那么 Java 会自动将其他参数都转换为字符串。</p><h3 id="命令行参数"><a href="#命令行参数" class="headerlink" title="命令行参数"></a>命令行参数</h3><p>在 Java 中字符串的一个重要的用途就是<strong>使程序能够接收到从命令行传递来的信息</strong>。<br>当你输入命令 java 和一个库名以及一系列字符串之后，Java 系统会调用库的 main() 方法并<strong>将那一系列字符串变成一个数组</strong>作为参数传递给它。</p><blockquote><p><strong>字符串的用法</strong>是现代程序中的重要部分。</p></blockquote><h2 id="输入输出"><a href="#输入输出" class="headerlink" title="输入输出"></a>输入输出</h2><p>我们的标准输入、输出和绘图库的作用是建立一个 Java 程序<strong>和外界交流的简易模型</strong>。默认情况下，命令行参数、标准输入和标准输出是和应用程序绑定的，而应用程序是<strong>由能够接受命令输入的操作系统或是开发环境所支持</strong>。<br>我们笼统地用<code>终端</code>来指代这个应用程序提供的供输入和显示的窗口。</p><h3 id="命令和参数"><a href="#命令和参数" class="headerlink" title="命令和参数"></a>命令和参数</h3><p>Java 类都会包含一个静态方法 main()，它有一个 <strong>String 数组类型的参数 args[]</strong>。这个数组的内容就是我们输入的命令行参数，操作系统会将它传递给 Java。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/05.jpg" alt></p><h3 id="标准输出"><a href="#标准输出" class="headerlink" title="标准输出"></a>标准输出</h3><p>一般来说，系统会将标准输出打印到终端窗口：</p><ul><li>print() 方法会将它的参数放到标准输出中；</li><li>pirntln() 方法会<strong>附加一个换行符</strong>；</li><li>pirntf() 方法能够格式化输出；</li></ul><h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p>printf() 方法接受两个参数。第一个参数是一个<code>格式字符串</code>，描述了第二个参数应该如何在输出中被转换为一个字符串。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/06.jpg" alt></p><h3 id="标准输入"><a href="#标准输入" class="headerlink" title="标准输入"></a>标准输入</h3><p>StdIn 库从标准输入流中获取数据，这些数据可能为空也可能是一系列由空白字符分隔的值（<strong>空格、制表符、换行符等</strong>）。默认状态下，系统会将标准输出定向到终端窗口——你输入的内容就是输入流（<strong>由 &lt;ctrl+d&gt; 结束</strong>）。<br>只要程序读取了一个值，它就不能回退并再次读取它。这个特点产生了一些限制，但它<strong>反映了一些输入设备的物理特性</strong>并简化了对这些设备的抽象。</p><h3 id="重定向与管道"><a href="#重定向与管道" class="headerlink" title="重定向与管道"></a>重定向与管道</h3><p>标准输入输出使我们能够利用许多操作系统都支持的<strong>命令行的扩展功能</strong>。<br>向启动程序的命令中加入一个简单的提示符，就可以将它的标准输出<code>重定向</code>至一个文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java RandomSep 1000 100.0 200.0 &gt; data.txt</span><br></pre></td></tr></table></figure><p>我们可以重定向标准输入以使 StdIn 从文件而不是终端应用程序中读取数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java Average &lt; data.txt</span><br></pre></td></tr></table></figure><p>将这些结合起来，将一个程序的输出重定向为另一个程序的输入叫做<code>管道</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java RandomSep 1000 100.0 200.0 | java Average</span><br></pre></td></tr></table></figure><blockquote><p><strong>突破了我们能够处理的输入输出流的长度限制</strong>。我们的程序不再需要担心细节，因为它们只会和标准输入和标准输出的抽象打交道。</p></blockquote><h3 id="基于文件的输入输出"><a href="#基于文件的输入输出" class="headerlink" title="基于文件的输入输出"></a>基于文件的输入输出</h3><p>In 和 Out 两个库也实现了一些数据类型和它们的实例方法，这使我们能够<strong>将多个文件作为输入输出流</strong>并将网页作为输入流（name 参数可以是文件或网页）：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/07.jpg" alt></p><h3 id="标准绘图库（基本方法）"><a href="#标准绘图库（基本方法）" class="headerlink" title="标准绘图库（基本方法）"></a>标准绘图库（基本方法）</h3><p>我们要介绍一个产生图像输出的抽象层。这个库的使用非常简单并且允许我们利用可视化的方式<strong>处理比文字丰富得多的信息</strong>：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/08.jpg" alt></p><h3 id="标准绘图库（控制方法）"><a href="#标准绘图库（控制方法）" class="headerlink" title="标准绘图库（控制方法）"></a>标准绘图库（控制方法）</h3><p>标准绘图库中还包含了一些方法来改变画布的大小和比例、直线的颜色和宽度、文本字体、绘图时间等：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CLRS/01/09.jpg" alt><br>绘图库<strong>支持动画</strong>，我们会在数据分析和算法的可视化中使用 StdDraw。</p><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>展示学习新算法的基本方法。</p><h3 id="二分查找-1"><a href="#二分查找-1" class="headerlink" title="二分查找"></a>二分查找</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BinarySearch</span> </span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">rank</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span>[] a)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 数组必须是有序的</span></span><br><span class="line">        <span class="keyword">int</span> lo = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hi = a.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (lo &lt;= hi)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 被查找的键要么不存在，要么必然存在于a[lo..hi]之中</span></span><br><span class="line">            <span class="keyword">int</span> mid = lo + (hi - lo) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (key &lt; a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                hi = mid - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (key &gt; a[mid])</span><br><span class="line">            &#123;</span><br><span class="line">                lo = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] whitelist = In.readInts(args[<span class="number">0</span>]);</span><br><span class="line">        Arrays.sort(whitelist);</span><br><span class="line">        <span class="keyword">while</span> (StdIn.isEmpty() == <span class="keyword">false</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 读取键值，如果不存在于白名单中则将其打印</span></span><br><span class="line">            <span class="keyword">int</span> key = StdIn.readInt();</span><br><span class="line">            <span class="keyword">if</span> (rank(key, whitelist) &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                StdOut.println(key);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段程序接受一个白名单文件作为参数，并会过滤掉标准输入中的所有存在于白名单中的条目，<strong>仅将不在白名单上的整数打印到标准输出中</strong>。</p><h3 id="开发用例"><a href="#开发用例" class="headerlink" title="开发用例"></a>开发用例</h3><p>对于每个算法的实现，我们都会开发一个用例 main() 函数，并<strong>提供一个示例输入文件</strong>来辅助学习该算法并检测它的性能。</p><h3 id="白名单过滤"><a href="#白名单过滤" class="headerlink" title="白名单过滤"></a>白名单过滤</h3><p>如果可能，我们的测试用例都会通过<strong>模拟实际情况</strong>来展示当前算法的必要性。这里该过程被称为<code>白名单过滤</code>。</p><h3 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h3><p>一个程序只是可用往往是不够的。没有如二分查找或者归并排序这样的高效算法，解决大规模的白名单问题是不可能的。<strong>良好的性能常常是极为重要的</strong>。</p><blockquote><p>基础编程模型的目标是：确保你能够在计算机上运行类似于 BinarySearch 的代码，使用它处理我们的测试数据并<strong>为适应各种情况修改它</strong>，以完全理解它的可应用性。</p></blockquote><h2 id="展望"><a href="#展望" class="headerlink" title="展望"></a>展望</h2><p>现代编程技术已经更进一步，前进的这一步被称为<code>数据抽象</code>，有时也被称为<code>面向对象编程</code>。简单地说，数据抽象的主要思想是鼓励程序定义自己的数据类型，而<strong>不仅仅是那些操作预定义的数据类型的静态方法</strong>。<br>“拥抱”数据抽象的原因主要有三：</p><ul><li>它允许我们通过模块化编程复用代码；</li><li>它使我们可以轻易构造出多种所谓的<code>链式数据结构</code>，它们比数组更灵活，在许多情况下都是高效算法的基础；</li><li>借助它我们可以准确地定义所面对的算法问题；</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CLRS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Meetings</title>
      <link href="2019/08/18/Meetings/"/>
      <url>2019/08/18/Meetings/</url>
      
        <content type="html"><![CDATA[<h2 id="Running-a-face-to-face-meeting"><a href="#Running-a-face-to-face-meeting" class="headerlink" title="Running a face-to-face meeting"></a>Running a face-to-face meeting</h2><blockquote><p>So, let’s get started.</p></blockquote><h3 id="USEFUL-TIPS"><a href="#USEFUL-TIPS" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><ul><li><strong>Go through the agenda</strong> at the start of the meeting and check no items are missing;</li><li><strong>Ensure good timekeeping</strong> during the meeting, making sure that participants stick to the agenda and don’t get sidetracked;</li><li><strong>Control the discussion</strong>, making sure all participants contribute where relevant and that no one person dominates the whole meeting;</li><li><strong>Summarize key decisions</strong> at the end of each agenda point;<a id="more"></a></li></ul><h3 id="Track-45"><a href="#Track-45" class="headerlink" title="Track 45"></a>Track 45</h3><p>Janette: Everybody is here now. <strong>So, let’s get stared.</strong> Now, we’re here to discuss the rollout of the new SAP customer relationship program. You are the people who’ll have to implement it and we need to decide what you need for the rollout. <strong>So, let’s look at point number one on the agenda:</strong> resources. <strong>Fabian, would you like to start?</strong><br>Fabian: Right, at the moment there’s a shortage of human resources to…<br>J: …so by the time everyone has finished the training course, we should be OK. <strong>So, to sum up point number one,</strong> we’ve agreed that Lucy will arrange training sessions for the rollout team together with SAP and I’ll talk to Human Resources about finding more SAP specialists.<br>Lucy: Thanks.<br>J: Good. <strong>Let’s move onto the next point:</strong> budget. <strong>Tony, that’s your field.</strong><br>Tony: Well, I’m afraid that we have a very limited budget for this project, which means that we really have to be imaginative about how we allocate resources…<br>F: …Does that mean training will be cut? Because look at the problems we had last year with the database. I spoke to Billy West in the data center and he said that there was a problem with the…<br>J: <strong>Can I stop you there,</strong> Fabian? <strong>Let’s not go sidetracked.</strong> Let Tony tell us what exactly is planned and then we can…<br>J: …the meeting has been very useful. We all have our action points to deal with and we know the next steps. <strong>How does everybody feel about that?</strong><br>T, L and F: Fine. OK. Good.<br>J: Great! <strong>So, that wraps up everything for today.</strong> Thanks very much for all your ideas. Anybody want to go to lunch?</p><h2 id="Negotiating-agreement"><a href="#Negotiating-agreement" class="headerlink" title="Negotiating agreement"></a>Negotiating agreement</h2><blockquote><p>Well, that’s an interesting proposal, but…</p></blockquote><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SPEAKING/01.jpg" alt></p><h3 id="Track-50"><a href="#Track-50" class="headerlink" title="Track 50"></a>Track 50</h3><p>Janette: And that, basically, is why I called you, Stuart. We don’t have enough SAP specialists for this job ourselves.<br>Stuart: I see. So, what exactly do you need?<br>J: <strong>We propose that</strong> you second us five programmers for customizing the basic SAP package to our needs, two web interface experts to make sure the package is user-friendly and one technical project manager.<br>S: OK. But <strong>we need to talk about</strong> fees. They would have quite different daily rates: €650 for a programmer, €875 for the interface specialists and, um, at least €1,250 for a project manager. Depending on his or her experience.<br>J: Well, we’d like to keep the bookkeeping easy. So, we’d like to aggregate these daily rates. <strong>We suggest that</strong> we pay you €700 per head per day.<br>S: I see. Well, <strong>that’s an interesting proposal, but</strong> €700 per day is far too low. €950 is nearer the mark.<br>J: <strong>I don’t think we could go along with that.</strong> You see, we have very strict budget limits.<br>S: Hmm… <strong>Let’s think about how we can make this work… Another possibility might be</strong> to have two rates: €650 for the programmers and €950 for the others.<br>J: But <strong>have you considered the advantages of</strong> just one single flat rate? It makes the administration so much easier. I mean, <strong>what’s the downside?</strong><br>S: <strong>I take your point.</strong> It’s just a question of agreeing the rate.<br>J: Right. So, by my calculations <strong>if we agree on a daily rate of €750 per head per day, over six months your company will receive</strong>… just a second… €772,000.<br>S: €750 per head per day for six months. Yes, I think we <strong>can live with that.</strong><br>J: Excellent! So, now we just need to decide which people will be most suited…</p><h2 id="Assigning-action-points"><a href="#Assigning-action-points" class="headerlink" title="Assigning action points"></a>Assigning action points</h2><blockquote><p>Who would like to take responsibility for this?</p></blockquote><h3 id="USEFUL-TIPS-1"><a href="#USEFUL-TIPS-1" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><ul><li>Ask people to <strong>agree to action points</strong> rather than simply telling them to do something;</li><li>For a general action point, e.g. organizing somebody to look after visitors to company, <strong>offer the opportunity to anybody</strong> from the team. It may be seen as attractive, especially if it involves entertaining the visitors;</li><li>If the action point is unattractive, such as writing the minutes of a meeting, and nobody volunteers, then <strong>ask the most qualified person</strong>. If necessary, ask if they can reprioritize other tasks;</li><li>Summarize who is responsible for what and <strong>when they have agreed to deliver</strong>;</li></ul><h3 id="Track-55"><a href="#Track-55" class="headerlink" title="Track 55"></a>Track 55</h3><p>Janette: …and we need to work together with SAP experts on this if we want to get the rollout to work properly, right?<br>Lucy, Fabian and Tony: Yeah. Looks like it.<br>J: So, we need to speak to SAP about running a training program for all the system users. <strong>Could you handle that,</strong> Lucy?<br>L: Sure, I’ll call Dieter Grossmann.<br>J: <strong>How soon can you</strong> finish the complete training program, <strong>do you think?</strong><br>L: To train everybody, we’ll need about 3 months. So, <strong>not until</strong> the end of September.<br>J: Great, now the project kick-off meeting. We all agreed to have it on the 12th of July but nobody has done anything yet, have they? No, I thought not. I know I haven’t! Well, we need to move fast on that, so Fabian, <strong>could you deal with that?</strong> Invitations to start with, refreshments, you know.<br>F: Of course.<br>J: <strong>When will the invitations be ready, do you think?</strong><br>F: I’ll do them this afternoon.<br>J: Fine. <strong>I’d like to have them out by</strong> this evening. Now, next week one of our biggest customers, Dimitri Mischkovic, is coming from Moscow to visit the company. He’s arriving on Friday night and is staying here until Wednesday next week. Originally, I was going to take him out in London at the weekend, but my mother is in hospital. <strong>So I need somebody to</strong> take him out, all expenses paid by the company, of course. <strong>Who would like to take responsibility for this?</strong><br>T: Oh, I don’t mind. I mean, if nobody else wants to do that.<br>F: That’s OK with me.<br>L: I don’t think my boyfriend would like me going around London with somebody else anyway!<br>J: Good, I’ll send you the details, Tony. Now, item number four on the agenda: we are going to be audited.<br>T, F and L: No. Not again! So soon?<br>J: Yes. Company policy, I’m afraid. I need somebody to write a report on our business activities over the last 12 months. <strong>Is anybody interested in</strong> doing that? Tony, <strong>how do you feel about taking responsibility for that?</strong> You have the most experience.<br>T: Well, it’s a bit difficult, Janette, you know. I’ve got the department meeting to organize and then the budget to do and then Mr Mischkovic.<br>F: I could look after Mr. Mischkovic for you, Tony.<br>T: No, I mean, I’m not saying…<br>J: <strong>Would you mind prioritizing this,</strong> Tony? It’s really very important.<br>T: Oh. Well, I suppose so.<br>J: Thanks. <strong>Can you send me the report by Friday midday?</strong> Then you can relax over the weekend with Mr. Mischkovic!</p><h2 id="Running-a-teleconference"><a href="#Running-a-teleconference" class="headerlink" title="Running a teleconference"></a>Running a teleconference</h2><blockquote><p>Hi, this is Lee Ming here.</p></blockquote><h3 id="USEFUL-TIPS-2"><a href="#USEFUL-TIPS-2" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><ul><li>One person should take the role of the facilitator. The facilitator should lay out the ground rules for the meeting at the start and control the participants. <strong>Only the facilitator should interrupt another speaker.</strong> Otherwise, it can get very confusing;</li><li>As with regular meetings, there should be a clear agenda, if possible with <strong>strict time limits for each item</strong>;</li><li>The facilitator should ask people by name to contribute to specific topics. Each speaker should <strong>give their name before speaking</strong>;</li><li>Clarity is essential in a teleconference, so native speakers should aim to <strong>speak clearly</strong>, for example minimizing the use of difficult idioms, and non-native speakers should ask if anything is unclear;</li><li>The facilitator should <strong>do a summary</strong> of all points discussed at the end of the teleconference;</li></ul><h3 id="Track-59"><a href="#Track-59" class="headerlink" title="Track 59"></a>Track 59</h3><p>Janette: …so that’s Petra, Carlo, Sanjay. We’re just waiting for Lee Ming and then…<br>System: Ping! Speaker 5 is entering the conference room.<br>Lee Ming: Hi, <strong>this is Lee Ming here.</strong><br>J: Great! So, <strong>it’s Janette here.</strong> Thank you all for participating today. Before we start, let’s just check some ground rules for telephone conferences. <strong>Please always give your name first,</strong> so that we all know who’s speaking. Also, <strong>don’t interrupt other speakers, please.</strong> I’ll make sure that we keep the conversation on track and don’t lose any time. Finally, <strong>please could you make sure that you speak clearly</strong> and <strong>just let me know if anything is unclear?</strong> OK?<br>Petra, Carlo, Sanjay and Lee Ming: Yes. Fine. Good. OK.<br>J: Right, let’s run through the agenda. First of all we want to look at…<br>P: …the hardware and the software is now being tested and will be ready…<br>C: But Petra, that’s not the problem at all! We need to know when!<br>J: Janette here. <strong>Sorry Carlo, can you let Petra finish?</strong> As I said at the beginning of the teleconference, just <strong>one speaker at a time.</strong><br>C: Ah yes. Um, Carlo here. Sorry about that. <strong>Could you repeat that, Petra?</strong> About the software testing?<br>P: Petra here. No problem. So it’ll be ready…<br>S: …and we think that the advantages of outsourcing all activities to Mumbai will be much greater if we are working closely with Singapore.<br>LM: Hmm. Lee Ming here. <strong>I’m not sure what you mean by “closely”.</strong><br>S: Sanjay here. Well, we have a lot of software programmers who could quickly develop the products that your people in Singapore design.<br>J: Janette here. <strong>What do you think about that,</strong> Lee Ming?<br>LM: Lee Ming here. Um, well it depends on what the designers are looking for because…<br>J: …Well, that was very helpful, I think. <strong>So, let me recap our discussion.</strong> The next step is for all of us to begin work on speaking with all the key suppliers in Mumbai… and when that’s finished, the project will be over. <strong>Is that acceptable for you,</strong> Sanjay and Lee Ming?<br>S and LM: Yes. That’s fine.<br>J: And <strong>how about you,</strong> Petra and Carlo? Any questions?<br>P and C: No, I’m happy. Sounds good.<br>J: Excellent! Then, I think that’s enough for today. We have another meeting scheduled for…</p>]]></content>
      
      
      
        <tags>
            
            <tag> SPEAKING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mesos - 优秀的集群资源调度平台</title>
      <link href="2019/08/12/Mesos-%E4%BC%98%E7%A7%80%E7%9A%84%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0/"/>
      <url>2019/08/12/Mesos-%E4%BC%98%E7%A7%80%E7%9A%84%E9%9B%86%E7%BE%A4%E8%B5%84%E6%BA%90%E8%B0%83%E5%BA%A6%E5%B9%B3%E5%8F%B0/</url>
      
        <content type="html"><![CDATA[<p>Mesos 项目是源自 UC Berkeley 的对集群资源进行抽象和管理的开源项目，类似于操作系统内核，使用它可以很容易地<strong>实现分布式应用的自动化调度</strong>。同时，Mesos 自身也很好地结合和支持了 Docker 等相关容器技术，基于 Mesos 已有的大量应用框架，可以是实现用户应用的快速上线。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Mesos 可以将整个数据中心的<code>资源</code>（包括 CPU、内存、存储、网络等）进行抽象和调度，使得多个应用同时运行在集群中分享资源，并无须关心资源的物理分布情况。<br>如果把数据中心的集群资源看作一台服务器，那么 Mesos 要做的事情，其实就是今天操作系统内核的职责：<strong>抽象资源 + 调度任务</strong>；Mesos 拥有许多引人注目的特性，包括：</p><ul><li>支持数万个节点的<strong>大规模场景</strong>（Apple、Twitter、eBay 等公司使用）；</li><li>支持多种应用框架，包括 Marathon、Singularity、Aurora 等；</li><li>支持 <code>HA</code>（基于 ZooKeeper 实现）；</li><li>支持 Docker、LXC 等容器机制进行任务隔离；</li><li>提供了多个流行语言的 API，包括 Python、Java、C++ 等；</li><li>自带了简洁易用的 <code>WebUI</code>，方便用户直接进行操作。</li></ul><blockquote><p>Mesos 自身只是一个资源抽象的平台，要使用它往往需要结合运行在其上的分布式应用（<code>framework</code>）。</p></blockquote><a id="more"></a><h2 id="Mesos-安装与使用"><a href="#Mesos-安装与使用" class="headerlink" title="Mesos 安装与使用"></a>Mesos 安装与使用</h2><p>以 Mesos 结合 Marathon 应用框架为例，来看一下如何快速搭建一套 Mesos 平台。<br>ZooKeeper 是一个分布式集群中<code>信息同步的工具</code>，通过<strong>自动在多个节点中选举 leader</strong>，保障多个节点之间的某些信息保持一致性。</p><blockquote><p>一般在生产环境中，需要启动多个 Mesos master 服务（3 个或 5 个），并且使用 Supervisord 等进程管理器来自动保持服务的运行。</p></blockquote><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>Mesos 也采用了经典的<code>主-从结构</code>，一般包括若干主节点和大量从节点。<br>安装可以通过<strong>源码编译</strong>、<strong>软件源</strong>、<strong>Docker 方式</strong>进行。</p><h4 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h4><p>可以保证获取到最新版本，但编译过程比较费时间。<br>常规 C++ 项目的方法，配置之后利用 Makefile 进行编译和安装。</p><h4 id="软件源安装"><a href="#软件源安装" class="headerlink" title="软件源安装"></a>软件源安装</h4><p>安装相对会省时间，但往往不是最新版本。<br>可以通过 service 命令来方便进行管理，实际上是通过调用 <code>/usr/bin/mesos-init-wrapper</code> 脚本文件进行处理。</p><h4 id="Docker-方式安装"><a href="#Docker-方式安装" class="headerlink" title="Docker 方式安装"></a>Docker 方式安装</h4><p>需要如下三个镜像：ZooKeeper、Mesos、Marathon，其中 <code>mesos-master</code> 镜像在后面将分别作为 master 和 slave 角色进行使用。<br>可以通过访问本地 8080 端口来使用 Marathon 启动服务。</p><h3 id="配置说明"><a href="#配置说明" class="headerlink" title="配置说明"></a>配置说明</h3><h4 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h4><p>ZooKeeper 是一个分布式应用的协调工具，用来<strong>管理多个主节点的选举和冗余</strong>，监听在 <code>2181</code> 端口。推荐至少布置三个主节点来被 ZooKeeper 维护。<br>配置文件默认都在 /etc/zookeeper/conf/ 目录下，比较关键的配置文件有两个：</p><ul><li><strong>myid</strong>：记录加入 ZooKeeper 集群的节点的序号（1~255）；</li><li><strong>zoo.cfg</strong>：添加上加入 ZooKeeper 集群的机器的序号和对应的监听地址。</li></ul><blockquote><p>可以用主机名形式，需要各个节点 <code>/etc/hosts</code> 文件中都记录地址到主机名对应的映射关系。</p></blockquote><h4 id="Mesos"><a href="#Mesos" class="headerlink" title="Mesos"></a>Mesos</h4><p>Mesos 的默认配置目录有三个：</p><ul><li><strong>/etc/mesos/</strong>：主节点和从节点都会读取的配置文件，需要在所有节点上修改 /etc/mesos/zk，写入主节点集群的 ZooKeeper 地址列表；</li><li><strong>/etc/mesos-master</strong>：只有主节点会读取的配置，等价于启动 mesos-master 命令时的默认选项。建议配置至少四个参数文件：ip、quorum、work_dir、cluster；</li><li><strong>/etc/mesos-slave</strong>：建议在从节点上，创建 ip 文件，在其中写入跟主节点通信的地址。</li></ul><p>修改配置之后，启动服务即可生效：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service mesos-master/slave start</span><br></pre></td></tr></table></figure><h4 id="Marathon"><a href="#Marathon" class="headerlink" title="Marathon"></a>Marathon</h4><p>Marathon 作为 Mesos 的一个应用框架，配置要更为简单，<strong>必需的配置项有 --master 和 --zk</strong>。<br>手动创建配置目录，并添加配置项，让 Marathon 能连接到已创建的 Mesos 集群中。</p><h3 id="访问-Mesos-图形界面"><a href="#访问-Mesos-图形界面" class="headerlink" title="访问 Mesos 图形界面"></a>访问 Mesos 图形界面</h3><p>Mesos 自带了 Web 图形界面，可以方便用户查看集群状态。<br>用户在 Mesos 主节点服务和从节点服务都启动后，可以通过浏览器访问主节点 <code>5050</code> 端口，看到如下界面：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Kubernetes/01.jpg" alt></p><h3 id="访问-Marathon-图形界面"><a href="#访问-Marathon-图形界面" class="headerlink" title="访问 Marathon 图形界面"></a>访问 Marathon 图形界面</h3><p>Marathon 服务启动后，在 Mesos 的 Web 界面的 Frameworks 标签页下面将能看到名称为 marathon 的框架出现。<br>同时，可以通过浏览器访问 <code>8080</code> 端口，看到 Marathon 自己的管理界面：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Kubernetes/02.jpg" alt></p><h2 id="原理与架构"><a href="#原理与架构" class="headerlink" title="原理与架构"></a>原理与架构</h2><p>基于 Mesos，可以比较容易地为各种应用管理框架或者中间件平台，<strong>提供分布式运行能力</strong>；同时多个框架也可以同时运行在一个 Mesos 集群中，<strong>提高整体的资源使用率</strong>。</p><h3 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h3><p>Mesos 的基本架构：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Kubernetes/03.jpg" alt><br>Mesos 采用了经典的主-从架构，其中主节点可以使用 ZooKeeper 来做 HA。<br>Mesos slave 服务运行在各个计算任务节点上，负责完成具体任务的应用框架，并与 Mesos master 进行交互申请资源。</p><h3 id="基本单元"><a href="#基本单元" class="headerlink" title="基本单元"></a>基本单元</h3><p>Mesos 有三个基本的组件：</p><ul><li><strong>管理服务（master）</strong>：主节点起到管理作用，将看到全局的信息，负责不同应用框架之间的资源调度和逻辑控制；</li><li><strong>任务服务（slave）</strong>：负责汇报本从节点上的资源状态给主节点，并负责隔离本地资源来执行主节点分配的具体任务；</li><li><strong>应用框架（framework）</strong>：应用框架是实际干活的，包括两个主要组件：<ul><li><code>调度器</code>（scheduler）：注册到主节点，等待分配资源；</li><li><code>执行器</code>（executor）：在从节点上执行框架指定的任务。</li></ul></li></ul><p>应用框架可以分两种：</p><ul><li>对资源的<strong>需求会扩展</strong>，申请后还可能调整，比如 Hadoop、Spark 等；</li><li>对资源的<strong>需求将会固定</strong>，一次申请即可，比如 MPI 等。</li></ul><h3 id="调度"><a href="#调度" class="headerlink" title="调度"></a>调度</h3><p>对于一个资源调度框架来说，最核心的就是<code>调度机制</code>，如何快速高效地完成对某个应用框架资源的分配，是其核心竞争力所在。<br>Mesos 为了实现尽量优化的调度，采取了<strong>两层调度算法</strong>。</p><h4 id="算法基本过程"><a href="#算法基本过程" class="headerlink" title="算法基本过程"></a>算法基本过程</h4><p>master 先全局调度一大块资源给某个 framework，framework 自己再实现内部的细粒度调度，决定哪个任务用多少资源。<br>调度机制支持插件机制来实现不同的策略，默认是 Dominant Resource Fairness（<code>DRF</code>）。</p><blockquote><p>两层调度简化了 Mesos master 自身的调度过程，通过将复杂的细粒度调度交由 framework 实现，<strong>避免了 Mesos master 成为性能瓶颈</strong>。</p></blockquote><h4 id="调度过程"><a href="#调度过程" class="headerlink" title="调度过程"></a>调度过程</h4><p>基本调度过程如下：</p><ol><li>slave 节点会周期性汇报自己可用的资源给 master；</li><li>某个时候，master 收到应用框架发来的资源请求，根据调度策略，计算出来一个资源 offer 给 framework；</li><li>framework 收到 offer 后可以决定要不要，如果接受的话，<strong>返回一个描述</strong>，说明自己如何使用和分配这些资源来运行某些任务；</li><li>master 则根据 framework 答复的具体分配情况发送给 slave，以使 framework 的 executor 按照分配的资源策略执行任务。</li></ol><h4 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h4><p>framework 可以通过<code>过滤器机制</code>告诉 master 它的资源偏好。过滤器可以避免某些应用资源长期分配不到所需要的资源的情况，<strong>加速整个资源分配的交互过程</strong>。</p><h4 id="回收机制"><a href="#回收机制" class="headerlink" title="回收机制"></a>回收机制</h4><p>为了避免某些任务长期占用集群中资源，Mesos 也支持<code>回收机制</code>。主节点可以定期回收计算节点上的任务所占用的资源，<strong>动态调整长期任务和短期任务的分布</strong>。</p><h3 id="高可用性"><a href="#高可用性" class="headerlink" title="高可用性"></a>高可用性</h3><p>除了使用 ZooKeeper 来解决单点失效问题之外，Mesos 的 master 节点自身还提供了很高的鲁棒性。Mesos master 节点再重启后，可以动态通过 slave 和 framework 发来的消息<strong>重建内部状态</strong>，虽然可能导致一定的时延，但这<strong>避免了传统控制节点对数据库的依赖</strong>。<br>当然，为了减少 master 节点的负载过大，在集群中 slave 节点数目较多的时候，要<strong>避免把各种通知的周期配置得过短</strong>。</p><blockquote><p>实践中，可以通过部署多个 Mesos 集群来保持单个集群的规模不要过大。</p></blockquote><h2 id="Mesos-配置解析"><a href="#Mesos-配置解析" class="headerlink" title="Mesos 配置解析"></a>Mesos 配置解析</h2><p>Mesos 的配置项分为三种类型：通用项、master 专属配置项、slave 专属配置项。</p><h3 id="通用项"><a href="#通用项" class="headerlink" title="通用项"></a>通用项</h3><p>通用项数量不多，主要涉及服务绑定地址和日志信息等：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Kubernetes/04.jpg" alt></p><h3 id="master-专属配置项"><a href="#master-专属配置项" class="headerlink" title="master 专属配置项"></a>master 专属配置项</h3><p>这些配置项是针对主节点上的 Mesos master 服务的，围绕高可用、注册信息、对应用框架的资源管理等。<br><strong>必须指定</strong>的配置项有以下三个：</p><ul><li>--quorum=VALUE：利用 ZooKeeper 实现 HA 时，参与投票时的最少节点个数；</li><li>--work_dir=VALUE：注册表持久化信息存储位置；</li><li>--zk=VALUE：指定 ZooKeeper 的服务地址，支持多个地址，之间用逗号隔离。</li></ul><h3 id="slave-专属配置项"><a href="#slave-专属配置项" class="headerlink" title="slave 专属配置项"></a>slave 专属配置项</h3><p><strong>slave 节点支持的配置项是最多的</strong>，因为它所完成的事情也最复杂。这些配置项既包括跟主节点打交道的一些参数，也包括对本地资源的配置，包括隔离机制、本地任务的资源限制等。<br>必备项就一个：--master=VALUE，master 所在地址，或对应 ZooKeeper 服务地址，或文件路径，可以是列表。<br>为了避免主机分配的临时端口，跟我们指定的临时端口范围冲突，需要在主机节点上进行配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">"57345 61000"</span> &gt; /proc/sys/net/ipv4/ip_local_port_range</span><br></pre></td></tr></table></figure><blockquote><p><strong>非临时端口是 Mesos 分配给框架</strong>，绑定到任务使用的，端口号往往有明确的意义；<strong>临时端口是系统分配的</strong>，往往不太关心具体端口号。</p></blockquote><h2 id="日志与监控"><a href="#日志与监控" class="headerlink" title="日志与监控"></a>日志与监控</h2><p>Mesos 自身提供了强大的日志和监控功能，某些应用框架也提供了针对框架中任务的监控能力。</p><h3 id="日志配置"><a href="#日志配置" class="headerlink" title="日志配置"></a>日志配置</h3><p>日志文件默认在 <code>/var/log/mesos</code> 目录下，根据日志等级带有不同后缀。用户可以<strong>通过日志来调试</strong>使用中碰到的问题。</p><h3 id="监控"><a href="#监控" class="headerlink" title="监控"></a>监控</h3><p>Mesos 提供了方便的<code>监控接口</code>，供用户查看集群中各个节点的状态：</p><ul><li><strong>主节点</strong>：通过 <a href="http://MASTER_NODE:5050/metrics/snapshot" target="_blank" rel="noopener">http://MASTER_NODE:5050/metrics/snapshot</a> 地址，可以获取到 Mesos 主节点的各种状态统计信息，包括资源使用、系统状态、从节点、应用框架、任务状态等。</li><li><strong>从节点</strong>：通过 <a href="http://SLAVE_NODE:5051/metrics/snapshot" target="_blank" rel="noopener">http://SLAVE_NODE:5051/metrics/snapshot</a> 地址，可以获取到 Mesos 从节点的各种状态统计信息，包括资源、系统状态、各种消息状态等。</li></ul><h2 id="常见应用框架"><a href="#常见应用框架" class="headerlink" title="常见应用框架"></a>常见应用框架</h2><p>应用框架是实际干活的，可以理解为 Mesos 之上跑的应用，应用框架<strong>注册到 Mesos master 服务</strong>上即可使用。<br>Mesos 目前支持的应用框架分为四大类：<strong>长期运行任务</strong>、<strong>大数据处理</strong>、<strong>批量调度</strong>、<strong>数据存储</strong>。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Kubernetes/05.jpg" alt></p><blockquote><p>结合 Docker，Mesos 可以很容易部署一套私有的容器云，可以很好地应用并集成到生产环境中；但它的定位集中在资源调度，往往需要结合应用框架或二次开发。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Kubernetes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Networking</title>
      <link href="2019/08/12/Networking/"/>
      <url>2019/08/12/Networking/</url>
      
        <content type="html"><![CDATA[<h2 id="Starting-a-conversation"><a href="#Starting-a-conversation" class="headerlink" title="Starting a conversation"></a>Starting a conversation</h2><blockquote><p>Where do you come from then?</p></blockquote><h3 id="USEFUL-TIPS"><a href="#USEFUL-TIPS" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><ul><li>Successful small talk is not about saying brilliant things. It’s about commenting on and asking about <strong>ordinary things</strong> with conviction, interest, and enthusiasm;</li><li><strong>Match the mood</strong> of your conversation partner. If they are smiling and cheerful, be ready to laugh. If they seem serious, be serious too;</li><li>Ask where your partner comes from and, when somebody asks you the same thing, be ready to add <strong>something interesting</strong> about the place;</li><li>Ask what your partner does and, when you’re asked the same question, <strong>don’t only give a title</strong>. Add a small piece of interesting or amusing information about the job or responsibility;</li></ul><h3 id="Track-01"><a href="#Track-01" class="headerlink" title="Track 01"></a>Track 01</h3><h4 id="1"><a href="#1" class="headerlink" title="1"></a>1</h4><p>A: That was really interesting what the last speaker said about opening bank accounts in the Cayman Islands.<br>B: Yes, it was. <strong>So, what do you do exactly?</strong><br>A: <strong>I’m an auditor, a forensic auditor.</strong><br>B: Ah, um, you’re a forensic, um, auditor?<br>A: Yes, that’s right.<br>B: Right, oh. I see. Look at the time! I must get to the next presentation…</p><a id="more"></a><h4 id="2"><a href="#2" class="headerlink" title="2"></a>2</h4><p>C: Mmm, lovely coffee! I needed that. I just flew in from London very early this morning. <strong>How did you get here?</strong><br>D: I came on the TGV train from Paris.<br>C: Really? I’ve never been on the TGV. <strong>How long did that take?</strong><br>D: Oh, about 4 hours. But I was able to have breakfast and do some reading.<br>C: That sounds nice. I must try it sometime. <strong>Marseilles’s really beautiful, isn’t it?</strong><br>D: Yes, it is. <strong>Have you been here before?</strong> If you haven’t, you must…</p><h4 id="3"><a href="#3" class="headerlink" title="3"></a>3</h4><p>E: …I’m certainly looking forward to the dinner this evening.<br>F: I am too. Especially the fish. We don’t have much fish where I live.<br>E: Really? <strong>Where do you come from then?</strong><br>F: Garmisch-Partenkirchen. It’s in the mountains just near Munich. What about you?<br>E: I’m from Cork in Ireland. The high street is supposed to have more pubs than any other town in Ireland.<br>F: Really? I’m going there on a business trip soon to visit the Apple factory. I must see if I can find time to visit some…</p><h4 id="4"><a href="#4" class="headerlink" title="4"></a>4</h4><p>G: …and then I went jogging early this morning along by the sea. Fantastic sunrise coming up over the sea.<br>H: Really? Sunrise, you say?<br>G: Yes, amazing! Do you like jogging? You should try it, you know. It makes you feel really great all day long. Just set the alarm for 5:30, jump out of bed and after you’ve been running for about an hour or so, go back, have a shower and…<br>H: <strong>Sorry, but do you know where I can smoke?</strong> I think I want a cigarette before the next presentation. Ah, that way? Thanks.</p><h2 id="Talking-about-jobs"><a href="#Talking-about-jobs" class="headerlink" title="Talking about jobs"></a>Talking about jobs</h2><blockquote><p>It’s a very challenging profession.</p></blockquote><h3 id="USEFUL-TIPS-1"><a href="#USEFUL-TIPS-1" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When telling people about your job:</p><ul><li><strong>Be brief</strong> and precise;</li><li>Show how your job <strong>benefits people</strong> or organizations;</li><li>Make sure that your description is <strong>relevant to the person</strong> you are talking to;</li><li><strong>Avoid technical terms</strong> or abbreviations unless talking to a fellow expert;</li><li><strong>Emphasize the positive aspects</strong> rather than the negative;</li></ul><h3 id="Track-07"><a href="#Track-07" class="headerlink" title="Track 07"></a>Track 07</h3><p>Student: Excuse me, are you working on the Foodaid stand?<br>Jenny: Yes, can I help you?<br>S: Well, can you tell me what jobs at Foodaid involve?<br>J: There are lots of jobs at Foodaid which <strong>involve doing</strong> all sorts of different things. What subject do you study at university?<br>S: Engineering<br>J: Very important for Foodaid. My colleague, Hassan Sahin, for example, is a mechanical engineer and <strong>he is responsible for helping</strong> farmers in countries such as Chad or Pakistan where we work as an NGO to drill water wells.<br>S: Er… an NGO?<br>J: Sorry, a Non-Governmental Organization.<br>S: Right, of course. And what do you do?<br>J: Well, actually <strong>I’m a lawyer. I’m in charge of managing</strong> the legal department and we make sure that Foodaid understands any legal issues that might crop up in the work it does.<br>S: I hope I don’t sound rude, but you look very young to do that.<br>J: That’s what’s so good about Foodaid! You get important responsibilities very quickly. A friend of mine is working in Somalia and <strong>she manages</strong> a development budget of about 2 million dollars and <strong>she supplies</strong> the whole of West Africa with trucks for transporting food and equipment. <strong>It’s a very challenging job</strong> and she’s only 23!<br>S: I see. But, as it’s a charity, do you get paid for your work?<br>J: Yes, of course. You’ll never be rich working for Foodaid, but you get paid. Very often people like you work with us for a few years to gain experience and then they move on to other jobs. Lots of companies like the fact that you’ve worked for a charity.<br>S: Hmm. So, what makes a job with Foodaid interesting, then?<br>J: <strong>It’s very rewarding.</strong> You feel you are doing something useful with your skills, not just making some company shareholders rich. And even if <strong>the work is demanding</strong>, it’s never boring.<br>S: It sounds really interesting. Thanks for telling me about it.<br>J: That’s fine. Here’s some more information about what we do and my card. If you have any more questions, just give me a ring…</p><h2 id="Showing-interest-in-other-people"><a href="#Showing-interest-in-other-people" class="headerlink" title="Showing interest in other people"></a>Showing interest in other people</h2><blockquote><p>Oh, I know what you mean.</p></blockquote><h3 id="USEFUL-TIPS-2"><a href="#USEFUL-TIPS-2" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>When you are in conversation:</p><ul><li><strong>Echo the key information</strong> to encourage further explanation, for example, <em>I’m allergic to shellfish. To shellfish?</em>;</li><li>Empathize. Use phrases to show that you <strong>understand how your partner feels</strong>, for example, <em>That’s amazing!</em> or <em>Really?</em>;</li><li>Paraphrase. <strong>Reformulate in your own words</strong> what has been said to show that you are listening, for example, <em>So what you’re telling me is…</em>;</li></ul><h3 id="Track-10"><a href="#Track-10" class="headerlink" title="Track 10"></a>Track 10</h3><p>Casper: It’s very different way to do business here in Singapore, compared to Germany.<br>Emily: <strong>I know what you mean.</strong> Do you find it difficult?<br>C: No, not at all. It’s interesting.<br>E: Interesting?<br>C: Yes. For example, in Singapore you discuss prices much earlier in a negotiation than we do in Germany.<br>E: <strong>Really? So, you mean that</strong> you leave price negotiations till the end of a discussion?<br>C: Oh, yes. In Singapore you start talking about prices for products when in Germany we’re still trying to define exactly what’s wanted.<br>E: <strong>How amazing!</strong> I didn’t realize. I suppose we think it’s a waste of time discussing something if the price is always going to be unrealistic.<br>C: <strong>I see.</strong><br>E: Whereas in Germany you feel you can’t begin to think about price until you know all the details.<br>C: <strong>That’s right.</strong><br>E: So, do you like Singapore?<br>C: Oh, yes. Very much, especially the food. But I need to do some sport. I’ve put on 2 kilos already! Back in Berlin I play centre forward for the company football team.<br>E: <strong>Really?</strong><br>C: Yes, um… anyway, um…<br>E: Do you notice any other differences between business life here and in Germany?<br>C: Well, another difference is the flexibility that a manager has here.<br>D: Flexibility?<br>C: Yes. In Germany it’s very difficult to be a manager because every time you want to introduce a change in the organization or in communication processes, you have to ask the Workers’ Council for permission. This makes innovation very slow, which isn’t good for the employees at all.<br>E: <strong>So, what you’re saying is</strong> that the Workers’ Council in Germany makes things more difficult for employees, not easier.<br>C: Sometimes, yes.<br>E: <strong>That’s terrible!</strong></p><h2 id="Exchanging-information"><a href="#Exchanging-information" class="headerlink" title="Exchanging information"></a>Exchanging information</h2><blockquote><p>I heard it on the grapevine.</p></blockquote><h3 id="USEFUL-TIPS-3"><a href="#USEFUL-TIPS-3" class="headerlink" title="USEFUL TIPS"></a>USEFUL TIPS</h3><p>Here are 3 ways to get the information you want within your organization:</p><ul><li><strong>First offer appropriate information</strong> yourself. If you want to find out about a particular area, offer information of your own first to show you can be trusted. Think carefully about what information is appropriate to pass on to others;</li><li><strong>Ask questions indirectly.</strong> If you want to ask about sb or sth, use statements with question tags rather than direct questions, for example, <em>You know John, don’t you?</em> rather than <em>Do you know John?</em> A direct question may frighten someone into remaining silent but a statement that sounds more like speculation will often be confirmed or corrected by sb with better information;</li><li><strong>Create intimacy.</strong> If you don’t know sb very well, but want to exchange information with that person, you can use these techniques: Drop their name into conversation more than usual and use <em>we, us</em> and <em>our</em> as often as possible, for example, <em>I think we’re going to see a lot of changes in our department soon, Peter.</em>;</li></ul><h3 id="Track-18"><a href="#Track-18" class="headerlink" title="Track 18"></a>Track 18</h3><p>Candy: I really want to thank you, Michael, for taking me with you to the meeting. I just can’t get used to driving on the left!<br>Michael: No problem.<br>C: You used to work for our new chief legal officer, Christine Bender, didn’t you?<br>M: Yes, that’s right. She and I started together in the legal department 5 years ago. Then I changed over to IT.<br>C: Christine is so successful. She did an amazing job for us dealing with that whole corruption scandal last year, don’t you think?<br>M: Yes, she did. But, <strong>between you and me,</strong> Christine could never have managed that without her team.<br>C: That’s so true, Michael. She always picks good people to work with her. By the way, <strong>I heard on the grapevine</strong> that she’s going to move to our New York office next.<br>M: Yes, I heard that too. <strong>I wonder how</strong> her husband feels about it. He’s journalist, I think.<br>C: Well, <strong>according to</strong> Christine’s assistant, Mrs Weber, that’s not a problem. He’s going to write articles about New York nightlife. Although <strong>I can’t imagine</strong> who’s going to look after the children then.<br>M: <strong>Apparently,</strong> they’re going to have a nanny. <strong>I overheard</strong> Christine talking to the boss about it this morning. It must be very expensive, but they’ll have enough money.<br>C: <strong>I suppose</strong> they might appoint sb from Christine’s team to carry on her work.<br>M: Ah, no! <strong>It seems that</strong> Christine didn’t want to recommend any of them to the boss, so Gabriele from the commercial department will take over. Christine’s team was really angry!</p>]]></content>
      
      
      
        <tags>
            
            <tag> SPEAKING </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Dockerfile 创建镜像</title>
      <link href="2019/08/04/%E4%BD%BF%E7%94%A8-Dockerfile-%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/"/>
      <url>2019/08/04/%E4%BD%BF%E7%94%A8-Dockerfile-%E5%88%9B%E5%BB%BA%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p>Dockerfile 是一个文本格式的配置文件，用户可以使用 Dockerfile 来快速创建自定义的镜像，本文会介绍使用 Dockerfile 的一些<strong>最佳实践</strong>。</p><h2 id="基本结构"><a href="#基本结构" class="headerlink" title="基本结构"></a>基本结构</h2><p>Dockerfile 由一行行命令语句组成，并且支持以 <code>#</code> 开头的注释行。主体内容分为四部分：<strong>基础镜像信息</strong>、<strong>维护者信息</strong>、<strong>镜像操作指令</strong>、<strong>容器启动时执行指令</strong>。<br>下面给出一个简单的示例：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># escape=\ (backslash)</span></span><br><span class="line"><span class="comment"># This dockerfile uses the ubuntu:xeniel image</span></span><br><span class="line"><span class="comment"># VERSION 2 - EDITION 1</span></span><br><span class="line"><span class="comment"># Author: docker_user</span></span><br><span class="line"><span class="comment"># Command format: Instruction [arguments / command] ..</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Base image to use, this must be set as the first line</span></span><br><span class="line"><span class="keyword">FROM</span> ubuntu:xeniel</span><br><span class="line"></span><br><span class="line"><span class="comment"># Maintainer: docker_user &lt;docker_user at email.com&gt; (@docker_user)</span></span><br><span class="line"><span class="keyword">LABEL</span><span class="bash"> maintainer docker_user&lt;docker_user@email.com&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands to update the image</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"deb http://archive.ubuntu.com/ubuntu/ xeniel main universe"</span> &gt;&gt; /etc/apt/sources.list</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> apt-get update &amp;&amp; apt-get install -y nginx</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> <span class="built_in">echo</span> <span class="string">"\ndaemon off;"</span> &gt;&gt; /etc/nginx/nginx.conf</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Commands when creating a new container</span></span><br><span class="line"><span class="keyword">CMD</span><span class="bash"> /usr/sbin/nginx</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>首行可以通过注释来指定解析器命令，后续通过注释说明镜像的相关信息。主体部分首先使用 <code>FROM</code> 指令指明所基于的镜像名称，接下来一般是使用 <code>LABEL</code> 指令说明维护者信息。每运行一条 <code>RUN</code> 指令，镜像添加新的一层并提交，最后是 <code>CMD</code> 指令，来指定运行容器时的操作命令。</p><h2 id="指令说明"><a href="#指令说明" class="headerlink" title="指令说明"></a>指令说明</h2><p>Dockerfile 中指令的一般格式为：INSTRUCTION arguments，包括<code>配置指令</code>（配置镜像信息）和<code>操作指令</code>（具体执行操作）。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Docker/8-1.jpg" alt></p><h3 id="配置指令"><a href="#配置指令" class="headerlink" title="配置指令"></a>配置指令</h3><h4 id="ARG"><a href="#ARG" class="headerlink" title="ARG"></a>ARG</h4><p>定义创建镜像过程中使用的变量，在执行 docker build 时，可以通过 <code>-build-arg[=]</code> 来为变量赋值。当镜像编译成功后，ARG 指定的变量将不再存在（<strong>ENV 指定的变量将在镜像中保留</strong>），一些内置的变量：HTTP_PROXY、HTTPS_PROXY、FTP_PROXY、NO_PROXY 等。</p><h4 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h4><p>指定所创建镜像的基础镜像，任何 Dockerfile 中<strong>第一条指令</strong>必须为 FROM 指令。为了保证镜像精简，可以选用体积较小的镜像。</p><h4 id="LABEL"><a href="#LABEL" class="headerlink" title="LABEL"></a>LABEL</h4><p>LABEL 指令可以为生成的镜像添加元数据标签信息，用来<strong>辅助过滤出特定的镜像</strong>。</p><h4 id="EXPOSE"><a href="#EXPOSE" class="headerlink" title="EXPOSE"></a>EXPOSE</h4><p><strong>声明</strong>镜像内服务监听的端口，该指令只是起到声明作用，并不会自动完成端口映射。在启动容器时可以使用 <code>-P</code> 参数或 <code>-p HOST_PORT:CONTAINER_PORT</code> 参数。</p><h4 id="ENV"><a href="#ENV" class="headerlink" title="ENV"></a>ENV</h4><p>指定环境变量，在镜像生成过程中会被后续 RUN 指令使用，在镜像启动的容器中也会存在。指令指定的环境变量在运行时<strong>可以被覆盖掉</strong>。</p><h4 id="ENTRYPOINT"><a href="#ENTRYPOINT" class="headerlink" title="ENTRYPOINT"></a>ENTRYPOINT</h4><p>指定镜像的默认入口命令，该命令会在启动容器时作为<code>根命令</code>执行，所有传入值作为该命令的参数。此时，<strong>CMD 指令</strong>指定值将作为根命令的参数；在运行时，可以被 –entrypoint 参数覆盖掉。</p><h4 id="VOLUME"><a href="#VOLUME" class="headerlink" title="VOLUME"></a>VOLUME</h4><p>创建一个<strong>数据卷挂载点</strong>，运行容器时可以从本地主机或其他容器挂载数据卷，一般用来存放数据库和需要保持的数据等。</p><h4 id="USER"><a href="#USER" class="headerlink" title="USER"></a>USER</h4><p>指定运行容器时的用户名或 UID，后续的 <strong>RUN 等指令</strong>也会使用指定的用户身份。当服务不需要管理员权限时，可以通过该命令指定运行用户，要临时获取管理员权限时可以使用 <code>gosu</code> 命令。</p><h4 id="WORKDIR"><a href="#WORKDIR" class="headerlink" title="WORKDIR"></a>WORKDIR</h4><p>为后续的 RUN、CMD、ENTRYPOINT 指令<strong>配置工作目录</strong>，为了避免出错，推荐只使用<code>绝对路径</code>。</p><h4 id="ONBUILD"><a href="#ONBUILD" class="headerlink" title="ONBUILD"></a>ONBUILD</h4><p>指定当基于所生成镜像创建子镜像时，<strong>自动执行</strong>的操作指令。<br>例如，使用如下的 Dockerfile 创建父镜像 ParentImage，指定 ONBUILD 指定：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile for ParentImage</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">ADD</span><span class="bash"> . /app/src</span></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>使用 docker build 命令创建子镜像 ChildImage 时，会首先执行 ParentImage 中配置的 ONBUILD 指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Dockerfile for ChildImage</span></span><br><span class="line"><span class="keyword">FROM</span> ParentImage</span><br></pre></td></tr></table></figure><p>等价于在 ChildImage 的 Dockerfile 中添加如下指令：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Automatically run the following when building ChildImage</span></span><br><span class="line"><span class="keyword">ADD</span><span class="bash"> . /app/src</span></span><br><span class="line"><span class="keyword">RUN</span><span class="bash"> /usr/<span class="built_in">local</span>/bin/python-build --dir /app/src</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure><blockquote><p>ONBUILD 指令在创建专门用于自动编译、检查等操作的基础镜像时，十分有用。</p></blockquote><h4 id="STOPSIGNAL"><a href="#STOPSIGNAL" class="headerlink" title="STOPSIGNAL"></a>STOPSIGNAL</h4><p>指定所创建镜像启动的容器，<strong>接收退出的信号值</strong>：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">STOPSIGNAL <span class="keyword">signal</span><span class="string"></span></span><br></pre></td></tr></table></figure><h4 id="HEALTHCHECK"><a href="#HEALTHCHECK" class="headerlink" title="HEALTHCHECK"></a>HEALTHCHECK</h4><p>配置所启动容器如何进行<strong>健康检查</strong>，格式有两种：</p><ul><li>HEALTHCHECK [OPTIONS] CMD command：根据所执行命令返回值是否为 0 来判断；</li><li>HEALTHCHECK NONE：禁止基础镜像中的健康检查。</li></ul><p>OPTION 支持如下参数：</p><ul><li>-interval=DURATION (default: 30s)：过多久检查一次；</li><li>-timeout=DURATION （default: 30s)：每次检查等待结果的超时；</li><li>-retries=N (default: 3)：如果失败了，重试几次才最终确定失败。</li></ul><h4 id="SHELL"><a href="#SHELL" class="headerlink" title="SHELL"></a>SHELL</h4><p>指定其他命令使用 Shell 时的默认 <strong>Shell 类型</strong>，默认值为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">"/bin/sh"</span>, <span class="string">"-c"</span>]</span><br></pre></td></tr></table></figure><h3 id="操作指令"><a href="#操作指令" class="headerlink" title="操作指令"></a>操作指令</h3><h4 id="RUN"><a href="#RUN" class="headerlink" title="RUN"></a>RUN</h4><p>运行指定指令，有两种格式：</p><ul><li>RUN command 默认将在 Shell 终端中运行命令，即 /bin/sh -c；</li><li>RUN [“executable”, “param1”, “param2”]，会被解析为 JSON 数组，因此<strong>必须用双引号</strong>。</li></ul><p>每条 RUN 指令将在当前镜像基础上执行指定命令，并提交为新的镜像层。当命令较长时，可以使用<code>\</code>换行。</p><h4 id="CMD"><a href="#CMD" class="headerlink" title="CMD"></a>CMD</h4><p>CMD 指令用来指定<strong>启动容器时默认执行的命令</strong>，支持三种格式：</p><ul><li>CMD [“executable”, “param1”, “param2”]：相当于执行 executable param1 param2，推荐方式；</li><li>CMD command param1 param2：在默认的 Shell 中执行，提供给需要交互的应用；</li><li>CMD [“param1”, “param2”]：提供给 ENTRYPOINT 的默认参数。</li></ul><blockquote><p>每个 Dockerfile 只能有一条 CMD 命令。如果制定了多条命令，只有最后一条会被执行。</p></blockquote><h4 id="ADD"><a href="#ADD" class="headerlink" title="ADD"></a>ADD</h4><p>添加内容到镜像，格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ADD <span class="tag">&lt;<span class="name">src</span>&gt;</span> <span class="tag">&lt;<span class="name">dest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该命令将复制指定 <code>src 路径</code>下的内容，到容器中的 <code>dest 路径</code>下。</p><h4 id="COPY"><a href="#COPY" class="headerlink" title="COPY"></a>COPY</h4><p>复制内容到镜像，格式为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY <span class="tag">&lt;<span class="name">src</span>&gt;</span> <span class="tag">&lt;<span class="name">dest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>COPY 与 ADD 指令功能类似，当<strong>本地目录为源目录</strong>时，推荐使用 COPY。</p><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><p>编写完成 Dockerfile 之后，可以通过 docker build 命令来创建镜像。该命令将读取指定路径下的 Dockerfile，并<strong>将该路径下所有数据作为 context</strong> 发送给 Docker 服务端。<br>逐条执行其中定义的指令，碰到 <code>ADD、COPY、RUN 指令</code>会生成一层新的镜像，最终如果创建镜像成功，会返回最终镜像的 ID。<br>例如，上下文路径为：/tmp/docker_builder/，并且希望生成镜像标签为：builder／first_image:1.0.0，可以使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t builder/first_image:1.0.0 /tmp/docker_builder/</span><br></pre></td></tr></table></figure><h3 id="命令选项"><a href="#命令选项" class="headerlink" title="命令选项"></a>命令选项</h3><p>docker build 命令支持一系列的选项，可以<strong>调整创建镜像过程的行为</strong>。</p><h3 id="选择父镜像"><a href="#选择父镜像" class="headerlink" title="选择父镜像"></a>选择父镜像</h3><p>大部分情况下，生成新的镜像都需要通过 <code>FROM 指令</code>来指定父镜像。父镜像是生成镜像的基础，会直接影响到所生成镜像的大小和功能。<br>用户可以选择两种镜像作为父镜像：</p><ul><li><strong>基础镜像</strong>（base image），其 Dockerfile 中往往不存在 FORM 指令，或者基于 scratch 镜像（FROM scratch），这意味着其在整个镜像树中处于根的位置。</li><li><strong>普通镜像</strong>也可以作为父镜像来使用，包括常见的 busybox、debian、ubuntu 等。</li></ul><p>Docker 不同类型镜像之间的继承关系如图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Docker/8-2.jpg" alt></p><h3 id="使用-dockerignore-文件"><a href="#使用-dockerignore-文件" class="headerlink" title="使用 .dockerignore 文件"></a>使用 .dockerignore 文件</h3><p>可以通过 .dockerignore 来让 Docker 忽略匹配路径或文件，在创建镜像的时候，<strong>不将无关数据发送到服务端</strong>。<br>语法支持 Golang 风格的正则格式：</p><ul><li>“*”表示任意多个字符；</li><li>“?”表示单个字符；</li><li>“!”表示不匹配（即不忽略指定的路径或文件）。</li></ul><h3 id="多步骤创建"><a href="#多步骤创建" class="headerlink" title="多步骤创建"></a>多步骤创建</h3><p>Docker 支持多步骤镜像创建（multi-stage build）特性，可以<strong>精简最终生成的镜像大小</strong>。对于需要编译的应用来说，通常情况下至少需要准备两个环境的 Docker 镜像：</p><ul><li><code>编译环境镜像</code>：包括完整的编译引擎、依赖库等，往往比较庞大。作用是编译应用为二进制文件。</li><li><code>运行环境镜像</code>：利用编译好的二进制文件，运行应用，由于不需要编译环境，体积比较小。</li></ul><p>使用多步骤创建，可以在保证最终生成的运行环境镜像保持精简的情况下，使用单一的 Dockerfile，<strong>降低维护复杂度</strong>。</p><h2 id="最佳实践"><a href="#最佳实践" class="headerlink" title="最佳实践"></a>最佳实践</h2><p><strong>从需求出发</strong>，来定制合适自己、高效方便的镜像。<br><code>Docker Hub</code> 官方仓库中提供了大量的优秀镜像和对应的 Dockerfile，可以通过阅读它们来学习如何撰写高效的 Dockerfile。<br>尝试从如下角度进行思考，完善所生成的镜像：</p><ul><li>精简镜像用途；</li><li><strong>选用合适的基础镜像</strong>：推荐选用瘦身过的应用镜像（node:slim），或者较为小巧的系统镜像（alpine、busybox 或 debian）；</li><li>提供注释和维护者信息</li><li><strong>正确使用版本号</strong>：非依赖于默认的 latest，通过版本号可以避免环境不一致导致的问题；</li><li><strong>减少镜像层数</strong>：尽量合并 RUN、ADD 和 COPY 指令；</li><li><strong>恰当使用多步骤构建</strong>：通过多步创建，可以将编译和运行等过程分开，保证最终生成的镜像只包括运行应用所需要的<code>最小化环境</code>；</li><li>使用 .dockerignore 文件；</li><li><strong>及时删除临时文件和缓存文件</strong>：特别是在执行 apt-get 指令后，<code>/var/cache/apt</code> 下面会缓存了一些安装包；</li><li>提高生成速度；</li><li><strong>调整合理的指令顺序</strong>：在<code>开启 cache</code> 的情况下，内容不变的指令尽量放在前面，这样可以尽量复用；</li><li>减少外部源的干扰。</li></ul><blockquote><p>在使用 Dockerfile 构建镜像的过程中，可以体会到 Docker 镜像在使用上“一处修改代替大量更新”的灵活之处。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Programmer&#39;s View of SAP HANA</title>
      <link href="2019/07/09/The-Programmer-s-View-of-SAP-HANA/"/>
      <url>2019/07/09/The-Programmer-s-View-of-SAP-HANA/</url>
      
        <content type="html"><![CDATA[<h2 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This chapter presents the application developer’s view of SAP HANA. It gives an overview of both the <strong>programming languages</strong> for writing code that runs inside SAP HANA, and the <strong>client libraries</strong> used by client applications to connect to SAP HANA.<br>Database applications use well-defined interfaces to communicate with the database management system functioning as a <strong>data source</strong>, usually over a network connection.<br>The application, often running in the context of an application server, takes the role of <strong>a client</strong>, while the database system plays the role of <strong>a server</strong>. Client applications typically use vendor-supplied client libraries which implement part of the API and encapsulates the communication details.<br>The leading programming language for database application is the <code>SQL</code>. SQL provides <strong>functional capabilities</strong> for creating, accessing, maintaining, controlling, and protecting relational data.<br>SAP HANA greatly <strong>extends SQL</strong>. This includes <strong>SAP HANA-specific</strong> SQL statements, views, data types, and the possibility to write <code>Procedures</code> in several languages, such as SQLScript, L, C++ and R.<br><code>Modeled Views</code> are <strong>design-time abstractions</strong> that allow developers to work efficiently with SAP HANA’s extended views on a higher level of abstraction.<br>An alternative query language for clients is <code>MDX</code>. Pioneered by Microsoft, MDX is used by applications to <strong>query OLAP</strong> (OnLine Analytical Processing) data models. Applications can <strong>query graph data</strong> with the <code>openCypher</code> query language and implement custom graph algorithms as graph stored procedures.</p><a id="more"></a><p>Traditionally, the client application is written in a high-level language such as ABAP, Java or C++, has to <strong>build its own high-level data models</strong>. The involved data then needs to be sent back and forth across the SQL interface, often introducing significant inefficiencies. Another well-recognized complexity that application developers face is that these data models <strong>cannot easily be shared by different technology stacks</strong>, leading to duplication and re-engineering. Toady, SAP HANA helps to overcome these difficulties in 3 ways:</p><ul><li>SAP HANA allows developers to create application-specific procedures and models that are executed within the index server, with fast access to the in-memory data. This way, <strong>in-memory technology can be used</strong> and the <strong>data transfer with the client can be minimized</strong> as well.</li><li>Developers can use XS to provide service APIs, data and resources to HTTP clients, <strong>without the need of an additional application server</strong>.</li><li>SAP HANA has been enhanced with a new abstraction layer, called <code>Core Data Services</code> (CDS). The CDS allow application developers to create data models on a high level of abstraction. These models can then <strong>be reused from different application development environments</strong>.</li></ul><p>It shows <strong>most elements</strong> of the SAP HANA programming model and their relationships:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/4-1.jpg" alt></p><h2 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a>Clients</h2><p>SAP HANA supports clients using the following development environments and interfaces:</p><ul><li>Client applications written in C/C++, which use the <code>ODBC</code> (Open DataBase Connectivity) interface.</li><li>Client applications written in Java, which use the <code>JDBC</code> (Java DataBase Connectivity) interface.</li><li>Client applications written in Python, which use the <code>Python Database API</code>.</li><li>Windows-based client applications that use the <code>ODBO</code> (Object linking and embedding DataBase for Online analytical processing) interface for MDX.</li><li>MDX clients using <code>XMLA</code> (XML for Analysis) over HTTP.</li><li>ABAP applications using <code>DBSL</code> (DataBase Shared Library) to connect to the SAP HANA system.</li><li>XS applications can execute SQL statements using a database API provided by the <code>XS</code> server.</li><li>The <code>InA</code> (InformationAccess) infrastructure provides a client API, which combines analytical queries, search and planning. It connects to the InA service in the backend via HTTP using an InA-specific internal protocol.</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/4-2.jpg" alt><br>ODBC is a standard, implementation-agnostic C-based API for accessing a database. Analogously, JDBC is a data access API for Java, and the Python Database API is the data access interface for Python. All three interfaces provide methods for creating and maintaining connections, as well as transactions, and other mechanisms for querying and updating data in a database, which map directly to underlying SQL semantics, <strong>hiding the actual communication details</strong>.<br>ODBO is a Microsoft specification and an industry standard for multi-dimensional data processing. The ODBO API is used by applications that use the MDX query language to access multi-dimensional data in SAP HANA. <strong>As alternative to ODBO</strong>, MDX clients can use XMLA which exposes a similar interface as a <code>SOAP</code> (Simple Object Access Protocol) web service over HTTP. On the server side, the <strong>XMLA interface is provided by an application that runs in the XS server</strong>.</p><h2 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h2><p>The SAP HANA SQL implementation is based on the <code>P*TIME</code> (Parallel<em>Transact-In-Memory Engine) SQL dialect which implements SQL 92 entry level and some features of SQL 99. SAP HANA *</em>offers several SQL extensions** on top of this standard, for example:</p><ul><li>SQL extensions for creating tables as row-based or column-based and for conversion <strong>between both storage formats</strong>. Row-based tables can be converted into columnar tables and vice versa.</li><li>Support for <strong>managing columnar in-memory tables</strong>. One example is the <code>MERGE DELTA</code> statement for merging the delta and the main part of a column-based table. Other examples are the <code>LOAD</code> and <code>UNLOAD</code> statements for explicitly loading and unloading table to memory.</li><li>SAP HANA supports a number of <strong>extended SQL views</strong>. <code>Join views</code> are parameterized join-based views on columnar tables. <code>OLAP views</code> contain metadata for querying data cubes stored in column-based tables. <code>Calculation views</code> expose results calculated by a procedure or based on a data flow graph. <code>Hierarchy views</code> support querying and navigating hierarchical data in column-based tables in an efficient way.</li><li>An extended <code>PROCEDURE</code> specification, allowing the <strong>development of embedded procedures</strong> using multiple technologies and programming languages.</li><li>Support for defining and querying <strong>history tables</strong>.</li><li>Support for <strong>full text search</strong> on database tables and views.</li><li>Support for <strong>spatial data</strong>.</li><li>Support for <strong>accessing remote data sources</strong> via virtual tables.</li><li>Flexible tables, which can be dynamically extended with new columns when data is inserted or updated, <strong>without the need to explicitly call SQL data definition statements</strong>.</li><li>Extensions to <strong>support the planning engine</strong>, which provides planning commands that are invoked by planning applications.</li></ul><blockquote><p>For most SQL statement it is syntactically irrelevant whether the table is column-based or row-based.</p></blockquote><h2 id="Modeled-Views"><a href="#Modeled-Views" class="headerlink" title="Modeled Views"></a>Modeled Views</h2><p>Modeled views are <strong>design-time definitions</strong>, created by application developers with specific modeling tools. The <strong>actual database objects</strong> are generated from these definitions during deployment via HDI or during activation, if the classic repository is used.<br>There are <strong>several reasons</strong> why developers use modeled views:</p><ul><li>They support structured and modular <strong>abstractions</strong>.</li><li>Using modeling tools is <strong>more convenient</strong> than writing complex statements in pure SQL.</li><li><strong>Additional semantics</strong> can be provided, such as description texts for attributes, hierarchies, variables and parameters.</li><li>Modeled views generate <strong>additional metadata</strong> at deploy-time, which enable access to the views for MDX clients and for generic Business Intelligence (BI).</li><li>Values of columns in the resulting database objects can be <strong>calculated using formulas</strong>.</li></ul><h3 id="Calculation-Views"><a href="#Calculation-Views" class="headerlink" title="Calculation Views"></a>Calculation Views</h3><p>Calculation views can be used for <strong>defining advanced slices</strong> on the data available in the SAP HANA database, based on complex calculations. The data foundation of the calculation view can include any combination of various sources such as tables, views of different types, table functions and virtual tables for accessing remote data. The logic of a calculation view can be programmed in SQLScript or you can use a visual view editor to create the <strong>data flow graph</strong> for the view.</p><h3 id="Traditionally-Used-Modeled-View-types"><a href="#Traditionally-Used-Modeled-View-types" class="headerlink" title="Traditionally Used Modeled View types"></a>Traditionally Used Modeled View types</h3><p><code>Attribute views</code> are created on data <strong>from column store tables</strong>, using projection and join operations. They were traditionally used to represent the master data dimensions in a <strong>star schema</strong>, and they also support the definition of hierarchies. <code>Analytic views</code> are created on column tables and attribute views. They were traditionally used to define star schemas, linking the central fact table to the dimensions.<br>In the <strong>SAP HANA studio</strong>, the traditional view types are still supported.</p><h3 id="Modeled-Views-and-Column-Views"><a href="#Modeled-Views-and-Column-Views" class="headerlink" title="Modeled Views and Column Views"></a>Modeled Views and Column Views</h3><p>It is important to understand the difference between modeled views and the corresponding database objects that are <strong>generated at run-time</strong>. The modeled views are <strong>design-time artifacts</strong>. To create the actual database objects, the modeled views need to <code>deployed</code> (when HDI is used) or <code>activated</code> (if the classic repository is used). For calculation views, the main database object is a <strong>column view</strong> of type CALCULATION. For attribute views, it is a column view of type JOIN. For analytic views a column view of type OLAP is created.</p><h2 id="Procedures"><a href="#Procedures" class="headerlink" title="Procedures"></a>Procedures</h2><p>An important SAP HANA SQL feature is its specification of database procedures (also known as <strong>stored procedures</strong>). The <code>CREATE PROCEDURE</code> statement supports the specification of the procedure body using several technologies and programming languages. These procedures <strong>run directly in the database layer</strong>, thus benefiting from the performance improvement of the SAP HANA algorithms and <strong>eliminating large amounts of data transfers</strong> from the database to the application.</p><table><thead><tr><th align="left">Procedure Language</th><th align="left">Comments</th></tr></thead><tbody><tr><td align="left">SQLScript</td><td align="left">SQLScript is used to <strong>write procedural orchestration logic</strong>, to define complex data flows and to write user-defined scalar functions.</td></tr><tr><td align="left">L</td><td align="left">L is an imperative programming language, derived from C++, for implementing embedded code. L programs are <strong>compiled to native code</strong>, and thus very efficient.</td></tr><tr><td align="left">C++</td><td align="left">Application Function Libraries (<code>AFLs</code>) can be written in C++ to develop performance critical code. One example of AFLs is the <strong>Predictive Analytics Library</strong> (PAL).</td></tr><tr><td align="left">R</td><td align="left">R is an open-source programming language and software environment for <strong>statistical computing and graphics</strong>.</td></tr></tbody></table><blockquote><p>Note that programming in L or C++ is not released for customers.</p></blockquote><h2 id="SQLScript"><a href="#SQLScript" class="headerlink" title="SQLScript"></a>SQLScript</h2><p>SAP HANA provides <code>SQLScript</code> as the <strong>default programming language</strong> for writing embedded orchestration and data flow logic, in the form of embedded procedures.<br>SQLScript has table variables that can contain internal tables, which can be seen as <strong>temporary tables</strong> inside the index server. Table variables need not be declared, their structure is automatically <strong>determined by the compiler</strong> from the type of the assigned values.<br>In SQLScript, the data types of procedure parameters need to be declared. A table type defines the names and the types of columns <strong>without creating a table</strong> on the database.<br>A SQLScript procedure may contain SQL statements, call other procedures, and uses if/else statements or loops for control flow. Cursors can be used to iterate through result sets. With <strong>support for loops and cursors</strong>, SQLScript procedures can process data row-by-row. However, procedures that follow the row-oriented processing model are <strong>hard to parallelize and optimize</strong>.</p><blockquote><p>Programmers are encouraged to process mass data using read-only procedures with declarative table operators.</p></blockquote><h3 id="Calculation-Engine-Operators"><a href="#Calculation-Engine-Operators" class="headerlink" title="Calculation Engine Operators"></a>Calculation Engine Operators</h3><p>SQLScript procedures may directly call the intrinsic operators of the calculation engine. Using intrinsic calculation engine operators can result in <strong>higher performance</strong> in some cases and therefore be used for fine-tuning the execution of a procedure. Calculation engine operators of the following categories are available:</p><ul><li>Operators for binding tables or views to <strong>table variables</strong>.</li><li><strong>Relational operators</strong> such as join, union, projection and aggregation.</li><li>Expressions with mathematical operations, string operations and date/time operations.</li><li>Implementation of <strong>business logic</strong> such as currency conversion.</li></ul><p>While these operators are <strong>implemented inside</strong> the calculation engine, in some cases the operator implementation just forwards the execution to the column store.<br>The <code>calculation engine operators</code> and the <code>corresponding SQL statement</code> are implemented differently and sometimes even have different semantics.</p><blockquote><p>Mixing SQL queries and calculation engine operators in the same procedure is <strong>not recommended</strong> for performance reasons.</p></blockquote><h3 id="Read-Only-Procedures"><a href="#Read-Only-Procedures" class="headerlink" title="Read-Only Procedures"></a>Read-Only Procedures</h3><p>Read-only procedures must not contain any statements that modify the database and they may <strong>only call other read-only procedures</strong>. As read-only procedures are guaranteed to <strong>be free of side effects</strong>, they can be better optimized and execution can be better parallelized.<br>The code sample below shows a simple read-only procedure:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> TT_TAB1 <span class="keyword">AS</span> <span class="keyword">TABLE</span> (<span class="string">"A"</span> <span class="built_in">INTEGER</span>, <span class="string">"B"</span> <span class="built_in">INTEGER</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> TT_TAB2 <span class="keyword">AS</span> <span class="keyword">TABLE</span> (<span class="string">"A"</span> <span class="built_in">INTEGER</span>, <span class="string">"C"</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> TT_TAB3 <span class="keyword">AS</span> <span class="keyword">TABLE</span> (<span class="string">"A"</span> <span class="built_in">INTEGER</span>, <span class="string">"B"</span> <span class="built_in">INTEGER</span>, <span class="string">"C"</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TYPE</span> TT_TAB4 <span class="keyword">AS</span> <span class="keyword">TABLE</span> (<span class="string">"A"</span> <span class="built_in">INTEGER</span>, <span class="string">"C"</span> <span class="built_in">VARCHAR</span>(<span class="number">50</span>));</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> PROC1 (</span><br><span class="line">    <span class="keyword">IN</span> T1 TT_TAB1,</span><br><span class="line">    <span class="keyword">IN</span> T2 TT_TAB2,</span><br><span class="line">    <span class="keyword">IN</span> T3 TT_TAB3,</span><br><span class="line">    <span class="keyword">IN</span> p1 <span class="built_in">INTEGER</span>,</span><br><span class="line">    <span class="keyword">OUT</span> T4 TT_TAB4  </span><br><span class="line">)</span><br><span class="line"><span class="keyword">LANGUAGE</span> SQLSCRIPT</span><br><span class="line"><span class="keyword">READS</span> <span class="keyword">SQL</span> <span class="keyword">DATA</span> <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    V1 = CE_JOIN (:T1, :T2, [<span class="string">"A"</span>], [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>]);</span><br><span class="line">    V2 = CE_UNION_ALL (:V1, :T3);</span><br><span class="line">    V3 = CE_PROJECTION (:V2, ["B", "C"], '"B" &gt; :p1');</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><h3 id="Table-Functions"><a href="#Table-Functions" class="headerlink" title="Table Functions"></a>Table Functions</h3><p>SQLScript is also used to write table functions. A table function contains read-only SQLScript code and <strong>returns a single table</strong> as its result value. The function call can be used instead of a table or view in SQL queries.<br>In the following example a table function FUNC1 is used as the <strong>data source</strong> for a select operation:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> col1, col2 <span class="keyword">FROM</span> FUNC1(<span class="number">5</span>, <span class="string">'AB'</span>) <span class="keyword">WHERE</span> col1 &gt; <span class="number">3000</span>;</span><br></pre></td></tr></table></figure><p>Table functions make it <strong>possible to call complex logic</strong> from client tools that can only invoke queries and which cannot call procedures.</p><h3 id="Scalar-SQLScript-Functions"><a href="#Scalar-SQLScript-Functions" class="headerlink" title="Scalar SQLScript Functions"></a>Scalar SQLScript Functions</h3><p>With SQLScript you can also write user-defined functions that <strong>return one or more scalar values</strong>. Like the <strong>built-in SQL functions</strong> they can be used in projection lists, group-by clauses and where conditions.<br>The code sample shows the definition of a scalar function F1, which returns two scalar values Y1 and Y2:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">FUNCTION</span> F1 (X1 <span class="keyword">DOUBLE</span>, X2 <span class="keyword">DOUBLE</span>)</span><br><span class="line"><span class="keyword">RETURNS</span> Y1 <span class="keyword">DOUBLE</span>, Y2 <span class="keyword">DOUBLE</span></span><br><span class="line"><span class="keyword">LANGUAGE</span> SQLSCRIPT</span><br><span class="line"><span class="keyword">READS</span> <span class="keyword">SQL</span> <span class="keyword">DATA</span> <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    Y1 := X1 * X1 + <span class="number">3</span> * X2 - X1;</span><br><span class="line">    Y2 := X2 * X2 - X1 / 2;</span><br><span class="line"><span class="keyword">END</span>;</span><br></pre></td></tr></table></figure><p>In the following example the function F1 is called twice, in the projection list and in the WHERE condition:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A, F1(A, B).Y1 <span class="keyword">FROM</span> T1</span><br><span class="line"><span class="keyword">WHERE</span> B &gt; F1(A, B).Y2;</span><br></pre></td></tr></table></figure><blockquote><p>Currently, scalar functions do not support table-valued parameters and they cannot contain operations on database tables.</p></blockquote><h2 id="L"><a href="#L" class="headerlink" title="L"></a>L</h2><p><code>L</code> is a language designed by SAP for <strong>executing procedural code</strong> in SAP HANA. One purpose of L is to serve as an internal common <strong>intermediate language</strong> for other SAP HANA languages. SQLScript procedures and FOX formula code are internally compiled into L.<br>L can be roughly described as a <strong>safe subset of C++</strong> with support for the SAP HANA data types. Unlike C++, L does not contain unsafe language elements (e.g. pointers) that may crash the server process.<br>L programs consist of a set of type definitions, variables and functions:</p><ul><li>For control flow, the L language provides <strong>if/else</strong> clauses and loops.</li><li>Exception handling with <strong>try/catch</strong> is also supported.</li><li>L comes with a <strong>math library</strong> with common mathematical functions and matrix operations.</li></ul><p>L programs are <strong>compiled at runtime</strong>. Using L for the wrong tasks may cause performance issues, L programs are executed sequentially. If procedural code is required, <strong>SQLScript should be the first choice</strong>.</p><blockquote><p>User-defined scalar functions can also be written in L. However, the SQLScript is the preferred choice.</p></blockquote><h3 id="L-Procedures"><a href="#L-Procedures" class="headerlink" title="L Procedures"></a>L Procedures</h3><p>Writing procedures in L is useful when application logic <strong>cannot be expressed</strong> with SQL or SQLScript, and for accessing internal data structures that are <strong>not exposed</strong> in SQLScript.<br>Procedures written in L <strong>cannot contain SQL statements</strong>. Tables can only be accessed via table typed input and output parameters.</p><h2 id="C-AFL"><a href="#C-AFL" class="headerlink" title="C++ (AFL)"></a>C++ (AFL)</h2><ul><li>A typical use case is to develop application-specific C++ functions that can <strong>be called from L code</strong>, for example from a procedure written in L.</li><li>Another use case is <strong>extending the calculation engine</strong> by writing custom operations in L which can call the C++ function.</li></ul><blockquote><p>Application logic written in C++ can be executed within SAP HANA by creating an Application Function Library (AFL).</p></blockquote><ul><li>The main reason for writing business logic in C++ is <strong>performance</strong>.</li><li>Another reason may be the need to <strong>use internal interfaces</strong> that are not available otherwise.</li></ul><p>However, using C++ also means that programming errors in the application code affect the <strong>stability and availability of the whole server</strong>. It needs to be carefully examined, whether using C++ is really required and writing application logic in C++ is restricted to privileged developers.</p><h2 id="R"><a href="#R" class="headerlink" title="R"></a>R</h2><p><code>R</code> is an open-source programming language and software environment for <strong>statistical computing and graphs</strong>. With over 4,000 add-on packages, R provides a wide range of <strong>library functions</strong>. It provides roughly the same functions as the combination of the most successful commercial packages, SAS and SPSS.<br>SAP HANA provides interoperability with the <strong>R runtime environment</strong>, via a tight component integration, and support for functions written in R, which are encapsulated by a regular embedded procedure interface. <strong>Table parameters</strong> can be passed to R code, and a result is returned in the form of tables:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- prepare tables</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PRIME (<span class="built_in">NUMBER</span> <span class="built_in">INTEGER</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> PRIME <span class="keyword">VALUES</span>(<span class="number">2</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> PRIME <span class="keyword">VALUES</span>(<span class="number">3</span>);</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> PRIME <span class="keyword">VALUES</span>(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> PRIME_SQR (<span class="built_in">NUMBER</span> <span class="built_in">INTEGER</span>);</span><br><span class="line"><span class="comment">-- create R procedure that fills output table with squares of values in input table</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">PROCEDURE</span> my_sq (</span><br><span class="line">    <span class="keyword">IN</span> input1 PRIME,</span><br><span class="line">    <span class="keyword">OUT</span> <span class="keyword">result</span> PRIME_SQR</span><br><span class="line">)</span><br><span class="line"><span class="keyword">LANGUAGE</span> RLANG <span class="keyword">AS</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">result</span> &lt;- as.data.frame(input1$<span class="built_in">NUMBER</span>^<span class="number">2</span>);</span><br><span class="line">    names(result) &lt;- c("NUMBER");</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line"><span class="comment">-- execute procedure and retrieve result</span></span><br><span class="line"><span class="keyword">CALL</span> my_sq(PRIME, PRIME_SQR) <span class="keyword">WITH</span> OVERVIEW;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> PRIME_SQR;</span><br></pre></td></tr></table></figure><h2 id="MDX"><a href="#MDX" class="headerlink" title="MDX"></a>MDX</h2><p>MDX syntactically resembles SQL, but it <strong>incorporates concepts like cube, dimensions, hierarchies and measures</strong>, and can be used to connect a variety of analytics applications including SAP Business Objects BI tools and Microsoft Excel.<br>The following is an example of an MDX query:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &#123;</span><br><span class="line">    [<span class="keyword">Measures</span>].[unit_sales],</span><br><span class="line">    [<span class="keyword">Measures</span>].[base_sales]</span><br><span class="line">&#125; <span class="keyword">ON</span> <span class="keyword">COLUMNS</span>,</span><br><span class="line">NON <span class="keyword">EMPTY</span></span><br><span class="line">FILTER (</span><br><span class="line">    CROSSJOIN (</span><br><span class="line">        [Product].[MyProducts].Members,</span><br><span class="line">        [Customer].[Country].[IT].Children</span><br><span class="line">    ),</span><br><span class="line">    [<span class="keyword">Measures</span>].[unit_sales] &gt; <span class="number">20000</span>  </span><br><span class="line">) <span class="keyword">ON</span> <span class="keyword">ROWS</span></span><br><span class="line"><span class="keyword">FROM</span> [MySales]</span><br><span class="line"><span class="keyword">WHERE</span> [<span class="built_in">Time</span>].[Calendar].[<span class="number">2011</span>];</span><br></pre></td></tr></table></figure><p>MDX includes a rich set of functions for statistical analysis, but unlike SQL, MDX has <strong>limited DDL or DML capabilities</strong>. MDX cubes are defined in SAP HANA by creating calculation views.</p><blockquote><p>The current MDX implementation in SAP HANA covers most parts of the MDX specification, and includes additional SAP-specific extensions.</p></blockquote><h2 id="Decision-Tables"><a href="#Decision-Tables" class="headerlink" title="Decision Tables"></a>Decision Tables</h2><p>SAP HANA supports decision tables as an <strong>intuitive design-time representation of business rules</strong>. At runtime, the business rules are executed as database procedures for best performance. From the decision table model, a SQLScript procedure with result view is generated for execution.</p><h2 id="Declarative-OData-Provisioning-in-XS"><a href="#Declarative-OData-Provisioning-in-XS" class="headerlink" title="Declarative OData Provisioning in XS"></a>Declarative OData Provisioning in XS</h2><p>XS application programmers can define <code>OData</code> (Open Data protocol) data access services <strong>without programming</strong>. OData is a resource-based web protocol for querying and updating data. OData defines operations on resources using HTTP verbs, and specifies the URI syntax for identifying the resources. OData defines a set of query parameters, which allow clients to <strong>influence the result set</strong>.<br>To create an OData service, XS developers just have to create an <strong>OData service descriptor file</strong>. These declarations are evaluated by a generic OData provider component of the XS platform to provide the services at runtime.</p><h2 id="Server-Side-Application-Code-in-XS"><a href="#Server-Side-Application-Code-in-XS" class="headerlink" title="Server-Side Application Code in XS"></a>Server-Side Application Code in XS</h2><p>Developers of <code>XS Classic</code> applications can <strong>write server-side logic in JavaScript</strong>. This is server-side JavaScript, augmented to support connections to the SAP HANA database and the SAP HANA data types.<br>Ths server part of <code>XS Advanced</code> applications can be written in Java, or in JavaScript on Node.js. In addition, a <strong>XS Classic compatibility layer</strong> is provided, which was developed for executing existing XS Classic JavaScript code with as few migration efforts as possible.</p><h2 id="Core-Data-Services-CDS"><a href="#Core-Data-Services-CDS" class="headerlink" title="Core Data Services (CDS)"></a>Core Data Services (CDS)</h2><h3 id="Introducing-CDS"><a href="#Introducing-CDS" class="headerlink" title="Introducing CDS"></a>Introducing CDS</h3><p>Application programs implement their own domain-specific models and access logic on top of the SQL standard API, but the implementation-specific information <strong>cannot be shared</strong> across technology stacks, programming languages, and application frameworks. To address this, HANA has introduced the Core Data Services (<code>CDS</code>), an infrastructure for defining and consuming semantically <strong>enriched data models</strong>. These CDS can be consumed by applications written in different languages, such as ABAP, Java and others.<br>The CDS comprise a family of programming specifications:</p><ul><li><strong>Schema Definition Language</strong> (SDL) for defining semantically enriched domain data models. The SDL allows developers to define persisted entities that are similar to tables but <strong>have some additional features</strong>. SDL also supports the definition of views and reusable structured types. CDS annotations allow for enriching data models with additional metadata.</li><li><strong>Query Language</strong> (QL) for <strong>conveniently and efficiently reading data</strong>. The QL extends the SQL <code>SELECT</code> statement by allowing a path-like syntax for identifying associated entities that is much easier to use than an equivalent <code>JOIN</code> statement in SQL. QL can be used in SDL view definitions.</li><li><strong>Expression Language</strong> (EL) for specifying calculated fields, default values, constraints, etc. with queries as well as for elements in data models.</li><li><strong>Data Control Language</strong> (DCL) for defining the application’s authorization model. The DCL supports <code>static privileges</code> and <code>predicated privileges</code>.<ul><li>Static privileges <strong>control access to an entire resource</strong>, e.g. a CDS view, in an all or nothing fashion.</li><li>Predicated privileges allow for <strong>dynamic access control</strong>, based on the values of the attributes of entity instances.</li></ul></li></ul><blockquote><p>The CDS focus on providing functional services independent of any programming language and language paradigms.</p></blockquote><h3 id="CDS-Support-in-SAP-HANA"><a href="#CDS-Support-in-SAP-HANA" class="headerlink" title="CDS Support in SAP HANA"></a>CDS Support in SAP HANA</h3><p>CDS support in SAP HANA allows application developers to <strong>define the data models by creating CDS design-time files</strong> that contain CDS definitions. CDS can be used to define various aspects of an application such as persisted data model, views, analytical models, search models, and the authorization models. SAP HANA internally <strong>transforms the CDS definitions to the existing mechanisms</strong> for data definition, to SQL, to database privileges, to calculation models executed by the calculation engine, or to L programs.<br>The SQL <code>CREATE TABLE</code> statement now supports the <strong>definition of CDS associations</strong>, and in SQL queries you can <strong>navigate such associations with path expressions</strong>. The following code snippets from illustrate this feature.</p><ul><li><p>SQL data definition with CDS association:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> Employees (</span><br><span class="line">    <span class="keyword">id</span>, <span class="keyword">name</span>, ..., homeAddress_id <span class="built_in">INTEGER</span></span><br><span class="line">) <span class="keyword">WITH</span> ASSOCIATIONS (</span><br><span class="line">    <span class="keyword">JOIN</span> Address <span class="keyword">AS</span> homeAddress <span class="keyword">ON</span> homeAddress.id = homeAddress_id;  </span><br><span class="line">)</span><br></pre></td></tr></table></figure></li><li><p>SQL query with CDS infix filters and path expressions along association:</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, address[kind=<span class="string">'business'</span>].town.country.name</span><br><span class="line"><span class="keyword">FROM</span> Employees;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> HANA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAP HANA System Architecture Overview</title>
      <link href="2019/07/04/SAP-HANA-System-Architecture-Overview/"/>
      <url>2019/07/04/SAP-HANA-System-Architecture-Overview/</url>
      
        <content type="html"><![CDATA[<h2 id="The-SAP-HANA-System"><a href="#The-SAP-HANA-System" class="headerlink" title="The SAP HANA System"></a>The SAP HANA System</h2><p>The SAP HANA system consists of multiple servers:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/3-1.jpg" alt><br>The most important component is the <code>index server</code>. The index server contains the in-memory data stores and the <strong>engines for processing the data</strong>.<br>The <code>name server</code> owns the information about the topology of an SAP HANA system. In a distributed system, the name server <strong>knows where the components are running</strong>, and which data is located on which server.</p><a id="more"></a><p>The <code>XS</code> runtime is the application server for native SAP HANA-based web applications. It is installed with the SAP HANA system and allows developers to write and run SAP HANA-based applications <strong>without the need to run an additional application server</strong>.<br>The <code>extended store server</code> is part of the <strong>dynamic tiering</strong> option. Less frequently accessed data, which you do not want to keep in main memory, can be put into the extended store. With dynamic tiering, SAP HANA can host very big databases with reduced cost of ownership.<br>The <code>data provisioning server</code> is part of <strong>Enterprise Information Management</strong> (EIM) in SAP HANA. It provides capabilities such as data provisioning in real time and batch mode, real-time data transformations, data quality functions.<br>The <code>streaming cluster</code> is part of the <strong>smart data streaming</strong> option. Smart data streaming extends SAP HANA with capabilities of SAP Event Stream Processor for consuming data streams and complex event processing.<br>The <code>HDI server</code> is a <strong>separate server process</strong> that is part of the HANA deployment infrastructure.<br>The <strong>SAP HANA server software</strong> is developed mainly in C++ and runs on the Linux operation system. The <strong>XS Advanced on-premise platform components</strong> are developed in Java.</p><h2 id="SAP-HANA-Tools"><a href="#SAP-HANA-Tools" class="headerlink" title="SAP HANA Tools"></a>SAP HANA Tools</h2><p>Traditionally, the <strong>Eclipse-based</strong> SAP <code>HANA Studio</code> has been the development environment and administration tool for SAP HANA. The studio is superseded by <strong>web-based tools</strong>, which are grouped in the following three categories:</p><ul><li>Administration Tools<br>Web-based administration tools for SAP HANA are available in the SAP <code>HANA Cockpit</code>. The cockpit is an SAP Fiori launchpad site that integrates various tools for administration, monitoring, and software life-cycle management.</li><li>Development Tools<br>SAP <code>Web IDE</code> for SAP HANA is the browser-based development environment for SAP HANA-based application. It covers various aspects of development, such as editing, modeling, versioning, build, deployment, and debugging. It is based on <strong>XS Advanced</strong> and HDI and uses Git for source code management.<br>SAP Web IDE for SAP HANA supersedes the SAP HANA <code>Web Workbench</code>, which can be used to develop SAP HANA-based applications for <strong>XS Classic</strong>.</li><li>Runtime Tools<br>The web-based SAP HANA runtime tools contain functions that are <strong>needed by both developers and administrators</strong>. Example are the SAP HANA database catalog browser, the SQL console and the Plan Visualizer for inspecting query execution plans.</li></ul><h2 id="Distributed-SAP-HANA-Systems"><a href="#Distributed-SAP-HANA-Systems" class="headerlink" title="Distributed SAP HANA Systems"></a>Distributed SAP HANA Systems</h2><p>SAP HANA supports distribution of its server components <strong>across multiple hosts</strong> – for example for scalability and availability.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/3-2.jpg" alt><br>An installed SAP HANA system is identified by a <strong>System ID</strong> (SID). It is perceived as one unit from the perspective of <code>the administrator</code>, who can install, update, start up, shut down, or backup the system as a whole. The different components of the system share the same metadata, and requests from client applications are transparently dispatched to different servers in system, if required:</p><ul><li>A distributed SAP HANA <code>system</code> is installed on more than one host. Otherwise it is a <strong>single-host system</strong>.</li><li>A <code>host</code> is <strong>a machine</strong> which runs parts of the SAP HANA system.</li><li>A SAP HANA <code>instance</code> is the <strong>set of components</strong> of a distributed system that are installed on one host.</li></ul><p>The streaming cluster nodes and the extended store servers run on <strong>their own dedicated hosts</strong>, at least in product systems. This means that you <strong>always need a distributed system</strong> if you run one of these options in production.</p><h2 id="The-Index-Server"><a href="#The-Index-Server" class="headerlink" title="The Index Server"></a>The Index Server</h2><p>This section presents an overview of the architecture of the index server:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/3-3.jpg" alt><br>The <code>Connection and Session Management</code> component at the top creates and manages sessions and connections for the <code>Database Clients</code>. Once a session is established, database clients typically use <strong>SQL statements</strong> to communicate with the index server. Analytical applications may use <strong>MDX queries</strong> (MultiDimensional eXpressions). SQL statements and MDX queries are sent over the same connection using the <strong>same network communication protocol</strong>.<br>The <code>Authentication</code> component is invoked when a new connection is established. Users are authenticated either by the SAP HANA system itself or external provider. The <code>Authorization Manager</code> is invoked by other components to check whether the user has the <strong>required privileges</strong> to execute the requested operations.<br>Each statement is processed in the context of a transaction. The <code>Transaction Manager</code> is the component that coordinates transaction, controls transactional isolation, and keeps track of running and closed transactions. The transaction manager cooperates with the persistence layer to <strong>achieve atomic and durable transactions</strong>.<br>The client requests are analyzed and executed by the set of components summarized as <code>Request Processing and Execution Control</code>. SAP HANA offers <strong>rich programming capabilities</strong> for running application-specific calculations inside the database system. In addition to SQL and MDX, SAP HANA provides its own programming languages for different use cases.<br>Incoming <strong>SQL requests</strong> are received by the <code>SQL Processor</code>. Data manipulation statements are executed by the SQL processor itself. Other types of requests are delegated to the respective components:</p><ul><li>Data definition statements are dispatched to the <strong>metadata manager</strong>.</li><li>Transaction control statements are forwarded to the <strong>transaction manager</strong>.</li><li>Planning commands are routed to the <strong>planning engine</strong>.</li><li>Task related commands are forwarded to the <code>Task Manager</code>.</li></ul><p>Incoming <strong>MDX requests</strong> are delegated to the <code>MDX Processor</code>. Procedure calls are forwarded to the <code>Procedure Processor</code>, which further dispatches the calls, for example to the calculation engine, the <code>Graph Engine</code>, the repository, or the HDI proxy. Procedures are also used to call liveCache functions.<br>The index server also contains a component called the <code>Planning Engine</code> that allows planning applications. It is mainly used for planning in SAP <strong>Business Warehouse</strong> (BW).<br>The SAP HANA <strong>Enterprise Performance Management</strong> (EPM) platform provides the infrastructure for developing and running enterprise performance management application on SAP HANA. The <code>EPM Runtime</code> is a central component of the EPM platform. While the planning engine provides basic planning operations, the EPM platform <strong>provides the foundation</strong> for complete planning application. It is usually invoked directly by an <strong>XS-based service</strong>.</p><blockquote><p>While the planning engine is mainly used for planning in BW, the EPM platform addresses planning and simulation applications in general.</p></blockquote><p>The SQL processor, the MDX processor, the planning engine and the task framework, translate the different programming languages, query languages, and models into <strong>common representation that is optimized and executed</strong> by the <code>Calculation Engine</code>.<br>Metadata can be accessed via <code>Metadata Manager</code> component. Metadata <strong>comprises a variety of objects</strong>, such as definitions of relational tables, columns, views, indexes and procedures. In distributed systems, central metadata is shared across servers.<br>The row store, column store, and the federation component are <code>Relational Stores</code>, which provide access to data organized in  relational tables:</p><ul><li>The <code>Column Store</code> stores relational tables column-wise. The column store also contains the <strong>text search</strong> and analysis capabilities, support for <strong>spatial data</strong>, and operators and storage for graph-structured data.</li><li>The <code>Row Store</code> stores relational tables row-wise. When a table is created, the creator needs to specify whether it should be row or column-based. Tables can be <strong>migrated between the two storage formats</strong>.</li><li>The <code>Federation</code> component can be viewed as a <strong>virtual relational data store</strong>. It provides access to remote data in external systems through virtual tables, which can be used in SQL queries like normal tables. The data federation feature of SAP HANA is referred to as <strong>smart data access</strong>. The federation capabilities of smart data access are extended by <strong>Enterprise Information Management</strong> (EIM) in SAP HANA.</li><li>The SAP HANA database provides native support for storing and processing <strong>graph-structured data</strong>. However, technically it is <strong>not a separate physical data store</strong>. Instead it is built using the column store, which was extended with a dedicated graph API.</li><li>SAP HANA includes an integration of SAP liveCache technology into the index server. <code>liveCache in SAP HANA</code> is a <strong>non-relational, in-memory store</strong> with data represented as networks of C++ objects, which can be persisted to disk. Unlike the row store and column store, liveCache does not use relational tables. Instead the liveCache objects are <strong>directly stored in containers</strong> provided by the persistence layer.</li></ul><blockquote><p>The index server uses the federation infrastructure to send SQL statements to the extended store server.</p></blockquote><p>The <code>Persistence Layer</code> is responsible for durability and atomicity of transactions. It ensures that the database is <strong>restored to the most recent committed state</strong> after a restart and that transactions are either completely executed or completely undone. To achieve this goal in an efficient way, the persistence layer uses a combination of <strong>write-ahead logs, shadow paging and savepoints</strong>. It also contains the logger component that manages the transaction log.<br>The <code>HDI Proxy</code> is a small component which forwards requests to the DI server, the <strong>main component</strong> of the HDI. HDI supersedes the classic SAP HANA <code>Repository</code>. In general the repository contains design-time representations, which <strong>need to be activated</strong> to create the corresponding runtime objects.</p>]]></content>
      
      
      
        <tags>
            
            <tag> HANA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Basic In-Memory Database Concepts</title>
      <link href="2019/07/01/Basic-In-Memory-Database-Concepts/"/>
      <url>2019/07/01/Basic-In-Memory-Database-Concepts/</url>
      
        <content type="html"><![CDATA[<p><code>In-memory database technology</code> is a core feature of the SAP HANA database, which enables new applications that were not possible before.</p><h2 id="Impact-of-Modern-Hardware-on-Database-System-Architecture"><a href="#Impact-of-Modern-Hardware-on-Database-System-Architecture" class="headerlink" title="Impact of Modern Hardware on Database System Architecture"></a>Impact of Modern Hardware on Database System Architecture</h2><p>In the past database management systems were designed for optimizing performance on hardware with limited main memory and with slow disk I/O as the main bottleneck. The focus was on <strong>optimizing disk access</strong>, for example by minimizing the number of disk pages to be read into main memory when processing a query.<br>Today’s computer architectures have changed. With <code>multi-core processors</code>, parallel processing is possible with fast communication between processor cores. Very large main memory configurations are now commercially available and affordable.<br>With all relevant data in memory, disk access is no longer a limiting factor for performance. With the increasing number of cores, CPUs are able to process more and more data per time interval. That means the performance bottleneck is now <strong>between the CPU cache and main memory</strong>.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/2-1.jpg" alt><br>A <code>high performance data management system</code> for modern hardware must have the following characteristics:</p><a id="more"></a><ul><li>In-memory database<br>All relevant data must be kept in main memory, so read operations can be executed without disk I/O. <strong>Disk storage</strong> is still needed to make changes durable.</li><li>Cache aware memory organization, optimization and execution<br>The design must minimize the number of CPU cache misses and avoid CPU stalls because of memory access. One approach for achieving this goal is using <strong>column-based storage</strong> in memory. This leads to high spatial locality of data and instructions, so the operations can be executed completely in the CPU cache without costly random memory accesses.</li><li>Support for parallel execution<br>In recent years CPUs did not become faster by increasing clock rates. Instead the number of processor cores was increased. For data management systems this means that it must be possible to <strong>partition data in sections</strong> for which the calculations can be executed in parallel.</li></ul><h2 id="Columnar-and-Row-Based-Data-Storage"><a href="#Columnar-and-Row-Based-Data-Storage" class="headerlink" title="Columnar and Row-Based Data Storage"></a>Columnar and Row-Based Data Storage</h2><p>For storing a table in linear memory, two options can be chosen. A row store stores a sequence of records that contains the fields of one row in the table. In a column store, the entries of column are stored in contiguous memory locations.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/2-2.jpg" alt></p><h3 id="Choosing-Between-Column-and-Row-Store"><a href="#Choosing-Between-Column-and-Row-Store" class="headerlink" title="Choosing Between Column and Row Store"></a>Choosing Between Column and Row Store</h3><p>Column-based tables have advantages if:</p><ul><li>Calculations are typically executed on single of few columns only.</li><li>The table is searched based on values of a few columns.</li><li>The table has a big number of columns.</li><li>The table has a big number of rows and columnar operations are required (aggregate, scan, …).</li><li><strong>High compression rate</strong> can be achieved because the majority of the columns contain only a few distinct values.</li></ul><p>Row-based tables have advantages if:</p><ul><li>The application needs to process only one single record at one time.</li><li>The application typically needs to <strong>access the complete record</strong>.</li><li>The columns contain mainly distinct values so the data compression rate would be low.</li><li>Neither aggregations nor <strong>fast search</strong> are required.</li><li>The table has a small number of rows.</li></ul><h3 id="Advantages-of-Columnar-Tables"><a href="#Advantages-of-Columnar-Tables" class="headerlink" title="Advantages of Columnar Tables"></a>Advantages of Columnar Tables</h3><h4 id="Higher-Data-Compression-Rates"><a href="#Higher-Data-Compression-Rates" class="headerlink" title="Higher Data Compression Rates"></a>Higher Data Compression Rates</h4><p>The goal to keep all relevant data in main memory can be achieved with lower cost because <strong>data compression</strong> is used. Columnar data storage allows highly efficient compression. Especially if the column is sorted, there will be ranges of the same values in contiguous memory, so compression methods such as run length encoding or cluster encoding can be used more effectively.</p><h4 id="Higher-Performance-for-Column-Operations"><a href="#Higher-Performance-for-Column-Operations" class="headerlink" title="Higher Performance for Column Operations"></a>Higher Performance for Column Operations</h4><p>With columnar data organization, operation on single columns, such as searching or aggregations can be implemented as loops over an array stored in contiguous memory locations.<br>Higher data compression rate not only saves memory but also increases speed for the following reasons:</p><ul><li>Compressed data can be loaded faster into the CPU cache. As the limiting factor is the data transport between memory and CPU cache, the performance gain <strong>exceeds the additional computing time needed for decompression</strong>.</li><li>With <strong>dictionary encoding</strong>, the columns are stored as arrays of bit encoded integers. That means that check for equality can be executed on the integers. This is much faster than comparing for example string values.</li><li>Compression can speed up operations such as scans and aggregations if the operator is aware of the compression. Given a good compression rate, computing the sum of the values in a column will be much faster if many additions of the same value can be <strong>replaced by a single multiplication</strong>.</li></ul><h4 id="Elimination-of-Additional-Indexes"><a href="#Elimination-of-Additional-Indexes" class="headerlink" title="Elimination of Additional Indexes"></a>Elimination of Additional Indexes</h4><p>Storing data in columns already works like having a built-in index for each column. In many cases it will <strong>not be required to have addition index structures</strong>. Eliminating indexes reduces memory size, can improve write performance, and reduces development efforts.</p><h4 id="Elimination-of-Materialized-Aggregates"><a href="#Elimination-of-Materialized-Aggregates" class="headerlink" title="Elimination of Materialized Aggregates"></a>Elimination of Materialized Aggregates</h4><p>Traditional business applications use <code>materialized aggregates</code> to increase read performance. That means that the application developers define additional tables in which the application redundantly stores the results of aggregates computed on other tables.<br>SAP HANA eliminates the need for materialized aggregates in many cases. Financial applications, for instance, can compute totals and balances from the accounting documents when they are queried, <strong>instead of maintaining them as materialized values</strong>.<br>Eliminating materialized aggregates has several advantages:</p><ul><li>It simplifies data model and aggregation logic, which makes development and maintenance <strong>more efficient</strong>.</li><li>It allows for <strong>a higher level of concurrency</strong> because write operations do not require exclusive locks for updating aggregated values.</li><li>It ensures that the aggregated values are <strong>always up-to-date</strong>, while materialized aggregates are sometimes updated only at scheduled times.</li></ul><h4 id="Parallelization"><a href="#Parallelization" class="headerlink" title="Parallelization"></a>Parallelization</h4><p><code>Column-based storage</code> also simplifies parallel execution using multiple processor cores. That means operations on different columns can easily be processed in parallel.<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/2-3.jpg" alt><br>If multiple columns <strong>need to be searched or aggregated</strong>, each of these operations can be assigned to a different processor core. In addition, the execution of operations on one column can be parallelized by dividing the column into multiple sections that are processed by different processor cores.</p><h2 id="History-Tables"><a href="#History-Tables" class="headerlink" title="History Tables"></a>History Tables</h2><p>SAP HANA supports history tables which allow queries on historical data. Applications may use this feature for example <strong>for time-based reporting and analysis</strong>. Write operations on history tables do not physically overwrite existing records. Instead, write operations always <strong>insert new versions</strong> of the data record into the database. Each row in a history table has <strong>timestamp-like system attributes</strong> that indicate the time period when the record version in this row was the current one.<br>In literature, data with time-based validity or visibility is known as <code>temporal data</code>. The standard distinguishes two levels of temporal data support, which can be characterized as <strong>system-versioned</strong> and as <strong>application-managed</strong>.<br>For system-versioned temporal data, the timestamps are <strong>automatically set</strong> and indicate the so-called transaction time when the data was current. New versions are automatically created by the system during updates. Application-managed is different, the time period indicates the period of validity on <strong>application level</strong>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> HANA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SAP HANA Overview</title>
      <link href="2019/06/30/SAP-HANA-Overview/"/>
      <url>2019/06/30/SAP-HANA-Overview/</url>
      
        <content type="html"><![CDATA[<p>SAP HANA is a <strong>data management platform</strong> that is deploy as an appliance or in the cloud.<br>And its core is the <code>SAP HANA database</code>, an innovative in-memory database management system which makes full use of the capabilities of current hardware to increase application performance, to reduce cost of ownership and to enable new scenarios and applications that were not possible before.<br>The SAP HANA database is a hybrid database management system that combines several paradigms in one system. It includes a full <strong>relational database management system</strong> where individual tables can be stored column-based or row-based in memory, and column-based on disk.<br>It supports SQL, transactional isolation and recovery (ACID properties) and high availability. These capabilities are extended with the following features:</p><ul><li><strong>Text analysis and search</strong> capabilities that support a state-of-the-art search experience. This includes full text search with advanced features such as free style search, linguistic search and fault-tolerant fuzzy search.</li><li>Native support for <strong>geo-spatial</strong> data and operations.</li><li>Support for <strong>series data</strong>.</li><li>Built-in support for <strong>planning</strong> applications.</li><li>SAP HANA provides capabilities for the efficient storage and processing of <strong>graph-like</strong> data structures with a flexible data schema.</li><li>A <strong>task framework</strong> for executing potentially long running tasks. Task can started asynchronously and can be monitored on the level of application-defined steps.</li></ul><a id="more"></a><p>SAP HANA can combine and analyze all kinds of data within the <strong>same database management system</strong> - a core capability required by modern business applications that provides a competitive advantage for SAP.<br>The SAP HANA database is built for <strong>high performance</strong> applications. All relevant data is kept in main memory, so all read operations can run in main memory. SAP HANA is also designed to make full use of multi-core CPUs by parallelization of execution.<br>The SAP HANA database provides several programming and modeling options for <strong>executing application logic close to the data</strong>. This is required to make full use of the parallelization and optimization capabilities of SAP HANA and to reduce the amount of data that needs to be transported between the database and the application server.<br>A single SAP HANA system can contain several databases, which are isolated from each other and have their own data, metadata, and users. These contained databases are called <strong>multi-tenant database containers</strong>.<br>SAP HANA can process <strong>big data</strong> both inside the SAP HANA database and by integration with Apache Hadoop.<br>SAP HANA <strong>eXtended application Services</strong> (XS) is a layer on top of the SAP HANA database. It provides the platform for running SAP HANA-based web applications.<br>The database part of an XS Advanced application is deployed using the SAP <strong>HANA Deployment Infrastructure</strong> (HDI). HDI is a service layer of the SAP HANA database that simplifies the continuous deployment of HANA database objects.</p>]]></content>
      
      
      
        <tags>
            
            <tag> HANA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>端口映射与容器互联</title>
      <link href="2019/06/23/%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/"/>
      <url>2019/06/23/%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E4%B8%8E%E5%AE%B9%E5%99%A8%E4%BA%92%E8%81%94/</url>
      
        <content type="html"><![CDATA[<p>在实践中，经常会碰到多个服务组件容器共同协作的情况，这往往需要多个容器之间，能够互相访问到对方的服务。<br>Docker 除了通过网络访问外，还提供了两个很方便的功能，来满足服务访问的基本需求：</p><ul><li>允许映射容器内应用的服务端口到宿主机。</li><li>互联机制实现多个容器间，通过容器名来快速访问。</li></ul><h2 id="端口映射实现容器访问"><a href="#端口映射实现容器访问" class="headerlink" title="端口映射实现容器访问"></a>端口映射实现容器访问</h2><h3 id="从外部访问容器应用"><a href="#从外部访问容器应用" class="headerlink" title="从外部访问容器应用"></a>从外部访问容器应用</h3><p>当容器中运行一些网络应用，要让外部访问这些应用时，可以通过 <strong>-P</strong> 或 <strong>-p</strong> 参数来指定端口映射。<br>当使用 -P 参数时，Docker 会随机映射一个端口到内部容器开放的网络端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P training/webapp python app.py</span><br></pre></td></tr></table></figure><blockquote><p>当使用 -p 参数时，可以指定要映射的端口，并且在一个指定端口上，只可以绑定一个容器。</p></blockquote><a id="more"></a><h3 id="映射所有接口地址"><a href="#映射所有接口地址" class="headerlink" title="映射所有接口地址"></a>映射所有接口地址</h3><p>使用 <code>HostPort:ContainerPort</code> 格式，将宿主机的 5000 端口映射到容器的 5000 端口，可以执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><blockquote><p>默认会绑定宿主机所有接口上的所有地址。</p></blockquote><h3 id="映射到指定地址的指定端口"><a href="#映射到指定地址的指定端口" class="headerlink" title="映射到指定地址的指定端口"></a>映射到指定地址的指定端口</h3><p>使用 <code>IP:HostPort:ContainerPort</code> 格式，指定映射的特定地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1:5000:5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="映射到指定地址的任意端口"><a href="#映射到指定地址的任意端口" class="headerlink" title="映射到指定地址的任意端口"></a>映射到指定地址的任意端口</h3><p>使用 <code>IP::ContainerPort</code> 绑定 localhost 的任意端口到容器的 5000 端口，宿主机会<strong>自动分配</strong>一个端口：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 127.0.0.1::5000 training/webapp python app.py</span><br></pre></td></tr></table></figure><h3 id="查看映射端口配置"><a href="#查看映射端口配置" class="headerlink" title="查看映射端口配置"></a>查看映射端口配置</h3><p>使用 <strong>docker port</strong> 来查看当前映射的端口配置，也可以查看到绑定的地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker port relaxed_pike 5000</span><br></pre></td></tr></table></figure><blockquote><p>容器有自己的内部网络和 IP 地址，使用 docker inspect 可以获取容器的具体信息。</p></blockquote><h2 id="互联机制实现便捷互访"><a href="#互联机制实现便捷互访" class="headerlink" title="互联机制实现便捷互访"></a>互联机制实现便捷互访</h2><p>容器的<strong>互联</strong>（linking）是一种让多个容器中的应用进行快速交互的方式，接收容器可以通过容器名快速访问到源容器，而不用指定具体的 IP 地址。</p><h3 id="自定义容器命名"><a href="#自定义容器命名" class="headerlink" title="自定义容器命名"></a>自定义容器命名</h3><p>自定义容器命名的好处：</p><ul><li>自定义的命名比较好记，比如一个 Web 应用容器我们可以给他起名叫 web，一目了然。</li><li>当要连接其他容器的时候（即便重启），也可以使用容器名而不用改变，比如连接 web 容器到 db 容器。</li></ul><p>使用 <code>--name</code> 参数可以为容器自定义命名：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P --name web training/webapp python app.py</span><br></pre></td></tr></table></figure><p>在执行 docker run 的时候，如果添加 --rm 参数，则容器在终止后会立刻删除。注意：<strong>--rm 和 -d 参数不能同时使用</strong>。</p><h3 id="容器互联"><a href="#容器互联" class="headerlink" title="容器互联"></a>容器互联</h3><p>使用 <code>--link</code> 参数可以让容器之间安全的交互。<br>先创建一个新的数据库容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --name db training/postgres</span><br></pre></td></tr></table></figure><p>然后创建一个新的 web 容器，并将他连接到 db 容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P --name web --link db:db training/webapp python app.py</span><br></pre></td></tr></table></figure><p>此时，db 容器和 web 容器建立互联关系。<br>--link 参数的格式为 <code>--link name:alias</code>，其中 name 是要连接的容器的名称，alias 是别名。<br>Docker 相当于在两个互联的容器之间创建了一个虚机通道，而且不用映射他们的端口到宿主机上，<strong>避免了暴露数据库服务端口到外部网络上</strong>。<br>Docker 通过两种方式为容器公开连接信息：</p><ul><li>环境变量</li><li><code>/etc/hosts</code> 文件</li></ul><p>使用 <strong>env 命令</strong>来查看 web 容器的环境变量：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --link db:db training/webapp env</span><br></pre></td></tr></table></figure><p> 查看父容器 web 的 hosts 文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --rm --link db:db training/webapp /bin/bash</span><br><span class="line">$ cat /etc/hosts</span><br></pre></td></tr></table></figure><p>可以在 web 容器中安装 <strong>ping 命令</strong>，来测试跟 db 容器的连通：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install -yqq inetutils-ping</span><br><span class="line">$ ping db</span><br></pre></td></tr></table></figure><blockquote><p>用户可以连接多个子容器到父容器，比如可以连接多个 web 到同一个 db 容器上。</p></blockquote><p>在生产环境中，网络方面的需求更加复杂和多变，包括跨主机甚至跨数据中心的通信，这时候往往就需要引入格外的机制：</p><ul><li>SDN（软件定义网络）</li><li>NFV（网络功能虚拟化）</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 数据管理</title>
      <link href="2019/06/22/Docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/"/>
      <url>2019/06/22/Docker-%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>在生产环境中使用 Docker，往往需要对数据进行<code>持久化</code>，或者需要在多个容器之间进行<code>数据共享</code>，这必然涉及容器的数据管理操作。<br>容器中管理数据主要有两种方式：</p><ul><li>数据卷（Data Volumes）：宿主机目录直接映射进容器。</li><li>数据卷容器（Data Volumes Containers）：使用特定容器维护数据卷。</li></ul><p>通过这些机制，即使容器在运行中出现故障，用户也不必担心数据发生丢失，只需要快速的重新创建容器即可。</p><h2 id="数据卷"><a href="#数据卷" class="headerlink" title="数据卷"></a>数据卷</h2><p><strong>数据卷</strong>是一个可供容器使用的特殊目录，类似于 Linux 中的 <code>mount</code> 行为。</p><blockquote><p>对数据卷的更新不会影响镜像，解耦开应用和数据。</p></blockquote><a id="more"></a><h3 id="创建数据卷"><a href="#创建数据卷" class="headerlink" title="创建数据卷"></a>创建数据卷</h3><p>Docker 提供了 <code>volume</code> 子命令来管理数据卷，如下命令可以快速在本地创建一个数据卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker volume create -d <span class="built_in">local</span> <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>查看创建的数据卷的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ls -l /var/lib/docker/volumes</span><br></pre></td></tr></table></figure><p>除了 create 外，<strong>docker volume</strong> 还支持 inspect、ls、prune、rm 等。</p><h3 id="绑定数据卷"><a href="#绑定数据卷" class="headerlink" title="绑定数据卷"></a>绑定数据卷</h3><p>可以在创建容器时将主机本地的任意路径挂载到容器内作为数据卷，这种形式创建的数据卷称为<strong>绑定数据卷</strong>。<br>在用 docker run 命令的时候，使用 <strong>–mount</strong> 选项，支持三种类型的数据卷：</p><ul><li>volume：普通数据卷，映射到主机 <code>/var/lib/docker/volumes</code> 路径下。</li><li>bind：绑定数据卷，映射到主机<code>指定路径</code>下。</li><li>tmpfs：临时数据卷，只存在于<code>内存</code>中。</li></ul><p>下面使用 /training/webapp 镜像创建一个 Web 容器，并创建一个数据卷挂载到容器的 /opt/webapp 目录：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -P --name web --mount <span class="built_in">type</span>=<span class="built_in">bind</span>, <span class="built_in">source</span>=/webapp, destination=/opt/webapp training/webapp python app.py</span><br></pre></td></tr></table></figure><p>这个功能在进行<code>应用测试</code>的时候十分方便，本地目录的路径必须是绝对路径，容器内路径可以为相对路径。</p><blockquote><p>推荐的方式是：直接挂载文件所在的<code>目录</code>到容器。</p></blockquote><h2 id="数据卷容器"><a href="#数据卷容器" class="headerlink" title="数据卷容器"></a>数据卷容器</h2><p>创建一个数据卷容器 dbdata，并在其中创建一个数据卷挂载到 /dbdata：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it -v /dbdata --name dbdata ubuntu</span><br></pre></td></tr></table></figure><p>可以在其他容器中使用 <code>--volumes-from</code> 来挂载 dbdata 容器中的数据卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it --volumes-from dbdata --name db1 ubuntu</span><br><span class="line">$ docker run -it --volumes-from dbdata --name db2 ubuntu</span><br></pre></td></tr></table></figure><p>三个容器任何一方在该目录下的写入，其他容器都可以看到；可以多次使用 –volumes-from 参数来从多个容器挂载多个数据卷，还可以从其他已经挂载了数据卷的容器来挂载数据卷。</p><blockquote><p>使用 –volumes-from 参数所挂载数据卷的容器自身，并不需要保持在运行状态。</p></blockquote><p>要删除一个数据卷，必须在删除最后一个还挂载着它的容器时，显示使用 docker rm -v 命令来指定同时删除关联的数据卷。</p><h2 id="利用数据卷容器来迁移数据"><a href="#利用数据卷容器来迁移数据" class="headerlink" title="利用数据卷容器来迁移数据"></a>利用数据卷容器来迁移数据</h2><p>可以利用数据卷容器对其中的数据<strong>进行备份、恢复，以实现数据的迁移</strong>。</p><h3 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h3><p>使用下面的命令来备份 <code>dbdata</code> 数据卷容器内的数据卷：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --volumes-from dbdata -v $(<span class="built_in">pwd</span>):/backup busybox tar cvf /backup/backup.tar /dbdata</span><br></pre></td></tr></table></figure><h3 id="恢复"><a href="#恢复" class="headerlink" title="恢复"></a>恢复</h3><p>首先创建一个带有数据卷的容器 <code>dbdata2</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -v /dbdata --name dbdata2 ubuntu /bin/bash</span><br></pre></td></tr></table></figure><p>然后创建另一个临时容器，挂载 dbdata2 的数据卷，并解压备份文件到挂载的数据卷中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm --volumes-from dbdata2 -v $(<span class="built_in">pwd</span>):/backup busybox tar xvf /backup/backup.tar</span><br></pre></td></tr></table></figure><p>通过这些机制，即使容器在运行中出现故障，用户也不必担心数据发生丢失，只需要快速的重新创建容器即可。<br>在生产环境中，除了使用数据卷外：</p><ul><li>定期将主机的本地数据进行备份</li><li>使用支持容错的存储系统，包括 RAID 或分布式文件系统，如 Ceph、GPFS、HDFS 等。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>访问 Docker 仓库</title>
      <link href="2019/06/16/%E8%AE%BF%E9%97%AE-Docker-%E4%BB%93%E5%BA%93/"/>
      <url>2019/06/16/%E8%AE%BF%E9%97%AE-Docker-%E4%BB%93%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<p><strong>仓库</strong>（Repository）是集中维护容器镜像的地方，为 Docker 镜像文件的<code>分发和管理</code>提供了便捷的途径，又分为公共仓库和私有仓库。<br><strong>注册服务器</strong>（Registry）是存放仓库的具体服务器，一个注册服务器可以有多个仓库，而每个仓库下面可以有多个镜像。<br>仓库可以被认为是一个具体的<code>项目或目录</code>，例如对于仓库地址 <code>private-docker.com/ubuntu</code> 来说，<code>private-docker.com</code> 是注册服务器地址，<code>ubuntu</code> 是仓库名。</p><h2 id="Docker-Hub-公共镜像市场"><a href="#Docker-Hub-公共镜像市场" class="headerlink" title="Docker Hub 公共镜像市场"></a>Docker Hub 公共镜像市场</h2><p>Docker Hub 是 Docker 官方提供的最大的公共镜像仓库，目前包括了超过 100, 000 的镜像，地址为 <code>https://hub.docker.com</code>。</p><h3 id="登陆"><a href="#登陆" class="headerlink" title="登陆"></a>登陆</h3><p>可以执行 <strong>docker login</strong> 命令进行登录，登录成功的用户可以 push 个人制作的镜像到 Docker Hub。</p><a id="more"></a><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><p>用户无须登录即可通过 docker search 命令来查找官方仓库中的镜像，并利用 docker pull 命令来将他下载到本地。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Docker/5-1.jpeg" alt><br>根据是否为官方提供，可将这些镜像资源分为两类：</p><ul><li>类似于 centos 这样的基础镜像（根镜像），由 Docker 公司创建、验证、支持、提供，这样的镜像往往使用<code>单个单词</code>作为名字。</li><li>带有用户名称为<code>前缀</code>，表明是某用户下的某仓库。可以通过“user_name/镜像名”，来指定使用某个用户提供的镜像。</li></ul><h3 id="自动创建"><a href="#自动创建" class="headerlink" title="自动创建"></a>自动创建</h3><p><code>自动创建</code>（Automated Builds）是 Docker Hub 提供的自动化服务。允许用户通过 Docker Hub 指定跟踪一个目标网站（GitHub、BitBucket）上的项目，一旦项目发生新的提交，则自动执行创建。</p><h2 id="第三方镜像市场"><a href="#第三方镜像市场" class="headerlink" title="第三方镜像市场"></a>第三方镜像市场</h2><p>国内不少云服务商都提供了 Docker 镜像市场，包括腾讯云、网易云、阿里云等。</p><h3 id="查看镜像"><a href="#查看镜像" class="headerlink" title="查看镜像"></a>查看镜像</h3><p>访问 <code>https://hub.tenxcloud.com</code>，即可看到已存在的仓库和存储的镜像。</p><h3 id="下载镜像"><a href="#下载镜像" class="headerlink" title="下载镜像"></a>下载镜像</h3><p>要在镜像名称前添加注册服务器的具体地址，格式为：<code>index.tenxcloud.com/&lt;namespace&gt;/&lt;repository&gt;:&lt;tag&gt;</code>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull index.tenxcloud.com/docker_library/node:latest</span><br></pre></td></tr></table></figure><p>下载后，可以更新镜像的标签，与官方标签保持一致，方便使用：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag index.tenxcloud.com/docker_library/node:latest node:latest</span><br></pre></td></tr></table></figure><h2 id="搭建本地私有仓库"><a href="#搭建本地私有仓库" class="headerlink" title="搭建本地私有仓库"></a>搭建本地私有仓库</h2><h3 id="使用-registry-镜像创建私有仓库"><a href="#使用-registry-镜像创建私有仓库" class="headerlink" title="使用 registry 镜像创建私有仓库"></a>使用 registry 镜像创建私有仓库</h3><p>可以通过官方提供的 registry 镜像，来简单搭建一套本地私有仓库环境：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 5000:5000 registry:2</span><br></pre></td></tr></table></figure><p>默认情况下，仓库会被创建在容器的 <code>/var/lib/registry</code> 目录下。</p><blockquote><p>还可以使用其他的开源方案（如 nexus），来搭建私有化的容器镜像仓库。</p></blockquote><h3 id="管理私有仓库"><a href="#管理私有仓库" class="headerlink" title="管理私有仓库"></a>管理私有仓库</h3><p>在企业的生产环境中，往往需要使用私有仓库来维护内部镜像。<br>出于安全性的考虑，会要求仓库支持 SSL/TLS 证书。对于内部使用的私有仓库，可以<code>自行配置证书</code>或<code>关闭安全性检查</code>。<br>修改 Docker Daemon 的启动参数（<code>/etc/default/docker</code>），添加如下参数，不进行安全证书检查：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">DOCKER_OPTS</span>=<span class="string">"--insecure-registry 10.0.2.2:5000"</span></span><br></pre></td></tr></table></figure><p>之后再重启 Docker 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure><p>如果要使用安全证书，用户也可以从较知名的 CA 服务商（如 verisign）申请公开的 SSL/TLS 证书，或者使用 OpenSSL 等软件来自行生成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作 Docker 容器</title>
      <link href="2019/06/16/%E6%93%8D%E4%BD%9C-Docker-%E5%AE%B9%E5%99%A8/"/>
      <url>2019/06/16/%E6%93%8D%E4%BD%9C-Docker-%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><strong>容器</strong>是 Docker 的另一个核心概念，容器是镜像的一个运行实例。镜像是静态的只读文件，容器中的应用进程处于运行状态。</p><h2 id="创建容器"><a href="#创建容器" class="headerlink" title="创建容器"></a>创建容器</h2><p>对容器的操作就像<code>直接操作应用</code>一样简单和快速。</p><h3 id="新建容器"><a href="#新建容器" class="headerlink" title="新建容器"></a>新建容器</h3><p>可以使用 <strong>docker create</strong> 命令新建一个容器，新建的容器处于停止状态，可以使用 docker start 命令来启动他。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker create -it ubuntu:latest</span><br></pre></td></tr></table></figure><p>容器是整个 Docker 技术栈的核心，支持的选项十分复杂。主要包括如下几大类：</p><ul><li>与容器运行模式相关</li><li>与容器环境配置相关</li><li>与容器资源限制和安全保护相关</li></ul><a id="more"></a><h3 id="启动容器"><a href="#启动容器" class="headerlink" title="启动容器"></a>启动容器</h3><p>使用 <strong>docker start</strong> 命令来启动一个已经创建的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker start af</span><br></pre></td></tr></table></figure><p>此时，通过 docker ps 命令可以查看到一个运行中的容器。</p><h3 id="新建并启动容器"><a href="#新建并启动容器" class="headerlink" title="新建并启动容器"></a>新建并启动容器</h3><p>也可以直接<code>新建并启动</code>容器，所需要的命令为 <strong>docker run</strong>。等价于先执行 docker create 命令，再执行 docker start 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu:18.04 /bin/bash</span><br></pre></td></tr></table></figure><blockquote><p>对于容器来说，当其中的应用退出后，容器的使命完成，也就没有继续运行的必要了。</p></blockquote><h3 id="守护态运行"><a href="#守护态运行" class="headerlink" title="守护态运行"></a>守护态运行</h3><p>更多的时候，需要让容器在后台以守护态（daemonized）形式运行，可以通过添加 <code>-d</code> 参数来实现。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d ubuntu /bin/bash -c <span class="string">"while true; do echo hello world; sleep 1; done"</span></span><br></pre></td></tr></table></figure><h3 id="查看容器输出"><a href="#查看容器输出" class="headerlink" title="查看容器输出"></a>查看容器输出</h3><p>要获取容器的输出信息，可以通过 <strong>docker logs</strong> 命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker logs ce554267d7a4</span><br></pre></td></tr></table></figure><h2 id="停止容器"><a href="#停止容器" class="headerlink" title="停止容器"></a>停止容器</h2><h3 id="暂停容器"><a href="#暂停容器" class="headerlink" title="暂停容器"></a>暂停容器</h3><p>可以使用 <strong>docker pause</strong> 命令来暂停一个运行中的容器：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name <span class="built_in">test</span> --rm -it ubuntu bash</span><br><span class="line">$ docker pause <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>处于 <code>Paused</code> 状态的容器，可以使用 <strong>docker unpause</strong> 命令来恢复到运行状态。</p><h3 id="终止容器"><a href="#终止容器" class="headerlink" title="终止容器"></a>终止容器</h3><p>可以使用 <strong>docker stop</strong> 来终止一个运行中的容器，该命令会首先向容器发送 SIGTERM 信号，等待一段超时时间后（默认为 10 秒），再发送 SIGKILL 信号来终止容器。<br>还可以通过 <strong>docker kill</strong> 直接发送 SIGKILL 信号来强行终止容器<br>执行 <strong>docker container prune</strong> 命令，会自动清除掉所有处于 <code>Exited</code> 状态的容器。</p><blockquote><p>处于 Exited 状态的容器，可以通过 docker start 命令来重新启动。</p></blockquote><p><strong>docker restart</strong> 命令会将一个运行态的容器先终止，然后再重新启动。</p><h2 id="进入容器"><a href="#进入容器" class="headerlink" title="进入容器"></a>进入容器</h2><p>使用 <code>-d</code> 参数，容器启动后进入后台，用户无法看到其中的信息，也无法进行操作。此时，推荐使用官方的 <strong>attach</strong> 或 <strong>exec</strong> 命令。</p><h3 id="attach-命令"><a href="#attach-命令" class="headerlink" title="attach 命令"></a>attach 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker attach nostalgic_hypatia</span><br></pre></td></tr></table></figure><p>使用 attach 命令有时候并不方便。当多个窗口同时 attach 到同一个容器的时候，所有窗口都会<code>同步显示</code>；当某个窗口因命令阻塞时，其他窗口也无法执行操作了。</p><h3 id="exec-命令"><a href="#exec-命令" class="headerlink" title="exec 命令"></a>exec 命令</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">exec</span> -it 243c32535da7 /bin/bash</span><br></pre></td></tr></table></figure><p>可以在运行中容器内直接执行任意命令。会打开一个新的 bash 终端，在不影响容器内其他应用的前提下，用户可以与容器进行交互。</p><blockquote><p><code>-t</code> 选项让 Docker 分配一个伪终端（pseudo-tty）并绑定到容器的标准输入上；<code>-i</code> 则让容器的标准输入保持打开。通过 exec 命令对容器执行操作是最为推荐的方式。</p></blockquote><h2 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker rm ce554267d7a4</span><br></pre></td></tr></table></figure><p>默认情况下，<strong>docker rm</strong> 命令只能删除已经处于终止或退出状态的容器，并不能删除还处于运行状态的容器。</p><h2 id="导出和导入容器"><a href="#导出和导入容器" class="headerlink" title="导出和导入容器"></a>导出和导入容器</h2><h3 id="导出容器"><a href="#导出容器" class="headerlink" title="导出容器"></a>导出容器</h3><p>导出一个已经创建的容器到一个文件，不管此时这个容器是否处于运行状态，可以使用 <strong>docker export</strong> 命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker <span class="built_in">export</span> e81 &gt; test_for_stop.tar</span><br></pre></td></tr></table></figure><h3 id="导入容器"><a href="#导入容器" class="headerlink" title="导入容器"></a>导入容器</h3><p>导出的文件又可以使用 <strong>docker import</strong> 命令导入变成镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker import test_for_stop.tar <span class="built_in">test</span>/ubuntu:v1.0</span><br></pre></td></tr></table></figure><p>既可以使用 docker load 命令来导入镜像存储文件到本地镜像库，也可以使用 docker import 命令来导入一个容器快照到本地镜像库，两者的区别在于：</p><ul><li>容器快照文件仅保存容器当时的<code>快照状态</code>，而镜像存储文件保存了所有的历史记录和<code>元数据信息</code>。</li><li>从容器快照文件导入时，可以重新指定标签等元数据信息。</li></ul><h2 id="查看容器"><a href="#查看容器" class="headerlink" title="查看容器"></a>查看容器</h2><h3 id="查看容器详情"><a href="#查看容器详情" class="headerlink" title="查看容器详情"></a>查看容器详情</h3><p>查看容器详情可以使用 <strong>docker inspect</strong> 命令，会以 JSON 格式返回包括容器 ID、创建时间、路径、状态、镜像、配置等在内的各项信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="查看容器内进程"><a href="#查看容器内进程" class="headerlink" title="查看容器内进程"></a>查看容器内进程</h3><p>查看容器内进程可以使用 <strong>docker top</strong> 命令，会打印出包括 PID、用户、时间、命令等进程信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker top <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="查看统计信息"><a href="#查看统计信息" class="headerlink" title="查看统计信息"></a>查看统计信息</h3><p>查看统计信息可以使用 <strong>docker stats</strong> 命令，会显示 CPU、内存、存储、网络等使用情况的统计信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker stats</span><br></pre></td></tr></table></figure><h2 id="其他容器命令"><a href="#其他容器命令" class="headerlink" title="其他容器命令"></a>其他容器命令</h2><h3 id="复制文件"><a href="#复制文件" class="headerlink" title="复制文件"></a>复制文件</h3><p><strong>docker cp</strong> 命令支持在容器和主机时间复制文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker cp data <span class="built_in">test</span>:/tmp/</span><br></pre></td></tr></table></figure><h3 id="查看变更"><a href="#查看变更" class="headerlink" title="查看变更"></a>查看变更</h3><p><strong>docker diff</strong> 命令查看容器内文件系统的变更：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker diff <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="查看端口映射"><a href="#查看端口映射" class="headerlink" title="查看端口映射"></a>查看端口映射</h3><p><strong>docker port</strong> 命令可以查看容器的端口映射情况：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker port <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h3 id="更新配置"><a href="#更新配置" class="headerlink" title="更新配置"></a>更新配置</h3><p><strong>docker update</strong> 命令可以更新容器的一些运行时配置，例如，限制总配额为 1 秒，容器 test 所占用时间为 10%：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker update --cpu-quota 1000000 <span class="built_in">test</span></span><br><span class="line">$ docker update --cpu-period 100000 <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>在生产环境中，提高容器的高可用性和安全性：</p><ul><li>合理使用<code>资源限制参数</code>，来管理容器的资源消耗。</li><li>指定合适的<code>容器重启策略</code>，来自动重启退出的容器。</li><li>使用 HAProxy 等辅助工具来<code>处理负载均衡</code>，自动切换故障的应用容器。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用 Docker 镜像</title>
      <link href="2019/06/09/%E4%BD%BF%E7%94%A8-Docker-%E9%95%9C%E5%83%8F/"/>
      <url>2019/06/09/%E4%BD%BF%E7%94%A8-Docker-%E9%95%9C%E5%83%8F/</url>
      
        <content type="html"><![CDATA[<p><strong>镜像</strong>是 Docker 三大核心概念中最重要的。</p><h2 id="获取镜像"><a href="#获取镜像" class="headerlink" title="获取镜像"></a>获取镜像</h2><p>可以使用 <strong>docker pull 命令</strong>直接从 Docker Hub 镜像源来下载镜像，描述一个镜像需要包括“名称+标签”信息（NAME[:TAG]）。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure><blockquote><p>如果不显式指定 TAG，则默认会选择 latest 标签。从稳定性上考虑，不要在生产环境中忽略镜像的标签信息或使用默认的 lastest 标记的镜像。</p></blockquote><p>镜像文件一般由若干层（layer）组成，当不同的镜像包括相同的层时，本地仅存储了层的一份内容，减少了存储空间。<br>如果从非官方的仓库下载镜像，则需要在仓库名称前指定完整的仓库地址：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker pull hub.c.163.com/public/ubuntu:18.04</span><br></pre></td></tr></table></figure><p>下载镜像到本地后，即可随时使用该镜像了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -it ubuntu:18.04 /bin/bash</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="查看镜像信息"><a href="#查看镜像信息" class="headerlink" title="查看镜像信息"></a>查看镜像信息</h2><h3 id="docker-images"><a href="#docker-images" class="headerlink" title="docker images"></a>docker images</h3><p><strong>docker images 命令</strong>可以列出本地主机上已有镜像的基本信息，可以使用该 ID 的前若干个字符组成的<code>可区分串</code>来替代完整的 ID。<br>镜像大小信息只是表示了该镜像的<strong>逻辑体积</strong>大小，实际上由于相同的镜像层本地只会存储一份，物理上占用的存储空间会小于各镜像逻辑体积之和。</p><h3 id="docker-tag"><a href="#docker-tag" class="headerlink" title="docker tag"></a>docker tag</h3><p>为了方便在后续工作中使用特定镜像，还可以使用 <strong>docker tag 命令</strong>来为本地镜像任意添加新的标签。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag ubuntu:latest myubuntu:latest</span><br></pre></td></tr></table></figure><p>ID 完全一致，添加的标签实际上起到了<code>类似链接</code>的作用。</p><h3 id="docker-inspect"><a href="#docker-inspect" class="headerlink" title="docker inspect"></a>docker inspect</h3><p>使用 <strong>docker inspect 命令</strong>可以获取该镜像的详细信息，只要其中一项内容时，可以使用 -f 来指定：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker inspect -f &#123;&#123;<span class="string">".Architecture"</span>&#125;&#125; ubuntu:18.04</span><br></pre></td></tr></table></figure><h3 id="docker-history"><a href="#docker-history" class="headerlink" title="docker history"></a>docker history</h3><p>可以使用 <strong>docker history 命令</strong>列出各层的创建信息。</p><h2 id="搜寻镜像"><a href="#搜寻镜像" class="headerlink" title="搜寻镜像"></a>搜寻镜像</h2><p>使用 <strong>docker search 命令</strong>可以搜索 Docker Hub 官方仓库中的镜像。<br>搜索所有收藏数超过 4 的、关键词包括 tensorflow 的镜像（默认的输出结果将按照星级评价进行排序）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker search --filter=stars=4 tensorflow</span><br></pre></td></tr></table></figure><h2 id="删除和清理镜像"><a href="#删除和清理镜像" class="headerlink" title="删除和清理镜像"></a>删除和清理镜像</h2><h3 id="使用标签删除镜像"><a href="#使用标签删除镜像" class="headerlink" title="使用标签删除镜像"></a>使用标签删除镜像</h3><p>使用 <strong>docker rmi 命令</strong>可以删除镜像。</p><blockquote><p>当同一个镜像拥有多个标签的时候，只是删除了该镜像多个标签中的指定标签而已，并不影响镜像文件。</p></blockquote><p>当镜像只剩下一个标签的时候就要小心了，此时再使用 docker rmi 命令会彻底删除镜像。</p><h3 id="使用-ID-删除镜像"><a href="#使用-ID-删除镜像" class="headerlink" title="使用 ID 删除镜像"></a>使用 ID 删除镜像</h3><blockquote><p>先尝试删除所有指向该镜像的标签，然后删除该镜像文件本身。</p></blockquote><p>当有该镜像创建的容器存在时，镜像文件默认是无法被删除的。正确的做法是，先删除依赖该镜像的所有容器，再来删除镜像。</p><h3 id="清理镜像"><a href="#清理镜像" class="headerlink" title="清理镜像"></a>清理镜像</h3><p>使用 Docker 一段时间后，系统中可能会遗留一些临时的镜像文件，以及一些没有被使用的镜像，可以通过 <strong>docker image prune 命令</strong>来进行清理：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker image prune -f</span><br></pre></td></tr></table></figure><h2 id="创建镜像"><a href="#创建镜像" class="headerlink" title="创建镜像"></a>创建镜像</h2><h3 id="基于已有容器创建"><a href="#基于已有容器创建" class="headerlink" title="基于已有容器创建"></a>基于已有容器创建</h3><p>使用 <strong>docker commit 命令</strong>，主要选项包括：-m：提交消息；-a：作者信息。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker commit -m <span class="string">"add a new file"</span> -a <span class="string">"hyang"</span> a925cb40b3f0 <span class="built_in">test</span>:0.1</span><br></pre></td></tr></table></figure><h3 id="基于本地模版导入"><a href="#基于本地模版导入" class="headerlink" title="基于本地模版导入"></a>基于本地模版导入</h3><p>可以使用 <strong>docker import 命令</strong>，直接从一个操作系统模版文件导入一个镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cat ubuntu-18.04-x86_64-minimal.tar.gz | docker import - ubuntu:18.04</span><br></pre></td></tr></table></figure><h3 id="基于-Dockerfile-创建"><a href="#基于-Dockerfile-创建" class="headerlink" title="基于 Dockerfile 创建"></a>基于 Dockerfile 创建</h3><p>基于 Dockerfile 创建是最常见的方式。Dockerfile 是一个文本文件，利用给定的指令，描述基于某个父镜像创建新镜像的过程。<br>创建的过程可以使用 <strong>docker build 命令</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker build -t python:3</span><br></pre></td></tr></table></figure><h2 id="存出和载入镜像"><a href="#存出和载入镜像" class="headerlink" title="存出和载入镜像"></a>存出和载入镜像</h2><h3 id="存出镜像"><a href="#存出镜像" class="headerlink" title="存出镜像"></a>存出镜像</h3><p>可以使用 <strong>docker save 命令</strong>，导出镜像到指定的文件中：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker save -o ubuntu_18.04.tar ubuntu:18.04</span><br></pre></td></tr></table></figure><h3 id="载入镜像"><a href="#载入镜像" class="headerlink" title="载入镜像"></a>载入镜像</h3><p>可以使用 <strong>docker load 命令</strong>，从指定文件中读入镜像内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker load -i ubuntu_18.04.tar</span><br></pre></td></tr></table></figure><h2 id="上传镜像"><a href="#上传镜像" class="headerlink" title="上传镜像"></a>上传镜像</h2><p>使用 <strong>docker push 命令</strong>默认上传到 Docker Hub 官方仓库（需要登录）。<br>可以先添加新的标签，然后再上传镜像：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker tag <span class="built_in">test</span>:latest hyang/<span class="built_in">test</span>:latest</span><br><span class="line">$ docker push hyang/<span class="built_in">test</span>:latest</span><br></pre></td></tr></table></figure><p>登陆信息会记录到本地 <code>~/.docker</code> 目录下。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>核心概念与安装配置</title>
      <link href="2019/06/08/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
      <url>2019/06/08/%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p><strong>镜像</strong>（image）、<strong>容器</strong>（container）、<strong>仓库</strong>（repository），只有理解了这三个核心概念，才能顺利的理解 Docker 容器的整个生命周期。</p><h2 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h2><h3 id="Docker-镜像"><a href="#Docker-镜像" class="headerlink" title="Docker 镜像"></a>Docker 镜像</h3><p>Docker 镜像类似于虚拟机镜像，可以将他理解为一个只读的模版。<br>通过<code>版本管理</code>和<code>增量的文件系统</code>，Docker 提供了一套十分简单的机制来创建和更新现有的镜像，用户甚至可以从网上下载一个已经做好的应用镜像，并直接使用。</p><h3 id="Docker-容器"><a href="#Docker-容器" class="headerlink" title="Docker 容器"></a>Docker 容器</h3><p>Docker 容器类似于一个轻量级的沙箱，Docker 利用容器来运行和隔离应用。</p><blockquote><p>镜像自身是只读的。容器从镜像启动的时候，会在镜像的最上层创建一个可写层。</p></blockquote><a id="more"></a><h3 id="Docker-仓库"><a href="#Docker-仓库" class="headerlink" title="Docker 仓库"></a>Docker 仓库</h3><p>Docker 仓库类似于代码仓库，是 Docker 集中存放镜像文件的场所。<br>最大的公开仓库是官方提供的 Docker Hub，其中存放着数量庞大的镜像供用户下载。</p><blockquote><p>Docker 利用仓库管理镜像的设计理念与 Git 代码仓库的概念非常相似，实际上 Docker 设计上借鉴了 Git 的很多优秀思想。</p></blockquote><h2 id="安装-Docker-引擎"><a href="#安装-Docker-引擎" class="headerlink" title="安装 Docker 引擎"></a>安装 Docker 引擎</h2><p>Docker 引擎是使用 Docker 容器的核心组件，可以在主流的<code>操作系统</code>和<code>云平台</code>上使用。<br>Docker 引擎分为两个版本：社区版本（Community Edition，CE）和企业版本（Enterprise Edition，EE）。社区版每个月会发布一次尝鲜（Edge）版本，每个季度（3、6、9、12 月）会行一次稳定（Stable）版本。<br>Ubuntu 发行版中，LTS（Long-Term-Support）意味着更稳定的功能和更长期（5 年）的升级支持，生产环境中推荐尽量使用 LTS 版本。<br>推荐实践环境的操作系统是 Debian 稳定版本系统，使用 Linux 4.0 以上内核。</p><blockquote><p>Ubuntu 16.04 代号为 xenial，Ubuntu 18.04 代号为 bionic。</p></blockquote><h2 id="配置-Docker-服务"><a href="#配置-Docker-服务" class="headerlink" title="配置 Docker 服务"></a>配置 Docker 服务</h2><p>为了避免每次使用 Docker 命令时都需要切换到特权身份，可以将当前用户加入安装中自动创建的 <strong>docker 用户组</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker USER_NAME</span><br></pre></td></tr></table></figure><p>Docker 服务启动时实际上是调用了 <strong>dockered 命令</strong>，启动参数选项可以写入 <code>/etc/docker/</code> 路径下的 daemon.json 文件中。<br>Docker 服务的默认配置文件为 <code>/etc/default/docker</code>，可以通过修改其中的 DOCKER_OPTS 来修改服务启动的参数。<br>修改之后，通过 <strong>service 命令</strong>来重启 Docker 服务：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker restart</span><br></pre></td></tr></table></figure><p>在 Ubuntu 或 CentOS 系统上可以执行命令 journalctl -u docker.service 查看 Docker 服务的<strong>日志信息</strong>。<br>每次重启 Docker 服务后，可以通过 <strong>docker info 命令</strong>查看 Docker 信息，确保服务已经正常运行。</p><h2 id="一张图总结-Docker-命令"><a href="#一张图总结-Docker-命令" class="headerlink" title="一张图总结 Docker 命令"></a>一张图总结 Docker 命令</h2><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Docker/2-1.jpg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 Docker 与容器</title>
      <link href="2019/06/07/%E5%88%9D%E8%AF%86-Docker-%E4%B8%8E%E5%AE%B9%E5%99%A8/"/>
      <url>2019/06/07/%E5%88%9D%E8%AF%86-Docker-%E4%B8%8E%E5%AE%B9%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p>从 20 世纪 60 年代 IBM 推出的大型主机虚拟化，到后来以 Xen、KVM 为代表的虚拟机虚拟化，再到现在以 Docker 为代表的容器技术。</p><h2 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h2><h3 id="Docker-开源项目背景"><a href="#Docker-开源项目背景" class="headerlink" title="Docker 开源项目背景"></a>Docker 开源项目背景</h3><p>Docker 是基于 <code>Go 语言</code>实现的开源容器项目。<br>通过对应用的封装（Packaging）、分发（Distribution）、部署（Deployment）、运行（Runtime）生命周期进行管理，达到应用组件级别的<strong>一次封装，到处运行</strong>。</p><h3 id="Linux-容器技术（Linux-Containers，LXC）"><a href="#Linux-容器技术（Linux-Containers，LXC）" class="headerlink" title="Linux 容器技术（Linux Containers，LXC）"></a>Linux 容器技术（Linux Containers，LXC）</h3><p>最早的容器技术可以追溯到 1982 年 Unix 系列操作系统上的 chroot 工具。<br>容器技术有效的将由单个操作系统管理的资源划分到<strong>孤立的组</strong>中，以更好的在孤立的组之间平衡有冲突的资源使用需求。</p><a id="more"></a><h3 id="从-Linux-容器到-Docker"><a href="#从-Linux-容器到-Docker" class="headerlink" title="从 Linux 容器到 Docker"></a>从 Linux 容器到 Docker</h3><p>可以将 Docker 容器理解为一种轻量级的沙盒（sandbox），每个容器内运行着一个应用，不同的容器相互隔离，容器之间也可以通过网络相互通信。</p><blockquote><p>直接把容器当作应用本身也没有任何问题。</p></blockquote><h2 id="为什么要使用-Docker"><a href="#为什么要使用-Docker" class="headerlink" title="为什么要使用 Docker"></a>为什么要使用 Docker</h2><h3 id="Docker-容器虚拟化的好处"><a href="#Docker-容器虚拟化的好处" class="headerlink" title="Docker 容器虚拟化的好处"></a>Docker 容器虚拟化的好处</h3><p>假设用户试图基于最常见的 LAMP（Linux+Apache+MySQL+PHP）组合来构建网站。首先需要<code>安装</code>各自运行所依赖的环境；之后分别对他们进行参数<code>配置</code>；经过大量的操作后，还需要进行功能<code>测试</code>，看是否工作正常；如果不正常，则进行<code>调试</code>追踪，意味着更多的时间代价和不可控的风险。</p><blockquote><p>根源：应用直接运行在底层操作系统上，无法保证同一份应用在不同的环境中行为一致。</p></blockquote><h3 id="Docker-在开发和运维中的优势"><a href="#Docker-在开发和运维中的优势" class="headerlink" title="Docker 在开发和运维中的优势"></a>Docker 在开发和运维中的优势</h3><ul><li>更快速的交付和部署：开发人员可以使用镜像来快速构建一套标准的开发环境；开发完成之后，测试和运维人员可以直接使用完全相同的环境来部署代码。</li><li>更高效的资源利用：运行 Docker 容器不需要额外的虚拟化管理程序（VMM、Hypervisor）的支持。</li><li>更轻松的迁移和扩展：Docker 容器几乎可以在任意的平台上运行。</li><li>更简单的更新管理：使用 Dockerfile，只需要小小的配置修改，就可以替代以往大量的更新工作。</li></ul><h3 id="Docker-与虚拟机比较"><a href="#Docker-与虚拟机比较" class="headerlink" title="Docker 与虚拟机比较"></a>Docker 与虚拟机比较</h3><ul><li>Docker 容器很快，启动和停止可以在秒级实现，这相比传统的虚拟机方式要快的多。</li><li>Docker 容器对系统资源需求很少，一台主机上可以同时运行数千个 Docker 容器。</li><li>Docker 通过类似 Git 设计理念的操作来方便用户获取、分发和更新应用镜像，存储复用，增量更新。</li><li>Docker 通过 Dockerfile 支持灵活的自动化创建和部署机制，以提高工作效率，并标准化流程。</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Docker/1-1.jpeg" alt></p><h2 id="Docker-与虚拟化"><a href="#Docker-与虚拟化" class="headerlink" title="Docker 与虚拟化"></a>Docker 与虚拟化</h2><blockquote><p>虚拟化的核心是对资源的抽象。</p></blockquote><p>可分为基于硬件的虚拟化（不多见）和基于软件的虚拟化。其中，基于软件的虚拟化又可细分为：</p><ul><li>完全虚拟化（full virtualization）：虚拟机模拟完整的底层硬件环境和特权指令的过程。</li><li>准虚拟化（para virtualization）：部分硬件接口以软件的形式提供给客户机操作系统。</li><li>操作系统级虚拟化：内核通过创建多个虚拟的操作系统实例（内核和库），来隔离不同的进程。</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Docker/1-2.jpeg" alt><br>传统方式需要有额外的虚拟机管理应用和虚拟机操作系统层，Docker 直接复用本地主机的操作系统，更加轻量级。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>目标文件里有什么</title>
      <link href="2018/11/16/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88/"/>
      <url>2018/11/16/%E7%9B%AE%E6%A0%87%E6%96%87%E4%BB%B6%E9%87%8C%E6%9C%89%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h2 id="目标文件的格式"><a href="#目标文件的格式" class="headerlink" title="目标文件的格式"></a>目标文件的格式</h2><p>目标文件就是源代码编译后但未进行链接的那些<strong>中间文件</strong>（Windows 的 .obj 和 Linux 的 .o），它跟可执行文件的内容和结构很相似，所以一般跟可执行文件采用同一种格式存储。<br>PC 平台流行的<strong>可执行文件格式</strong>主要是 Windows 下的 PE（Portable Executable）和 Linux 下的 ELF（Executable Linkable Format），它们都是 COFF（Common file format）格式的变种。<br><strong>动态链接库</strong>（DLL，Dynamic Linking Library）（Windows 的 .dll 和 Linux 的 .so）及<strong>静态链接库</strong>（Static Linking Library）（Windows 的 .lib 和 Linux 的 .a）文件也按照可执行文件格式存储。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/3-1.jpeg" alt></p><a id="more"></a><h2 id="目标文件是什么样的"><a href="#目标文件是什么样的" class="headerlink" title="目标文件是什么样的"></a>目标文件是什么样的</h2><p>目标文件中的内容有编译后的机器指令代码、数据，还包括了链接时所需要的一些信息，比如：符号表、调试信息、字符串等。目标文件将这些信息按不同的属性，以<code>段（Segment）</code>的形式存储。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/3-2.jpeg" alt><br>ELF 文件的开头是一个“文件头”，它描述了整个文件的文件属性，包括文件是否可执行、是静态链接还是动态链接及入口地址。<br>执行语句编译成机器代码，保存在 <code>.text</code> 段；已初始化的全局变量和局部静态变量都保存在 <code>.data</code> 段；未初始化的全局变量和局部静态变量一般放在一个叫 <code>.bss</code> 的段里。</p><blockquote><p>.bss 段只是为未初始化的全局变量和局部静态变量预留位置而已，没有内容，在文件中不占据空间。</p></blockquote><p>总体来说，主要分成两种段：</p><ul><li>程序指令：代码段</li><li>程序数据：数据段、.bss 段</li></ul><h3 id="数据和指令分段的好处"><a href="#数据和指令分段的好处" class="headerlink" title="数据和指令分段的好处"></a>数据和指令分段的好处</h3><ul><li>数据区域对于进程来说是可读写的，而指令区域对于进程来说是只读的，将这两个虚存区域的权限分别设置成可读写和只读，可以<strong>防止程序的指令被改写</strong>。</li><li>现代 CPU 的缓存一般都被设计成数据缓存和指令缓存分离，所以程序的指令和数据分开存放对 <strong>CPU 的缓存命中率提高</strong>有好处。</li><li>当系统中运行着多个该程序的副本时，它们的指令都是一样的，只须要保存一份该程序的指令部分，将<strong>节省大量空间</strong>。</li></ul><h2 id="挖掘-SimpleSection-o"><a href="#挖掘-SimpleSection-o" class="headerlink" title="挖掘 SimpleSection.o"></a>挖掘 SimpleSection.o</h2><blockquote><p>真正了不起的程序员对自己的程序的每一个字节都了如指掌。</p></blockquote><p>不了解 ELF 文件的结构细节就像学习了 TCP/IP 网络没有了解 IP 包头的结构一样。<br>参数“-c”表示只编译不链接：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c SimpleSection.c</span><br></pre></td></tr></table></figure><p>“-h”参数就是把 ELF 文件的各个段的基本信息打印出来，也可以使用“objdump -x”把更多的信息打印出来。查看各种目标文件的结构和内容：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -h SimpleSection.o</span><br></pre></td></tr></table></figure><p>其中，最容易理解的是段的长度（Size）和段所在的位置（File Offset），“CONTENTS”表示该段在文件中存在。</p><h3 id="代码段"><a href="#代码段" class="headerlink" title="代码段"></a>代码段</h3><p>“-s”参数可以将所有段的内容以十六进制的方式打印出来，“-d”参数可以将所有包含指令的段<strong>反汇编</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ objdump -s -d SimpleSection.o</span><br></pre></td></tr></table></figure><h3 id="数据段和只读数据段"><a href="#数据段和只读数据段" class="headerlink" title="数据段和只读数据段"></a>数据段和只读数据段</h3><p>.data 段保存的是那些已经<strong>初始化了的全局静态变量和局部静态变量</strong>。<br>.rodata 段存放的是只读数据，一般是程序里面的只读变量（如 const 修饰的变量）和字符串常量，在语义上支持了 C++ 的 const 关键字。<br>CPU 的<strong>字节序</strong>（Byte Order）的问题，也就是所谓的<code>大端（Big-endian）</code>和<code>小端（Little-endian）</code>的问题。在不同的计算机体系结构中，对于数据（比特、字节、字）等的存储和传输机制有所不同，如果达不成一致的规则，计算机的通信与存储将会无法进行。<br>定义两个概念：</p><ul><li><code>MSB</code>是 Most Significant Bit/Byte 的首字母缩写，通常译为最重要的位或最重要的字节。</li><li><code>LSB</code>是 Least Significant Bit/Byte 的首字母缩写，通常译为最不重要的位或最不重要的字节。</li></ul><p>大端和小端的区别就是：大端规定 MSB 在存储时放在低地址，在传输时 MSB 放在流的开始；LSB 存储时放在高地址，在传输时放在流的末尾。小端则与之相反。<br>目前的 TCP/IP 网络及 Java 虚拟机的字节序都是大端的。</p><h3 id="BSS-段"><a href="#BSS-段" class="headerlink" title="BSS 段"></a>BSS 段</h3><p>.bss 段存放的是<strong>未初始化的全局变量和局部静态变量</strong>。<br>变量存放的位置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">static int x1 = 0;</span><br><span class="line">static int x2 = 1;</span><br></pre></td></tr></table></figure><p>x1 会被放在 .bss 中，x2 会被放在 .data 中。x1 为 0，可以认为是未初始化的，因为未初始化的都是 0，所以被优化掉了可以放在 .bss，这样可以节省磁盘空间，因为 .bss 不占磁盘空间。</p><h3 id="其他段"><a href="#其他段" class="headerlink" title="其他段"></a>其他段</h3><p>“.”作为前缀，表示这些段的名字是系统保留的，应用程序也可以使用一些非系统保留的名字作为段名。<br>在全局变量或函数之前加上“_attribute_((section(“name”)))”属性就可以把相应的变量或函数放到以“name”作为段名的段中。</p><h2 id="ELF-文件结构描述"><a href="#ELF-文件结构描述" class="headerlink" title="ELF 文件结构描述"></a>ELF 文件结构描述</h2><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/3-3.jpeg" alt><br>ELF 目标文件格式的最前部是 <strong>ELF 文件头</strong>（ELF Header），它包含了描述整个文件的基本属性，比如：ELF 文件版本、目标机器型号、程序入口地址等。<br>与段有关的重要结构就是<strong>段表</strong>（Section Header Table），该表描述了 ELF 文件包含的所有段的信息，比如每个段的段名、段的长度、在文件中的偏移、读写权限及段的其他属性。</p><h3 id="文件头"><a href="#文件头" class="headerlink" title="文件头"></a>文件头</h3><blockquote><p>我们可以用 readelf -h 命令来详细查看 ELF 文件。</p></blockquote><p>ELF 文件头结构及相关常数被定义在“/usr/include/elf.h”里，“elf.f”使用 <code>typedef</code> 定义了一套自己的变量体系。以 32 版本的头文件结构“Elf32_Ehdr”为例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> e_ident[<span class="number">16</span>];</span><br><span class="line">    Elf32_Half e_type;</span><br><span class="line">    Elf32_Half e_machine;</span><br><span class="line">    Elf32_Word e_version;</span><br><span class="line">    Elf32_Addr e_entry;</span><br><span class="line">    Elf32_Off  e_phoff;</span><br><span class="line">    Elf32_Off  e_shoff;</span><br><span class="line">    Elf32_Word e_flags;</span><br><span class="line">    Elf32_Half e_ehsize;</span><br><span class="line">    Elf32_Half e_phentsize;</span><br><span class="line">    Elf32_Half e_phnum;</span><br><span class="line">    Elf32_Half e_shentsize;</span><br><span class="line">    Elf32_Half e_shnum;</span><br><span class="line">    Elf32_Half e_shstrndx;</span><br><span class="line">&#125; Elf32_Ehdr;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/3-4.jpeg" alt></p><h4 id="ELF-魔数"><a href="#ELF-魔数" class="headerlink" title="ELF 魔数"></a>ELF 魔数</h4><p>对应 <code>e_ident 成员</code>，最开始的 4 个字节是所有 ELF 文件都必须相同的标识码，分别为 0x7F、0x45、0x4c、0x46，第一个字节对应 ASCII 字符里面的 DEL 控制符，后面 3 个字节刚好是 ELF 这 3 个字母的 ASCII 码。</p><blockquote><p>操作系统在加载可执行文件的时候会确认魔数是否正确，如果不正确会拒绝加载。</p></blockquote><h4 id="文件类型"><a href="#文件类型" class="headerlink" title="文件类型"></a>文件类型</h4><p><code>e_type 成员</code>表示 ELF 文件类型，系统通过这个常量来判断 ELF 的 真正文件类型，而不是通过文件的扩展名。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/3-5.jpeg" alt></p><h4 id="机器类型"><a href="#机器类型" class="headerlink" title="机器类型"></a>机器类型</h4><p><code>e_machine 成员</code>表示 ELF 文件的平台属性。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/3-6.jpeg" alt></p><h3 id="段表"><a href="#段表" class="headerlink" title="段表"></a>段表</h3><p>段表是保存这些段的基本属性的结构。段表的结构比较简单，它是一个以“Elf32_Shdr”结构体为元素的数组。数组元素的个数等于段的个数，每个“Elf32_Shdr”结构体对应一个段。<br>“Elf32_Shdr”又被称为<strong>段描述符</strong>（Section Descriptor）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word sh_name;</span><br><span class="line">    Elf32_Word sh_type;</span><br><span class="line">    Elf32_Word sh_flags;</span><br><span class="line">    Elf32_Addr sh_addr;</span><br><span class="line">    Elf32_Off  sh_offset;</span><br><span class="line">    Elf32_Word sh_size;</span><br><span class="line">    Elf32_Word sh_link;</span><br><span class="line">    Elf32_Word sh_info;</span><br><span class="line">    Elf32_Word sh_addralign;</span><br><span class="line">    Elf32_Word sh_entsize;</span><br><span class="line">&#125; Elf32_Shdr;</span><br></pre></td></tr></table></figure><h4 id="段的类型（sh-type）"><a href="#段的类型（sh-type）" class="headerlink" title="段的类型（sh_type）"></a>段的类型（sh_type）</h4><p>段的名字对于编译器、链接器来说是有意义的，但是对于操作系统来说并没有实质的意义。一个段该如何处理取决于它的属性和权限，即由段的类型（sh_type）和段的标志位（sh_flags）这两个成员决定。</p><h4 id="段的标志位（sh-flags）"><a href="#段的标志位（sh-flags）" class="headerlink" title="段的标志位（sh_flags）"></a>段的标志位（sh_flags）</h4><p>表示该段在进程虚拟地址空间中的<code>属性</code>，比如是否可写，是否可执行等。</p><h4 id="段的链接信息（sh-link、sh-info）"><a href="#段的链接信息（sh-link、sh-info）" class="headerlink" title="段的链接信息（sh_link、sh_info）"></a>段的链接信息（sh_link、sh_info）</h4><p>段的类型是与链接相关的（不论动态链接或静态链接），比如重定位表、符号表等。</p><h3 id="重定位表"><a href="#重定位表" class="headerlink" title="重定位表"></a>重定位表</h3><p>重定位的信息都记录在 ELF 文件的重定位表里面，对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。<br>一个重定位表同时也是 ELF 的一个段，它的“sh_link”表示符号表的下标，它的“sh_info”表示它作用于哪个段。</p><h3 id="字符串表"><a href="#字符串表" class="headerlink" title="字符串表"></a>字符串表</h3><p>ELF 文件中用到了很多字符串，比如段名、变量名等。一种常见的做法是，把字符串集中起来存放到一个表，然后使用字符串在表中的<code>偏移</code>来引用字符串。<br>引用字符串只须给出一个数字下标即可，不用考虑字符串长度的问题。<strong>字符串表</strong>用来保存普通的字符串，比如符号的名字；<strong>段表字符串表</strong>用来保存段表中用到的字符串，最常见的就是段名（sh_name）。</p><blockquote><p>只要分析 ELF 文件头，就可以得到段表和段表字符串表的位置，从而解析整个 ELF 文件。</p></blockquote><h2 id="链接的接口——符号"><a href="#链接的接口——符号" class="headerlink" title="链接的接口——符号"></a>链接的接口——符号</h2><p>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。<br>比如：目标文件 B 要用到目标文件 A 中的函数“foo”，那么我们就称目标文件 A <code>定义</code>（Define）了函数“foo”，称目标文件 B <code>引用</code>（Reference）了目标文件 A 中的函数“foo”。<br>函数和变量统称为<strong>符号</strong>（Symbol），函数名或变量名就是<strong>符号名</strong>（Symbol Name）。<br>链接过程中很关键的一部分就是符号的管理，每一个目标文件都会有一个相应的<strong>符号表</strong>（Symbol Table），每个定义的符号有一个相应的值，叫做<strong>符号值</strong>（Symbol Value）。对于变量和函数来说，符号值就是它们的地址。</p><ul><li>定义在本目标文件的<code>全局符号</code>，可以被其他目标文件引用。</li><li>在本目标文件中引用的全局符号，却没有定义在本目标文件，这一般叫做<code>外部符号</code>，也就是我们前面所讲的符号引用。</li></ul><p>链接过程<strong>只关心全局符号</strong>的相互“粘合”，局部符号、段名、行号等都是次要的，它们对于其他目标文件来说是“不可见”的，在链接过程中也是无关紧要的。使用<code>nm</code>命令可以查看符号表。</p><h3 id="ELF-符号表结构"><a href="#ELF-符号表结构" class="headerlink" title="ELF 符号表结构"></a>ELF 符号表结构</h3><p>符号表的结构很简单，它是一个 Elf32_Sym 结构的数组，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    Elf32_Word st_name;</span><br><span class="line">    Elf32_Addr st_value;</span><br><span class="line">    Elf32_Word st_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_info;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> st_other;</span><br><span class="line">    Elf32_Half st_shndx;</span><br><span class="line">&#125; Elf32_Sym;</span><br></pre></td></tr></table></figure><h4 id="符号类型和绑定信息（st-info）"><a href="#符号类型和绑定信息（st-info）" class="headerlink" title="符号类型和绑定信息（st_info）"></a>符号类型和绑定信息（st_info）</h4><p>该成员低 4 位表示符号的类型（Symbol Type），高 28 位表示符号绑定信息（Symbol Binding）。</p><h4 id="符号所在段（st-shndx）"><a href="#符号所在段（st-shndx）" class="headerlink" title="符号所在段（st_shndx）"></a>符号所在段（st_shndx）</h4><p>如果符号定义在本目标文件中，那么这个成员表示符号所在的段在段表中的下标。</p><h4 id="符号值（st-value）"><a href="#符号值（st-value）" class="headerlink" title="符号值（st_value）"></a>符号值（st_value）</h4><p><code>readelf -s</code>的输出格式更为清晰，与上面描述的 Elf32_Sym 的各个成员几乎一一对应。</p><h3 id="特殊符号"><a href="#特殊符号" class="headerlink" title="特殊符号"></a>特殊符号</h3><p>当我们使用 ld 作为链接器来链接生产可执行文件时，它会为我们定义很多特殊的符号，这些符号并没有在你的程序中定义，但是你可以直接声明并且引用它，我们称之为<strong>特殊符号</strong>。它们跟 ld 的链接脚本有关。</p><h3 id="符号修饰与函数签名"><a href="#符号修饰与函数签名" class="headerlink" title="符号修饰与函数签名"></a>符号修饰与函数签名</h3><p>像 C++ 这样后来设计的语言，增加了<strong>名称空间</strong>（Namespace）的方法解决多模块的符号冲突问题。</p><h4 id="C-符号修饰"><a href="#C-符号修饰" class="headerlink" title="C++ 符号修饰"></a>C++ 符号修饰</h4><p>强大而又复杂的 C++ 拥有类、继承、虚机制、重载、名称空间等这些特性，它们使得符号管理更为复杂。<br>为了支持 C++ 这些复杂的特性，人们发明了<strong>符号修饰</strong>（Name Decoration）或<strong>符号改编</strong>（Name Mangling）的机制。<br><code>函数签名</code>（Function Signature）包含了一个函数的信息，包括函数名、它的参数类型、它所在的类和名称空间及其他信息。函数的名字只是函数签名的一部分。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/3-7.jpeg" alt><br>每个函数签名对应一个修饰后名称（Decorated Name），C++ 的源代码编译后的目标文件中所使用的符号名是相应的函数和变量的修饰后名称。参照 <strong>GNU C++</strong> 的名称修饰标准，binutils 里面提供了一个叫<code>c++filt</code>的工具。<br>C++ 中的全局变量和静态变量也同样具有签名和名称修饰机制。变量的类型并没有被加入到修饰后名称中。<strong>Visual C++</strong> 的名称修饰规则并没有对外公开，Microsoft 提供了一个 UnDecorateSymbolName() 的 API，可以将修饰后名称转换成函数签名。</p><h3 id="extern-“C”"><a href="#extern-“C”" class="headerlink" title="extern “C”"></a>extern “C”</h3><p>C++ 为了与 C 兼容，在符号的管理上，有一个用来声明或定义一个 C 的符号的 <code>extern &quot;C&quot;</code> 关键字。<br>为了兼容 C 语言和 C++ 语言定义两套头文件，未免过于麻烦。我们可以使用条件宏来判断当前编译单元是不是 C++ 代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">memset</span> <span class="params">(<span class="keyword">void</span> *, <span class="keyword">int</span>, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>如果当前编译单元是 C++ 代码，那么 memset 会在 extern “C” 里面被声明；如果是 C 代码，就直接声明。</p><h3 id="弱符号与强符号"><a href="#弱符号与强符号" class="headerlink" title="弱符号与强符号"></a>弱符号与强符号</h3><blockquote><p>强符号和弱符号都是针对<strong>定义</strong>来说的，不是针对符号的引用。</p></blockquote><p>编译器默认函数和初始化了的全局变量为<code>强符号</code>（Strong Symbol），未初始化的全局变量为<code>弱符号</code>（Weak Symbol）。我们可以通过 GCC 的“__attribute__((weak))”来定义任何一个强符号为弱符号。<br>一些规则：</p><ul><li>不允许强符号被多次定义（即不同的目标文件中不能有同名的强符号）；如果有多个强符号定义，则链接器报符号重复定义错误。</li><li>如果一个符号在某个目标文件中是强符号，在其他文件中都是弱符号，那么选择强符号。</li><li>如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个。</li></ul><h4 id="弱引用和强引用"><a href="#弱引用和强引用" class="headerlink" title="弱引用和强引用"></a>弱引用和强引用</h4><p>链接器处理强引用（Strong Reference）和弱引用（Weak Reference）的过程几乎一样，只是对于未定义的弱引用，链接器不认为它是一个错误。可以通过使用“__attribute__((weakref))”这个扩展关键字来声明对一个外部函数的引用为弱引用。<br>库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以<strong>使用自定义版本的库函数</strong>。程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用；如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的<strong>功能更加容易裁剪和组合</strong>。</p><h2 id="调试信息"><a href="#调试信息" class="headerlink" title="调试信息"></a>调试信息</h2><p>设置断点、单步调试的前提是编译器必须提前将<strong>源代码与目标代码之间的关系</strong>等，比如目标代码中的地址对应源代码中的哪一行、函数和变量的类型、结构体的定义、字符串保存到目标文件里面。<br>在 GCC 编译时加上“-g”参数，编译器就会在产生的目标文件里面加上调试信息。我们通过<code>readelf</code>等工具可以看到，目标文件多了很多“debug”相关的段。<br>现在的 ELF 文件采用一个叫 <strong>DWARF</strong>（Debug With Arbitrary Record Formats）的标准的调试信息格式。在 Linux 下，我们可以使用 <code>strip</code> 命令来去掉 ELF 文件中的调试信息。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DevPrepares </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编译和链接</title>
      <link href="2018/11/14/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/"/>
      <url>2018/11/14/%E7%BC%96%E8%AF%91%E5%92%8C%E9%93%BE%E6%8E%A5/</url>
      
        <content type="html"><![CDATA[<p>集成开发环境（IDE）一般都将编译和链接的过程一步完成，将这种编译和链接合并到一起的过程称为<code>构建（Build）</code>。<br>我们看到的是这些问题的现象，但是却很难看清本质，所有这些问题的本质就是软件运行背后的机理及支撑软件运行的各种平台和工具。</p><h2 id="被隐藏了的过程"><a href="#被隐藏了的过程" class="headerlink" title="被隐藏了的过程"></a>被隐藏了的过程</h2><p>分解为 4 个步骤，分别是：<strong>预处理</strong>（Preprocessing）、<strong>编译</strong>（Compilation）、<strong>汇编</strong>（Assembly）和<strong>链接</strong>（Linking）。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/2-1.jpeg" alt></p><a id="more"></a><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E hello.c -o hello.i</span><br></pre></td></tr></table></figure><p>经过预处理后的 *.i 文件不包含任何宏定义，因为所有的宏已经被展开，并且包含的文件也已经被插入到 *.i 文件中。<br>当我们无法判断宏定义是否正确或头文件包含是否正确时，可以查看预编译后的文件来确定问题。</p><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译过程就是把预处理完的文件进行一系列的词法分析、语法分析、语义分析及优化后生成相应的汇编代码文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S hello.i -o hello.s</span><br></pre></td></tr></table></figure><p>现在版本的 GCC 把预编译和编译两个步骤合并成一个步骤，实际上 <code>gcc 命令</code>只是这些后台程序的包装，它会根据<strong>不同参数</strong>去调用编译器 cc1、汇编器 as、链接器 ld。</p><h3 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h3><p>汇编器是将汇编代码转变成机器可以执行的指令，每一个汇编语句几乎对应一条机器指令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ as hello.s -o hello.o</span><br></pre></td></tr></table></figure><h3 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h3><p>要将一大堆文件链接起来才可以得到“a.out”，即最终的可执行文件。</p><h2 id="编译器做了什么"><a href="#编译器做了什么" class="headerlink" title="编译器做了什么"></a>编译器做了什么</h2><p>编译器就是将高级语言翻译成机器语言的一个工具。高级编程语言的出现使得程序开发的效率大大提高，高级语言的可移植性也使得它在多种计算机平台下能够游刃有余。<br>编译过程一般可以分为 6 步：词法分析、语法分析、语义分析、源代码优化、代码生成和目标代码优化，即从<strong>源代码</strong>（Source Code）到<strong>最终目标代码</strong>（Final Target Code）的过程。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/2-2.jpeg" alt></p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>源代码程序被输入到<strong>扫描器</strong>（Scanner），简单地进行词法分析，运用一种类似于<strong>有限状态机</strong>（Finite State Machine）的算法可以很轻松地将源代码的字符序列分割成一系列的<strong>记号</strong>（Token）。<br>在识别记号的同时，扫描器也完成了其他工作。比如将标识符存放到符号表，将数字、字符串常量存放到文字表等，以备后面的步骤使用。<br>使用 <code>lex 工具</code>，无须为每个编译器开发一个独立的词法扫描器，而是根据需要改变词法规则就可以了。</p><h3 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h3><p><strong>语法分析器</strong>（Grammar Parser）将对由扫描器产生的记号进行语法分析，从而产生<strong>语法树</strong>（Syntax Tree）。整个分析过程采用了<strong>上下文无关语法</strong>（Context-free Grammar）。<br>简单地讲，由语法分析器生成的语法树就是以<strong>表达式</strong>（Expression）为节点的树。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/2-3.jpeg" alt><br>使用 <code>yacc 工具</code>，只须改变语法规则，而无须为每个编译器编写一个语法分析器。所以它又被称为“编译器编译器（Compiler Compiler）”。</p><h3 id="语义分析"><a href="#语义分析" class="headerlink" title="语义分析"></a>语义分析</h3><p>语义分析由<strong>语义分析器</strong>（Semantic Analyzer）来完成，语法分析仅仅是完成了对表达式的语法层面的分析，但是它并不了解这个语句是否真正有意义。<br>编译器所能分析的语义是<strong>静态语义</strong>（Static Semantic），所谓静态语义是指在编译期可以确定的语义，与之对应的<strong>动态语义</strong>（Dynamic Semantic）就是只有在运行期才能确定的语义。<br>经过语义分析阶段以后，整个语法树的表达式都被标识了类型。</p><h3 id="中间语言生成"><a href="#中间语言生成" class="headerlink" title="中间语言生成"></a>中间语言生成</h3><p><strong>源码级优化器</strong>（Source Code Optimizer）在不同编译器中可能会有不同的定义或有一些其他的差异。所以，源代码优化器往往将整个语法树转换成<strong>中间代码</strong>（Intermediate Code），它是语法树的顺序表示，已经非常接近目标代码了。<br><code>编译器前端</code>负责产生机器无关的中间代码，<code>编译器后端</code>将中间代码转换成目标机器代码。这样对于一些可以跨平台的编译器而言，它们可以针对不同的平台使用同一个前端和数个后端。<br>中间代码比较常见的形式有：<strong>三地址码</strong>（Three-address Code）和 <strong>P-代码</strong>（P-Code）。</p><h3 id="目标代码生成与优化"><a href="#目标代码生成与优化" class="headerlink" title="目标代码生成与优化"></a>目标代码生成与优化</h3><p>编译器后端主要包括<strong>代码生成器</strong>（Code Generator）和<strong>目标代码优化器</strong>（Target Code Optimizer）。代码生成器将中间代码转换成目标机器码，目标代码优化器对上述的目标代码进行优化。<br>事实上，定义在其他模块的全局变量和函数在最终运行时的绝对地址，都要在最终链接的时候才能确定。现代的编译器可以将一个源代码文件编译成一个<strong>未链接的</strong>目标文件，然后由链接器最终将这些目标文件链接起来形成可执行文件。</p><h2 id="链接器年龄比编译器长"><a href="#链接器年龄比编译器长" class="headerlink" title="链接器年龄比编译器长"></a>链接器年龄比编译器长</h2><p>汇编语言使用接近人类的各种符号和标记来帮助记忆。<code>符号（Symbol）</code>这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可能是一段子程序（后来发展成<strong>函数</strong>）的起始地址，也可以是一个<strong>变量</strong>的起始地址。<br>在比较高级的语言中，如 Java 中，每个类是一个基本的模块，若干个模块组成一个<strong>包</strong>（Package），若干个包组合成一个程序。<br>模块之间如何组合的问题可以归结为模块之间如何通信的问题，最常见的通信有两种方式：</p><ul><li>模块间的函数调用</li><li>模块间的变量访问</li></ul><p>这两种方式可以归结为一种方式，即模块间符号的引用。<br>基于符号的模块化的一个直接结果是：<code>链接（Linking）</code>过程在整个程序开发中变得十分重要和突出。</p><h2 id="模块拼装——静态链接"><a href="#模块拼装——静态链接" class="headerlink" title="模块拼装——静态链接"></a>模块拼装——静态链接</h2><p>链接的主要内容就是把各个模块之间相互引用的部分都处理好，使得各个模块之间能够正确地衔接。链接过程主要包括了<strong>地址和空间分配</strong>（Address and Storage Allocation）、<strong>符号决议</strong>（Symbol Resolution）和<strong>重定位</strong>（Relocation）等这些步骤。<br>目标文件和<strong>库</strong>（Library）一起链接形成最终可执行文件，库其实是一组目标文件的包。最常见的库就是<strong>运行时库</strong>（Runtime Library），它是支持程序运行的基本函数的集合。<br>地址修正的过程也被叫做重定位，每个要被修正的地方叫一个<strong>重定位入口</strong>（Relocation Entry）。重定位所做的就是给程序中每个这样的绝对地址引用的位置“打补丁”，使它们指向正确的地址。</p>]]></content>
      
      
      
        <tags>
            
            <tag> DevPrepares </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>温故而知新</title>
      <link href="2018/11/11/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/"/>
      <url>2018/11/11/%E6%B8%A9%E6%95%85%E8%80%8C%E7%9F%A5%E6%96%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="从-Hello-World-说起"><a href="#从-Hello-World-说起" class="headerlink" title="从 Hello World 说起"></a>从 Hello World 说起</h2><p>很多问题看似很简单，但实际上我们并没有一个非常清晰的思路；或者在我们脑海里有着模糊的印象，但真正到某些细节的时候可能又模糊不清了。<br>从基本的编译、静态链接到操作系统如何装载程序、动态链接及运行库和标准库的实现，甚至一些操作系统的机制，力争深入浅出地将这些问题层层剥开，最终使得这些程序运行背后的机制形成一个<strong>非常清晰而流畅的脉络</strong>。</p><h2 id="万变不离其宗"><a href="#万变不离其宗" class="headerlink" title="万变不离其宗"></a>万变不离其宗</h2><p>将计算机的范围限定在：采用兼容 x86 指令集的 32 位 CPU 的个人计算机。</p><ul><li>系统程序开发者：多如牛毛的硬件设备中，三个部件最为关键：CPU、内存和 I/O 控制芯片。</li><li>普通应用程序开发者：关心 CPU，其他的硬件细节基本不用关心。</li><li>高级平台开发者：连 CPU 都不需要关心，平台（Java、.NET 等）提供了一个通用的抽象的计算机。</li></ul><a id="more"></a><p>早期的计算机没有很复杂的图形功能，CPU 的核心频率不高，跟内存的频率一样，直接连接在同一个<code>总线（Bus）</code>上。为了能够让 CPU 能够和 I/O 设备进行通信，每个设备都会有一个相应的 I/O 控制器。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-1.jpeg" alt><br>为了协调 CPU、内存和高速的图像设备，专门设计了一个高速的<strong>北桥芯片</strong>（Northbridge），以便它们之间能够高速地交换数据。为了避免设计的复杂，又设计了专门处理低速设备的<strong>南桥芯片</strong>（Southbridge）。系统总线上采用的是 PCI 结构，低速设备上采用的是 ISA 总线。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-2.jpeg" alt></p><h3 id="SMP-与多核"><a href="#SMP-与多核" class="headerlink" title="SMP 与多核"></a>SMP 与多核</h3><p>CPU 的频率被 4GHz 的“天花板”所限制，人们开始想办法从另外一个角度来提高 CPU 的速度，就是增加 CPU 的数量。最常见的一种形式就是<strong>对称多处理器</strong>（SMP，Symmertical Multi-Processing），理想情况下，速度的提高与 CPU 的数量成正比。实际上并非如此，因为程序并不能分解成若干个完全不相干的子问题，当然很多时候多处理器是非常有用的，比如：在大型数据库、网络服务器上，同时处理大量的相互独立的请求。<br>“被打包”的处理器之间共享比较昂贵的缓存部件，只保留多个核心，这就是<strong>多核处理器</strong>（Multi-core Processor）的基本想法。</p><h2 id="站得高，望得远"><a href="#站得高，望得远" class="headerlink" title="站得高，望得远"></a>站得高，望得远</h2><blockquote><p>计算机科学领域的任何问题都可以通过增加一个间接的中间层来解决。</p></blockquote><p>用于管理计算机本身的软件称为<code>系统软件</code>。</p><ul><li>平台性的：操作系统内核、驱动程序、运行库和数以千计的系统工具。</li><li>用于程序开发的：编译器、汇编器、链接器等开发工具和开发库。</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-3.jpeg" alt><br>每个层次之间都须要相互通信，通信的协议称为<code>接口（Interface）</code>，接口的下面那层是接口的提供者，由它定义接口；接口的上面那层是接口的使用者，它使用该接口来实现所需要的功能。<br>开发工具与应用程序是属于同一层次的，都使用<strong>应用程序编程接口</strong>（Application Programming Interface），运行库使用操作系统提供的<strong>系统调用接口</strong>（System call Interface），系统调用接口实现中往往以<strong>软件中断</strong>（Software Interrupt）的方式提供。硬件的接口被叫做<strong>硬件规格</strong>（Hardware Specification），决定了驱动程序如何操作硬件，如何与硬件进行通信。</p><h2 id="操作系统做什么"><a href="#操作系统做什么" class="headerlink" title="操作系统做什么"></a>操作系统做什么</h2><ul><li>提供抽象的接口。</li><li>管理硬件资源：CPU、存储器（内存和磁盘）和 I/O 设备。</li></ul><h3 id="不要让-CPU-打盹"><a href="#不要让-CPU-打盹" class="headerlink" title="不要让 CPU 打盹"></a>不要让 CPU 打盹</h3><p>当某个程序暂时无须使用 CPU 时，监控程序就把另外的正在等待 CPU 资源的程序启动，使得 CPU 能够充分地利用起来。这种被称为<strong>多道程序</strong>（Multiprogramming）的方法看似很原始，但是它当时的确大大提高了 CPU 的利用率。<br>每个程序运行一段时间以后都主动让出 CPU 给其他程序，使得一段时间内每个程序都有机会运行一小段时间。这种程序协作模式叫做<strong>分时系统</strong>（Time-Sharing System），完整的操作系统雏形已经逐渐形成了。<br><strong>多任务系统</strong>（Multi-tasking），操作系统接管了所有的硬件资源，并且本身运行在一个受硬件保护的级别，所有的应用程序都以<code>进程（Process）</code>的方式运行在比操作系统权限更低的级别，进程之间的地址空间相互隔离。CPU 的分配方式采用<code>抢占式（Preemptive）</code>，在多个进程间快速地切换，造成了很多进程都在同时运行的假象。</p><h3 id="设备驱动"><a href="#设备驱动" class="headerlink" title="设备驱动"></a>设备驱动</h3><p>繁琐的硬件细节全都交给了操作系统，具体地讲是操作系统中的<strong>硬件驱动程序</strong>（Device Driver）来完成，驱动程序往往跟操作系统内核一起运行在特权级。<br>现代的硬盘普遍使用一种叫做 LBA（Logical Block Address）的方式，当我们给出一个逻辑的扇区号时，硬盘的电子设备会将其转换成实际的盘面、磁道等位置。</p><h2 id="内存不够怎么办"><a href="#内存不够怎么办" class="headerlink" title="内存不够怎么办"></a>内存不够怎么办</h2><p>进程的总体目标是希望每个进程从逻辑上来看都可以独占计算机的资源，那么很明显的一个问题是：<strong>如何将计算机上有限的物理内存分配给多个程序使用</strong>。</p><ul><li>地址空间不隔离：很容易改写其他程序的内存数据。</li><li>内存使用效率低：有大量的数据在换入换出，导致效率十分低下。</li><li>程序运行的地址不确定：程序每次需要装入运行时，空闲区域的位置是不确定的。</li></ul><p>解决这几个问题的思路：增加中间层。我们把程序给出的地址看作是一种<strong>虚拟地址</strong>（Virtual Address），然后通过某些映射的方法，将这个虚拟地址转换成实际的物理地址。</p><h3 id="关于隔离"><a href="#关于隔离" class="headerlink" title="关于隔离"></a>关于隔离</h3><p>地址空间分两种：</p><ul><li>虚拟地址空间（Virtual Address Space）</li><li>物理地址空间（Physical Address Space）</li></ul><p>每个进程都有自己独立的虚拟空间，只能访问自己的地址空间，这样就有效地做到了进程的隔离。</p><h3 id="分段（Segmentation）"><a href="#分段（Segmentation）" class="headerlink" title="分段（Segmentation）"></a>分段（Segmentation）</h3><p>分段的方法还是没有解决我们的第二个问题，即内存使用效率的问题。这种方法还是显得粗糙，粒度比较大。</p><h3 id="分页（Paging）"><a href="#分页（Paging）" class="headerlink" title="分页（Paging）"></a>分页（Paging）</h3><p>分页的基本方法是把地址空间人为地等分成固定大小的页，由操作系统选择决定页的大小。<br>在这里，我们把虚拟空间的页就叫<strong>虚拟页</strong>（VP，Virtual Page），把物理内存中的页叫做<strong>物理页</strong>（PP，Physical Page），把磁盘中的页叫做<strong>磁盘页</strong>（DP，Disk Page）。虚拟空间的页被映射到同一个物理页，这样就可以实现内存共享。<br>虚拟存储的实现需要依靠硬件的支持，采用一个叫 <strong>MMU</strong>（Memory Management Unit）的部件来进行页映射。一般 MMU 都集成在 CPU 内部，不会以独立的部件存在。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-4.jpeg" alt></p><h2 id="众人拾柴火焰高"><a href="#众人拾柴火焰高" class="headerlink" title="众人拾柴火焰高"></a>众人拾柴火焰高</h2><h3 id="线程基础"><a href="#线程基础" class="headerlink" title="线程基础"></a>线程基础</h3><p>线程的概念、线程的调度、线程安全、用户线程与内核线程之间的映射关系。</p><h4 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h4><p><code>线程（Thread）</code>有时候被称为<strong>轻量级进程</strong>（Lightweight Process，LWP），是程序执行流的最小单元。<br>一个标准的线程由线程 ID、当前指令指针（PC）、寄存器集合和堆栈组成。对于多进程应用，多线程在数据共享方面效率要高很多。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-5.jpeg" alt></p><h4 id="线程的访问权限"><a href="#线程的访问权限" class="headerlink" title="线程的访问权限"></a>线程的访问权限</h4><p>线程也拥有自己的私有存储空间。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-6.jpeg" alt></p><h4 id="线程调度与优先级"><a href="#线程调度与优先级" class="headerlink" title="线程调度与优先级"></a>线程调度与优先级</h4><p>当线程数量 &lt;= 处理器数量时，线程的并发是真正的并发。在单处理器对应多线程的情况下，并发是一种模拟出来的状态。<br>如果在时间片用尽之前进程就开始等待某事件，那么它将进入等待状态。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-7.jpeg" alt><br>现在主流的调度方式不尽相同，但都带有<strong>优先级调度</strong>（Priority Schedule）和<strong>轮转法</strong>（Round Robin）的痕迹。<br>IO 密集型线程（IO Bound Thread）总是比 CPU 密集型线程容易得到优先级的提升。<br>为了避免<strong>饿死</strong>（Starvation）现象，调度系统常常会逐步提升那些等待了过长时间的得不到执行的线程的优先级。<br>线程的优先级改变一般有三种方式：</p><ul><li>用户指定优先级。</li><li>根据进入等待状态的频繁程度提升或降低优先级。</li><li>长时间得不到执行而被提升优先级。</li></ul><h4 id="可抢占线程和不可抢占线程"><a href="#可抢占线程和不可抢占线程" class="headerlink" title="可抢占线程和不可抢占线程"></a>可抢占线程和不可抢占线程</h4><p>不可<strong>抢占</strong>（Preemption）线程的线程调度的时机是确定的，只会发生在线程主动放弃执行或线程等待某事件的时候。</p><h4 id="Linux-的多线程"><a href="#Linux-的多线程" class="headerlink" title="Linux 的多线程"></a>Linux 的多线程</h4><p>Linux 将所有的执行实体（进程、线程）都称为<strong>任务</strong>（Task）。实际意义上，共享了同一个内存空间的多个任务构成了一个进程，这些任务也就成了这个进程里的线程。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-8.jpeg" alt><br>fork 和 exec 通常用于产生新任务，而如果要产生新线程，则可以使用 clone。</p><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><p>多线程程序在并发时，数据的一致性变得非常重要。</p><h4 id="竞争与原子操作"><a href="#竞争与原子操作" class="headerlink" title="竞争与原子操作"></a>竞争与原子操作</h4><p>把单指令的操作称为<strong>原子的</strong>（Atomic），单条指令的执行是不会被打断的。要保证一个复杂的数据结构更改的原子性，原子操作指令就力不从心了，需要更加通用的手段：<code>锁（Lock）</code>。</p><h4 id="同步与锁"><a href="#同步与锁" class="headerlink" title="同步与锁"></a>同步与锁</h4><p>所谓<strong>同步</strong>（Synchronization），即指在一个线程访问数据未结束的时候，其他线程不得对同一个数据进行访问。<br>同步的最常见方法是使用锁，每一个线程在访问数据或资源之前首先试图<strong>获取</strong>（Acquire）锁，并在访问结束之后<strong>释放</strong>（Release）锁。<br><strong>二元信号量</strong>（Binary Semaphore）是最简单的一种锁，它只有两种状态：占用与非占用。<br>多元信号量简称<strong>信号量</strong>（Semaphore），一个初始值为 N 的信号量允许 N 个线程并发访问。<br>信号量在整个系统可以被任意线程获取并释放，而<strong>互斥量</strong>（Mutex）则要求哪个线程获取了互斥量，哪个线程就要负责释放这个锁。<br><strong>临界区</strong>（Critical Section）是比互斥量更加严格的同步手段。互斥量和信号量在系统的任何进程里都是可见的，而临界区的作用范围仅限于本进程，其他的进程无法获取该锁。<br><strong>读写锁</strong>（Read-Write Lock）致力于一种更加特定的场合的同步，信号量、互斥量或临界区对于读取频繁，而仅仅偶尔写入的情况，会显得非常低效。读写锁有两种获取方式：共享的（Shared）或独占的（Exclusive）。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-9.jpeg" alt><br><strong>条件变量</strong>（Condition Variable）可以让许多线程一起等待某个事件的发生，当事件发生时（条件变量被唤醒），所有的线程可以一起恢复执行。<br>线程可以有两种操作：</p><ul><li>等待条件变量</li><li>唤醒条件变量</li></ul><h4 id="可重入（Reentrant）与线程安全"><a href="#可重入（Reentrant）与线程安全" class="headerlink" title="可重入（Reentrant）与线程安全"></a>可重入（Reentrant）与线程安全</h4><blockquote><p>可重入是并发安全的强力保障，一个可重入的函数可以在多线程环境下放心使用。</p></blockquote><p>一个函数被重入，表示这个函数没有执行完成，由于外部因素或内部调用，又一次进入该函数执行。分为两种情况：</p><ul><li>多个线程同时执行这个函数。</li><li>函数自身（可能是经过多层调用之后）调用自身。</li></ul><h4 id="过度优化"><a href="#过度优化" class="headerlink" title="过度优化"></a>过度优化</h4><p>即使合理地使用了锁，也不一定能保证线程安全，源于落后的编译器技术已经无法满足日益增长的并发需求。很多看似无错的代码在优化和并发面前又产生了麻烦。<br><code>volatile 关键字</code>试图阻止过度优化，可以做到两件事：</p><ul><li>阻止编译器为了提高速度将一个变量缓存到寄存器内而不写回。</li><li>阻止编译器调整操作 volatile 变量的指令顺序。</li></ul><p>即使 volatile 能够阻止编译器调整顺序，也无法阻止 CPU 动态调度换序。<br>要保证线程安全，阻止 CPU 换序是必需的，通常调用 CPU 提供的 <code>barrier 指令</code>。一条 barrier 指令会阻止 CPU 将该指令之前的指令交换到 barrier 之后，反之亦然。</p><h3 id="三种线程模型"><a href="#三种线程模型" class="headerlink" title="三种线程模型"></a>三种线程模型</h3><p>线程的并发执行是由多处理器或操作系统调度来实现的，但实际情况要更为复杂一些，内核线程和我们之前讨论的一样。然而，用户实际使用的是存在于用户态的用户线程，用户态线程并不一定在操作系统内核里对应同等数量的内核线程。</p><h4 id="一对一模型"><a href="#一对一模型" class="headerlink" title="一对一模型"></a>一对一模型</h4><p>一个用户使用的线程就唯一对应一个内核使用的线程（反之不一定）。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-10.jpeg" alt><br>线程之间的并发是真正的并发，一对一线程缺点有两个：</p><ul><li>由于许多操作系统限制了内核线程的数量，因此一对一线程会让用户的线程数量受到限制。</li><li>许多操作系统内核线程调度时，上下文切换的开销较大，导致用户线程的执行效率下降。</li></ul><h4 id="多对一模型"><a href="#多对一模型" class="headerlink" title="多对一模型"></a>多对一模型</h4><p>多对一模型的好处是高效的上下文切换和几乎无限制的线程数量。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-11.jpeg" alt><br>多对一模型一大问题是，如果其中一个用户线程阻塞，那么所有的线程都将无法执行，因为此时内核里的线程也随之阻塞了。<br>另外，在多处理器系统上，处理器的增多对多对一模型的线程性能也不会有明显的帮助。</p><h4 id="多对多模型"><a href="#多对多模型" class="headerlink" title="多对多模型"></a>多对多模型</h4><p>多对多模型结合了多对一模型和一对一模型的特点。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/DevPrepares/1-12.jpeg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> DevPrepares </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM：现在与未来</title>
      <link href="2018/07/10/SLAM%EF%BC%9A%E7%8E%B0%E5%9C%A8%E4%B8%8E%E6%9C%AA%E6%9D%A5/"/>
      <url>2018/07/10/SLAM%EF%BC%9A%E7%8E%B0%E5%9C%A8%E4%B8%8E%E6%9C%AA%E6%9D%A5/</url>
      
        <content type="html"><![CDATA[<p>除了经典 V-SLAM 框架之外，也积累了许多优秀的开源 SLAM 方案，大部分实现都比较复杂，不适合作为初学者的上手材料。</p><h2 id="当前的开源方案"><a href="#当前的开源方案" class="headerlink" title="当前的开源方案"></a>当前的开源方案</h2><p>在 SLAM 研究领域，能见到开源方案是很不容易的。论文中，往往介绍理论只占 20% 的内容，其他 80% 都写在代码中。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/14_1.jpeg" alt></p><a id="more"></a><h3 id="MonoSLAM"><a href="#MonoSLAM" class="headerlink" title="MonoSLAM"></a>MonoSLAM</h3><p>被认为是许多工作的发源地，<code>EKF</code> 在早期 SLAM 中占据着明显主导地位，所以 MonoSLAM也是建立在 EKF 的基础之上。<br>特征点在三维空间中的表示：在某个方向上显得越长，说明在该方向的位置就越不确定。<br>在当时已经是里程碑式的工作了，因为在此之前的 V-SLAM 系统基本不能在线运行。</p><h3 id="PTAM"><a href="#PTAM" class="headerlink" title="PTAM"></a>PTAM</h3><p>PTAM（Parallel Tracking and Mapping）的重要意义：</p><ul><li>提出并实现了跟踪、建图过程的并行化。跟踪部分需要实时响应图像数据，而对地图的优化则没必要实时地计算。</li><li>第一个使用非线性优化，而不是使用传统的滤波器作为后端的方案。引入了<code>关键帧</code>机制：不必精细地处理每一幅图像。</li></ul><blockquote><p>PTAM 是早期结合 AR 的 SLAM 工作之一。</p></blockquote><h3 id="ORB-SLAM"><a href="#ORB-SLAM" class="headerlink" title="ORB-SLAM"></a>ORB-SLAM</h3><h4 id="明显优势"><a href="#明显优势" class="headerlink" title="明显优势"></a>明显优势</h4><ul><li>支持单目、双目、RGB-D 三种模式，良好的泛用性。</li><li>整个系统围绕 ORB 特征进行计算。</li><li>ORB 的回环检测是亮点。</li><li>创新式地使用了三个线程完成 SLAM：<ol><li>实时跟踪特征点的 Tracking 线程</li><li>局部 Bundle Adjustment 的优化线程（Co-visibility，<code>小图</code>）</li><li>全局 Pose Graph 的回环检测与优化线程（Essential Graph，<code>大图</code>）<br>由于全局地图中的地图点太多，这个线程的优化不包括地图点，而只有相机位姿组成的位姿图。</li></ol></li><li>围绕<strong>特征点</strong>进行了不少的优化：在 OpenCV 的特征提取基础上保证了特征点的均匀分布；在优化位姿时使用了一种得到更多正确匹配的方法；比 PTAM 更为宽松的关键帧选取策略。</li></ul><h4 id="不足之处"><a href="#不足之处" class="headerlink" title="不足之处"></a>不足之处</h4><ul><li>必须对每幅图像都计算一遍 ORB 特征，这是非常耗时的，移植到嵌入式设备上有一定困难。</li><li>稀疏特征点地图只能满足我们对定位的需求，而无法提供导航、避障、交互等诸多功能。</li></ul><h3 id="LSD-SLAM"><a href="#LSD-SLAM" class="headerlink" title="LSD-SLAM"></a>LSD-SLAM</h3><p>LSD-SLAM（Large Scale Direct monocular SLAM）标志着<strong>单目直接法</strong>在 SLAM 中的成功应用。</p><h4 id="主要优点"><a href="#主要优点" class="headerlink" title="主要优点"></a>主要优点</h4><ul><li>直接法是基于像素进行的。</li><li>在 CPU 上实现了半稠密场景的重建。基于特征点的方法只能是稀疏的，进行稠密重建的方案大多要使用 RGB-D 传感器，或者使用 GPU 构建稠密地图。</li><li>使用了一些精妙的手段来保证追踪的实时性与稳定性。</li></ul><p>半稠密地图建模了灰度图中有明显梯度的部分，既有直接法的优点（对特征缺失区域不敏感），也继承了直接法的缺点：</p><ul><li>对相机内参、曝光非常敏感，在相机快速运动时容易丢失。</li><li>依赖于特征点方法进行回环检测，尚未完全摆脱特征点的计算。</li></ul><h3 id="SVO"><a href="#SVO" class="headerlink" title="SVO"></a>SVO</h3><p>SVO（Semi-direct Visual Odoemtry）是一种基于<strong>半直接法</strong>的视觉里程计。<code>半直接</code>在原文中的意思是指特征点与直接法的混合使用。<br>跟踪了一些关键点（角点，没有描述子），SVO 的最大优势是速度极快，非常适用于计算平台受限的场合，例如无人机、手持 AR/VR 设备的定位。</p><blockquote><p>SVO 的另一创新之处是提出了深度滤波器的概念。</p></blockquote><h4 id="一些问题"><a href="#一些问题" class="headerlink" title="一些问题"></a>一些问题</h4><ul><li>目标应用平台为无人机的俯视相机，想要在平视相机中使用 SVO，必须自己加以修改。</li><li>舍弃了后端优化和回环检测部分，也基本没有建图功能，而且没有描述子用来回环检测，所以，称它为一个 VO，而不是称它为完整的 SLAM。</li></ul><h3 id="RTAB-MAP"><a href="#RTAB-MAP" class="headerlink" title="RTAB-MAP"></a>RTAB-MAP</h3><p>RTAB-MAP（Real Time Appearance-Based Mapping）是 RGB-D 传感器上的 SLAM 方案，可以直接从 ROS 中获得其二进制程序，此外，在 Google Project Tango 上也可以获取其 App 使用。<br>由于<code>集成度</code>较高，进行二次开发变得困难，RTAB-MAP 更适合作为 SLAM 应用而非研究使用。</p><h2 id="未来的-SLAM-话题"><a href="#未来的-SLAM-话题" class="headerlink" title="未来的 SLAM 话题"></a>未来的 SLAM 话题</h2><p>SLAM 将来的发展趋势有两大类：</p><ul><li>朝轻量级、小型化方向发展，让 SLAM 能够在嵌入式或手机等小型设备上良好运行，然后考虑以它为底层功能的应用。</li><li>利用高性能计算设备，实现精密的三维重建、场景理解等功能。由于可以利用 GPU，这个方向和深度学习亦有结合点。</li></ul><h3 id="视觉-惯性导航-SLAM"><a href="#视觉-惯性导航-SLAM" class="headerlink" title="视觉 + 惯性导航 SLAM"></a>视觉 + 惯性导航 SLAM</h3><p><strong>学术界</strong>喜欢<code>大而且干净的问题</code>（Big Clean Problem），<strong>产业界</strong>则更注重让算法更加实用。</p><h4 id="IMU-与相机传感器的互补性"><a href="#IMU-与相机传感器的互补性" class="headerlink" title="IMU 与相机传感器的互补性"></a>IMU 与相机传感器的互补性</h4><p>惯性传感器（IMU）能够测量传感器本体的角速度、加速度，被认为与相机传感器具有明显的互补性：</p><ul><li>IMU 的测量量存在明显的漂移（Drift），但是，对于短时间内的快速运动，IMU 能够提供一些较好的估计。</li><li>相机数据可以有效地估计并修正 IMU 读数中的漂移。</li><li>纯视觉 SLAM 难以处理动态的障碍物，而 IMU 能够感受到自己的运动信息，从某种程度上减轻动态物体的影响。</li></ul><blockquote><p>IMU 为快速运动提供了较好的解决方式，而相机又能在慢速运动下解决 IMU 的漂移问题。</p></blockquote><p>不管是理论还是实践，VIO（Visual Inertial Odometry）都是相当复杂的，目前 VIO 的框架已经定型为两大类：<code>松耦合</code>（Loosely Coupled）、<code>紧耦合</code>（Tightly Coupled）。<br>尽管在纯视觉 SLAM 中优化方法已经占了主流，但在 VIO 中，由于 IMU 的数据频率非常高，对状态进行优化需要的计算量就更大，因此目前仍处于滤波与优化并存的阶段。<br>结合<strong>稀疏直接法</strong>，有望在低端硬件上取得良好的 SLAM 或 VO 效果，是非常有前景的。</p><h3 id="语义-SLAM"><a href="#语义-SLAM" class="headerlink" title="语义 SLAM"></a>语义 SLAM</h3><p>到目前为止，SLAM的方案都处于特征点或者像素的层级，与我们人类的做法不怎么相似，SLAM 的另一个大方向就是和深度学习技术结合。</p><h4 id="SLAM-和语义的结合点"><a href="#SLAM-和语义的结合点" class="headerlink" title="SLAM 和语义的结合点"></a>SLAM 和语义的结合点</h4><ul><li>语义帮助 SLAM。能得到一个带有标签的地图，另外，物体信息亦可为回环检测、BA 优化带来更多的条件。</li><li>SLAM 帮助语义。如果有自动生成的带高质量标注的样本数据，能够很大程度上加速分类器的训练过程。</li></ul><p>在深度学习广泛应用之前，我们只能利用<code>支持向量机</code>、<code>条件随机场</code>等传统工具对物体或场景进行分割和识别，或者直接将观测数据与数据库中的样本进行比较。<br>随着深度学习的发展，我们开始使用<code>神经网络</code>，越来越准确地对图像进行识别、检测和分割。<br>将 SLAM 与深度学习结合起来处理图像，亦是一个很有前景的研究方向。</p><h3 id="SLAM-的未来"><a href="#SLAM-的未来" class="headerlink" title="SLAM 的未来"></a>SLAM 的未来</h3><p>V-SLAM 经过了三个大时代：提出问题、寻找算法、完善算法。我们目前正处于第三个时代。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS 入门</title>
      <link href="2018/07/09/ROS-%E5%85%A5%E9%97%A8/"/>
      <url>2018/07/09/ROS-%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="ROS-是什么"><a href="#ROS-是什么" class="headerlink" title="ROS 是什么"></a>ROS 是什么</h2><p>ROS 并不是一个真正意义上的操作系统，而更像是基于操作系统之上的一个<code>软件包</code>。<br>支持面向对象的编程语言 C++，以及脚本语言 Python。</p><h2 id="ROS-的特点"><a href="#ROS-的特点" class="headerlink" title="ROS 的特点"></a>ROS 的特点</h2><p>屏蔽底层硬件及其接口的不一致性，实现<code>软件复用</code>。</p><a id="more"></a><h3 id="数据来源"><a href="#数据来源" class="headerlink" title="数据来源"></a>数据来源</h3><ul><li>传感器</li><li>数据集</li><li>bag 文件</li></ul><p>最方便的方式是利用 ROS 下的 bag 文件发布 topic，然后 SLAM 程序就可以监视 topic 发出的数据，就像使用真实的传感器采集数据一样。</p><h2 id="如何快速上手-ROS"><a href="#如何快速上手-ROS" class="headerlink" title="如何快速上手 ROS"></a>如何快速上手 ROS</h2><h3 id="rqt"><a href="#rqt" class="headerlink" title="rqt"></a>rqt</h3><p>ROS 下的一个软件框架，提供了各种方便好用的 GUI，可以实时地查看 ROS 中流动的消息。</p><h3 id="rosbag"><a href="#rosbag" class="headerlink" title="rosbag"></a>rosbag</h3><p>ROS 提供的一个非常好用的<code>录制及播放</code> topic 数据的工具。使用公开提供的 bag 文件来进行图像或者数据的模拟。</p><h3 id="rviz"><a href="#rviz" class="headerlink" title="rviz"></a>rviz</h3><p>ROS 提供的<code>可视化模块</code>，可实时地查看 ROS 中的图像、点云、地图、规划的路径。从而更方便地调试程序。</p><blockquote><p>ROS2 解决了 ROS 实时性的问题。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>三维空间刚体运动</title>
      <link href="2018/01/15/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/"/>
      <url>2018/01/15/%E4%B8%89%E7%BB%B4%E7%A9%BA%E9%97%B4%E5%88%9A%E4%BD%93%E8%BF%90%E5%8A%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="旋转矩阵"><a href="#旋转矩阵" class="headerlink" title="旋转矩阵"></a>旋转矩阵</h2><h3 id="点和向量，坐标系"><a href="#点和向量，坐标系" class="headerlink" title="点和向量，坐标系"></a>点和向量，坐标系</h3><blockquote><p>坐标的具体取值，一是和向量本身有关，二是和坐标系的选取有关。</p></blockquote><p>刚体：不光有位置，还有自身的姿态。<br>不要把向量与它的坐标两个概念混淆，只有当我们指定这个三维空间中的<strong>某个坐标系</strong>时，才可以谈论该向量在此坐标系下的坐标；如果我们确定了一个坐标系，也就是一个线性空间的基(e1, e2, e3)，那么就可以谈论向量 a 在这组基下的坐标了：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_1.jpeg" alt></p><ul><li>内积：a · b = a T b = |a||b|cos&lt;a, b&gt;，数量积，描述向量间的投影关系。</li><li>外积：a x b = a ^ b = |a||b|sin&lt;a, b&gt;，向量积，方向垂直于这两个向量，是两个向量张成的四边形的有向面积。</li></ul><p>外积只对三维向量存在定义，我们还能用外积表示<strong>向量的旋转</strong>。大拇指的朝向就是旋转向量的方向，大小则由 a 和 b 的夹角决定。</p><a id="more"></a><h3 id="坐标系间的欧氏变换"><a href="#坐标系间的欧氏变换" class="headerlink" title="坐标系间的欧氏变换"></a>坐标系间的欧氏变换</h3><p>转换关系由一个矩阵 T 来描述：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_2.jpeg" alt><br>相机运动是一个刚体运动，这种变换称为<strong>欧氏变换</strong>，对于同一个向量 a ，该向量并没有随着坐标系的旋转而发生运动。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_3.jpeg" alt><br>矩阵 R 描述了旋转本身，因此又称为<strong>旋转矩阵</strong>。<br>旋转矩阵可以描述相机的旋转，是行列式为 1 的正交矩阵，集合定义如下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_4.jpeg" alt><br>SO(3) 是特殊正交群（Special Orthogonal Group）。<br>正交矩阵即逆为自身转置的矩阵，R^T 刻画了一个相反的旋转。<br><code>a&#39;=Ra+t</code> 用一个旋转矩阵 R 和一个平移向量 t 完整地描述了一个欧氏空间的坐标变换关系。</p><h3 id="变换矩阵与齐次坐标"><a href="#变换矩阵与齐次坐标" class="headerlink" title="变换矩阵与齐次坐标"></a>变换矩阵与齐次坐标</h3><p><code>a&#39;=Ra+t</code> 的变换关系不是一个<strong>线性关系</strong> ，在变换多次后会过于复杂。因此，我们要引入<strong>齐次坐标</strong>和变换矩阵重写式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_5.jpeg" alt><br>把旋转和平移写在一个矩阵里面，使得整个关系变成线性关系，矩阵 T 称为<strong>变换矩阵</strong>（Transform Matrix）。<br>用 4 个实数描述了一个三维向量，多了一个自由度，一个点的具体坐标值不是唯一的。如 [1, 1, 1, 1]^T 和 [2, 2, 2, 2]^T 是同一个点。<br>T 具有比较特别的结构：左上角为旋转矩阵，右侧为平移向量，左下角为 0 向量，右下角为 1。这种矩阵又称为特殊欧氏群（Special Euclidean Group）：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_6.jpeg" alt><br>与 SO(3) 一样，求解该矩阵的逆表示一个反向的变换:<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_20.jpeg" alt></p><blockquote><p>旋转可以有旋转矩阵 SO(3) 描述，平移直接由一个 R^3 向量描述。如果将平移和旋转放在一个矩阵中，就形成了变换矩阵 SE(3)。</p></blockquote><h2 id="实践：Eigen"><a href="#实践：Eigen" class="headerlink" title="实践：Eigen"></a>实践：Eigen</h2><blockquote><p>本节讲解如何使用 Eigen 来表示矩阵、向量。</p></blockquote><p>Eigen 是一个 C++ 开源线性代数库，它提供了快速的<strong>有关矩阵</strong>的线性代数运算，还包括<strong>解方程</strong>等功能。许多上层的软件库也使用 Eigen 进行矩阵运算，包括 g2o、Sophus 等。<br>可以输入以下命令，查找 Eigen 头文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo updatedb</span><br><span class="line">$ locate eigen3</span><br></pre></td></tr></table></figure><p>不需要使用 <code>target_link_libraries</code> 将程序链接到库上，Eigen 是一个纯用<strong>头文件</strong>搭建起来的库，没有 *.so 或 *.a 那样的二进制<strong>库文件</strong>。除了使用 <code>include_directories</code> 指定头文件目录，我们还可以使用 <code>find_package</code> 命令去搜索库。</p><h3 id="几处重要说明"><a href="#几处重要说明" class="headerlink" title="几处重要说明"></a>几处重要说明</h3><ul><li>Eigen 以矩阵为基本数据单元，它是一个模板类，前三个参数为：数据类型、行、列。</li><li>在 Eigen 中需要指定矩阵的大小和类型，处理起来会比动态变化大小的矩阵更快一些。</li><li>必须显式地对矩阵类型进行转换， 否则报错：<code>YOU MIXED DIFFERENT NUMERIC TYPES</code>。</li><li>必须保证矩阵维数的正确性，否则报错：<code>YOU MIXED MATRICES OF DIFFERENT SIZES</code>。</li></ul><h2 id="旋转向量和欧拉角"><a href="#旋转向量和欧拉角" class="headerlink" title="旋转向量和欧拉角"></a>旋转向量和欧拉角</h2><h3 id="旋转向量"><a href="#旋转向量" class="headerlink" title="旋转向量"></a>旋转向量</h3><blockquote><p>旋转向量就是李代数</p></blockquote><p>任意旋转都可以用<strong>一个旋转轴和一个旋转角</strong>来刻画，我们可以使用一个向量，其方向与旋转轴一致，而长度等于旋转角。这种向量称为<code>旋转向量</code>（或轴角，Axis-Angle）。<br>对于变换矩阵，我们使用一个旋转向量和一个平移向量即可表达一次变换，这时的维数正好是六维。</p><h4 id="矩阵表示方式的缺点"><a href="#矩阵表示方式的缺点" class="headerlink" title="矩阵表示方式的缺点"></a>矩阵表示方式的缺点</h4><ul><li>SO(3) 的旋转矩阵有 9 个量，用它表达 3 个自由度的旋转<code>是冗余的</code>。同理，SE(3) 的变换矩阵用 16 个量表达了 6 自由度的变换。</li><li>旋转矩阵自身<code>带有约束</code>：它必须是正交矩阵，且行列式为 1。变换矩阵也是如此。</li></ul><h4 id="旋转向量到旋转矩阵的转换"><a href="#旋转向量到旋转矩阵的转换" class="headerlink" title="旋转向量到旋转矩阵的转换"></a>旋转向量到旋转矩阵的转换</h4><p>借助罗德里格斯公式（Rodrigues’s Formula）：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_7.jpeg" alt><br>符号 ^ 是向量的反对称转换符。</p><h4 id="旋转矩阵到旋转向量的转换"><a href="#旋转矩阵到旋转向量的转换" class="headerlink" title="旋转矩阵到旋转向量的转换"></a>旋转矩阵到旋转向量的转换</h4><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_8.jpeg" alt><br>由于旋转轴上的向量在旋转后不反生改变，转轴 <strong>n</strong> 是矩阵 <strong>R</strong> 特征值 1 对应的特征向量。</p><h3 id="欧拉角"><a href="#欧拉角" class="headerlink" title="欧拉角"></a>欧拉角</h3><p>旋转矩阵、旋转向量虽然能描述旋转，但对我们人类是非常不直观的。欧拉角提供了一种非常直观的方式来描述旋转——它使用了 <strong>3 个分离的转角</strong>。<br>欧拉角当中比较常用的一种，便是用“偏航-俯仰-滚转”（yaw-pitch-roll）3 个角度来描述一个旋转，等价于 ZYX 轴的旋转。<br>刚体朝向我们的方向为 X 轴，右侧为 Y 轴，上方为 Z 轴。</p><h4 id="万向锁问题（Gimbal-Lock）"><a href="#万向锁问题（Gimbal-Lock）" class="headerlink" title="万向锁问题（Gimbal Lock）"></a>万向锁问题（Gimbal Lock）</h4><p>在俯仰角为 ±90° 时，第一次旋转与第三次旋转将使用同一个轴，使得系统丢失了一个自由度。<br>只要想用 3 个实数表达三维旋转时，都会不可避免地碰到<code>奇异性</code>问题。</p><h2 id="四元数"><a href="#四元数" class="headerlink" title="四元数"></a>四元数</h2><h3 id="四元数的定义"><a href="#四元数的定义" class="headerlink" title="四元数的定义"></a>四元数的定义</h3><p>旋转矩阵用 9 个量描述 3 自由度的旋转，具有冗余性；欧拉角和旋转向量是紧凑的，但具有奇异性。事实上，我们找不到<strong>不带奇异性的三维向量描述方式</strong>。<br>这有点类似于用两个坐标表示地球表面（如经度和纬度），将必定存在奇异性（纬度为 ±90° 时经度无意义）。<br>我们用复数集 C 表示复平面上的向量，而复数的乘法则表示复平面的旋转：例如，乘上复数 i 相当于逆时针把一个复向量旋转 90°。类似地，在表达三维空间的旋转时，也有一种类似于复数的代数：<code>四元数</code>（Quaternion）。四元数是一种扩展的复数，它<strong>既是紧凑的，也没有奇异性</strong>。<br>一个四元数 <strong>q</strong> 拥有一个实部和三个虚部，像下面这样：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_9.jpeg" alt><br>其中，I，j，k 为四元数的三个虚部。这三个虚部满足以下关系式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_10.jpeg" alt><br>有时人们也用一个标量和一个向量来表达四元数：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_11.jpeg" alt><br>这里，s 称为四元数的实部，而 <strong>v</strong> 称为它的虚部。如果一个四元数的虚部为 <strong>0</strong>，称之为<code>实四元数</code>。反之，若它的实部为 0，则称之为<code>虚四元数</code>。</p><blockquote><p>任意的旋转都可以由两个互为相反数的四元数表示。</p></blockquote><h3 id="四元数的运算"><a href="#四元数的运算" class="headerlink" title="四元数的运算"></a>四元数的运算</h3><p>四元数和通常复数一样，可以进行一系列的运算。常见的有四则运算、数乘、点乘、求逆、求模、共轭等。</p><h3 id="四元数与旋转向量的转换"><a href="#四元数与旋转向量的转换" class="headerlink" title="四元数与旋转向量的转换"></a>四元数与旋转向量的转换</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_12.jpeg" alt><br>反之，亦可从单位四元数中计算出对应旋转轴与夹角：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_13.jpeg" alt></p><h3 id="四元数与旋转矩阵的转换"><a href="#四元数与旋转矩阵的转换" class="headerlink" title="四元数与旋转矩阵的转换"></a>四元数与旋转矩阵的转换</h3><p>现在看来把四元数转换为矩阵的最直观方法，是先把四元数 <strong>q</strong> 转换为轴角 θ 和 <strong>n</strong>，然后再根据罗德里格斯公式转换为矩阵。不过那样要计算一个 arccos 函数，代价较大。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_14.jpeg" alt><br>反之，由旋转矩阵到四元数的转换如下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_15.jpeg" alt></p><blockquote><p>无论是四元数、旋转矩阵还是轴角，它们都可以用来描述同一旋转。我们应该在实际中选择最为方便的形式，而不拘泥于某种特定的形式。</p></blockquote><h2 id="相似、仿射、射影变换"><a href="#相似、仿射、射影变换" class="headerlink" title="相似、仿射、射影变换"></a>相似、仿射、射影变换</h2><p>欧氏变换保持了向量的长度和夹角，相当于我们把一个刚体原封不动地进行了移动或旋转，不改变它自身的样子。而其他几种变换则会<strong>改变它的外形</strong>，它们都拥有类似的矩阵表示。</p><h3 id="相似变换"><a href="#相似变换" class="headerlink" title="相似变换"></a>相似变换</h3><p>相似变换比欧氏变换多了一个自由度，它允许物体进行均匀缩放，其矩阵表示为：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_16.jpeg" alt></p><h3 id="仿射变换"><a href="#仿射变换" class="headerlink" title="仿射变换"></a>仿射变换</h3><p>与欧氏变换不同的是，仿射变换只要求 <strong>A</strong> 是一个可逆矩阵，而不必是正交矩阵。经过仿射变换之后，立方体不再是方的了，但是各个面仍然是平行四边形，其矩阵形式如下：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_17.jpeg" alt></p><h3 id="射影变换"><a href="#射影变换" class="headerlink" title="射影变换"></a>射影变换</h3><p>从真实世界到相机照片的变换可以看成一个射影变换（如果相机的焦距为无穷远，那么这个变换为仿射变换）。我们可以想象一个原本方形的地板砖，在照片中是什么样子：首先，它不再是方形的。由于近大远小的关系，它甚至不是平行四边形，而是一个不规则的四边形，它的矩阵形式为：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_18.jpeg" alt><br>下表总结了几种变换的性质。注意在<code>不变性质</code>中，从上到下是有包含关系的：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_19.jpeg" alt></p><h2 id="实践：Eigen-几何模块"><a href="#实践：Eigen-几何模块" class="headerlink" title="实践：Eigen 几何模块"></a>实践：Eigen 几何模块</h2><p>我们将在 Eigen 中使用四元数、欧拉角和旋转矩阵，演示它们之间的变换方式。每种类型都有单精度和双精度两种数据类型（不能由编译器自动转换），下面以双精度为例，把最后的 d 改成 f，即得到单精度的数据结构：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/3_21.jpeg" alt></p><h2 id="可视化演示"><a href="#可视化演示" class="headerlink" title="可视化演示"></a>可视化演示</h2><p>我们准备了一个<a href="https://github.com/gaoxiang12/slambook/tree/master/ch3/visualizeGeometry" target="_blank" rel="noopener">小程序</a>，以可视化的形式演示了各种表达方式的异同。<br>实际中，我们会至少定义两个坐标系：<strong>世界坐标系</strong>和<strong>相机坐标系</strong>。在该定义下，设某个点在世界坐标系中的坐标为 Pw，在相机坐标系下为 Pc，那么：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Pc</span> = TcwPw</span><br></pre></td></tr></table></figure><p>这里 Tcw 表示世界坐标系到相机坐标系间的变换。或者可以用反过来的 Twc：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Pw</span> = TwcPc = Tcw^-<span class="number">1</span>Pc</span><br></pre></td></tr></table></figure><p>如果把上面式子的 Pc 取成零向量（也就是相机坐标系的原点），那么，此时的 Pw 就是相机原点在世界坐标系下的坐标，可以从 Twc 中直接看到相机在何处（Twc 的平移部分）：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Pw</span> = Twc0 = twc</span><br></pre></td></tr></table></figure><blockquote><p>实践中使用 Tcw 更加常见，而 Twc 更为直观。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库原理</title>
      <link href="2018/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/"/>
      <url>2018/01/08/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="SQL-语言的功能"><a href="#SQL-语言的功能" class="headerlink" title="SQL 语言的功能"></a>SQL 语言的功能</h2><p>SQL 是结构化查询语言（Structured Query Language）的缩写，其功能包括<strong>四个部分：</strong></p><ul><li>数据查询，数据库中最常见的操作，通过 select 语句可以得到所需的信息；</li><li>数据操纵，<code>DML</code>（Data Manipulation Language）主要包括插入数据、修改数据、删除数据；</li><li>数据定义，<code>DDL</code>（Data Definition Language）实现数据定义功能，可对数据库用户、基本表、视图、索引进行定义与撤销；</li><li>数据控制，<code>DCL</code>（Data Control Language）用于对数据库进行统一的控制管理，保证数据在多用户共享的情况下能够安全。</li></ul><p>基本的 SQL 语句：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/5_1.jpg" alt></p><a id="more"></a><h3 id="delete-与-truncate-命令的区别"><a href="#delete-与-truncate-命令的区别" class="headerlink" title="delete 与 truncate 命令的区别"></a>delete 与 truncate 命令的区别</h3><p>相同点：都可以用来删除一个表中的数据。<br>不同点：</p><ol><li>truncate 是一个 DDL，它会被隐式地提交，一旦执行后将不能回滚。delete 将删除的操作以日志的形式进行保存，以便将来进行回滚操作；</li><li>用 delete 操作后，被删除的数据占用的存储空间还在。而用 truncate 操作删除数据后，被删除的数据会立即释放占用的存储空间；</li><li>truncate 的执行速度比 delete 快。</li></ol><h2 id="内连接与外连接的区别"><a href="#内连接与外连接的区别" class="headerlink" title="内连接与外连接的区别"></a>内连接与外连接的区别</h2><p>内连接（INNER JOIN）也被称为自然连接，只有两个表相匹配的行才能在结果集中出现，可能会造成信息的丢失；<br>SQL 的外连接共有 3 种 类型：左外连接（LEFT OUTER JOIN）、右外连接（RIGHT OUTER JOIN）、全外连接（FULL OUTER JOIN），外连接的用法和内连接一样。</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><p>事务是数据库中一个单独的<code>执行单元</code>，通常由高级数据库操作语言或编程语言编写的用户程序的执行所引起。<br>事务必须满足<strong>四个属性：</strong>原子性（atomicity）、一致性（consistency）、隔离性（isolation）、持久性（durability）。</p><blockquote><p>严格来说，ACID 都是由数据库管理系统来保证的，在整个应用程序运行过程中，应用无需去考虑数据库的 ACID 实现。</p></blockquote><h3 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h3><p>事务是一个不可分割的整体，避免了只执行操作的一部分而带来的错误，原子性要求事务必须被完整执行。</p><h3 id="一致性"><a href="#一致性" class="headerlink" title="一致性"></a>一致性</h3><p>一个事务执行之前和执行之后，数据库数据必须保持一致性状态，一致性由用户来负责，由并发控制机制实现。</p><h3 id="隔离性"><a href="#隔离性" class="headerlink" title="隔离性"></a>隔离性</h3><p>将一个事务内部的操作与事务的操作隔离起来，不被其他正在进行的事务看到。数据库有 <code>4 种类型</code>的事务隔离级别：未提交读、已提交读、可重复读、可序列化（最高级别）。</p><h3 id="持久性"><a href="#持久性" class="headerlink" title="持久性"></a>持久性</h3><p>事务完成以后，DBMS 保证它对数据库中数据的修改是永久性的，持久性一般通过数据库备份与恢复来保证。</p><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>SQL 语句在执行时要先编译，然后再被执行。<br>在大型数据库系统中，为了提高效率，将为了完成特定功能的 <strong>SQL 语句集</strong>进行编译优化后，存储在数据库服务器中，用户通过指定存储过程的名字来调用执行。<br>创建存储过程的常用语法：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/5_2.jpg" alt><br>使用存储过程可以增强 SQL 语言的功能和灵活性；同时，存储过程可以使没有权限的用户间接地存取数据库，也保证了数据的<code>安全</code>。</p><h3 id="与函数的不同"><a href="#与函数的不同" class="headerlink" title="与函数的不同"></a>与函数的不同</h3><ol><li>存储过程一般是作为一个独立的部分来执行，而函数可以作为查询语句的一部分来调用；</li><li>存储过程实现的过程较复杂，而函数实现的功能针对性较强；</li><li>函数只能返回一个值或表对象，而存储过程可以返回多个参数；</li><li>函数不能直接操作实体表，只能操作内建表；</li><li>存储过程在创建时即在服务器上进行了编译，其执行速度比函数快。</li></ol><h2 id="各种范式的区别"><a href="#各种范式的区别" class="headerlink" title="各种范式的区别"></a>各种范式的区别</h2><p>使用正确的数据结构，不仅有助于对数据库进行相应的存取操作，还可以极大地简化应用程序中的其他内容。<br><code>范化</code>是在识别数据库中的数据元素、关系以及定义所需的表和各表中的项目，这些初始工作之后的一个细化过程。常见的范式有 1NF、2NF、3NF、BCNF、4NF。<br>各范式的关系图：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/5_3.png" alt></p><h3 id="1NF"><a href="#1NF" class="headerlink" title="1NF"></a>1NF</h3><p>第一范式是指数据库表的每一列都是不可分割的基本数据项，同一列中不能有多个值，即实体中的某个属性不能有多个值或者不能有重复的属性。<br>简而言之，第一范式就是<strong>无重复的列</strong>。</p><h3 id="2NF"><a href="#2NF" class="headerlink" title="2NF"></a>2NF</h3><p>第二范式是在第一范式的基础上建立起来的，即满足第二范式必须先满足第一范式。要求数据库表中的每个实例或行必须可以被唯一地区分。<br>如果关系模式 R 为第一范式，并且 R 中的每一个非主属性完全函数依赖于 R 的某个<code>候选键</code>，则称 R 为第二范式。</p><h3 id="3NF"><a href="#3NF" class="headerlink" title="3NF"></a>3NF</h3><p>如果关系模式 R 是第二范式，且每个非主属性都<strong>不传递依赖</strong>于 R 的候选键，则称 R 是第三范式的模式。</p><h3 id="BCNF"><a href="#BCNF" class="headerlink" title="BCNF"></a>BCNF</h3><p>构建在第三范式的基础上，如果关系模式 R 是第三范式，且<strong>每个属性</strong>都不传递依赖于 R 的候选键，那么称 R 为 BCNF 的模式。<br>排除关键字段决定关键字段的情况。</p><h3 id="4NF"><a href="#4NF" class="headerlink" title="4NF"></a>4NF</h3><p>假设 R 是一个关系模式，D 是 R 上的多值依赖集合，如果 D 中但凡存在多值依赖 X→Y，X 必是 R 的<code>超键</code>，那么称 R 是第四范式的模式。</p><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><p>触发器是一种特殊类型的存储过程，它由事件触发，而不是程序调用或手工启动。<br>触发器与存储过程的区别：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/HANA/5_4.jpg" alt></p><h3 id="触发器的作用"><a href="#触发器的作用" class="headerlink" title="触发器的作用"></a>触发器的作用</h3><ol><li>增加安全性；</li><li>利用触发器，记录所进行的修改以及相关信息，跟踪用户对数据库的操作，实现审计；</li><li>完成<strong>比约束更复杂</strong>的数据约束，例如，同步实时地复制表中的数据。</li></ol><h3 id="事前触发和事后触发的区别"><a href="#事前触发和事后触发的区别" class="headerlink" title="事前触发和事后触发的区别"></a>事前触发和事后触发的区别</h3><ul><li><code>事前触发</code>发生在事件发生之前，用于验证一些条件或进行一些准备工作，可以获得之前的字段值；</li><li><code>事后触发</code>发生在事件发生之后，做一些收尾工作，可以保证事务的完整性。</li></ul><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>数据库中，游标提供了一种对从表中检索出的数据，进行操作的灵活手段，它实际上是一种能从包含多条数据记录的结果集中，每次提取一条记录的机制。<br>游标是由结果集和结果集中指向特定记录的游标位置组成的。</p><blockquote><p>游标总是与一条 SQL 选择语句相关联。</p></blockquote><h3 id="游标的优点"><a href="#游标的优点" class="headerlink" title="游标的优点"></a>游标的优点</h3><ol><li>在使用游标的表中，对行提供删除和更新的功能；</li><li>游标将<code>面向集合</code>的数据库管理系统和<code>面向行</code>的程序设计连接了起来。</li></ol><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>日志文件记录所有对数据库数据的修改，主要是保护数据库以防故障发生，以及恢复数据时使用。<br>一旦数据库中日志满了，就只能执行查询等读操作，不能执行更改、备份等操作，基本上处于不能使用的状态（任何写操作都要记录日志）。</p><h2 id="union-和-union-all-的区别"><a href="#union-和-union-all-的区别" class="headerlink" title="union 和 union all 的区别"></a>union 和 union all 的区别</h2><ul><li>union 在进行表求并集后，会去掉重复的元素，会对所产生的结果进行排序运算，删除重复的记录再返回结果；</li><li>union all 只是简单地将两个结果集，合并后就返回结果，可能会包含重复的数据。</li></ul><p>在执行查询操作时，union all 要比 union 快很多。所以，如果可以确认合并的两个结果集中不包含重复的数据，<strong>最好使用 union all</strong>。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是由从数据库的基本表中选取出来的数据，组成的逻辑窗口，与基本表不同，它是一个<code>虚表</code>。<br>在数据库中，存放的只是视图的定义，而不存放视图包含的数据项，这些项目仍然存放在原来的基本表结构中。</p><h3 id="视图的作用"><a href="#视图的作用" class="headerlink" title="视图的作用"></a>视图的作用</h3><ol><li>可以简化数据查询语句（不能提高查询的效率）；</li><li>可以使用户能从多角度看待同一数据；</li><li>通过引入视图，可以提高数据的安全性；</li><li>视图还提供了一定程度的逻辑独立性。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HANA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《面试宝典》读书笔记-4</title>
      <link href="2018/01/06/%E3%80%8A%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4/"/>
      <url>2018/01/06/%E3%80%8A%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-4/</url>
      
        <content type="html"><![CDATA[<blockquote><p>容器、多线程、Java 数据库操作</p></blockquote><h2 id="Java-Collections-框架"><a href="#Java-Collections-框架" class="headerlink" title="Java Collections 框架"></a>Java Collections 框架</h2><p>包含了大量集合接口以及这些接口的实现类和操作它们的算法。<br><code>Collection</code> 是整个集合框架的基础，它里面储存一组对象，表示不同类型的 Collections，它的作用只是维护一组对象的基本接口而已。<br>Set、List、Map 都继承自 Collection 接口：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Java/4_1.jpg" alt></p><a id="more"></a><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>表示数学意义上的<strong>集合概念</strong>，集合中的元素不能重复，必须定义 equals() 方法来确保对象的唯一性。<br>两个实现类：HashSet、TreeSet，TreeSet 容器中的元素是有序的。</p><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><p>按对象进入的顺序保存对象，可以保存重复的对象。LinkedList、ArrayList、Vector 都实现了 List 接口。</p><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>提供了一个<strong>从键映射到值</strong>的数据结构，用于保存键值对。值可以重复，键是唯一的。</p><ul><li>HashMap 是基于散列表实现的，采用对象的 HashCode 可以进行快速查询；</li><li>TreeMap 基于红黑树的数据结构来实现的，内部元素是按序排列的。</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代器（Iterator）是一个对象，它的工作是<strong>遍历并选择</strong>序列中的对象，提供了一种访问容器对象中的各个元素，而又不必暴露该对象内部细节的方法。</p><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ul><li>使用 iterator() 方法返回一个 Iterator，然后通过 next() 方法返回第一个元素；</li><li>使用 hasNext() 方法判容器中是否还有元素；</li><li>可以通过 remove() 方法删除迭代器返回的元素。</li></ul><h3 id="Iterator-与-ListIterator-的区别"><a href="#Iterator-与-ListIterator-的区别" class="headerlink" title="Iterator 与 ListIterator 的区别"></a>Iterator 与 ListIterator 的区别</h3><ul><li>Iterator 只能正向遍历集合，适用于获取移除元素；</li><li>ListIterator 继承自 Iterator，专门针对 List，可以从两个方向遍历 List，同时支持元素的修改。</li></ul><h2 id="ArrayList、Vector、LinkedList-的区别"><a href="#ArrayList、Vector、LinkedList-的区别" class="headerlink" title="ArrayList、Vector、LinkedList 的区别"></a>ArrayList、Vector、LinkedList 的区别</h2><blockquote><p>ArrayList、Vector、LinkedList 类均在 java.util 包中，为可伸缩数组。</p></blockquote><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><p>ArrayList、Vector 都是基于存储元素的 Object[] array 来实现的，会在内存中开辟一块连续的空间来存储，支持用<code>下标</code>来访问元素。</p><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>ArrayList、Vector 最大的区别就是<code>同步</code>的使用。没有一个 ArrayList 的方法是同步的，不是<strong>线程安全</strong>的；而 Vector 的绝大多数方法都是同步的，是线程安全的。</p><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p>采用双向列表来实现，对数据的索引需要从列表头开始遍历。随机访问效率较低，插入效率较高，是非线程安全的容器。</p><h3 id="容器的选择"><a href="#容器的选择" class="headerlink" title="容器的选择"></a>容器的选择</h3><ul><li>当对数据的操作主要为索引或只在集合的末端操作时，使用 ArrayList、Vector 效率比较高；</li><li>当对数据的操作主要为指定位置的操作时，使用 LinkedList 效率比较高；</li><li>当在多线程中使用容器时，选用 Vector 较为安全。</li></ul><h2 id="HashMap、HashTable、TreeMap、WeakHashMap-的区别"><a href="#HashMap、HashTable、TreeMap、WeakHashMap-的区别" class="headerlink" title="HashMap、HashTable、TreeMap、WeakHashMap 的区别"></a>HashMap、HashTable、TreeMap、WeakHashMap 的区别</h2><p>为数据结构中的<code>映射</code>定义了一个接口 java.util.Map，包括 3 个实现类：HashMap、HashTable、TreeMap。<br>在数组中通过<strong>数组下标</strong>来对其内容索引。而在 Map 中，则是通过对象来进行索引，用来索引的对象叫做 key，其对应的对象叫做 value。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><p>最常用的 Map，它根据<strong>键的 hashCode 值</strong>存储数据，根据键可以直接获取它的值，具有很快的访问速度。<br>HashMap 是 HashTable 的轻量级（非线程安全）实现，允许<code>空键值</code>，而 HashTable 不允许。<br>把 HashTable 的 contains 方法去掉了，改成 containsValue 和 containsKey。是 Map 接口的一个实现，而 HashTable 继承自 Dictionary 类。</p><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><p>是<strong>线程安全</strong>的，而 HashMap 不支持线程的同步。就效率而言，HashMap 可能高于 HashTable。<br>HashTable 和 HashMap 采用的 hash/rehash 算法几乎一样，所以性能不会有很大的差异。</p><blockquote><p>HashTable 使用 Enumeration，HashMap 使用 Iterator。</p></blockquote><h3 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h3><ul><li>在 Map 中插入、删除、定位元素，HashMap 是最好的选择。</li><li>TreeMap 实现了 <strong>SortMap 接口</strong>，如果需要按自然顺序或自定义顺序遍历键，那么 TreeMap 会更好。</li><li>LinkedHashMap 是 HashMap 的一个子类，如果需要输出的顺序和输入的相同，那么用 LinkedHashMap 可以实现。</li></ul><h3 id="WeakHashMap"><a href="#WeakHashMap" class="headerlink" title="WeakHashMap"></a>WeakHashMap</h3><p>与 HashMap 类似，不同之处在于 WeakHashMap 中，key 采用的是<code>弱引用</code>的方式，只要 key 不再被外部引用，它就可以被垃圾回收器回收。</p><h2 id="用自定义类作为-HashMap-HashTable-的-key-时，需要注意的问题"><a href="#用自定义类作为-HashMap-HashTable-的-key-时，需要注意的问题" class="headerlink" title="用自定义类作为 HashMap/HashTable 的 key 时，需要注意的问题"></a>用自定义类作为 HashMap/HashTable 的 key 时，需要注意的问题</h2><p>对于不同的 key 值可能会得到相同的 hash 值，因此就需要对冲突进行处理。<code>处理冲突</code>的方法有：开放地址发、再hash法、链地址法。<br>HashMap 使用的是链地址法来解决冲突：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Java/4_2.jpg" alt></p><ul><li>如果想根据<strong>对象的相关属性</strong>来自定义对象是否相等的逻辑，就需要重写 equals() 方法，一旦重写了 equals() 方法，那么就必须重写 hashCode() 方法。</li><li>当自定义类的多项作为 HashMap 的 key 时，最好把这个类设计为不可变类。</li><li>如果两个对象相等，那么这两个对象有着相同的 hashCode，反之不成立。</li></ul><h2 id="Collection和Collections的区别"><a href="#Collection和Collections的区别" class="headerlink" title="Collection和Collections的区别"></a>Collection和Collections的区别</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p>是一个<code>集合接口</code>，实现该接口的类主要有 List 和 Set，为各种具体的集合提供最大化的统一的操作方式。</p><h3 id="Collections"><a href="#Collections" class="headerlink" title="Collections"></a>Collections</h3><p>是针对集合类的一个<code>包装类</code>，提供一系列静态方法以实现对各种集合的搜索、排序、线程安全化等操作。<br><strong>不能实例化</strong>，如同一个工具类，服务于 Collection 框架。</p><hr><h2 id="线程与进程的区别，为什么要使用多线程？"><a href="#线程与进程的区别，为什么要使用多线程？" class="headerlink" title="线程与进程的区别，为什么要使用多线程？"></a>线程与进程的区别，为什么要使用多线程？</h2><p>线程是程序执行的最小单元。各个线程之间共享程序的内存空间（代码段、数据段、堆空间）及一些进程级的资源（打开的文件），但是各个线程线程拥有自己的<code>栈空间</code>。<br>线程有<strong>四种状态：</strong>运行、就绪、挂起、结束。<br>在<strong>操作系统级别</strong>上，程序的执行都是以进程为单位的，而每个进程中通常都会有多个线程互不影响地并发执行：</p><ul><li>使用多线程可以减少程序的响应时间。</li><li>与进程相比，线程的创建和切换开销更小，多线程在数据共享方面效率非常高。</li><li>在多 CPU 计算机上使用多线程能提高 CPU 的利用率。</li><li>使用多线程能简化程序的结构，使程序便于理解和维护。</li></ul><h2 id="同步、异步的区别"><a href="#同步、异步的区别" class="headerlink" title="同步、异步的区别"></a>同步、异步的区别</h2><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>要想实现同步操作，必须获得每一个线程对象的<code>锁</code>。获得它可以保证在同一时刻只有一个线程能够进入临界区，并且在这个锁被释放之前，其他线程就不能再进入这个临界区。<br>Java 语言在同步机制中提供了语言级的支持，可以通过使用 <strong>synchronized 关键字</strong>来实现同步。是以很大的系统开销作为代价的，有时候甚至可能造成死锁。</p><blockquote><p>同步控制并非越多越好，要尽量避免无谓的同步控制。</p></blockquote><p>实现同步的方式有两种：</p><ul><li>同步代码块</li><li>同步方法</li></ul><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>异步与<code>非阻塞</code>类似，由于每个线程都包含了运行时自身所需要的数据或方法，因此，在进行输入输出处理时，不必关心其他线程的状态或行为，也不必等到输入输出处理完毕才返回。</p><h2 id="实现-Java-多线程"><a href="#实现-Java-多线程" class="headerlink" title="实现 Java 多线程"></a>实现 Java 多线程</h2><h3 id="继承-Thread-类，重写-run-方法"><a href="#继承-Thread-类，重写-run-方法" class="headerlink" title="继承 Thread 类，重写 run() 方法"></a>继承 Thread 类，重写 run() 方法</h3><p>Thread 本质上也是实现了 Runnable 接口的一个实例，它代表一个线程的实例。启动线程的唯一方法就是通过 Thread 类的 start() 方法。</p><h3 id="实现-Runnable-接口，并实现该接口的-run-方法"><a href="#实现-Runnable-接口，并实现该接口的-run-方法" class="headerlink" title="实现 Runnable 接口，并实现该接口的 run() 方法"></a>实现 Runnable 接口，并实现该接口的 run() 方法</h3><ol><li>自定义类并实现 Runnable 接口，实现 run() 方法。</li><li>创建 Thread 对象，用实现 Runnable 接口的对象作为参数实例化该 Thread 对象。</li><li>调用 Thread 的 start() 方法。</li></ol><blockquote><p>不管是通过继承 Thread 类还是通过使用 Runnable 接口来实现多线程的方法，最终还是通过 Thread 的对象的 API 来控制线程的。</p></blockquote><h3 id="实现-Callable-接口，重写-call-方法"><a href="#实现-Callable-接口，重写-call-方法" class="headerlink" title="实现 Callable 接口，重写 call() 方法"></a>实现 Callable 接口，重写 call() 方法</h3><p>与 Runnable 接口的功能类似，但提供了更强大的功能：</p><ul><li>Callable 可以在任务结束后提供一个返回值。</li><li>Callable 中的 call() 方法可以抛出异常。</li><li>运行 Callable 可以拿到一个 Future 对象，表示异步计算的结果，提供了检查计算是否完成的方法。</li></ul><h2 id="run-方法、start-方法的区别"><a href="#run-方法、start-方法的区别" class="headerlink" title="run() 方法、start() 方法的区别"></a>run() 方法、start() 方法的区别</h2><p>系统通过调用线程类的 start() 方法来启动一个线程，此时该线程处于<strong>就绪状态</strong>，而非运行状态。也就意味着这个线程可以被 JVM 来调度执行。<br>在调度过程中，JVM 通过调用线程类的 run() 方法来完成实际的操作，当 run() 方法结束后，此线程就会终止。<br>start() 方法能够异步地调用 run() 方法，但是直接调用 run() 方法却是同步的。</p><blockquote><p>只有通过调用线程类的 start() 方法才能真正达到多线程的目的。</p></blockquote><h2 id="多线程同步的实现方法"><a href="#多线程同步的实现方法" class="headerlink" title="多线程同步的实现方法"></a>多线程同步的实现方法</h2><h3 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h3><p>在 Java 语言中，每个对象都有一个<code>对象锁</code>与之相关联，该锁表明对象在任何时候只允许被一个线程所拥有。</p><ul><li>synchronized 方法：<br>只要把多个线程对类，需要被同步的资源的操作，放到 mutiThreadAccess() 方法中，就能保证多线程访问的安全性。<br>当一个方法的方法体规模非常大时，把该方法声明为 synchronized 会大大影响程序的执行效率。</li><li>synchronized 块：<br>可以指定上锁的对象，有非常高的灵活性。</li></ul><h3 id="wait-方法与-notify-方法"><a href="#wait-方法与-notify-方法" class="headerlink" title="wait() 方法与 notify() 方法"></a>wait() 方法与 notify() 方法</h3><p>线程可以调用对象的 wait() 方法，释放对象锁，进入等待状态；<br>并且可以调用 notify() 方法或 notifyAll() 方法通知正在等待的其他进程。</p><h3 id="Lock"><a href="#Lock" class="headerlink" title="Lock"></a>Lock</h3><p>提供了如下一些方法来实现多线程的同步：</p><ul><li>lock()<br>以<code>阻塞</code>的方式获取锁，如果获取到了锁，立即返回；如果别的线程持有锁，当前线程等待，直到获取锁后返回。</li><li>tryLock()<br>以<code>非阻塞</code>的方式获取锁，只是尝试性地去获取一下锁，如果获取到锁，立即返回 true，否则，立即返回 false。</li><li>tryLock(long timeout, TimeUnit unit)<br>会等待参数给定的时间单元，在等待的过程中，如果获取了锁，就返回 true，如果等待超时，返回 false。</li><li>lockInterruptibly()<br>如果没有获取锁，当前线程处于休眠状态，<strong>直到获得锁</strong>；<br>或者当前线程被别的线程中断。</li></ul><h2 id="sleep-方法、wait-方法的区别"><a href="#sleep-方法、wait-方法的区别" class="headerlink" title="sleep() 方法、wait() 方法的区别"></a>sleep() 方法、wait() 方法的区别</h2><h3 id="原理不同"><a href="#原理不同" class="headerlink" title="原理不同"></a>原理不同</h3><ul><li>sleep() 方法是 Thread 类的静态方法，是线程用来控制自身流程的，它会使此线程暂停执行一段时间，等到计时时间一到，此线程会<strong>自动苏醒</strong>；</li><li>wait() 方法是 Object 类的方法，用于线程间通信，这个方法会使当前拥有该对象锁的进程等待，直到<strong>其他线程调用 notify() 方法</strong>时才醒来。</li></ul><h3 id="对锁的处理机制不同"><a href="#对锁的处理机制不同" class="headerlink" title="对锁的处理机制不同"></a>对锁的处理机制不同</h3><ul><li>sleep() 方法的主要作用是让线程暂停执行一段时间，时间一到则自动恢复，<strong>不涉及线程间的通信</strong>，因此，调用 sleep() 方法并不会释放锁；</li><li>当调用 wait() 方法后，线程会释放掉它所占用的锁，从而使线程所在对象中的其他 synchronized 数据可被别的线程使用。</li></ul><h3 id="使用区域不同"><a href="#使用区域不同" class="headerlink" title="使用区域不同"></a>使用区域不同</h3><ul><li>wait() 方法必须放在同步控制方法或同步控制语句块中使用，而 sleep() 方法则可以放在任何地方使用；</li><li>sleep() 方法必须捕获异常，而 wait()、notify() 不需要捕获异常。</li></ul><blockquote><p>由于 sleep() 不会释放“锁标志”，容易导致死锁问题的发生，一般情况下，推荐使用 wait() 方法。</p></blockquote><h2 id="终止线程的方法"><a href="#终止线程的方法" class="headerlink" title="终止线程的方法"></a>终止线程的方法</h2><h3 id="stop"><a href="#stop" class="headerlink" title="stop()"></a>stop()</h3><p>当用 Thread.stop() 来终止线程时，它会释放已经锁定的<strong>所有监视资源</strong>，这可能会导致程序执行的不确定性，并且这种问题很难被定位。</p><h3 id="suspend"><a href="#suspend" class="headerlink" title="suspend()"></a>suspend()</h3><p>由于调用 suspend() 方法不会释放锁，这就会容易发生死锁。</p><h3 id="自行结束进入-Dead-状态"><a href="#自行结束进入-Dead-状态" class="headerlink" title="自行结束进入 Dead 状态"></a>自行结束进入 Dead 状态</h3><p>如果想要停止一个线程的执行，就要提供某种方式让线程能够自动结束 run() 方法的执行。在实现时，可以通过设置一个 flag 标志来控制循环是否执行。</p><h2 id="synchronized、Lock-的异同"><a href="#synchronized、Lock-的异同" class="headerlink" title="synchronized、Lock 的异同"></a>synchronized、Lock 的异同</h2><p>Java 语言提供了两种锁机制来实现对某个共享资源的同步：synchronized 和 Lock。<br>其中，synchronized 使用 Object 对象本身的 wait、notify 调度机制；而 Lock 可以使用 Condition 进行线程之间的调度，完成 synchronized 实现的所有功能。</p><h3 id="用法不一样"><a href="#用法不一样" class="headerlink" title="用法不一样"></a>用法不一样</h3><p>synchronized 既可以加在方法上，也可以加在特定代码块中；而 Lock 需要显式地指定起始位置和终止位置。<br>synchronized 是托管给 JVM 执行的，而 Lock 的锁定是通过代码实现的，它有比 synchronized 更精确的线程语义。</p><h3 id="性能不一样"><a href="#性能不一样" class="headerlink" title="性能不一样"></a>性能不一样</h3><p>在资源竞争不是很激烈的情况下，synchronized 的性能要优于 ReetrantLock（重入锁）；<br>但是在资源竞争很激烈的情况下，synchronized 的性能会下降得非常快，而 ReetrantLock 的性能基本保持不变。</p><h3 id="锁机制不一样"><a href="#锁机制不一样" class="headerlink" title="锁机制不一样"></a>锁机制不一样</h3><p>synchronized 获取多个锁时，必须以相反的顺序释放，并且是自动解锁，不会引发死锁；<br>而 Lock 则需要开发人员手动去释放，并且必须在 finally 块中释放，否则会引起死锁问题的发生。Lock 还提供了<strong>更强大的功能</strong>。</p><blockquote><p>因为 ReetrantLock、synchronized 所使用的机制不同，最好不要同时使用这两种同步机制。</p></blockquote><h2 id="守护线程"><a href="#守护线程" class="headerlink" title="守护线程"></a>守护线程</h2><p>Java 提供了<strong>两种线程：</strong>守护线程、用户线程。守护线程并不属于程序中不可或缺的部分，通俗点讲，任何一个守护线程都是整个JVM中所有非守护线程的“保姆”。<br>如果用户线程已经全部退出运行，只剩下守护线程存在，JVM 也就退出了。<br>在 Java 语言中，守护线程一般具有较低的优先级，但用户在编写程序时也可以<strong>自己设置守护线程</strong>。例如，在调用 start() 方法启动线程之前，调用对象的 setDaemon(true) 方法（false：用户线程模式）。</p><blockquote><p>守护线程的一个典型例子就是垃圾回收器。只要 JVM 启动，它始终在运行，实时监控和管理系统中可以被回收的资源。</p></blockquote><h2 id="join-方法的作用"><a href="#join-方法的作用" class="headerlink" title="join() 方法的作用"></a>join() 方法的作用</h2><p>在 Java 语言中，join() 方法的作用是让调用该方法的线程在执行完 run() 方法后，再执行 join() 方法后面的代码。简单点说，就是<strong>将两个线程合并</strong>，用于实现同步功能。</p><hr><h2 id="通过-JDBC-访问数据库"><a href="#通过-JDBC-访问数据库" class="headerlink" title="通过 JDBC 访问数据库"></a>通过 JDBC 访问数据库</h2><p>Java 数据库连接（Java DataBase Connectivity，JDBC），用于在 Java 程序中实现数据库操作功能，java.sql 包中包含了 JDBC 操作数据库的所有类。<br>JDBC 访问数据库的<code>步骤</code>：</p><ol><li>加载 JDBC 驱动器。将数据库的 JDBC 驱动加载到 classpath 中；</li><li>加载 JDBC 驱动，并将其注册到 DriverManager 中。使用反射 Class.forName(String driveName)；</li><li>建立数据库连接，取得 Connection 对象。通过 DriverManager.getConnection(url, username, passwd)；</li><li>建立 Statement 对象或 PrepairedStatement 对象；</li><li>执行 SQL 语句；</li><li>访问结果集 ResultSet 对象；</li><li>依次将 ResultSet、Statement、PreparedStatement、Connection 对象关闭，释放掉所占用资源。使用 rs.close()、con.close() 等。</li></ol><h2 id="JDBC-处理事务的方法"><a href="#JDBC-处理事务的方法" class="headerlink" title="JDBC 处理事务的方法"></a>JDBC 处理事务的方法</h2><p>一个事务是由一条或多条对数据库操作的 SQL 语句组成的一个<code>不可分割</code>的工作单元，只有当事务中的所有操作都正常执行完了，整个事务才会被提交给数据库。<br>在 JDBC 中，一般是通过 commit() 方法或 rollback() 方法来结束事务的操作。其中 commit() 表示完成对<strong>事务的提交</strong>；rollback() 表示完成<strong>事务的回滚</strong>，多用于在处理事务的过程中出现了异常的情况。<br>这两种方法都位于 java.sql.Connection 类中。</p><h2 id="JDBC-的事务隔离级别"><a href="#JDBC-的事务隔离级别" class="headerlink" title="JDBC 的事务隔离级别"></a>JDBC 的事务隔离级别</h2><p>为了解决与“多个线程请求相同数据”相关的问题，事务之间通常会用锁相互隔离开。在 JDBC 中，定义了以下<strong>五种事务隔离级别：</strong></p><ol><li>TRANSACTION_NONE JDB。不支持事务；</li><li>TRANSACTION_READ_UNCOMMITTED。未提交读；</li><li>TRANSACTION_READ_COMMITTED。已提交读；</li><li>TRANSACTION_REPEATABLE_READ。可重复读；</li><li>TRANSACTION_SERIALIZABLE。可序列化，是最高的事务级别。</li></ol><p>可以通过 Connection 对象的 conn.setTransactionLevel() 方法来设置隔离级别，通过 conn.getTransactionIsolation() 方法来确定当前事务的级别。</p><blockquote><p>事务隔离级别越高，为避免冲突所花的精力也就越多。</p></blockquote><h2 id="Class-forName-的作用"><a href="#Class-forName-的作用" class="headerlink" title="Class.forName() 的作用"></a>Class.forName() 的作用</h2><p>在 Java 语言中，任何类只有被装载到 JVM 上才能运行。<br>Class.forName() 方法的作用就是把类加载到 JVM 中，它会返回一个与带有给定字符串名的类或接口相关联的 Class 对象，并且 JVM 会加载这个类，同时 JVM 会执行该类的静态代码段。</p><h2 id="Statement、PreparedStatement、CallableStatement-的区别"><a href="#Statement、PreparedStatement、CallableStatement-的区别" class="headerlink" title="Statement、PreparedStatement、CallableStatement 的区别"></a>Statement、PreparedStatement、CallableStatement 的区别</h2><h3 id="Statement"><a href="#Statement" class="headerlink" title="Statement"></a>Statement</h3><p>用于执行不带参数的简单 SQL 语句，并返回它所生成结果的对象，每次执行 SQL 语句时，数据库都要编译该 SQL 语句。</p><h3 id="PreparedStatement"><a href="#PreparedStatement" class="headerlink" title="PreparedStatement"></a>PreparedStatement</h3><p>表示预编译的 SQL 语句的对象，用于执行带参数的预编译 SQL 语句。<br>虽然 Statement 对象与 PreparedStatement 对象能够完成相同的功能，但相比之下，PreparedStatement 具有以下<code>优点</code>：</p><ul><li>效率更高</li><li>代码可读性和可维护性更好</li><li>安全性更好</li></ul><h3 id="CallableStatement"><a href="#CallableStatement" class="headerlink" title="CallableStatement"></a>CallableStatement</h3><p>提供了用来调用数据库中存储过程的接口，若有输出参数要注册，说明是输出参数。</p><h2 id="getString-方法与-getObject-方法的区别"><a href="#getString-方法与-getObject-方法的区别" class="headerlink" title="getString() 方法与 getObject() 方法的区别"></a>getString() 方法与 getObject() 方法的区别</h2><p>JDBC 提供了 getString()、getObject() 等方法从 ResultSet 中获取数据。程序会一次性地把数据都放到内存中，当查询结果集中的<code>数据量</code>较小时，不用考虑性能，使用这些方法完全能够满足需求；<br>当数据量大到内存中放不下时，使用 getObject() 方法。数据不会一次性被读到内存中，每次调用时会直接从数据库中去获取数据。</p><h2 id="使用-JDBC-时需要注意的问题"><a href="#使用-JDBC-时需要注意的问题" class="headerlink" title="使用 JDBC 时需要注意的问题"></a>使用 JDBC 时需要注意的问题</h2><ul><li>与数据库的连接是非常重要的资源，JDBC 连接池提供了数目有限的连接。编程时，一定要保证释放不再使用的连接；</li><li>在使用 JDBC 访问数据库时，createStatement、prepareStatement 最好放在循环外面，如果把对这两个方法的调用放到循环内，会一直不停地打开 cursor（游标）。</li></ul><h2 id="JDO"><a href="#JDO" class="headerlink" title="JDO"></a>JDO</h2><p>Java 数据对象（Java Data Object，JDO），是一种用于存取某种数据仓库中的对象的<strong>标准化 API</strong>，它使开发人员能够间接地访问数据库。</p><ul><li>JDO 是 JDBC 的一个补充，存储数据对象完全不需要额外的代码，这些繁琐的工作已经转移到 JDO 产品提供商身上，使开发人员解脱出来；</li><li>JDO 更灵活、更通用，提供了到任何数据底层（关系数据库、文件、XML 等）的存储功能，使得应用可移植性更强。</li></ul><h2 id="JDBC-与-Hibernate-的区别"><a href="#JDBC-与-Hibernate-的区别" class="headerlink" title="JDBC 与 Hibernate 的区别"></a>JDBC 与 Hibernate 的区别</h2><p>Hibernate 是 JDBC 的封装，采用<code>配置文件</code>的形式将数据库的连接参数写到 XML 文件中。对数据库的访问还是通过 JDBC 来完成的。</p><ul><li>Hibernate 是一个<strong>持久化框架</strong>，使用 HQL（Hibernate Query Language）查询，查询语句返回的是 List；</li><li>Hibernate 具有访问层（DAO 层），是 HQL 查询语句唯一出现的位置。如果表名改变了，只需修改 DAO 层的类即可，具有很好的维护性和扩展性。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 语言精要-3</title>
      <link href="2017/12/31/Python-%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81-3/"/>
      <url>2017/12/31/Python-%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81-3/</url>
      
        <content type="html"><![CDATA[<h2 id="列表、集合以及字典的推导式"><a href="#列表、集合以及字典的推导式" class="headerlink" title="列表、集合以及字典的推导式"></a>列表、集合以及字典的推导式</h2><p><strong>列表推导式</strong>是最受欢迎的 Python 的语言特性之一，只需一条简洁的表达式，即可对一组元素进行过滤，并对得到的元素进行转换变形。基本形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><p>这相当于下面这段 for 循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="keyword">for</span> val <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="keyword">if</span> condition:</span><br><span class="line">        result.append(expr)</span><br></pre></td></tr></table></figure><p>过滤条件可以省略。滤除长度小于等于 2 的字符串，并将剩下的字符串转换成大写字母形式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">strings = [<span class="string">'a'</span>, <span class="string">'as'</span>, <span class="string">'bat'</span>, <span class="string">'car'</span>, <span class="string">'dove'</span>, <span class="string">'python'</span>]</span><br><span class="line">[x.upper() <span class="keyword">for</span> x <span class="keyword">in</span> strings <span class="keyword">if</span> len(x) &gt; <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'BAT'</span>, <span class="string">'CAR'</span>, <span class="string">'DOVE'</span>, <span class="string">'PYTHON'</span>]</span><br></pre></td></tr></table></figure><a id="more"></a><p><strong>字典推导式</strong>的基本形式，产生的是字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dict_comp = &#123;key_expr:value_expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure><p><strong>集合推导式</strong>的基本形式，跟列表推导式的唯一区别就是花括号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set_comp = &#123;expr <span class="keyword">for</span> value <span class="keyword">in</span> collection <span class="keyword">if</span> condition&#125;</span><br></pre></td></tr></table></figure><p>推导式都只是<strong>语法糖</strong>而已，使代码变得更容易读写。<br>构造一个集合，其内容为列表字符串的各种长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unique_lengths = &#123;len(x) <span class="keyword">for</span> x <span class="keyword">in</span> strings&#125;</span><br><span class="line">unique_lengths</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">6</span>])</span><br></pre></td></tr></table></figure><p>为这些字符串创建一个指向其列表位置的映射关系：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">loc_mapping = &#123;val:index <span class="keyword">for</span> index, val <span class="keyword">in</span> enumerate(strings)&#125;</span><br><span class="line">loc_mapping</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'a'</span>:<span class="number">0</span>, <span class="string">'as'</span>:<span class="number">1</span>, <span class="string">'bat'</span>:<span class="number">2</span>, <span class="string">'car'</span>:<span class="number">3</span>, <span class="string">'dove'</span>:<span class="number">4</span>, <span class="string">'python'</span>:<span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="嵌套列表推导式"><a href="#嵌套列表推导式" class="headerlink" title="嵌套列表推导式"></a>嵌套列表推导式</h3><p>嵌套 for 循环中各个 for 的顺序是怎样的，嵌套推导式中各个 for 表达式的顺序就是怎样的。将一个由整数元组构成的列表<strong>扁平化</strong>为一个简单的整数列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_tuples = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line">flattened = [x <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples <span class="keyword">for</span> x <span class="keyword">in</span> tup]</span><br><span class="line">flattened</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br></pre></td></tr></table></figure><p>如果嵌套超过两三层，就需要思考一下<strong>数据结构</strong>的设计问题了。注意与“列表推导式中的列表推导式”之间的区别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[x <span class="keyword">for</span> x <span class="keyword">in</span> tup] <span class="keyword">for</span> tup <span class="keyword">in</span> some_tuples]</span><br></pre></td></tr></table></figure><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数是用 def 关键字声明的，并使用 return 关键字返回。可以有一些<strong>位置参数</strong>（positional）和一些<strong>关键字参数</strong>（keyword）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_function</span><span class="params">(x, y, z=<span class="number">1.5</span>)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> z &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> z * (x + y)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> z / (x + y)</span><br></pre></td></tr></table></figure><blockquote><p>关键字参数必须位于位置参数之后，你可以任何顺序指定关键字参数。</p></blockquote><h3 id="命名空间、作用域，以及局部函数"><a href="#命名空间、作用域，以及局部函数" class="headerlink" title="命名空间、作用域，以及局部函数"></a>命名空间、作用域，以及局部函数</h3><p>函数可以访问两种不同作用域中的变量：<strong>全局</strong>（global）和<strong>局部</strong>（local）。局部命名空间（namespace）是在函数被调用时创建的，执行完毕之后就会被销毁。<br>在函数中对全局变量进行赋值操作，必须用 <strong>global</strong> 关键字声明成全局的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="literal">None</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bind_a_variable</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> a</span><br><span class="line">    a = []</span><br></pre></td></tr></table></figure><blockquote><p>不要频繁使用 global 关键字，因为全局变量一般是用于存放系统的某些状态的。如果用了很多，说明需要面向对象编程（使用类）。</p></blockquote><p>严格意义上来说，所有函数都是某个作用域的局部函数。</p><h3 id="返回多个值"><a href="#返回多个值" class="headerlink" title="返回多个值"></a>返回多个值</h3><p>许多函数都可能会有多个输出（在该函数内部计算出的数据结构或其他辅助数据），其实只返回了一个对象，也就是<strong>一个元组</strong>。<br>返回字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">()</span>:</span></span><br><span class="line">    a = <span class="number">5</span></span><br><span class="line">    b = <span class="number">6</span></span><br><span class="line">    c = <span class="number">7</span></span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">'a'</span>:a, <span class="string">'b'</span>:b, <span class="string">'c'</span>:c&#125;</span><br></pre></td></tr></table></figure><h3 id="函数亦为对象"><a href="#函数亦为对象" class="headerlink" title="函数亦为对象"></a>函数亦为对象</h3><p>假设我们有下面这样一个字符串数组，希望对其进行一些数据清理工作并执行一堆转换：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">states = [<span class="string">'Alabama '</span>, <span class="string">'Georgia!'</span>, <span class="string">'Georgia'</span>, <span class="string">'georgia'</span>, <span class="string">'FlOrIda'</span>, <span class="string">'south   carolina##'</span>, <span class="string">'West virginia?'</span>]</span><br></pre></td></tr></table></figure><p>将需要在一组给定字符串上执行的所有运算做成一个列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除标点符号</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">remove_punctuation</span><span class="params">(value)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> re.sub(<span class="string">'[!#?]'</span>, <span class="string">''</span>, value)</span><br><span class="line">clean_ops = [str.strip, remove_punctuation, str.title]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">clean_strings</span><span class="params">(strings, ops)</span>:</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> strings:</span><br><span class="line">        <span class="keyword">for</span> function <span class="keyword">in</span> ops:</span><br><span class="line">            value = function(value)</span><br><span class="line">        result.append(value)</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>然后我们就有了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">clean_strings(states, clean_ops)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Alabama'</span>, <span class="string">'Georgia'</span>, <span class="string">'Georgia'</span>, <span class="string">'Georgia'</span>, <span class="string">'Florida'</span>, <span class="string">'South   Carolina'</span>, <span class="string">'West Virginia'</span>]</span><br></pre></td></tr></table></figure><p>这种多函数模式，能在很高的层次上，轻松修改字符串的转换方式。此时的 clean_strings 也更具<strong>可复用性</strong>。<br>还可以将函数用作其他函数的参数。<strong>map 函数</strong>用于在一组数据上应用一个函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">map(remove_punctuation, states)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Alabama '</span>, <span class="string">'Georgia'</span>, <span class="string">'Georgia'</span>, <span class="string">'georgia'</span>, <span class="string">'FlOrIda'</span>, <span class="string">'south   carolina'</span>, <span class="string">'West virginia'</span>]</span><br></pre></td></tr></table></figure><h3 id="匿名（lambda）函数"><a href="#匿名（lambda）函数" class="headerlink" title="匿名（lambda）函数"></a>匿名（lambda）函数</h3><p>仅由<strong>单条语句</strong>组成，该语句的结果就是返回值。<br>通过 <strong>lambda</strong> 关键字定义的，没有别的含义，仅仅是说“我们正在声明的是一个匿名函数”。<br>很多数据转换函数都以函数作为参数，直接传入 lambda 函数比编写完整的函数声明要少输入很多字，也更清晰：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_to_list</span><span class="params">(some_list, f)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> [f(x) <span class="keyword">for</span> x <span class="keyword">in</span> some_list]</span><br><span class="line">ints = [<span class="number">4</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>apply_to_list(ints, <span class="keyword">lambda</span> x: x * <span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>根据各字符串不同字母的数量对其进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">strings = [<span class="string">'foo'</span>, <span class="string">'card'</span>, <span class="string">'bar'</span>, <span class="string">'aaaa'</span>, <span class="string">'abab'</span>]</span><br><span class="line">strings.sort(key=<span class="keyword">lambda</span> x: len(set(list(x))))</span><br><span class="line">strings</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'aaaa'</span>, <span class="string">'foo'</span>, <span class="string">'abab'</span>, <span class="string">'bar'</span>, <span class="string">'card'</span>]</span><br></pre></td></tr></table></figure><blockquote><p>lambda 函数之所以会被称为匿名函数，原因之一就是这种函数对象，本身是没有提供名称属性的。</p></blockquote><h3 id="闭包：返回函数的函数"><a href="#闭包：返回函数的函数" class="headerlink" title="闭包：返回函数的函数"></a>闭包：返回函数的函数</h3><p>闭包就是由其他函数动态生成，并返回的函数。<br><strong>关键性质：</strong>被返回的函数可以访问，其创建者局部命名空间中的变量。<br>虽然可以修改任何内部状态对象（比如向字典添加键值对），但不能绑定外层函数作用域中的变量。解决办法是，修改字典或列表，而不是绑定变量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_counter</span><span class="params">()</span>:</span></span><br><span class="line">    count = [<span class="number">0</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">()</span>:</span></span><br><span class="line">        count[<span class="number">0</span>] += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> count[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">return</span> counter</span><br><span class="line"></span><br><span class="line">cnt = make_counter()</span><br></pre></td></tr></table></figure><p>可以编写带有大量选项的非常一般化的函数，然后再组装出更简单、更专门化的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">format_and_pad</span><span class="params">(template, space)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">formatter</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (template % x).rjust(space)</span><br><span class="line">    <span class="keyword">return</span> formatter</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个始终返回 15 位字符串的浮点数格式化器</span></span><br><span class="line">fmt = format_and_pad(<span class="string">'%.4f'</span>, <span class="number">15</span>)</span><br><span class="line">fmt(<span class="number">1.756</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'         1.7560'</span></span><br></pre></td></tr></table></figure><blockquote><p>通过面向对象编程，这种模式也能用类来实现。</p></blockquote><h3 id="扩展调用语法和-args、-kwargs"><a href="#扩展调用语法和-args、-kwargs" class="headerlink" title="扩展调用语法和 args、*kwargs"></a>扩展调用语法和 <em>args、*</em>kwargs</h3><p>在 Python 中，函数参数的工作方式其实很简单，位置和关键字参数分别被打包成元组和字典。<br>这一切都是在幕后悄悄发生的，函数实际接收到的是一个<strong>元组 args</strong> 和一个<strong>字典 kwargs</strong>。</p><h3 id="柯里化：部分参数应用"><a href="#柯里化：部分参数应用" class="headerlink" title="柯里化：部分参数应用"></a>柯里化：部分参数应用</h3><p>柯里化（currying）指的是：通过<strong>部分参数应用</strong>（partial argument application）从现有函数派生出新函数的技术。<br>其实只是定义了一个可以调用现有函数的新函数而已：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_numbers</span><span class="params">(x, y)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line">add_five = <span class="keyword">lambda</span> y: add_numbers(<span class="number">5</span>, y)</span><br></pre></td></tr></table></figure><p>add_numbers 的第二个参数称为“柯里化的”。内置的 functools 模块可以用 <strong>partial 函数</strong>将此过程简化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line">add_five = partial(add_numbers, <span class="number">5</span>)</span><br></pre></td></tr></table></figure><h3 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h3><p>能以一种一致的方式对序列进行迭代，是 Python 的一个重要特点。这是通过一种叫做迭代器协议（iterator protocol）的方式实现的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">some_dict = &#123;<span class="string">'a'</span>:<span class="number">1</span>, <span class="string">'b'</span>:<span class="number">2</span>, <span class="string">'c'</span>:<span class="number">3</span>&#125;</span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> some_dict:</span><br><span class="line">    <span class="keyword">print</span> key,    <span class="comment"># 注意逗号</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>a c b</span><br></pre></td></tr></table></figure><p><strong>迭代器</strong>是一种特殊对象，当你编写 for key in some_dict 时，Python 解释器首先会尝试从 some_dict 创建一个迭代器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dict_iterator = iter(some_dict)</span><br><span class="line">dict_iterator</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;dictionary-keyiterator at <span class="number">0x10a0a1578</span>&gt;</span><br></pre></td></tr></table></figure><p><strong>生成器</strong>（generator）是构造可迭代对象的一种简单方式。生成器以<strong>延迟</strong>的方式返回一个值序列，即每返回一个值之后暂停，直到下一个值被请求时再继续。<br>要创建一个生成器，只需要将函数中的 return 替换为 <strong>yeild</strong> 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">squares</span><span class="params">(n=<span class="number">10</span>)</span>:</span></span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Generating squares from 1 to %d'</span> % (n ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">yield</span> i ** <span class="number">2</span></span><br></pre></td></tr></table></figure><p>调用该生成器时，没有任何代码会被立即执行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">gen = squares()</span><br><span class="line">gen</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&lt;generator object squares at <span class="number">0x34c8280</span>&gt;</span><br></pre></td></tr></table></figure><p>直到你从该生成器中请求元素时，它才会开始执行其代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> gen:</span><br><span class="line">    <span class="keyword">print</span> x,</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Generating squares <span class="keyword">from</span> <span class="number">1</span> to <span class="number">100</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span> <span class="number">4</span> <span class="number">9</span> <span class="number">16</span> <span class="number">25</span> <span class="number">36</span> <span class="number">49</span> <span class="number">64</span> <span class="number">81</span> <span class="number">100</span></span><br></pre></td></tr></table></figure><h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>生成器表达式（generator expression）是构造生成器的最简单方式。类似于列表、字典、集合推导式，创建方式为，把列表推导式两端的方括号改成圆括号：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">gen = (x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">100</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 与下面这个冗长的生成器，完全等价</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_gen</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">100</span>):</span><br><span class="line">        <span class="keyword">yield</span> x ** <span class="number">2</span></span><br><span class="line">gen = make_gen()</span><br></pre></td></tr></table></figure><p>生成器表达式可用于任何接受生成器的 Python 函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sum(x ** <span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> xrange(<span class="number">100</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">328350</span></span><br><span class="line"></span><br><span class="line">dict((i, i ** <span class="number">2</span>) <span class="keyword">for</span> i <span class="keyword">in</span> xrange(<span class="number">5</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">0</span>:<span class="number">0</span>, <span class="number">1</span>:<span class="number">1</span>, <span class="number">2</span>:<span class="number">4</span>, <span class="number">3</span>:<span class="number">9</span>, <span class="number">4</span>:<span class="number">16</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="itertools-模块"><a href="#itertools-模块" class="headerlink" title="itertools 模块"></a>itertools 模块</h4><p>标准库 itertools 模块中有一组用于许多常见数据算法的生成器。例如，groupby 可以接受任何序列和一个函数，根据函数的返回值，对序列中的连续元素<strong>进行分组：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> itertools</span><br><span class="line">first_letter = <span class="keyword">lambda</span> x: x[<span class="number">0</span>]</span><br><span class="line">names = [<span class="string">'Alan'</span>, <span class="string">'Adam'</span>, <span class="string">'Wes'</span>, <span class="string">'Will'</span>, <span class="string">'Albert'</span>, <span class="string">'Steven'</span>]</span><br><span class="line"><span class="keyword">for</span> letter, names <span class="keyword">in</span> itertools.groupby(names, first_letter):</span><br><span class="line">    <span class="keyword">print</span> letter, list(names)    <span class="comment"># names 是一个生成器</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A [<span class="string">'Alan'</span>, <span class="string">'Adam'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>W [<span class="string">'Wes'</span>, <span class="string">'Will'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>A [<span class="string">'Albert'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>S [<span class="string">'Steven'</span>]</span><br></pre></td></tr></table></figure><h2 id="文件和操作系统"><a href="#文件和操作系统" class="headerlink" title="文件和操作系统"></a>文件和操作系统</h2><p>Python 在文本和文件处理方面很流行。<br>为了打开一个文件以便读写，可以使用内置的 <strong>open 函数</strong>以及一个相对或绝对的文件路径：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">path = <span class="string">'ch13/segismundo.txt'</span></span><br><span class="line">f = open(path)</span><br></pre></td></tr></table></figure><p>默认情况下，文件是以只读模式（’r’）打开的。然后，我们就可以处理这个文件<strong>句柄</strong> f 了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>Python 的文件模式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/python/python_3.jpeg" alt><br>重要的 Python 文件方法或属性：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/python/python_4.jpeg" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 语言精要-2</title>
      <link href="2017/12/27/Python-%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81-2/"/>
      <url>2017/12/27/Python-%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81-2/</url>
      
        <content type="html"><![CDATA[<h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组（tuple）是一种一维的、定长的、<strong>不可变的</strong>Python 对象序列。最简单的创建方式是一组以逗号隔开的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup = <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span></span><br><span class="line">tup</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure><p>任何序列或迭代器都可以被转换为元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tup = tuple(<span class="string">'string'</span>)</span><br><span class="line">tup</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'s'</span>, <span class="string">'t'</span>, <span class="string">'r'</span>, <span class="string">'i'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>)</span><br></pre></td></tr></table></figure><p>元组的元素也可以通过方括号（[]）进行访问。<br>元组可以通过加号（+）运算符连接起来以产生更长的元组。<br>一个元组乘以一个整数，相当于是连接该元组的<strong>多个副本：</strong></p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="string">'foo'</span>, <span class="string">'bar'</span>) * <span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'foo'</span>, <span class="string">'bar'</span>)</span><br></pre></td></tr></table></figure><h3 id="元组拆包"><a href="#元组拆包" class="headerlink" title="元组拆包"></a>元组拆包</h3><p>对元组型变量表达式进行赋值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br><span class="line">a, b, c = tup</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span></span><br></pre></td></tr></table></figure><p>非常轻松地交换变量名：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">b, a = a, b</span><br></pre></td></tr></table></figure><p>对由元组或列表组成的序列进行迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>), (<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>), (<span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>)]</span><br><span class="line"><span class="keyword">for</span> a, b, c <span class="keyword">in</span> seq:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>处理从函数中返回的多个值。</p><h3 id="元组方法"><a href="#元组方法" class="headerlink" title="元组方法"></a>元组方法</h3><p>由于元组的<strong>大小和内存不能被修改</strong>，所以其实例方法很少。count 用于计算指定值的出现次数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line">a.count(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表（list）是变长的，其内容也是可以修改的，可以通过<strong>方括号（[]）或 list 函数</strong>进行定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tup = (<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>)</span><br><span class="line">b_list = list(tup)</span><br><span class="line">b_list</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br></pre></td></tr></table></figure><h3 id="添加和移除元素"><a href="#添加和移除元素" class="headerlink" title="添加和移除元素"></a>添加和移除元素</h3><p>通过 <strong>append</strong> 方法，可以将元素添加到列表的末尾：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b_list.append(<span class="string">'dwarf'</span>)</span><br><span class="line">b_list</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>, <span class="string">'dwarf'</span>]</span><br></pre></td></tr></table></figure><p>利用 <strong>insert</strong> 可以将元素插入到列表的指定位置：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b_list.insert(<span class="number">1</span>, <span class="string">'red'</span>)</span><br><span class="line">b_list</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'foo'</span>, <span class="string">'red'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>, <span class="string">'dwarf'</span>]</span><br></pre></td></tr></table></figure><p>insert 的逆运算是 <strong>pop</strong>，用于移除并返回指定索引处的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b_list.pop(<span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'bar'</span></span><br><span class="line"></span><br><span class="line">b_list</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'foo'</span>, <span class="string">'red'</span>, <span class="string">'baz'</span>, <span class="string">'dwarf'</span>]</span><br></pre></td></tr></table></figure><p><strong>remove</strong> 用于按值删除元素（删除第一个符合要求的值）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b_list.remove(<span class="string">'foo'</span>)</span><br><span class="line">b_list</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'red'</span>, <span class="string">'baz'</span>, <span class="string">'dwarf'</span>]</span><br></pre></td></tr></table></figure><p>通过 <strong>in</strong> 关键字，可以判断列表中是否含有某个值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'dwarf'</span> <span class="keyword">in</span> b_list</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure><blockquote><p>判断列表是否含有某个值的操作比字典和集合<strong>慢得多</strong>，因为 Python 会对列表中的值进行线性扫描，而另外两个基于哈希表，可以瞬间完成判断。</p></blockquote><h3 id="合并列表"><a href="#合并列表" class="headerlink" title="合并列表"></a>合并列表</h3><p>列表的合并是一种相当费资源的操作，必须创建一个<strong>新列表</strong>并将所有对象复制过去；用 <strong>extend</strong> 将元素附加到现有列表，就会好很多：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = [<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>]</span><br><span class="line">x.extend([<span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)])</span><br><span class="line">x</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">4</span>, <span class="literal">None</span>, <span class="string">'foo'</span>, <span class="number">7</span>, <span class="number">8</span>, (<span class="number">2</span>, <span class="number">3</span>)]</span><br></pre></td></tr></table></figure><h3 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h3><p>调用列表的 <strong>sort</strong> 方法可以实现就地排序（无需创建新对象）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">3</span>]</span><br><span class="line">a.sort()</span><br><span class="line">a</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><p>sort 有几个很不错的选项。<strong>次要排序键</strong>：一个能够产生可用于排序的值的函数。<br>可以通过长度对一组字符串进行排序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b = [<span class="string">'saw'</span>, <span class="string">'small'</span>, <span class="string">'He'</span>, <span class="string">'foxes'</span>, <span class="string">'six'</span>]</span><br><span class="line">b.sort(key=len)</span><br><span class="line">b</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'He'</span>, <span class="string">'saw'</span>, <span class="string">'six'</span>, <span class="string">'small'</span>, <span class="string">'foxes'</span>]</span><br></pre></td></tr></table></figure><h3 id="二分搜索及维护有序列表"><a href="#二分搜索及维护有序列表" class="headerlink" title="二分搜索及维护有序列表"></a>二分搜索及维护有序列表</h3><p>内置的 <strong>bisect 模块</strong>实现了二分查找以及对有序列表的插入操作：</p><ul><li>bisect.bisect 可以找出新元素应该被插入的位置。</li><li>bisect.insort 确实地将新元素插入到那个位置上去。</li></ul><blockquote><p>bisect 模块的函数不会判断原列表是否是有序的。将它们用于无序列表虽然不会报错，但可能导致不正确的结果。</p></blockquote><h3 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h3><p>通过切片标记法，可以选取<strong>序列类型</strong>的子集，其基本形式由索引运算符（[]）以及传入其中的 start:stop 构成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="number">7</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br><span class="line">seq[<span class="number">1</span>:<span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>stop 索引处的元素是未被包括在内的，元素的数量是 stop - start。<br>start 或 stop 都是<strong>可以省略</strong>的，此时它们分别默认为序列的起始处和结尾处，负数索引从序列的末尾开始切片：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq[<span class="number">-4</span>:]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">5</span>, <span class="number">6</span>, <span class="number">0</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/python/python_2.jpeg" alt><br>还可以在第二个冒号后面加上步长（step），实现每隔一位取出一个元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq[::<span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">7</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure><p>使用 -1 是一个很巧妙的方法，可以实现列表或元组的反序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq[::<span class="number">-1</span>]</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">0</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">7</span>]</span><br></pre></td></tr></table></figure><h2 id="内置的序列函数"><a href="#内置的序列函数" class="headerlink" title="内置的序列函数"></a>内置的序列函数</h2><p>Python 有一些很不错的序列函数，你应该熟悉它们，只要有机会就用。</p><h3 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h3><p>在对一个序列进行迭代时，常常需要跟踪当前项的索引。<br>Python 内置了一个 enumerate 函数，可以逐个返回序列的 (i, value) 元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i, value <span class="keyword">in</span> enumerate(collection):</span><br><span class="line">    <span class="comment"># 用 value 做一些事情</span></span><br></pre></td></tr></table></figure><h3 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h3><p>sorted 函数可以将任何序列返回为一个新的有序列表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sorted(<span class="string">'horse race'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">' '</span>, <span class="string">'a'</span>, <span class="string">'c'</span>, <span class="string">'e'</span>, <span class="string">'e'</span>, <span class="string">'h'</span>, <span class="string">'o'</span>, <span class="string">'r'</span>, <span class="string">'r'</span>, <span class="string">'s'</span>]</span><br></pre></td></tr></table></figure><h3 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h3><p>zip 用于将多个序列中的元素配对，从而产生一个新的<strong>元组列表</strong>。zip 可以接受任意数量的序列，得到的元组数量由最短的序列决定：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">seq1 = [<span class="string">'foo'</span>, <span class="string">'bar'</span>, <span class="string">'baz'</span>]</span><br><span class="line">seq2 = [<span class="string">'one'</span>, <span class="string">'two'</span>, <span class="string">'three'</span>]</span><br><span class="line">seq3 = [<span class="literal">False</span>, <span class="literal">True</span>]</span><br><span class="line">zip(seq1, seq2, seq3)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[(<span class="string">'foo'</span>, <span class="string">'one'</span>, <span class="literal">False</span>), (<span class="string">'bar'</span>, <span class="string">'two'</span>, <span class="literal">True</span>)]</span><br></pre></td></tr></table></figure><h3 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h3><p>reversed 用于按逆序迭代序列中的元素：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">list(reversed(range(<span class="number">10</span>)))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">9</span>, <span class="number">8</span>, <span class="number">7</span>, <span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">0</span>]</span><br></pre></td></tr></table></figure><h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典（dict）更常见的名字是哈希映射（hash map），是一种大小可变的<strong>键值对集</strong>。创建字典的方式之一是：使用大括号（{}）并用冒号分隔键和值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">empty_dict = &#123;&#125;</span><br><span class="line">d1 = &#123;<span class="string">'a'</span>:<span class="string">'some value'</span>, <span class="string">'b'</span>:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br><span class="line">d1</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'a'</span>:<span class="string">'some value'</span>, <span class="string">'b'</span>:[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]&#125;</span><br></pre></td></tr></table></figure><p>keys 和 values 方法分别用于获取键和值的列表。虽然键值对没有特定的顺序，但这两个函数会以<strong>相同的顺序</strong>输出键和值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">d1.keys()</span><br><span class="line">[<span class="string">'b'</span>, <span class="string">'a'</span>]</span><br><span class="line"></span><br><span class="line">d1.values()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="string">'some value'</span>]</span><br></pre></td></tr></table></figure><p>利用 <strong>update</strong> 方法，一个字典可以被合并到另一个字典中去：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">d1.update(&#123;<span class="string">'b'</span>:<span class="string">'foo'</span>, <span class="string">'c'</span>:<span class="number">12</span>&#125;)</span><br><span class="line">d1</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'a'</span>:<span class="string">'some value'</span>, <span class="string">'b'</span>:<span class="string">'foo'</span>, <span class="string">'c'</span>:<span class="number">12</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="从序列类型创建字典"><a href="#从序列类型创建字典" class="headerlink" title="从序列类型创建字典"></a>从序列类型创建字典</h3><p>我们完全可以用 dict 类型函数，直接将两个序列中的元素两两配对地组成一个字典：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mapping = dict(zip(range(<span class="number">5</span>), reversed(range(<span class="number">5</span>))))</span><br><span class="line">mapping</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="number">0</span>:<span class="number">4</span>, <span class="number">1</span>:<span class="number">3</span>, <span class="number">2</span>:<span class="number">2</span>, <span class="number">3</span>:<span class="number">1</span>, <span class="number">4</span>:<span class="number">0</span>&#125;</span><br></pre></td></tr></table></figure><h3 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h3><p>dict 的 <strong>get</strong> 和 <strong>pop</strong> 方法可以接受一个可供返回的默认值（如果 key 不存在，get 默认返回 None，pop 会引发异常）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> key <span class="keyword">in</span> some_dict:</span><br><span class="line">    value = some_dict[key]</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    value = default_value</span><br></pre></td></tr></table></figure><p>上面的 if-else 块可以被简单地写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = some_dict.get(key, default_value)</span><br></pre></td></tr></table></figure><p>常常会将字典中的值处理成别的<strong>集类型</strong>（比如列表），根据首字母对一组单词进行分类：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">word = [<span class="string">'apple'</span>, <span class="string">'bat'</span>, <span class="string">'bar'</span>, <span class="string">'atom'</span>, <span class="string">'book'</span>]</span><br><span class="line">by_letter = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    letter = word[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">if</span> letter <span class="keyword">not</span> <span class="keyword">in</span> by_letter:</span><br><span class="line">        by_letter[letter] = [word]</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        by_letter[letter].append(word)</span><br><span class="line"></span><br><span class="line">by_letter</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'a'</span>:[<span class="string">'apple'</span>, <span class="string">'atom'</span>], <span class="string">'b'</span>:[<span class="string">'bat'</span>, <span class="string">'bar'</span>, <span class="string">'book'</span>]&#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>setdefault</strong> 方法，上面的 if-else 块可以写成：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">by_letter.setdefault(letter, []).append(word)</span><br></pre></td></tr></table></figure><p>内置的 collections 模块有一个叫做 <strong>defaultdict</strong> 的类，传入一个类型或函数，用于生成字典各插槽所使用的默认值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> colletions <span class="keyword">import</span> defaultdict</span><br><span class="line">by_letter = defaultdict(list)</span><br><span class="line"><span class="keyword">for</span> word <span class="keyword">in</span> words:</span><br><span class="line">    by_letter[word[<span class="number">0</span>]].append(word)</span><br></pre></td></tr></table></figure><p>defaultdict 的初始化器只需要一个可调用对象，将默认值设置为 4：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">counts = defaultdict(<span class="keyword">lambda</span>: <span class="number">4</span>)</span><br></pre></td></tr></table></figure><h3 id="字典键的有效类型"><a href="#字典键的有效类型" class="headerlink" title="字典键的有效类型"></a>字典键的有效类型</h3><p>字典的值可以是任何 Python 对象，但键必须是不可变对象。术语是可哈希性，可通过 hash 函数判断：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TypeError</span></span><br><span class="line">hash((<span class="number">1</span>, <span class="number">2</span>, [<span class="number">2</span>, <span class="number">3</span>]))</span><br></pre></td></tr></table></figure><p>如果要将列表当作键，最简单的方法就是将其转换成元组。</p><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合（set）是由唯一元素组成的无序集，可以看成是<strong>只有键的字典</strong>。创建方式为 set 函数或大括号包起来的集合字面量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">set([<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">3</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>支持各种数学集合运算：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line">b = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;</span><br><span class="line"><span class="comment"># 对称差（异或）</span></span><br><span class="line">a ^ b</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set([<span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>])</span><br></pre></td></tr></table></figure><p>还可以判断一个集合是否是另一个集合的子集或超集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_set = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;</span><br><span class="line"></span><br><span class="line">&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;.issubset(a_set)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">a_set.isuperset(&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 11：旋转数组的最小数字</title>
      <link href="2017/12/21/%E9%9D%A2%E8%AF%95%E9%A2%98-11%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
      <url>2017/12/21/%E9%9D%A2%E8%AF%95%E9%A2%98-11%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如，数组 {3, 4, 5, 1, 2} 为 {1, 2, 3, 4, 5} 的一个旋转，该数组的最小值为 1。</p></blockquote><ul><li><strong>查找</strong>较为简单，不外乎顺序查找、二分查找、哈希表查找、二叉排序树查找。</li><li>遇到排序的数组（或者部分排序的数组），可以尝试用<strong>二分查找</strong>算法。</li><li>哈希表和二叉排序树查找的重点在于考查对应的数据结构，而不是算法：<ul><li><strong>哈希表</strong>最主要的优点是能够在 O(1) 时间内查找某一元素（效率最高），缺点是需要额外的空间；</li><li><strong>二叉排序树</strong>对应的数据结构是二叉搜索树。</li></ul></li><li><strong>排序</strong>复杂一些，要求比较插入排序、冒泡排序、归并排序、快速排序等不同算法的优劣。</li><li>要求应聘者写出快速排序的代码：Partition 函数 + 递归。<a id="more"></a></li></ul><p>应聘者一定要问清楚排序应用的环境是什么、有哪些约束条件。<br>无论移动第一个指针还是第二个指针，查找范围都会缩小到原来的一半。<br>最终，会指向两个相邻的元素，第二个指针指向的刚好是最小的元素。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/11_1.jpeg" alt><br>排序数组本身是数组旋转的一个特例；要考虑到数组中有相同数字的特例。</p><p><a href="https://gist.githubusercontent.com/snlndod/a88c202093a424346fd83f540847d252/raw/87208f33f2bc257f94a350f96770309fb67c11f3/11_MinNumberInRotatedArray.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 10：斐波那契数列</title>
      <link href="2017/12/18/%E9%9D%A2%E8%AF%95%E9%A2%98-10%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/"/>
      <url>2017/12/18/%E9%9D%A2%E8%AF%95%E9%A2%98-10%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>题目一：求斐波那契数列的第 n 项。<br>写一个函数，输入 n，求 Fibonacci 数列的第 n 项，斐波那契数列的定义如下：</p></blockquote><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/10_1.jpeg" alt></p><ul><li><strong>递归</strong>是在一个函数的内部调用这个函数自身；<strong>循环</strong>则是通过设置计算的初始值及终止条件，在一个范围内重复计算。</li><li>如果没有特别的要求，应聘者可以尽量多采用递归的方法编程，可能引起：<strong>调用栈溢出</strong>。</li><li>每一次函数调用，都需要在内存中分配空间以保存参数、返回地址、临时变量，而且往栈里压入数据和弹出数据都需要时间。</li></ul><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">Fibonacci</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">int</span> n)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Fibonacci(n<span class="number">-1</span>) + Fibonacci(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/10_2.jpeg" alt><br>在这棵树中有很多节点是重复的。重复的节点数会随着 n 的增大而急剧增加，往往意味着<strong>计算量</strong>的增大。<br>只要想办法避免重复计算就行了，比如我们可以把已经得到的数列中间项保存起来。更简单的做法是把递归的算法用循环实现，<strong>从下往上计算</strong>。</p><blockquote><p>题目二：青蛙跳台阶问题。<br>一只青蛙一次可以跳上 1 级台阶，也可以跳上 2 级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。</p></blockquote><ul><li>第一次跳的时候有两种不同的选择：一是第一次只跳 1 级；二是第一次跳 2 级。</li></ul><p><a href="https://gist.githubusercontent.com/snlndod/e4adb29942c20eb30575d2812c30e149/raw/b6bdc1a838e17ae8c2d234514748332d79089a4d/10_Fibonacci.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识 SLAM</title>
      <link href="2017/12/08/%E5%88%9D%E8%AF%86-SLAM/"/>
      <url>2017/12/08/%E5%88%9D%E8%AF%86-SLAM/</url>
      
        <content type="html"><![CDATA[<h2 id="引子：小萝卜的例子"><a href="#引子：小萝卜的例子" class="headerlink" title="引子：小萝卜的例子"></a>引子：小萝卜的例子</h2><p>希望小萝卜具有<strong>自主运动能力</strong>。<br>定位和建图可以看成感知的<code>内外之分</code>：</p><ul><li>一方面，要明白自身的状态（即位置）；</li><li>另一方面，也要了解外在的环境（即地图）。</li></ul><p>一类传感器是携带于机器人本体上的，测到的通常都是一些间接的物理量而不是直接的位置数据，这种定位方案可适用于未知环境；<br>另一类是安装于环境中的，限制了机器人的使用范围。<br>当谈论<strong>视觉 SLAM</strong>时，主要是指如何用<code>相机</code>解决定位和建图问题。<br>相机：以一定速率拍摄周围的环境，形成一个连续的视频流。<br>按照工作方式的不同，可分为：单目相机（Monocular）、双目相机（Stereo）、深度相机（RGB-D）。</p><a id="more"></a><h3 id="单目相机"><a href="#单目相机" class="headerlink" title="单目相机"></a>单目相机</h3><p>照片本质上是拍照时的场景（Scene）在相机的成像平面上留下的一个<code>投影</code>。它<strong>以二维的形式反映了三维的世界</strong>。<br>运动（Motion）：如果相机往右移动，那么图像里的东西就会往左边移动，这就给我们推测运动带来了信息；<br>结构（Structure）：近处的物体移动快，远处的物体则运动缓慢。于是，在相机移动时，这些物体在图像上的运动就形成了<code>视差</code>。<br>单目 SLAM 估计的轨迹和地图将与真实的轨迹和地图相差一个因子，也就是所谓的<code>尺度</code>（Scale）。</p><blockquote><p>平移之后才能计算深度，以及无法确定真实尺度。根本原因是：通过单张图像无法确定深度。</p></blockquote><h3 id="双目相机"><a href="#双目相机" class="headerlink" title="双目相机"></a>双目相机</h3><p>两个相机之间的距离（<code>基线</code>：Baseline）是已知的，这和人眼非常相似。<br>基线距离越大，能够测量到的就越远。<br>相对于人类非常笨拙，需要大量的计算才能估计每一个像素点的深度。需要使用 GPU 和 FPGA 设备加速后，才能实时输出整张图像的距离信息，<code>计算量</code>是双目的主要问题之一。</p><h3 id="深度相机"><a href="#深度相机" class="headerlink" title="深度相机"></a>深度相机</h3><p>通过红外结构光或 Time-of-Flight（ToF）原理，主动向物体发射光并接收返回的光。<br>不像双目相机那样通过软件计算来解决。<br>主要用于室内，室外则较难应用。</p><h2 id="经典视觉-SLAM-框架"><a href="#经典视觉-SLAM-框架" class="headerlink" title="经典视觉 SLAM 框架"></a>经典视觉 SLAM 框架</h2><p>SLAM 需要一个完善的框架：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/2_1.jpeg" alt><br>如果把工作环境限定在<strong>静态、刚体、光照变化不明显、没有人为干扰</strong>的场景，那么，这个 SLAM 系统是相当成熟的了。</p><h3 id="视觉里程计（Visual-Odometry）"><a href="#视觉里程计（Visual-Odometry）" class="headerlink" title="视觉里程计（Visual Odometry）"></a>视觉里程计（Visual Odometry）</h3><p>VO 又称为前端（Front End），只计算相邻时刻的运动，而和再往前的过去的信息没有关联。<br>仅通过视觉里程计来估计轨迹，将不可避免地出现<strong>累积漂移</strong>（Accumulating Drift），解决漂移问题，需要两种技术：</p><ul><li>回环检测：负责把“机器人回到原始位置”的事情检测出来；</li><li>后端优化：根据该信息，校正整个轨迹的形状。</li></ul><h3 id="后端优化（Optimization）"><a href="#后端优化（Optimization）" class="headerlink" title="后端优化（Optimization）"></a>后端优化（Optimization）</h3><p>后端接收不同时刻视觉里程计测量的相机位姿，以及回环检测的信息。由于接在 VO 之后，又称为后端（Back End）。<br>后端优化要考虑的问题，就是如何从这些带有噪声的数据中估计整个系统的状态，以及这个状态估计的不确定性有多大——这称为<strong>最大后验概率估计</strong>（Maximum-a-Posteriori，MAP）。<br>前端和<strong>计算机视觉</strong>研究领域更为相关，比如图像的特征提取与匹配等；后端则主要是<strong>滤波与非线性优化</strong>算法。</p><blockquote><p>SLAM 问题的本质：对运动主体自身和周围环境空间不确定性的估计。</p></blockquote><h3 id="回环检测（Loop-Closing）"><a href="#回环检测（Loop-Closing）" class="headerlink" title="回环检测（Loop Closing）"></a>回环检测（Loop Closing）</h3><p>如果检测到回环，它会把信息提供给后端进行处理。<br>需要让机器人具有<strong>识别到过的场景</strong>的能力，可以判断<strong>图像间的相似性</strong>来完成回环检测。<br>由于图像的信息非常丰富，使得正确检测回环的难度降低了不少。</p><h3 id="建图（Mapping）"><a href="#建图（Mapping）" class="headerlink" title="建图（Mapping）"></a>建图（Mapping）</h3><p>一个相机，它有 6 个自由度的运动，我们至少需要一张三维的地图；想要一个漂亮的重建结果，不仅是一组空间点，还需要带纹理的三角面片。<br>对于地图，大体上可以分为<strong>度量地图</strong>和<strong>拓扑地图</strong>两种。</p><h4 id="度量地图（Metric-Map）"><a href="#度量地图（Metric-Map）" class="headerlink" title="度量地图（Metric Map）"></a>度量地图（Metric Map）</h4><ul><li>稀疏（Sparse）地图：由路标（Landmark）组成的地图，而不是路标的部分就可以忽略掉，对于<code>定位</code>来说，稀疏地图就足够了；</li><li>稠密（Dense）地图：着重于建模所有看到的东西，用于<code>导航</code>时，往往需要稠密的地图。</li></ul><p>二维度量地图由许多小格子（Grid）组成，三维度量地图则由许多小方块（Voxel）组成。一个小块含有<strong>占据、空闲、未知</strong>三种状态。<br>需要存储每一个格点的状态，会耗费大量的存储空间，许多细节部分是无用的；有时候会出现<code>一致性</code>问题，很小的一点转向误差，可能会导致出现重叠，使地图失效。</p><h4 id="拓扑地图（Topological-Map）"><a href="#拓扑地图（Topological-Map）" class="headerlink" title="拓扑地图（Topological Map）"></a>拓扑地图（Topological Map）</h4><p>由节点和边组成，只考虑节点间的连通性，不考虑如何从 A 点到达 B 点。是一种更为紧凑的表达方式。</p><h2 id="SLAM-问题的数学表述"><a href="#SLAM-问题的数学表述" class="headerlink" title="SLAM 问题的数学表述"></a>SLAM 问题的数学表述</h2><ul><li>运动：我们要考虑从 k-1 时刻到 k 时刻，小萝卜的位置 x 是如何变化的；</li><li>观测：假设小萝卜在 k 时刻于 xk处探测到了某一路标yj，我们要考虑这件事情是如何用数学语言来描述的。</li></ul><p>针对不同的传感器，<strong>运动方程</strong>和<strong>观测方程</strong>有不同的参数化形式，我们把它们取成通用的抽象形式：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/2_2.jpeg" alt><br>这两个方程描述了最基本的 SLAM 问题：当知道运动测量的读数 u，以及传感器的读数 z 时，如何求解定位问题（估计 x）和建图问题（估计 y）？这时，我们就把 SLAM 问题建模成了一个<strong>状态估计问题：</strong>如何通过带有噪声的测量数据，估计内部的、隐藏着的状态变量？<br>按照运动和观测方程是否为线性，噪声是否服从高斯分布进行分类。分为<strong>线性/非线性</strong>和<strong>高斯/非高斯</strong>系统。<br>其中，线性高斯系统（Linear Gaussian，LG）是最简单的，它的无偏的最优估计可以由卡尔曼滤波器（Kalman Filter，KF）给出；而在复杂的非线形非高斯系统（Non-Linear Non-Gaussian，NLNG）中，我们会使用以扩展卡尔曼滤波器（Extended Kalman Filter，EKF）和非线性优化两大类方法去求解。<br>时至今日，主流视觉 SLAM 使用以<code>图优化</code>（Graph Optimization）为代表的优化技术进行状态估计。我们认为优化技术已经明显优于滤波器技术，只要计算资源允许，通常都偏向于使用优化方法。<br>数学知识：</p><ul><li>对 6 自由度的位姿，如何表达它，如何优化它；</li><li>观测方程如何参数化，空间中的路标点是如何投影到一张照片上。需要解释相机的成像模型；</li><li>知道了这些信息，怎么求解上述方程。需要非线性优化的知识。</li></ul><blockquote><p>位姿这个词表示“位置”加上“姿态”，包含了旋转（Rotation）和平移（Translation）。</p></blockquote><h2 id="实践：编程基础"><a href="#实践：编程基础" class="headerlink" title="实践：编程基础"></a>实践：编程基础</h2><h3 id="使用-cmake"><a href="#使用-cmake" class="headerlink" title="使用 cmake"></a>使用 cmake</h3><p>任意一个 C++ 程序都可以用 g++ 来编译，在历史上工程师们曾使用 makefile 进行自动编译，cmake 比它更加方便。<br>在一个 cmake 工程中，我们会用 cmake 命令生成一个 makefile 文件，然后，用 make 命令根据这个 makefile 文件的内容编译整个工程。<br>MakeFile 是一个自动化编译的脚本，我们用 cmake-make 的做法，cmake 过程处理了<strong>工程文件之间的关系</strong>，降低了维护整个工程的难度；而 make 过程实际调用了 g++ 来编译程序。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/SLAM/2_3.jpeg" alt><br>我们新建了一个中间文件夹“build”，这样，cmake 产生的中间文件就会生成在 build 文件夹中，当发布源代码时，只要把 build 文件夹删掉即可。</p><h3 id="使用库"><a href="#使用库" class="headerlink" title="使用库"></a>使用库</h3><p>程序代码由头文件和源文件组成，带有 main 函数的源文件编译成可执行程序，其他的编译成<code>库文件</code>。<br>一个库往往是许多算法、程序的集合。<br>在 Linux 中，库文件分成<code>静态库</code>和<code>共享库</code>两种，静态库以 .a 作为后缀名，共享库以 .so 结尾。<br>静态库每次被调用都会生成一个副本，而共享库则只有一个副本。<br>如果可执行程序想调用库文件中的函数，它需要参考该库提供的头文件，以明白调用的格式。同时，要把可执行程序<code>链接</code>到库文件上。</p><blockquote><p>只要拿到了头文件和库文件，就可以调用这个库了。</p></blockquote><h3 id="使用-IDE"><a href="#使用-IDE" class="headerlink" title="使用 IDE"></a>使用 IDE</h3><p>IDE（Integrated Development Environment）为开发者提供了跳转、补全、断点调试等很多方便的功能。<br>在 Linux 中，默认的调试工具 gdb 只提供了文本界面，有些 IDE 提供了断点调试功能（底层仍旧是 gdb），Kdevelop 就是其中之一。<br>对于编译类型，通常有调试用的 Debug 模式与发布用的 Release 模式。<br><code>启动器</code>：既可以直接选择一个 cmake 的工程目标，也可以直接指向一个二进制文件（推荐）。<br>在断点处，可以用单步运行（F10）、单步跟进（F11）、单步跳出（F12）功能控制程序的运行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SLAM</title>
      <link href="2017/11/29/SLAM/"/>
      <url>2017/11/29/SLAM/</url>
      
        <content type="html"><![CDATA[<h2 id="本书讲什么"><a href="#本书讲什么" class="headerlink" title="本书讲什么"></a>本书讲什么</h2><p>SLAM 是 <strong>S</strong>imultaneous <strong>L</strong>ocalization <strong>A</strong>nd <strong>M</strong>apping 的缩写，中文译作：同时定位与地图构建。<br>SLAM 的目的是解决<code>定位</code>与<code>地图构建</code>，希望<strong>实时地</strong>、在<strong>没有先验知识</strong>的情况下进行 SLAM。<br>我们眼中的花草树木、虫鱼鸟兽，在计算机中只是一个个由数字排列而成的矩阵。<br>与人工智能和机器学习所用的方式——<strong>概率学建模</strong>是不同的。<br>与 SLAM 相关的应用点：在许多地方，我们都希望知道自身的位置。<br>虽然 SLAM 的理论框架基本趋于稳定，但其编程实现仍然较为复杂。<br>我们会详细地介绍 SLAM 的理论背景、系统架构，以及各个模块的主流做法。<br>经典书籍：《概率机器人》（Probabilistic robotics）、《计算机视觉中的多视图几何》（Multiple View Geometry in Computer Vision）、《机器人学中的状态估计》（State Estimation for Robotics: A Matrix-Lie-Group Approach）</p><ul><li>目的在于介绍基础理论，SLAM 只是其应用之一；</li><li>内容偏重于数学理论，基本不涉及编程实现。</li></ul><a id="more"></a><h2 id="如何使用本书"><a href="#如何使用本书" class="headerlink" title="如何使用本书"></a>如何使用本书</h2><h3 id="组织方式"><a href="#组织方式" class="headerlink" title="组织方式"></a>组织方式</h3><p>某些做法只要经验上够用，没必要非得在数学上追求完备。<br><strong>数学基础</strong>篇+<strong>SLAM 技术</strong>篇</p><h3 id="风格约定"><a href="#风格约定" class="headerlink" title="风格约定"></a>风格约定</h3><p>各种程序库在 Linux 下的配置都非常便捷。<br>标量使用斜体字，向量和矩阵使用粗斜体，空心粗体代表特殊集合。<br>可以在终端中输入 vimtutor 阅读一遍所有内容。不要想着把 Vim 用成 IDE，我们只用它做文本编辑的工作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> SLAM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 9：用两个栈实现队列</title>
      <link href="2017/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98-9%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
      <url>2017/11/28/%E9%9D%A2%E8%AF%95%E9%A2%98-9%EF%BC%9A%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead，分别完成在队列尾部插入节点和在队列头部删除节点的功能。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        CQueue(<span class="keyword">void</span>);</span><br><span class="line">        ~CQueue(<span class="keyword">void</span>);</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">const</span> T&amp; node)</span></span>;</span><br><span class="line">        <span class="function">T <span class="title">deleteHead</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack1;</span><br><span class="line">        <span class="built_in">stack</span>&lt;T&gt; stack2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>操作系统会给每个线程创建一个栈用来存储函数调用时各个函数的参数、返回地址、临时变量等。</li><li>需要 O(n) 时间，才能找到栈中最大或者最小的元素。</li><li>考查应聘者写与<strong>模板</strong>相关的代码的能力。</li></ul><a id="more"></a><p>用两个栈模拟一个队列的操作：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/09_1.jpeg" alt><br>用两个队列模拟一个栈的操作：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/09_2.jpeg" alt></p><p><a href="https://gist.githubusercontent.com/snlndod/8541b926e44be4fbe2598d844e70c1ad/raw/1cfa29845cbbcff19ea6ea0bee4e3a95fac116d7/09_QueueWithTwoStacks.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 8：二叉树的下一个节点</title>
      <link href="2017/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
      <url>2017/11/23/%E9%9D%A2%E8%AF%95%E9%A2%98-8%EF%BC%9A%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一棵二叉树和其中的一个节点，如何找出中序遍历序列的下一个节点？树中的节点出了有两个分别指向左、右子节点的指针，还有一个指向父节点的指针。</p></blockquote><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/08.jpeg" alt><br>考虑不同位置的节点的下一个节点：</p><ol><li>节点有右子树：从右子节点出发一直沿着左指针向下遍历，就能找到下一个节点；</li><li>节点没有右子树：<ul><li>节点是它父节点的左子节点：下一个节点就是它的父节点；</li><li>节点是它父节点的右子节点：沿着父指针一直向上遍历，直到找到一个是它父节点的左子节点的节点，这个节点的父节点就是我们要找的下一个节点。反之，则没有下一个节点；</li></ul></li></ol><p><a href="https://gist.githubusercontent.com/snlndod/f19bd0f21ea220560a39f7739373c1fb/raw/1793dcc3fa964b117704ce2090cc39aae3dc3412/08_NextNodeInBinaryTrees.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 7：重建二叉树</title>
      <link href="2017/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-7%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>2017/11/22/%E9%9D%A2%E8%AF%95%E9%A2%98-7%EF%BC%9A%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<blockquote><p>输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如，输入前序遍历序列 {1, 2, 4, 7, 3, 5, 6, 8} 和中序遍历序列 {4, 7, 2, 1, 5, 3, 8, 6}，则重建二叉树并输出它的头节点。二叉树节点的定义如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_nValue;</span><br><span class="line">    BinaryTreeNode *m_pLeft;</span><br><span class="line">    BinaryTreeNode *m_pRight;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>由于树的操作会涉及大量的指针，因此与树有关的面试题都不太容易。</li><li>3 种遍历都有<strong>递归</strong>和<strong>循环</strong>两种不同的实现方法，递归实现都比循环实现要简洁很多。</li><li>我们可以平均在 O(logn) 的时间内，根据数值在二叉搜索树中找到一个节点。</li><li>需要快速找到最大值或最小值的问题都可以用堆来解决。</li><li><strong>红黑树：</strong>把树中的节点定义为红、黑两种颜色，并通过规则确保从根节点到叶节点的最长路径的长度<strong>不超过</strong>最短路径的<strong>两倍</strong>。STL 中，set、multiset、map、mutimap 等数据结构都是基于红黑树实现的。</li><li>考查应聘者分析复杂问题的能力。把构建二叉树的大问题分解成构建左、右子树的两个小问题。确定左、右子树节点的数量，用递归的方法去完成。<a id="more"></a><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/07.jpeg" alt></li></ul><p><a href="https://gist.githubusercontent.com/snlndod/6840384b5f5fb532d5a0508b26d08294/raw/9da792f3e0c712c7c9389e7305f223a7ede67ff3/07_ConstructBinaryTree.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 6：从尾到头打印链表</title>
      <link href="2017/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-6%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
      <url>2017/11/20/%E9%9D%A2%E8%AF%95%E9%A2%98-6%EF%BC%9A%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/</url>
      
        <content type="html"><![CDATA[<blockquote><p>输入一个链表的头节点，从尾到头反过来打印出每个节点的值。链表节点定义如下：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> m_mKey;</span><br><span class="line">    ListNode *m_pNext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>内存分配不是在创建链表时一次性完成的，由于没有闲置的内存，链表的空间效率比数组高。</li><li>如果我们打算修改输入的数据，最好先问面试官是不是允许修改。</li><li>典型的<strong>后进先出</strong>，可以用栈实现这种顺序。递归本质上就是一个栈结构，但有可能导致函数调用栈溢出，显然用<strong>栈基于循环</strong>实现的代码的鲁棒性要好一些。</li><li>考查对循环、递归、栈 3 个相互关联的概念的理解。</li></ul><p><a href="https://gist.githubusercontent.com/snlndod/39107507d9eb6a1736ee4e8cb98ef35f/raw/3aa2ee894f7880b74a5986bab68f47873f148d9d/06_PrintListInReversedOrder.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 5：替换空格</title>
      <link href="2017/11/19/%E9%9D%A2%E8%AF%95%E9%A2%98-5%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
      <url>2017/11/19/%E9%9D%A2%E8%AF%95%E9%A2%98-5%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      
        <content type="html"><![CDATA[<blockquote><p>请实现一个函数，把字符串中的每个空格替换成“20%”。例如，输入“We are happy.”，则输出“We%20are%20happy.”。</p></blockquote><ul><li>URL参数中含有特殊字符，如空格、”#”等。会导致服务器端无法获得正确的参数值，<strong>转换规则：</strong>”%”后面跟上 ASCII 码的两位十六进制的表示。</li><li>从前往后复制每个字符则需要重复移动数字多次（O(n^2)），从后往前复制，这样就能减少移动的次数，从而提高效率（O(n)）。能清晰地分析出两种不同方法的时间效率各是多少。</li><li>画一两个示意图解释自己的思路（<strong>两个指针</strong>），既能帮助我们厘清思路，也能使我们和面试官的交流变得更加高效。<a id="more"></a><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/CodingInterview/05.JPG" alt></li><li>对<strong>内存覆盖</strong>要有高度的警惕。</li></ul><p><a href="https://gist.githubusercontent.com/snlndod/cbc6c2d8837c42c565c31280b72c9c0b/raw/25994d295fcb1762a22b9e9a265ff7d36489930f/05_ReplaceSpaces.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 3.2：不修改数组找出重复的数字</title>
      <link href="2017/11/18/%E9%9D%A2%E8%AF%95%E9%A2%98-3.2%EF%BC%9A%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2017/11/18/%E9%9D%A2%E8%AF%95%E9%A2%98-3.2%EF%BC%9A%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在一个长度为 n+1 的数组里的所有数字都在 1～n 的范围内，所以数组中至少有一个数字是重复的。请找出数组中任意一个重复的数字，但不能修改输入的数组。例如，如果输入长度为 8 的数组 [2, 3, 5, 4, 3, 2, 6, 7]，那么对应的输出是重复的数字 2 或者 3。</p></blockquote><ul><li>可以创建一个长度为 n+1 的辅助数组，该方案需要 O(n) 的辅助空间。</li><li>某范围里数字的个数对解决这个问题很重要。</li><li>函数 countRange 将被调用 O(logn) 次，每次需要 O(n) 的时间，总时间复杂度是 O(nlogn)，相当于以时间换空间。</li><li><strong>交流的重要性：</strong>面试官提出不同的<strong>功能要求</strong>或者<strong>性能要求</strong>，我们最终选取的算法也将不同。</li><li>能快速、正确地实现二分查找算法的代码。</li></ul><p><a href="https://gist.githubusercontent.com/snlndod/74768154bc00d4b5f8c324470912b555/raw/a817b319e3f7aad1e202e0e5ff128d9f2387d7d5/03_02_FindDuplicationNoEdit.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 3.1：找出数组中重复的数字</title>
      <link href="2017/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98-3.1%EF%BC%9A%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
      <url>2017/11/16/%E9%9D%A2%E8%AF%95%E9%A2%98-3.1%EF%BC%9A%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在一个长度为 n 的数组里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。例如，如果输入长度为 7 的数组 [2, 3, 1, 0, 2, 5, 3]，那么对应的输出是重复的数字 2 或者 3。</p></blockquote><ul><li>排序一个长度为 n 的数组需要 O(nlogn) 的时间。</li><li>利用<strong>哈希表</strong>可以实现时间复杂度为 O(n) 的算法，但代价是一个空间复杂度为 O(n) 的哈希表。</li><li>重复数字通过<strong>指针</strong>，传递给函数的调用者。</li><li>尽管有一个两重循环，但每个数字最多只要交换两次就能找到属于它自己的位置，故时间复杂度是 O(n)。</li><li>一维数组在内存中占据连续的空间，可以根据下标定位对应的元素。</li><li>问题比较复杂时，关键是能否通过<strong>具体的例子</strong>找出其中的规律。</li></ul><p><a href="https://gist.githubusercontent.com/snlndod/8aa1c6ddebdd9da390161900a1f6240d/raw/79ad885bd1c1163c9f59ee558e63ac0e260ee68d/03_01_FindDuplication.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题 4：二维数组中的查找</title>
      <link href="2017/05/18/%E9%9D%A2%E8%AF%95%E9%A2%98-4%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
      <url>2017/05/18/%E9%9D%A2%E8%AF%95%E9%A2%98-4%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p></blockquote><ul><li>通过分析简单具体的例子，试图寻找普遍的规律。</li><li>在二维数组的中间选取一个数字，转变成从数组的一个角上选取数字。</li><li>如果该数字大于要查找的数字，则剔除这个数字所在列；如果该数字小于要查找的数字，则剔除这个数字所在的行。</li><li>也可以选取左下角的数字。</li><li>注意特殊输入测试（空指针）。</li><li>根据行号和列号计算出相对于数组首地址的偏移量。</li></ul><p><a href="https://gist.githubusercontent.com/snlndod/83dfc36a20f58eba1aea9dbc8da71bce/raw/81e306769a73284820e71f060207b028a90b14ca/04_FindInPartiallySortedMatrix.cpp" target="_blank" rel="noopener">Source Code</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> CodingInterview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOAPC 读书笔记-3</title>
      <link href="2017/05/07/AOAPC-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/"/>
      <url>2017/05/07/AOAPC-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>C++ 与 STL 入门</p></blockquote><h2 id="从C-到-C"><a href="#从C-到-C" class="headerlink" title="从C 到 C++"></a>从C 到 C++</h2><p>与其把 C++ 学得一知半解，还不如先把 C 语言的基础打好；<br>C++ 的精华与糟粕并存。</p><h3 id="C-版框架"><a href="#C-版框架" class="headerlink" title="C++ 版框架"></a>C++ 版框架</h3><p><strong>使用 C 头文件：</strong>在 C 头文件前加一个小写的 c 字母，然后去掉 .h 后缀；<br>C++ 流最大的缺点就是运行太慢；<br>如果两个函数的参数类型完全相同，则是<code>不能重载</code>的，解决方案是：分别把函数写在各自的<strong>命名空间</strong>里；<br>使用了 using namespace std 语句，可以用 cin 代替 std::cin，cout 代替 std::cout；<br>使用 const <strong>声明常数</strong>，而不是用 #define；<br>仍然可以用 int 来表示真假，但是用 bool 可以让程序更清晰。</p><a id="more"></a><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><p>C++ 中的<code>引用</code>就是变量的“别名”，可以在一定程度上代替 C 中的指针；<br>在参数名之前加一个“&amp;”符号，表示这个参数按照传引用（by reference）的方式传递，而不是传值（by value）的方式传递。在函数内改变参数的值，也会修改到函数的实参。</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>C 语言中的字符串就是字符数组，不是“一等公民”。字符串拼接：</p><ul><li>不能在函数中定义一个数组然后返回它的地址，必须申请新的内存空间以存放结果；</li><li>字符串数组本身并不保存长度。为了避免不必要的 strlen 调用，需在某个变量中保存字符串的长度。</li></ul><p>C++ 的 cin/cout 可以直接读写 string 类型，string 类型还可以像整数那样“相加”。可以把 string 作为流进行读写，定义在 <strong>sstream 头文件</strong>中；<br>string 很慢，sstream 更慢。</p><h3 id="再谈结构体"><a href="#再谈结构体" class="headerlink" title="再谈结构体"></a>再谈结构体</h3><p>C++ 不再需要用 typedef 的方式定义一个 struct。一般用 struct 定义“纯数据”类型，用 class 定义“拥有复杂行为”的类型；<br><strong>struct 和 class 的区别：</strong>默认访问权限和继承方式不同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Point</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Point(<span class="keyword">int</span> x=<span class="number">0</span>, <span class="keyword">int</span> y=<span class="number">0</span>):x(x),y(y)) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>结构体 Point 中定义了一个函数，函数名也叫 Point，但是没有返回值，这样的函数称为<strong>构造函数</strong>（ctor）；<br>C++ 中的结构体可以有一个或多个构造函数，在声明变量时调用；<br><strong>:x(x),y(y)：</strong>是一个简单的写法，表示“把成员变量 x 初始化为参数 x，成员变量 y 初始化为参数 y”。<br>也可以写成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Point(<span class="keyword">int</span> x=<span class="number">0</span>, <span class="keyword">int</span> y=<span class="number">0</span>) &#123;<span class="keyword">this</span>-&gt;x = x; <span class="keyword">this</span>-&gt;y = y;&#125;</span><br></pre></td></tr></table></figure><p><strong>this 是指向当前对象的指针</strong>，this-&gt;x 的意思是“当前对象的成员变量 x”，即 (*this).x。</p><h3 id="模版"><a href="#模版" class="headerlink" title="模版"></a>模版</h3><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">int</span> *<span class="built_in">begin</span>, <span class="keyword">int</span> *<span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="built_in">begin</span>;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> *p = <span class="built_in">begin</span>; p != <span class="built_in">end</span>; p++)</span><br><span class="line">        ans += *p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数没有错误，但<strong>比较局限</strong>。只能求整数数组的和，不能求 double 数组的和，更不能求 Point 数组的和。<br>可以用模版进行改造：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="title">sum</span><span class="params">(T *<span class="built_in">begin</span>, T *<span class="built_in">end</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T *p = <span class="built_in">begin</span>;</span><br><span class="line">    T ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(T *p = <span class="built_in">begin</span>; p != <span class="built_in">end</span>; p++)</span><br><span class="line">        ans = ans + *p;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="STL-初步"><a href="#STL-初步" class="headerlink" title="STL 初步"></a>STL 初步</h2><h3 id="排序与检索"><a href="#排序与检索" class="headerlink" title="排序与检索"></a>排序与检索</h3><p>sort 可以给任意对象排序，包括内置类型和自定义类型；<br>待排序／查找的元素可以放在数组里，也可以放在 vector 里；<br>lower_bound 的作用是查找“大于或者等于 x 的第一个位置”。</p><h3 id="不定长数组：vector"><a href="#不定长数组：vector" class="headerlink" title="不定长数组：vector"></a>不定长数组：vector</h3><p>vector 就是一个不定长数组，把一些常用操作<code>封装</code>在了 vector 类型内部；<br>vector&lt;int&gt; 是一个类似于 int a[] 的整数数组，而 vector&lt;string&gt; 就是一个类似于 string a[] 的字符串数组；<br>vector 之间可以直接赋值或者作为函数的返回值，像是“一等公民”一样。</p><h3 id="集合：set"><a href="#集合：set" class="headerlink" title="集合：set"></a>集合：set</h3><p>set 就是数学上的集合，自定义类型也可以构造 set，但必须定义<strong>小于运算符</strong>；<br>iterator 的意思是迭代器，是 STL 的重要概念，用法类似于指针。</p><h3 id="映射：map"><a href="#映射：map" class="headerlink" title="映射：map"></a>映射：map</h3><p>map 就是从键（key）到值（value）的映射。因为重载了 [] 运算符，map 像是数组的“高级版”，也称为关联数组；<br>没有良好的代码设计，是无法发挥 STL 的威力的。</p><h3 id="栈、队列与优先队列"><a href="#栈、队列与优先队列" class="headerlink" title="栈、队列与优先队列"></a>栈、队列与优先队列</h3><p>所谓栈，就是符合“后进先出”（LIFO）规则的数据结构。<br>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s;</span><br></pre></td></tr></table></figure><p>队列是符合“先进先出”（FIFO）原则的公平队列。<br>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; s;</span><br></pre></td></tr></table></figure><p>优先队列是一种*<em>抽象数据类型 *</em>（ADT），越小的整数优先级越低；<br>只要元素定义了“小于”运算符，就可以使用优先队列。<br>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="keyword">int</span>&gt; s;</span><br></pre></td></tr></table></figure><blockquote><p>在 C++ 中，重载了“()”运算符的类或结构体叫做<strong>仿函数</strong>（functor）。</p></blockquote><h3 id="测试-STL"><a href="#测试-STL" class="headerlink" title="测试 STL"></a>测试 STL</h3><p>使用之前测试库是一个好习惯。<br>cstdlib 中的 rand() 可以生成闭区间 [0, RAND_MAX] 内均匀分布的随机整数，RAND_MAX 最大为 32767；<br>若要生成更大的随机整数，可以用 rand() 的结果<strong>放大得到</strong>；<br>可以用 cstdlib 中的 srand 函数初始化随机数种子，并用 ctime 中的 time(NULL) 为参数调用 srand。即在随机数程序最开始时，执行一次 <strong>srand(time(NULL))</strong>；<br>time 函数返回的是自 UTC 时间 1970 年 1 月 1 日 0 点以来经过的秒数。</p><blockquote><p>把 vector 作为参数或者返回值时，应尽量改成用引用方式传递参数，以避免不必要的复制。</p></blockquote><p>C++ 支持<strong>函数重载</strong>，但函数的参数类型必须不同（不能只是返回值类型不同）；<br><strong>assert(表达式)：</strong>当表达式为假时强行终止程序，并给出错误提示，为真时无变化；<br>vector、set、map 都很快。</p><h2 id="题目举例"><a href="#题目举例" class="headerlink" title="题目举例"></a>题目举例</h2><p>可以给结构体重载赋值运算符，使得用起来更方便；<br>给结构体声明一些属于该结构体类型的静态成员变量，方法是加上 static 修饰符。静态成员变量在结构体外部使用时，要写成<code>结构体名::静态成员变量名</code>；<br><strong>unique</strong> 必须在 sort 之后调用，而且 unique 本身不会删除元素，而只是把重复的元素移到了后面。</p><blockquote><p>sort、set、map 都依赖于类型的“小于”运算符。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《面试宝典》读书笔记-3</title>
      <link href="2017/05/06/%E3%80%8A%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/"/>
      <url>2017/05/06/%E3%80%8A%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-3/</url>
      
        <content type="html"><![CDATA[<blockquote><p>异常处理、输入输出流、Java 平台与内存管理</p></blockquote><h2 id="finally-块不一定会被执行"><a href="#finally-块不一定会被执行" class="headerlink" title="finally 块不一定会被执行"></a>finally 块不一定会被执行</h2><ul><li>当程序在进入<code>try 块</code>之前就出现异常，会直接结束，不会执行 finally 块中的代码；</li><li>当程序在 try 块中强制退出时，也不会去执行 finally 块中的代码。</li></ul><h2 id="异常处理的原理"><a href="#异常处理的原理" class="headerlink" title="异常处理的原理"></a>异常处理的原理</h2><p>异常处理的目的：为了提高程序的安全性与鲁棒性。<br>JVM 将出现的错误表示为一个异常并抛出，这个异常可以在 <code>catch 块</code>中进行捕获，然后进行处理。<br>Java 中把异常当作对象来处理，并定义了一个基类（java.lang.Throwable）作为所有异常的父类。</p><a id="more"></a><h2 id="异常的分类"><a href="#异常的分类" class="headerlink" title="异常的分类"></a>异常的分类</h2><h3 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h3><p>表示程序在运行期间出现了非常严重的错误，并且该错误是不可恢复的。<br>JVM 层次的严重错误，会导致程序终止执行，编译器不会检查 Error 是否被处理。</p><h3 id="Exception"><a href="#Exception" class="headerlink" title="Exception"></a>Exception</h3><p>表示可恢复的异常，是编译器可以捕获到的。包含两种类型：</p><ul><li><code>检查异常</code>（checked exception）：<br>程序中最经常碰到的异常，发生在编译阶段，编译器强制程序去捕获此类型的异常。<ul><li>异常的发生并不会导致程序出错，进行处理后可以继续执行后续的操作。例如，SQL 异常；</li><li>程序依赖于不可靠的外部条件。例如，IO 异常。 </li></ul></li><li><code>运行异常</code>（runtime exception）：<br>编译器没有强制对其进行捕获并处理。<ul><li>多线程用 Thread.run() 方法抛出，这个线程也就退出了；</li><li>单线程用 main() 方法抛出，整个程序也就退出了。</li></ul></li></ul><blockquote><p>如果不对运行时的异常进行处理，后果是非常严重的，一旦发生，要么是线程终止，要么是主程序终止。</p></blockquote><h3 id="需要注意的问题"><a href="#需要注意的问题" class="headerlink" title="需要注意的问题"></a>需要注意的问题</h3><ul><li>在进行异常捕获时，正确的写法是：先捕获子类，再捕获基类的异常信息。</li><li>尽早抛出异常，同时对捕获的异常进行处理。</li><li>可以根据实际的需求<strong>自定义异常类</strong>。</li><li>异常能处理就处理，不能处理就抛出。</li></ul><blockquote><p>对于最终没有处理的异常，JVM 会进行处理。 </p></blockquote><hr><h2 id="IO-流的实现机制"><a href="#IO-流的实现机制" class="headerlink" title="IO 流的实现机制"></a>IO 流的实现机制</h2><p>Java IO 类在设计时采用了<strong>装饰者</strong>（Decorator）设计模式。<br>在 java.io 包中有许多的流，流的作用主要是为了改善程序设计性能并且使用方便。</p><h3 id="字节流"><a href="#字节流" class="headerlink" title="字节流"></a>字节流</h3><p>以字节（8 bit）为单位，包含两个抽象类：InputStream、OutputStream。<br>处理时，不会用到<code>缓存</code>。</p><h3 id="字符流"><a href="#字符流" class="headerlink" title="字符流"></a>字符流</h3><p>以字符（16 bit）为单位，包含两个抽象类：Reader、Writer。<br>处理时，用到了缓存。</p><h2 id="File-类"><a href="#File-类" class="headerlink" title="File 类"></a>File 类</h2><p>对文件或目录进行管理与操作在编程中有着非常重要的作用，Java 提供了一个非常重要的类（File）来管理文件和文件夹。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Java/3_1.png" alt></p><h2 id="Java-Socket"><a href="#Java-Socket" class="headerlink" title="Java Socket"></a>Java Socket</h2><p>网络上的两个程序通过一个双向的通信连接实现数据的交换，这个双向链路的一端称为一个 Socket。<br>Socket 也称为<code>套接字</code>，可以用来实现不同虚拟机或不同计算机之间的通信。任何一个 Socket 都是由 IP 地址和端口号唯一确定的。</p><h3 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h3><p>可以分为三个阶段：</p><ol><li>打开 Socket</li><li>使用 Socket 收发数据</li><li>关闭 Socket</li></ol><blockquote><p>Java中，可以使用 ServerSocket 来作为服务器端，Socket 作为客户端来实现网络通信。</p></blockquote><h2 id="Java-NIO"><a href="#Java-NIO" class="headerlink" title="Java NIO"></a>Java NIO</h2><p>非阻塞IO（Nonblocking IO）通过 Selector、Channel、Buffer 来实现非阻塞的 IO 操作：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Java/3_2.png" alt><br>NIO 的实现主要采用了<strong>反应器</strong>（Reactor）设计模式，可以用来处理多个事件源。<br>与传统 Socket 方式相比，由于 NIO 采用了非阻塞的方式，在处理大量并发请求时，使用 NIO 要比使用 Socket 效率高出很多。</p><h2 id="Java-序列化"><a href="#Java-序列化" class="headerlink" title="Java 序列化"></a>Java 序列化</h2><p>提供了两种对象持久化的方式：序列化、外部序列化。</p><h3 id="序列化（Serialization）"><a href="#序列化（Serialization）" class="headerlink" title="序列化（Serialization）"></a>序列化（Serialization）</h3><p>序列化是一种将对象以一连串的字节描述的过程，用于解决在对对象进行读写操作时所引发的问题。<br>所有要实现序列化的类都必须实现 Serializable 接口，位于 java.lang 包中，它里面没有包含任何方法。<br><strong>特点：</strong></p><ul><li>如果一个类能被序列化，那么它的子类也能够被序列化；</li><li>由于 static 代表类的成员，transient 代表对象的临时数据，因此被声明为这两种类型的数据成员是不能够被序列化的。</li></ul><p>由于序列化的使用会影响系统的性能，因此如果不是必须要使用序列化，应尽可能不要使用序列化，<strong>需要使用序列化的情况：</strong></p><ul><li>需要通过网络来发送对象，或对象的状态需要被持久化到数据库或文件中；</li><li>序列化能实现深复制，即可以复制引用的对象。</li></ul><h3 id="反序列化"><a href="#反序列化" class="headerlink" title="反序列化"></a>反序列化</h3><p>将流转换为对象，每个类都有一个特定的 serialVersionUID，通过其判定类的兼容性。<br><strong>自定义 serialVersionUID 的优点：</strong></p><ul><li>提高程序的运行效率。通过显式声明 serialVersionUID 的方式，省去了计算的过程，因此提高了程序的运行效率；</li><li>提高程序不同平台的兼容性。各个平台的编译器在计算 serialVersionUID 时，有可能会采用不同的计算方式；</li><li>增强程序各个版本的兼容性。后期对类进行修改时，类的 serialVersionUID 值将会发生变化。</li></ul><h3 id="外部序列化"><a href="#外部序列化" class="headerlink" title="外部序列化"></a>外部序列化</h3><p>使用外部序列化时，<strong>Externalizable 接口</strong>中的读写方法必须由开发人员来实现，编写程序的难度更大。<br>由于把控制权交给了开发人员，具有更多的灵活性。<br><strong>实现只序列化部分属性：</strong></p><ul><li>开发人员可以根据实际需求，实现 readExternal 与 wirteExternal 方法，来控制序列化与反序列化所使用的属性；</li><li>使用关键字 transient，被修饰的属性是临时的，不会被序列化。</li></ul><h2 id="System-out-println"><a href="#System-out-println" class="headerlink" title="System.out.println()"></a>System.out.println()</h2><p>提供了一种非常有效简单的方法来实现控制台的输出，该方法默认接收一个<strong>字符串类型</strong>的变量作为参数。</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="number">1</span> + <span class="number">2</span> + <span class="string">""</span>);</span><br><span class="line">    System.out.<span class="built_in">println</span>(<span class="string">""</span> + <span class="number">1</span> + <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果为：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">12</span></span><br></pre></td></tr></table></figure><hr><h2 id="JVM-解释执行的过程"><a href="#JVM-解释执行的过程" class="headerlink" title="JVM 解释执行的过程"></a>JVM 解释执行的过程</h2><h3 id="代码的装入"><a href="#代码的装入" class="headerlink" title="代码的装入"></a>代码的装入</h3><p>装入代码的工作，由<code>类装载器</code>完成。</p><h3 id="代码的校验"><a href="#代码的校验" class="headerlink" title="代码的校验"></a>代码的校验</h3><p>被装入的代码由<code>字节码校验器</code>进行检查。</p><h3 id="代码的执行"><a href="#代码的执行" class="headerlink" title="代码的执行"></a>代码的执行</h3><ul><li>即时编译方式</li><li>解释执行方式</li></ul><h2 id="Java-平台"><a href="#Java-平台" class="headerlink" title="Java 平台"></a>Java 平台</h2><p>Java 平台主要包含<strong>两个模块：</strong>JVM、Java API（Application Program Interface）。</p><h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>一个虚构出来的计算机，有自己完善的硬件结构，屏蔽了与具体操作系统平台相关的信息。<br>每当一个 Java 程序运行时，都会有一个对应的 JVM 实例，只有当程序运行结束后，这个 JVM 才会退出。</p><h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><p>Java 为了方便开发人员开发而设计的，这些接口也是用 Java 语言编写的，并且运行在 JVM 上。</p><h2 id="加载-class-文件的原理机制"><a href="#加载-class-文件的原理机制" class="headerlink" title="加载 class 文件的原理机制"></a>加载 class 文件的原理机制</h2><p>Java 语言是一种具有动态性的解释型语言，类只有被加载到 JVM 中后才能运行。<br>类加载器本身也是一个类，由 ClassLoader 和它的子类来实现，其实质是把类文件<strong>从硬盘读取到内存中</strong>。</p><h3 id="类的加载方式"><a href="#类的加载方式" class="headerlink" title="类的加载方式"></a>类的加载方式</h3><ul><li>隐式：使用 new 等方式创建对象，会隐式地调用类的加载器把对应的类加载到 JVM 中；</li><li>显式：通过直接调用 class.forName() 方法，把所需的类加载到 JVM 中。</li></ul><h3 id="类的分类"><a href="#类的分类" class="headerlink" title="类的分类"></a>类的分类</h3><p>类的加载是<code>动态</code>的，并不会一次性将所有类全部加载后再运行。而是保证基础类完全加载到 JVM 中，至于其他类，则在需要时才加载。</p><ul><li>系统类</li><li>扩展类</li><li>自定义类</li></ul><p>Java 针对这 3 种不同的类，提供了 3 种类型的加载器：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Java/3_3.png" alt></p><h3 id="类加载的步骤"><a href="#类加载的步骤" class="headerlink" title="类加载的步骤"></a>类加载的步骤</h3><ul><li>装载：根据查找路径找到对应的 class 文件，然后导入。</li><li>链接：<ul><li>检查，检查待加载的 class 文件的正确性；</li><li>准备，给类中的<strong>静态变量</strong>分配存储空间；</li><li>解析，将符号引用转换成直接引用（可选）。 </li></ul></li><li>初始化：对静态变量、静态代码块执行初始化工作。</li></ul><h2 id="GC-Garbage-Collection"><a href="#GC-Garbage-Collection" class="headerlink" title="GC(Garbage Collection)"></a>GC(Garbage Collection)</h2><p>垃圾回收是一个非常重要的概念，主要作用是回收程序中不再使用的<code>内存</code>。<br>垃圾回收器负责完成的三项任务：</p><ol><li>分配内存</li><li>确保被引用对象的内存不被错误地回收</li><li>回收不再被引用对象的内存空间</li></ol><blockquote><p>为了实现垃圾回收，垃圾回收器必须跟踪内存的使用情况，必定会增加 JVM 的负担，从而降低程序的执行效率。</p></blockquote><p>使用<code>有向图</code>来记录和管理堆内存中的所有对象。“不可达”的对象都是可被垃圾回收的。</p><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><ul><li>引用计数算法（Reference Counting Collector）</li><li>追踪回收算法（Tracing Collector）</li><li>压缩回收算法（Compacting Collector）</li><li>复制回收算法（Coping Collector）</li><li>按代回收算法（Generational Collector）</li></ul><h2 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h2><h3 id="判断垃圾回收的标准"><a href="#判断垃圾回收的标准" class="headerlink" title="判断垃圾回收的标准"></a>判断垃圾回收的标准</h3><ul><li>给对象赋予了空值 null，以后再没有被使用过；</li><li>给对象赋予了新值，重新分配了内存空间。</li></ul><h3 id="内存泄漏的原因"><a href="#内存泄漏的原因" class="headerlink" title="内存泄漏的原因"></a>内存泄漏的原因</h3><ul><li>静态集合类。例如 HashMap、Vector，如果这些容器为静态的，由于它们的生命周期与程序一致，那么容器中的对象在程序结束之前将不能被释放。</li><li>各种连接。例如数据库连接，如果在访问数据库的过程中，不显式地关闭，将会造成大量的对象无法被回收。</li><li>监听器。在释放对象的同时往往没有相应地删除监听器。</li><li>变量不合理的作用域：<ul><li>变量定义的作用范围大于其使用范围；</li><li>没有及时地把对象设置为 null。</li></ul></li><li>单例模式。由于单例对象以静态变量的方式存储，因此它在 JVM 的整个生命周期中都存在。</li></ul><h2 id="堆与栈的区别"><a href="#堆与栈的区别" class="headerlink" title="堆与栈的区别"></a>堆与栈的区别</h2><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>栈内存用来存放基本数据类型、引用变量。<br>主要是用来执行程序的，存取速度更快。但大小和生存周期必须是确定的，缺乏一定的灵活性。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p>堆内存用来存放<strong>运行时创建的对象</strong>。<br>主要用来存放对象的，可以在运行时动态地分配内存，生存期不用提前告诉编译器，但这也导致了其存取速度的<code>缓慢</code>。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Java/3_4.png" alt></p><blockquote><p>存储在栈中的变量通过压栈、弹栈操作，将会在栈中被回收；而存储在堆中的对象将会由垃圾回收器来自动回收。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《面试宝典》读书笔记-2</title>
      <link href="2017/05/04/%E3%80%8A%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/"/>
      <url>2017/05/04/%E3%80%8A%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>关键字、基本类型与运算、字符串与数组</p></blockquote><h2 id="变量命名的规则"><a href="#变量命名的规则" class="headerlink" title="变量命名的规则"></a>变量命名的规则</h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><ul><li>变量名</li><li>函数名</li><li>数组名</li></ul><h2 id="break、continue、return-的区别"><a href="#break、continue、return-的区别" class="headerlink" title="break、continue、return 的区别"></a>break、continue、return 的区别</h2><h3 id="break"><a href="#break" class="headerlink" title="break"></a>break</h3><p>用于直接强行跳出当前循环，不再执行剩余代码。<br>仅仅终止了内层循环的执行，而不影响外层循环的执行。</p><a id="more"></a><h3 id="continue"><a href="#continue" class="headerlink" title="continue"></a>continue</h3><p>用于停止当次循环，回到循环的起始处，进入下一次循环操作。<br>continue 只是中断了一次循环的执行而已。</p><h3 id="return"><a href="#return" class="headerlink" title="return"></a>return</h3><p>是一个<strong>跳转语句</strong>，可以使程序控制返回到调用该方法的地方。</p><h2 id="final、finally、finalize-的区别"><a href="#final、finally、finalize-的区别" class="headerlink" title="final、finally、finalize 的区别"></a>final、finally、finalize 的区别</h2><h3 id="final"><a href="#final" class="headerlink" title="final"></a>final</h3><ul><li>final 属性：属性不可变</li><li>final 方法：方法不可覆盖</li><li>final 类：类不可被继承</li></ul><h3 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h3><p>作为异常处理的一部分，只能用在 <strong>try/catch 语句</strong>中，并且附带一个语句块。<br>表示这段语句最终一定被执行，经常被用在需要释放资源的情况下。</p><h3 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h3><p>是 Object 类的一个方法，在<strong>垃圾回收器</strong>执行时会调用被回收对象的 finalize() 方法，可以覆盖此方法来实现对其他资源的回收。</p><h3 id="JDK-中不能继承的类"><a href="#JDK-中不能继承的类" class="headerlink" title="JDK 中不能继承的类"></a>JDK 中不能继承的类</h3><ul><li>用 final 关键字修饰的类。</li><li>基本类型：String、StringBuffer 等。</li></ul><h2 id="assert-的作用"><a href="#assert-的作用" class="headerlink" title="assert 的作用"></a>assert 的作用</h2><p>断言（assert）作为一种<strong>软件调试</strong>的方法，提供了一种在代码中进行正确性检查的机制。<br>为了提高程序运行的效率，在软件发布后，assert 检查默认是被关闭的。</p><h3 id="assert-与-if-的区别"><a href="#assert-与-if-的区别" class="headerlink" title="assert 与 if 的区别"></a>assert 与 if 的区别</h3><ul><li>assert 一般在调试程序时使用；</li><li>if 判断是逻辑判断，本身就是用来控制程序流程的。</li></ul><h3 id="Java-与-C-中，assert-的不同"><a href="#Java-与-C-中，assert-的不同" class="headerlink" title="Java 与 C++ 中，assert 的不同"></a>Java 与 C++ 中，assert 的不同</h3><ul><li>Java 中使用 assert 关键字去实现其功能，而 C 中使用的是库函数；</li><li>C 中的 assert 是在编译时开启，而 Java 中是在运行时开启。</li></ul><h2 id="static-的作用"><a href="#static-的作用" class="headerlink" title="static 的作用"></a>static 的作用</h2><h3 id="static-成员变量"><a href="#static-成员变量" class="headerlink" title="static 成员变量"></a>static 成员变量</h3><p>虽然 Java 中没有全局的概念，但可以通过 static 关键字来达到全局的效果。</p><ul><li><strong>静态变量</strong>属于类，只要静态变量所在的类被加载，这个静态变量就会被分配空间，因此就可以被使用了，它在内存中只有一个复制；</li><li><strong>实例变量</strong>属于对象，只有对象被创建后，实例变量才会被分配空间，才能被使用，它在内存中存在多个复制。</li></ul><h3 id="static-成员方法"><a href="#static-成员方法" class="headerlink" title="static 成员方法"></a>static 成员方法</h3><p>static 方法中不能使用 this 和 super 关键字，不能调用非 static 方法。<br>一个很重要的用途是实现单例模式。</p><h3 id="static-代码块"><a href="#static-代码块" class="headerlink" title="static 代码块"></a>static 代码块</h3><p>在类中是独立于成员变量和成员函数的代码块，只会被执行一次。</p><h3 id="static-内部类"><a href="#static-内部类" class="headerlink" title="static 内部类"></a>static 内部类</h3><p>可以不依赖于外部类实例对象而被实例化。<br>只能访问外部类中的静态成员和静态方法（包括私有类型）。</p><h2 id="volatile-的作用"><a href="#volatile-的作用" class="headerlink" title="volatile 的作用"></a>volatile 的作用</h2><p>一个类型修饰符，用来修饰被<strong>不同线程</strong>访问和修改的变量，使所有线程在任何时候所看到变量的值都是相同的。<br>不能保证操作的原子性，不能代替 <code>synchronized</code>；会阻止编译器对代码的优化，会降低程序的执行效率，尽量不要使用。</p><h2 id="instanceof-的作用"><a href="#instanceof-的作用" class="headerlink" title="instanceof 的作用"></a>instanceof 的作用</h2><p>一个二元运算符，判断一个引用类型的变量所指向的对象是否是一个类的实例：</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span>如果object是<span class="class"><span class="keyword">class</span>的一个实例，返回<span class="title">true</span>；反之，返回<span class="title">false</span></span></span><br><span class="line">result = object <span class="keyword">instanceof</span> <span class="class"><span class="keyword">class</span>;</span></span><br></pre></td></tr></table></figure><h2 id="strictfp-的作用"><a href="#strictfp-的作用" class="headerlink" title="strictfp 的作用"></a>strictfp 的作用</h2><p>是 strict float point 的缩写，指的是<strong>精确浮点</strong>。<br>当一个类被 strictfp 修饰时，所有方法都会自动被修饰。</p><hr><h2 id="Java-的基本数据类型"><a href="#Java-的基本数据类型" class="headerlink" title="Java 的基本数据类型"></a>Java 的基本数据类型</h2><ul><li><strong>8 种原始数据类型</strong>：byte、short、int、long、float、double、char、boolean。声明后会立刻在栈上分配内存空间；</li><li>引用类型：类、接口、数组等，类似于 C++ 中的指针概念。声明后不会被分配内存空间，只是存储了一个内存地址而已。</li></ul><p>Java 还提供了对这些原始数据类型的封装类，封装类型和原始类型的不同点：</p><ul><li>原始类型按值传递，封装类型按引用传递；</li><li>具有不同的特征和用法。</li></ul><p>默认声明的小数是 <code>double</code> 类型的，对 float 类型变量初始化时需要进行强制类型转换：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> f = (<span class="type">float</span>)<span class="number">3.4</span>;</span><br><span class="line"><span class="type">float</span> f = <span class="number">3.4</span>f;</span><br></pre></td></tr></table></figure><h2 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h2><p>具有使用简单、线程安全、节省内存等优点。<br>不可变类的对象会因为值的不同而产生新的对象，从而导致无法预料的问题，切不可滥用。</p><ul><li>类中所有成员变量被 private 所修饰。</li><li>类中没有写或者修改成员变量的方法。</li><li>确保类中所有方法不会被子类覆盖，用 final。</li><li>如果一个类成员不是不可变量，需要通过 clone 来确保类的不可变性。</li><li>如果有必要，可使用覆盖 Object 类的 equals() 方法、hashCode() 方法。</li><li>创建对象时，需要初始化所有成员变量。</li></ul><h2 id="类型转换的规则"><a href="#类型转换的规则" class="headerlink" title="类型转换的规则"></a>类型转换的规则</h2><h3 id="自动类型转换"><a href="#自动类型转换" class="headerlink" title="自动类型转换"></a>自动类型转换</h3><p>转换的规则为：从低精度向高精度转换，即优先级满足<code>byte &lt; short &lt; char &lt; int &lt; long &lt; float &lt; double</code>。</p><h3 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h3><p>从高级数据类型转换为低级数据类型时，需要进行强制类型转换。<br>涉及 byte、short、char 类型的运算时，会自动转换为 int 类型：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译器会报错</span></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>; s1 = s1 + <span class="number">1</span>;</span><br><span class="line"><span class="comment">//正确</span></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>; s1 = (<span class="keyword">short</span>)(s1 + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//Java编译器会对“+=”进行特殊处理，正确</span></span><br><span class="line"><span class="keyword">short</span> s1 = <span class="number">1</span>; s1 += <span class="number">1</span>;</span><br></pre></td></tr></table></figure><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><p>Java 中，为了保证移动位数的有效性（不超过 32bit），采用了<code>取余操作</code>。<br>即：a &gt;&gt; n 等价于 a &gt;&gt; (n%32)。</p><ul><li>“&gt;&gt;”为有符号右移运算符，正数高位补 0，<strong>负数高位补 1</strong>；</li><li>“&gt;&gt;&gt;”为无符号右移运算符，都补 0；</li><li>左移运算，移除高位的同时在低位补 0。</li></ul><hr><h2 id="new-String-“abc”-创建了几个对象？"><a href="#new-String-“abc”-创建了几个对象？" class="headerlink" title="new String(“abc”) 创建了几个对象？"></a>new String(“abc”) 创建了几个对象？</h2><p>一个或两个。如果字符串池中原来有“abc”，那么只创建一个对象；如果没有，就会创建两个。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Java/2_1.png" alt></p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在常量区里面存放了一个“abc”字符串对象</span></span><br><span class="line"><span class="keyword">String</span> s1 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//s2引用常量区中的对象，因此不会创建新对象</span></span><br><span class="line"><span class="keyword">String</span> s2 = <span class="string">"abc"</span>;</span><br><span class="line"><span class="comment">//在堆中创建新的对象</span></span><br><span class="line"><span class="keyword">String</span> s3 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"abc"</span>);</span><br><span class="line"><span class="comment">//在堆中又创建一个新的对象</span></span><br><span class="line"><span class="keyword">String</span> s4 = <span class="keyword">new</span> <span class="keyword">String</span>(<span class="string">"abc"</span>);</span><br></pre></td></tr></table></figure><h2 id="、equals、hashCode-的区别"><a href="#、equals、hashCode-的区别" class="headerlink" title="==、equals、hashCode 的区别"></a>==、equals、hashCode 的区别</h2><h3 id><a href="#" class="headerlink" title="=="></a>==</h3><p>用来比较两个变量的值是否相等。</p><h3 id="equals"><a href="#equals" class="headerlink" title="equals"></a>equals</h3><p>用于比较两个对象的内容是否相同，即<code>堆中的内容</code>是否相同。<br><strong>与“==”的不同：</strong>equals() 方法可以被覆盖，可以通过覆盖的方法让它不是比较引用而是比较数据内容。<br>返回的是 boolean 型。</p><h3 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode"></a>hashCode</h3><p>从 Object 类中继承过来，用来鉴定两个对象是否相等。<br>如果没有重写 hashCode() 方法，任何对象都不相等。<br><strong>与“equals”的不同：</strong>用户一般不会去调用 hashCode() 方法，它相当于是一个对象的编码，就好像文件中的 md5。<br>返回的是 int 型，比较起来不直观。</p><h2 id="String、StringBuffer、StringBuilder、StringTokenizer-的区别"><a href="#String、StringBuffer、StringBuilder、StringTokenizer-的区别" class="headerlink" title="String、StringBuffer、StringBuilder、StringTokenizer 的区别"></a>String、StringBuffer、StringBuilder、StringTokenizer 的区别</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p><code>不可变类</code>，适合在需要被共享的场合中使用。<br>可以利用构造函数的方式来对其进行初始化，也可以用<strong>赋值的方式</strong>来初始化；而 StringBuffer 只能使用构造函数的方式来初始化。</p><h3 id="StringBuffer"><a href="#StringBuffer" class="headerlink" title="StringBuffer"></a>StringBuffer</h3><p><code>可变类</code>，当一个字符串经常需要被修改时，最好使用 StringBuffer 来实现。<br>若使用 String，会多很多附加的操作，同时也生成了一些临时的对象，从而导致程序的执行效率降低。</p><h3 id="StringBuilder"><a href="#StringBuilder" class="headerlink" title="StringBuilder"></a>StringBuilder</h3><p>与 StringBuffer 类似，都是字符串缓冲区，但 StringBuilder 不是线程安全的。<br>若只是在<strong>单线程</strong>中使用字符串缓冲区，那么 StringBuilder 的效率会更高些。</p><blockquote><p>执行效率：StringBuilder &gt; StringBuffer &gt; String。</p></blockquote><h3 id="StringTokenizer"><a href="#StringTokenizer" class="headerlink" title="StringTokenizer"></a>StringTokenizer</h3><p>用来分割字符串的工具类。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>如果操作的数据量比较小，应优先使用 String 类；</li><li>如果是在单线程下操作大量数据，应优先使用 StringBuilder 类；</li><li>如果是在多线程下操作大量数据，应优先考虑 StringBuffer 类。</li></ul><h2 id="Java-中数组是对象"><a href="#Java-中数组是对象" class="headerlink" title="Java 中数组是对象"></a>Java 中数组是对象</h2><p>数组不仅有其自己的属性（length 属性），也有一些方法可以被调用（clone 方法），从这个角度来讲，数组是对象。<br>每个数组类型都有其对应的类型，可以通过 instanceof 来判断数据的类型。</p><h2 id="数组初始化与-C-的不同"><a href="#数组初始化与-C-的不同" class="headerlink" title="数组初始化与 C++ 的不同"></a>数组初始化与 C++ 的不同</h2><ul><li>Java 数组被创建后会根据数组存放的数据类型初始化成对应的初始值，int 会初始化为 0，对象会初始化为 null；</li><li>Java 数组在定义时，并不会给数组元素分配存储空间，因此[]中不需要指定数组的长度。</li></ul><h2 id="length-属性、length-方法、size-方法的区别"><a href="#length-属性、length-方法、size-方法的区别" class="headerlink" title="length 属性、length() 方法、size() 方法的区别"></a>length 属性、length() 方法、size() 方法的区别</h2><h3 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h3><p>数组提供了 length 属性来获取数组的长度。</p><h3 id="length-方法"><a href="#length-方法" class="headerlink" title="length() 方法"></a>length() 方法</h3><p>是针对<code>字符串</code>而言的，String 提供了 length() 方法来计算字符串的长度。</p><h3 id="size-方法"><a href="#size-方法" class="headerlink" title="size() 方法"></a>size() 方法</h3><p>是针对<code>泛型集合</code>而言的，用于查看泛型中有多少个元素。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOAPC 读书笔记-2</title>
      <link href="2017/05/03/AOAPC-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/"/>
      <url>2017/05/03/AOAPC-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<blockquote><p>函数和递归</p></blockquote><h2 id="自定义函数和结构体"><a href="#自定义函数和结构体" class="headerlink" title="自定义函数和结构体"></a>自定义函数和结构体</h2><p><strong>函数可以定义成：</strong></p><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">返回类型 函数名(参数列表) </span></span><br><span class="line"><span class="template-variable">&#123;</span></span><br><span class="line"><span class="template-variable">    函数体</span></span><br><span class="line"><span class="template-variable">&#125;</span></span><br></pre></td></tr></table></figure><p>函数体的最后一条语句，应该是“return 表达式”；<br>参数和返回值最好是“一等公民”；<br>执行过程中，碰到了 <strong>return 语句</strong>，将直接退出这个函数，不去执行后面的语句；<br>始终没有 return 语句，则会返回一个不确定的值。<br><strong>定义结构体的方法为：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> 结构体名称 </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    域定义</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><a id="more"></a><p>为了让结构体用起来和 int、double 这样的原生类型更接近，往往用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    域定义</span><br><span class="line">&#125; 类型名;</span><br></pre></td></tr></table></figure><p>即使最终答案在数据范围之内，中间结果仍然可能溢出；<br>对复杂的表达式<strong>进行化简</strong>，不仅能减少计算量，还能减少甚至避免中间结果溢出；<br>建议把<strong>谓词</strong>（用来判断某事物是否具有某种特性的函数）命名为“is_xxx”的形式。<br>通过四舍五入避免浮点误差：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> m = <span class="built_in">floor</span>(<span class="built_in">sqrt</span>(<span class="built_in">n</span>) + <span class="number">0.5</span>);</span><br></pre></td></tr></table></figure><h2 id="函数调用与参数传递"><a href="#函数调用与参数传递" class="headerlink" title="函数调用与参数传递"></a>函数调用与参数传递</h2><h3 id="形参与实参"><a href="#形参与实参" class="headerlink" title="形参与实参"></a>形参与实参</h3><p>函数的<strong>调用过程：</strong>计算实参的值，赋值给对应的形参，然后把“当前代码行”转移到函数的首部。</p><ul><li>函数的形参和在函数内声明的变量都是该函数的<code>局部变量</code>（local variable）。局部变量的存储空间是临时分配的，执行完毕时释放；</li><li>在函数外声明的变量是<code>全局变量</code>（global variable），可以被任何函数使用。操作全局变量有风险，应谨慎使用。</li></ul><h3 id="调用栈"><a href="#调用栈" class="headerlink" title="调用栈"></a>调用栈</h3><p><strong>调用栈</strong>（Call Stack）描述的是函数之间的调用关系，由多个栈帧（Stack Frame）组成。<br>每个栈帧对应着一个未运行完的函数，保存了该函数的返回地址和局部变量：</p><ul><li>能在执行完毕后找到正确的返回地址；</li><li>保证了不同函数间的局部变量互不相干。</li></ul><h3 id="用指针作参数"><a href="#用指针作参数" class="headerlink" title="用指针作参数"></a>用指针作参数</h3><p>每个变量都占有一定数目的字节，第一个字节的地址称为变量的地址。</p><ul><li>用 int *a 声明的变量 a 是指向 int 型变量的指针；</li><li>赋值 a = &amp;b 的含义是把变量 b 的地址存放在指针 a 中；</li><li>表达式 *a 代表 a 指向的变量。</li></ul><blockquote><p>千万不要滥用指针。</p></blockquote><h3 id="数组作为参数和返回值"><a href="#数组作为参数和返回值" class="headerlink" title="数组作为参数和返回值"></a>数组作为参数和返回值</h3><p>把数组作为参数传递给函数时，只有数组的首地址作为指针传递给了函数。在函数定义中的 <strong>int a[] 等价于 int *a</strong>。<br>需要另加一个参数表示元素个数：</p><figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">int</span> <span class="built_in">sum</span>(<span class="built_in">int</span> *a, <span class="built_in">int</span> <span class="built_in">n</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    for(<span class="built_in">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">n</span>; i++)</span><br><span class="line">        ans += a[i];</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>计算左闭右开区间内的元素和：</p><ul><li>算出从 begin 到 end（不含end）的元素个数 n；</li><li>用一个新指针 p 作为循环变量。</li></ul><h3 id="把函数作为函数的参数"><a href="#把函数作为函数的参数" class="headerlink" title="把函数作为函数的参数"></a>把函数作为函数的参数</h3><p>排序使用 C++ 中的 sort 函数，“将一个函数作为参数传递给另外一个函数”是很有用的。</p><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><h3 id="递归定义"><a href="#递归定义" class="headerlink" title="递归定义"></a>递归定义</h3><p>递归就是“自己使用自己”的意思，可以是直接的，也可以是间接的。</p><blockquote><p>递归定义的优点：简洁而严密。</p></blockquote><h3 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h3><p>注意为递归函数编写<strong>终止条件</strong>，否则将产生无限递归。</p><h3 id="C-语言对递归的支持"><a href="#C-语言对递归的支持" class="headerlink" title="C 语言对递归的支持"></a>C 语言对递归的支持</h3><p>由于使用了调用栈，在 C 语言中，调用自己和调用其他函数并没有本质不同；<br>尽管同一时刻可以有多个栈帧，但“当前代码行”只有一个。设计递归程序的重点在于给下级安排工作。</p><h3 id="段错误与栈溢出"><a href="#段错误与栈溢出" class="headerlink" title="段错误与栈溢出"></a>段错误与栈溢出</h3><p>每次递归调用都需要往调用栈里增加一个栈帧，久而久之就越界了，这种情况叫做<strong>栈溢出</strong>（Stack Overflow）；<br>在运行时，程序会动态创建一个堆栈段，里面存放着调用栈。</p><ul><li>在 Linux 中，栈大小并没有储存在可执行程序中，只能用 ulimit 命令修改；</li><li>在 Windows 中，栈大小存储在可执行程序中。</li></ul><p>把较大的数组放在 main 函数外；<br>局部变量也是放在堆栈段的，栈溢出也可能是局部变量太大。</p><h2 id="题目选讲"><a href="#题目选讲" class="headerlink" title="题目选讲"></a>题目选讲</h2><p>不用函数和递归也可以写出所有程序。<br>编写代码的顺序：</p><ul><li><strong>自顶向下</strong>：先写主程序，包括对函数的调用，再实现函数本身；</li><li><strong>自底向上</strong>：先写函数，再写主程序。</li></ul><p>在测试时，先测试工具函数的方式非常常用；<br>count、min、max 等都是 STL 已经使用的名字，程序中最好避开它们；</p><blockquote><p>根据函数编写的需要定义数据结构，而不是一开始就设计好数据结构。</p></blockquote><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>在编写实用软件时，往往需要编写自己的头文件。但在大部分算法竞赛中，只编写单个程序文件；<br>C 语言的函数可以有<code>副作用</code>，而不像数学函数那样“纯”。时刻警惕并最小化副作用；<br><strong>函数不能返回指针：</strong><br>局部变量在栈中，函数执行完毕后，局部变量就失效了。指针里保存的地址仍然存在，但不再属于那个局部变量了。<br><strong>推荐写法：</strong></p><ul><li>可以把这个指针作为参数，然后在函数里修改它；</li><li>可以使用 malloc 函数进行动态内存分配。</li></ul><p>缓解浮点误差的权宜之计：<br>加上一个 <code>EPS</code> 以后再输出，通常取一个比最低精度还要小几个数量级的小实数。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>《面试宝典》读书笔记-1</title>
      <link href="2017/04/30/%E3%80%8A%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/"/>
      <url>2017/04/30/%E3%80%8A%E9%9D%A2%E8%AF%95%E5%AE%9D%E5%85%B8%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>基本概念、面向对象技术</p></blockquote><h2 id="Java-语言的优点"><a href="#Java-语言的优点" class="headerlink" title="Java 语言的优点"></a>Java 语言的优点</h2><h3 id="纯面向对象语言"><a href="#纯面向对象语言" class="headerlink" title="纯面向对象语言"></a>纯面向对象语言</h3><p>能够直接反应现实生活中的对象。</p><h3 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h3><p>由于 Java 为解释型语言，编译器会把 Java 代码变成<code>中间代码</code>，然后在 JVM 上解释执行。<br>中间代码与平台无关，可以很好地跨平台执行，具有很好的可移植性。</p><h3 id="提供了很多内置的类库"><a href="#提供了很多内置的类库" class="headerlink" title="提供了很多内置的类库"></a>提供了很多内置的类库</h3><p>简化了开发人员的程序设计工作，同时缩短了项目开发的时间。<br>对多线程的支持、对网络通讯的支持、垃圾回收器。</p><a id="more"></a><h3 id="提供了对-Web-应用开发的支持"><a href="#提供了对-Web-应用开发的支持" class="headerlink" title="提供了对 Web 应用开发的支持"></a>提供了对 Web 应用开发的支持</h3><h3 id="具有较好的安全性和健壮性"><a href="#具有较好的安全性和健壮性" class="headerlink" title="具有较好的安全性和健壮性"></a>具有较好的安全性和健壮性</h3><ul><li>安全性：防止恶意代码攻击的安全机制，数组边界检测、Bytecode 校验；</li><li>健壮性：强类型机制、垃圾回收器、异常处理、安全检查机制。</li></ul><h3 id="去除-C-语言中不好的特性"><a href="#去除-C-语言中不好的特性" class="headerlink" title="去除 C++ 语言中不好的特性"></a>去除 C++ 语言中不好的特性</h3><p>头文件、指针、结构、单元、运算符重载、虚基类、多重继承，使得程序更加严谨、简洁。</p><h2 id="Java-与-C-的异同"><a href="#Java-与-C-的异同" class="headerlink" title="Java 与 C++ 的异同"></a>Java 与 C++ 的异同</h2><h3 id="Java-为解释型语言"><a href="#Java-为解释型语言" class="headerlink" title="Java 为解释型语言"></a>Java 为解释型语言</h3><p>C++ 为编译型语言，Java 执行速度更慢，但能跨平台执行。</p><h3 id="Java-为纯面向对象语言"><a href="#Java-为纯面向对象语言" class="headerlink" title="Java 为纯面向对象语言"></a>Java 为纯面向对象语言</h3><p>所有代码必须在类中实现，所有类型都是类。<br>不存在全局变量或全局函数。</p><h3 id="没有指针的概念"><a href="#没有指针的概念" class="headerlink" title="没有指针的概念"></a>没有指针的概念</h3><p>有效防止了 C++ 语言中操作指针可能引起的系统问题，更加安全。</p><h3 id="不支持多重继承"><a href="#不支持多重继承" class="headerlink" title="不支持多重继承"></a>不支持多重继承</h3><p>引入了<code>接口</code>的概念，接口也具有多态特性，Java 可以通过实现多个接口来实现与多重继承类似的目的。</p><h3 id="提供了垃圾回收器"><a href="#提供了垃圾回收器" class="headerlink" title="提供了垃圾回收器"></a>提供了垃圾回收器</h3><p>不需要程序显式地管理内存的分配，Java 语言中虽然没有析构函数，但引入了 finalize() 方法。<br>当垃圾回收器将要释放无用对象的内存时，会首先调用该对象的 finalized() 方法，开发人员不需要关心对象所占的内存空间何时会被释放。</p><h2 id="public-static-void-main-String-args"><a href="#public-static-void-main-String-args" class="headerlink" title="public static void main(String[] args)"></a>public static void main(String[] args)</h2><h3 id="public"><a href="#public" class="headerlink" title="public"></a>public</h3><p>权限修饰符，表明任何类或对象都可以访问这个方法。</p><h3 id="static"><a href="#static" class="headerlink" title="static"></a>static</h3><p>方法中的代码时存储在静态存储区的，只要类被加载后，就可以使用该方法而不需要通过实例化对象来访问。通过类名.main() 直接访问。</p><h3 id="void"><a href="#void" class="headerlink" title="void"></a>void</h3><p>表明方法没有返回值。</p><h3 id="main"><a href="#main" class="headerlink" title="main"></a>main</h3><p>JVM 识别的特殊方法名，是程序入口的方法。</p><h3 id="String-args"><a href="#String-args" class="headerlink" title="String[] args"></a>String[] args</h3><p>开发人员在命令行状态下与程序交互的手段。</p><h2 id="在-main-方法执行前输出“Hello-World”"><a href="#在-main-方法执行前输出“Hello-World”" class="headerlink" title="在 main() 方法执行前输出“Hello World”"></a>在 main() 方法执行前输出“Hello World”</h2><p>由于静态块不管顺序如何，都会在 main() 方法执行之前执行，因此利用静态块可以实现输出“Hello World”的功能。</p><h2 id="初始化顺序"><a href="#初始化顺序" class="headerlink" title="初始化顺序"></a>初始化顺序</h2><h3 id="静态对象优先于非静态对象"><a href="#静态对象优先于非静态对象" class="headerlink" title="静态对象优先于非静态对象"></a>静态对象优先于非静态对象</h3><p>静态对象只初始化一次，非静态对象可能会初始化很多次。</p><h3 id="父类优先于子类"><a href="#父类优先于子类" class="headerlink" title="父类优先于子类"></a>父类优先于子类</h3><h3 id="按照成员变量的定义顺序"><a href="#按照成员变量的定义顺序" class="headerlink" title="按照成员变量的定义顺序"></a>按照成员变量的定义顺序</h3><p>即使变量定义散布于方法定义之中，它们依然在任何方法被调用之前先初始化。</p><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h3><p>被 static 修饰的成员变量称为静态变量或全局变量，只要一个类被加载，JVM 就会给类的静态变量分配存储空间。</p><h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>作用域与可见性为它所在的花括号内。</p><h3 id="成员变量"><a href="#成员变量" class="headerlink" title="成员变量"></a>成员变量</h3><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/Java/1_1.png" alt><br>这些修饰符只能用来修饰成员变量，不能用来修饰局部变量。</p><blockquote><p>只有 public、abstract、final 能用来修饰类。</p></blockquote><h2 id="定义多个类"><a href="#定义多个类" class="headerlink" title="定义多个类"></a>定义多个类</h2><p>可以定义多个类，但是最多只能有一个类被 public 修饰。<br>当用 javac 指令编译 .java 文件时，它会给每一个类生成一个对应的 .class 文件。</p><h2 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h2><p>一种特殊的函数，用来在对象实例化时初始化对象的成员变量：</p><ul><li>构造函数必须与类的名字相同，并且不能有返回值。</li><li>每个类可以有多个构造函数。</li><li>构造函数可以有 0、1 或 1 以上的参数。</li><li>构造函数总是伴随着 <strong>new 操作</strong>一起调用，必须由系统调用。<ul><li>构造函数在对象实例化时会被自动调用，且只能运行一次；</li><li>普通方法是在程序执行到它时被调用，且可以被该对象调用多次。</li></ul></li><li>构造函数的主要作用是完成对象的初始化工作。</li><li>构造函数不能被继承，因此它不能被<strong>覆盖</strong>，但能够被<strong>重载</strong>。 </li><li>子类可以通过 super 关键字来显式地调用父类的构造函数。</li><li>默认构造器的修饰符只跟当前类的修饰符有关。</li></ul><h2 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h2><p>Java 中一个类只能有一个父类。接口是抽象方法定义的集合，是一种特殊的抽象类。</p><h3 id="只包含方法的定义"><a href="#只包含方法的定义" class="headerlink" title="只包含方法的定义"></a>只包含方法的定义</h3><p>没有方法的实现。</p><h3 id="成员的作用域修饰符都是-public"><a href="#成员的作用域修饰符都是-public" class="headerlink" title="成员的作用域修饰符都是 public"></a>成员的作用域修饰符都是 public</h3><h3 id="标识接口"><a href="#标识接口" class="headerlink" title="标识接口"></a>标识接口</h3><p>没有任何方法声明，仅仅充当一个标识的作用。</p><h2 id="clone-方法"><a href="#clone-方法" class="headerlink" title="clone() 方法"></a>clone() 方法</h2><p>Java 在处理基本数据类型（int、char等）时，采用按值传递的方式执行，传递的是输入参数的复制。<br>其他类型都是按引用传递的方式执行，传递的是对象的一个引用。<br><strong>赋值操作采用引用传递</strong>，无法达到对B的修改不会影响到A的目的。Java 提供一个简单有效的 clone() 方法来满足这个需求。</p><h2 id="反射机制"><a href="#反射机制" class="headerlink" title="反射机制"></a>反射机制</h2><p>反射机制是 Java 中一个非常重要的特性，它允许程序在运行时进行自我检查，同时也允许对其内部的成员进行操作。</p><blockquote><p>非常重要的一个作用：在运行时动态地创建类的对象。</p></blockquote><h3 id="创建对象的方法"><a href="#创建对象的方法" class="headerlink" title="创建对象的方法"></a>创建对象的方法</h3><ol><li>通过 new 语句实例化一个对象。</li><li>通过反射机制创建对象。</li><li>通过 clone() 方法创建一个对象。</li><li>通过反序列化的方式创建对象。</li></ol><h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>宗旨是把 .java 文件、.class 文件（编译后的文件）、其他 resource 文件有条理地进行一个组织，以供使用。类似于 Linux 文件系统。</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>提供多层命名空间，解决命名冲突；</li><li>对类按功能进行分类，使项目的组织更加清晰。</li></ul><h2 id="实现-C-中的函数指针"><a href="#实现-C-中的函数指针" class="headerlink" title="实现 C++ 中的函数指针"></a>实现 C++ 中的函数指针</h2><p><strong>回调函数：</strong>函数先在某处注册，而它将在稍后某个需要的时候被调用。<br>可以利用接口与类实现函数指针的功能。</p><hr><h2 id="面向对象与面向过程的区别"><a href="#面向对象与面向过程的区别" class="headerlink" title="面向对象与面向过程的区别"></a>面向对象与面向过程的区别</h2><h3 id="出发点不同"><a href="#出发点不同" class="headerlink" title="出发点不同"></a>出发点不同</h3><ul><li>面向对象：符合常规思维方式，映射到对象及对象之间的接口上。</li><li>面向过程：强调过程的抽象画与模块化。</li></ul><h3 id="层次逻辑不同"><a href="#层次逻辑不同" class="headerlink" title="层次逻辑不同"></a>层次逻辑不同</h3><p>面向对象：用类的层次结构体现类之间的继承和发展；<br>面向过程：用模块的层次结构概括模块或模块间的关系与功能，把客观世界的问题抽象成计算机可以处理的过程。</p><h3 id="数据处理方式与控制程序方式不同"><a href="#数据处理方式与控制程序方式不同" class="headerlink" title="数据处理方式与控制程序方式不同"></a>数据处理方式与控制程序方式不同</h3><p>面向对象：原则上对象的修改只能由自身的成员函数完成，通过<strong>事件驱动</strong>来激活和运行程序；<br>面向过程：直接通过程序来处理数据，各模块之间存在着控制与被控制、调用与被调用的关系。</p><h3 id="分析设计与编码转换方式不同"><a href="#分析设计与编码转换方式不同" class="headerlink" title="分析设计与编码转换方式不同"></a>分析设计与编码转换方式不同</h3><p>面向对象：分析、设计、编码采用一致性的模型，实现的是一种无缝连接；<br>面向过程：分析、设计、编码之间按规则进行转换，实现的是一种有缝连接。</p><h2 id="面向对象的特征"><a href="#面向对象的特征" class="headerlink" title="面向对象的特征"></a>面向对象的特征</h2><h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>并不打算了解全部问题，只是选择其中的一部分。包括：</p><ul><li>过程抽象</li><li>数据抽象</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>一种联结类的层次模型，子类可以修改或增加新的方法使之更适合特殊的需要。</p><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>每个类对自身的数据和方法实行保护，对不可信的操作进行信息隐藏。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>允许不同类的对象对同一消息作出响应，很好地解决了应用程序函数同名的问题。</p><h2 id="面向对象的优点"><a href="#面向对象的优点" class="headerlink" title="面向对象的优点"></a>面向对象的优点</h2><h3 id="较高的开发效率"><a href="#较高的开发效率" class="headerlink" title="较高的开发效率"></a>较高的开发效率</h3><p>与人类的思维过程类似，可以通过继承或组合的方式来实现代码的重用，大大地提高了软件的开发效率。</p><h3 id="保证软件的鲁棒性"><a href="#保证软件的鲁棒性" class="headerlink" title="保证软件的鲁棒性"></a>保证软件的鲁棒性</h3><p>可以重用在相关领域经过长期测试的代码，对软件的鲁棒性起到了良好的促进作用。</p><h3 id="保证软件的高可维护性"><a href="#保证软件的高可维护性" class="headerlink" title="保证软件的高可维护性"></a>保证软件的高可维护性</h3><p>一些非常成熟的设计模式，使程序在面对需求变更时，只需要修改部分的模块就可以满足需求。</p><h2 id="继承的特性"><a href="#继承的特性" class="headerlink" title="继承的特性"></a>继承的特性</h2><ul><li>Java 不支持多重继承。</li><li>子类只能继承父类的非私有成员变量与方法。</li><li>同名时，子类将会覆盖父类，而不会继承。</li></ul><h2 id="组合与继承的区别"><a href="#组合与继承的区别" class="headerlink" title="组合与继承的区别"></a>组合与继承的区别</h2><p>组合和继承是面向对象中两种代码复用的方式。</p><h3 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h3><p>组合中的整体类对应继承中的子类，是显式的。</p><h3 id="继承-1"><a href="#继承-1" class="headerlink" title="继承"></a>继承</h3><p>继承中的父类对应组合中的局部类，是隐式的。</p><h3 id="原则"><a href="#原则" class="headerlink" title="原则"></a>原则</h3><ul><li>不要单纯地为了实现重用而使用继承，会破坏代码的可维护性；</li><li>不要仅仅为了实现多态而使用继承，可以通过接口与组合的方式达到相同的目的，具有更好的可扩展性。</li></ul><blockquote><p>在 Java 语言中，能使用组合就尽量不要使用继承。</p></blockquote><h2 id="多态的实现机制"><a href="#多态的实现机制" class="headerlink" title="多态的实现机制"></a>多态的实现机制</h2><h3 id="方法的重载（overload）"><a href="#方法的重载（overload）" class="headerlink" title="方法的重载（overload）"></a>方法的重载（overload）</h3><p>编译时的多态。</p><h3 id="方法的覆盖（override）"><a href="#方法的覆盖（override）" class="headerlink" title="方法的覆盖（override）"></a>方法的覆盖（override）</h3><p>运行时的多态。</p><blockquote><p>只有类中的方法才有多态的概念，类中的成员变量没有多态的概念。</p></blockquote><h2 id="重载和覆盖的区别"><a href="#重载和覆盖的区别" class="headerlink" title="重载和覆盖的区别"></a>重载和覆盖的区别</h2><h3 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h3><ul><li>通过不同的方法参数来区分。</li><li>不能通过方法的访问权限、返回值类型、抛出的异常类型来进行重载。</li><li>private 不能重载。</li></ul><h3 id="覆盖"><a href="#覆盖" class="headerlink" title="覆盖"></a>覆盖</h3><ul><li>有相同的函数名和参数。</li><li>返回值相同。</li><li>抛出的异常一致。</li><li>private 不能覆盖。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>覆盖是子类和父类之间的关系，是<code>垂直关系</code>；重载是同一个类中方法之间的关系，是<code>水平关系</code>。</li><li>覆盖只能由一对方法产生关系；重载是多个方法之间的关系。</li><li>覆盖要求参数列表相同；重载要求参数列表不同。</li></ul><h2 id="抽象类与接口的异同"><a href="#抽象类与接口的异同" class="headerlink" title="抽象类与接口的异同"></a>抽象类与接口的异同</h2><h3 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h3><ul><li>都不能被实例化。</li><li>只有实现了接口或抽象类中的方法才能被实例化。</li></ul><h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><ul><li>接口只有定义，其方法不能在接口中实现；抽象类的方法可以在抽象类中被实现。</li><li>接口需要实现，一个类可以实现多个接口；抽象类只能被继承，一个类只能继承一个抽象类。</li><li>接口强调特定功能的实现，是“has -a”关系；抽象类强调所属关系，是“is-a”关系。</li><li>当功能需要累积时，用抽象类；不需要累积时，用接口。</li></ul><blockquote><p>接口被运用于实现比较常用的功能，便于日后维护或者添加删除方法；抽象类不适用于日后重新对里面的代码进行修改。</p></blockquote><h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><p>Java 中可以把一个类定义到另外一个类的内部，在类里面的这个类就叫做内部类。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><p>只能访问外部类中的静态成员和静态方法。</p><h3 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h3><p>可以自由地引用外部类中的属性和方法。</p><h3 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h3><p>作用范围为其所在的代码块，最少使用。</p><h3 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h3><p>没有类名的内部类，一定是<strong>在 new 的后面</strong>，必须继承一个父类或实现一个接口。</p><h2 id="获取父类的类名"><a href="#获取父类的类名" class="headerlink" title="获取父类的类名"></a>获取父类的类名</h2><p>getClass().getName()</p><h2 id="this-与-super-的区别"><a href="#this-与-super-的区别" class="headerlink" title="this 与 super 的区别"></a>this 与 super 的区别</h2><p><code>名字相同会覆盖</code></p><ul><li>this 用来区分对象的成员变量、方法的形参；</li><li>super 用来区分子类、父类的方法或成员变量。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python 语言精要-1</title>
      <link href="2017/04/27/Python-%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81-1/"/>
      <url>2017/04/27/Python-%E8%AF%AD%E8%A8%80%E7%B2%BE%E8%A6%81-1/</url>
      
        <content type="html"><![CDATA[<blockquote><p>常常得先把那些乱七八糟的数据，处理成漂亮点的结构化形式。</p></blockquote><h2 id="Python-解释器"><a href="#Python-解释器" class="headerlink" title="Python 解释器"></a>Python 解释器</h2><p>一次执行一条语句。<br>“&gt;&gt;&gt;”是提示符，可以在那里输入表达式。</p><h2 id="语言语义"><a href="#语言语义" class="headerlink" title="语言语义"></a>语言语义</h2><p>重视可读性、简洁性、明确性，可执行的伪代码。</p><h3 id="缩进，而不是大括号"><a href="#缩进，而不是大括号" class="headerlink" title="缩进，而不是大括号"></a>缩进，而不是大括号</h3><p>通过空白符（4 个空格）来组织代码。<br><strong>冒号</strong>表示一段缩进代码块的开始，其后必须缩进相同的量，直到代码块结束为止：</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> array:</span><br><span class="line">    <span class="keyword">if</span> x &lt; pivot:</span><br><span class="line">        less.append(x)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        greater.append(x)</span><br></pre></td></tr></table></figure><p>在一行上放置多条语句的做法是不推荐的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span>; b = <span class="number">6</span>; c = <span class="number">7</span></span><br></pre></td></tr></table></figure><h3 id="万物皆对象"><a href="#万物皆对象" class="headerlink" title="万物皆对象"></a>万物皆对象</h3><p>对象模型的一致性。<br>即使是函数也能被当做其他对象那样处理。</p><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>任何前缀为“#”的文本都会被解释器忽略掉。</p><h3 id="函数调用和对象方法调用"><a href="#函数调用和对象方法调用" class="headerlink" title="函数调用和对象方法调用"></a>函数调用和对象方法调用</h3><p>函数的调用需要用到圆括号以及 0 个或多个参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = f(x, y, z)</span><br></pre></td></tr></table></figure><p>几乎所有的 Python 对象都有一些附属函数（方法），可以访问该对象的内部数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj.some_method(x, y, z)</span><br></pre></td></tr></table></figure><p>函数既可以接受位置参数，也可以接受关键字参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result = f(a, b, c, d=<span class="number">5</span>, e=<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure><h3 id="变量和按引用传递"><a href="#变量和按引用传递" class="headerlink" title="变量和按引用传递"></a>变量和按引用传递</h3><p>在 Python 中对变量赋值时，其实是在创建等号右侧对象的一个<strong>引用</strong>。<br>只是传入了一个引用而已，不会发生任何复制：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/python/python_1.jpeg" alt></p><blockquote><p>按引用传递，Python 函数可以修改其参数的内容。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">append_element(data, <span class="number">4</span>)</span><br><span class="line">data</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h3 id="动态引用，强类型"><a href="#动态引用，强类型" class="headerlink" title="动态引用，强类型"></a>动态引用，强类型</h3><p>Python 中的对象引用没有与之关联的类型信息，对象的类型信息是保存在它自己<strong>内部</strong>的。<br>Python 可以被认为是一种<strong>强类型</strong>语言，隐式转换只在很明显的情况下才会发生：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># TypeError</span></span><br><span class="line"><span class="string">'5'</span> + <span class="number">5</span></span><br></pre></td></tr></table></figure><p>通过 isinstance 函数，可以检查一个对象是否是某个特定类型的实例。可以接受由类型组成的元组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5</span></span><br><span class="line">isinstance(a, (int, float))</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure><h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>Python 中的对象通常都既有属性（attribute），又有方法（method）。它们都能通过 obj.attribute_name 这样的语法进行访问。</p><ul><li>属性：存储在该对象内部的，其他 Python <strong>对象</strong>；</li><li>方法：与该对象有关的能够访问其内部数据的<strong>函数</strong>。</li></ul><h3 id="“鸭子”类型"><a href="#“鸭子”类型" class="headerlink" title="“鸭子”类型"></a>“鸭子”类型</h3><p>你可能不会关心对象的类型，只是想知道它到底有没有某些方法或行为。<br><strong>应用场景：</strong>在编写可以接受任何序列（列表、元祖、ndarray）或迭代器的函数时，先检查对象是不是列表，如果不是，就将其转换成是：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> isinstance(x, list) <span class="keyword">and</span> isiterable(x):</span><br><span class="line">    x = list(x)</span><br></pre></td></tr></table></figure><h3 id="引入（import）"><a href="#引入（import）" class="headerlink" title="引入（import）"></a>引入（import）</h3><p>模块（module）：一个含有函数和变量定义以及从其他 .py 文件引入的此类东西的 <strong>.py 文件</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># some_module.py</span></span><br><span class="line">PI = <span class="number">3.14159</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x + <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">g</span><span class="params">(a, b)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure><p>通过 <strong>as 关键字</strong>，可以引入不同的变量名（定义别名）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> some_module <span class="keyword">as</span> sm</span><br><span class="line"><span class="keyword">from</span> some_module <span class="keyword">import</span> PI <span class="keyword">as</span> pi, g <span class="keyword">as</span> gf</span><br><span class="line"></span><br><span class="line">r1 = sm.f(pi)</span><br><span class="line">r2 = gf(<span class="number">6</span>, pi)</span><br></pre></td></tr></table></figure><h3 id="二元运算符和比较运算符"><a href="#二元运算符和比较运算符" class="headerlink" title="二元运算符和比较运算符"></a>二元运算符和比较运算符</h3><p>判断两个引用是否指向同一对象，可以使用 is 关键字。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">b = a</span><br><span class="line"><span class="comment"># list 函数始终会创建新列表</span></span><br><span class="line">c = list(a)</span><br><span class="line"></span><br><span class="line">a <span class="keyword">is</span> b</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br><span class="line"></span><br><span class="line">a <span class="keyword">is</span> <span class="keyword">not</span> c</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="literal">True</span></span><br></pre></td></tr></table></figure><p>跟比较运算“==”，不是一回事。<br>is 和 is not 常常用于判断变量是否为 None，因为 None 的实例只有一个。</p><h3 id="严格与懒惰"><a href="#严格与懒惰" class="headerlink" title="严格与懒惰"></a>严格与懒惰</h3><p>在 Python 中，只要这些语句被求值，相关计算就会立即（也就是严格）发生。<br><strong>延迟计算</strong>（lazy evaluation）：具体值在被使用之前，不会被计算出来。<br>迭代器、生成器可以用于实现延迟计算，当执行一些负荷非常高的计算时，可以派上用场。</p><h3 id="可变和不可变的对象"><a href="#可变和不可变的对象" class="headerlink" title="可变和不可变的对象"></a>可变和不可变的对象</h3><p>大部分 Python 对象是可变的（mutable），它们所包含的对象或值是可以被修改的；<br>字符串、元组是不可变的（immutable）。<br>建议尽量避免<strong>副作用</strong>（side effect），注重不变性。</p><h2 id="标量类型"><a href="#标量类型" class="headerlink" title="标量类型"></a>标量类型</h2><h3 id="数值类型"><a href="#数值类型" class="headerlink" title="数值类型"></a>数值类型</h3><p>Python 会自动将非常大的整数转换为 long：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ival = <span class="number">17239871</span></span><br><span class="line">ival ** <span class="number">6</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">26254519291092456596965462913230729701102721L</span></span><br></pre></td></tr></table></figure><p>得到 C 风格的整数除法，使用 //：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">3</span> // <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure><p>复数的虚部是用 j 表示的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cval = <span class="number">1</span> + <span class="number">2j</span></span><br><span class="line">cval * (<span class="number">1</span> - <span class="number">2j</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span> + <span class="number">0j</span></span><br></pre></td></tr></table></figure><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>编写字符串时，既可以用单引号（’）也可以用双引号（’’）。<br>对于带有换行符的多行字符串，可以使用三重引号。<br>Python 字符串是<strong>不可变</strong>的，要修改字符串就只能创建一个新的。<br>许多对象都可以用 str 函数转换为字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">5.6</span></span><br><span class="line">s = str(a)</span><br><span class="line">s</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'5.6'</span></span><br></pre></td></tr></table></figure><p>字符串其实是一串<strong>字符序列</strong>，可以被当作某种序列类型进行处理：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'python'</span></span><br><span class="line">list(s)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'p'</span>, <span class="string">'y'</span>, <span class="string">'t'</span>, <span class="string">'h'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>]</span><br><span class="line"></span><br><span class="line">s[:<span class="number">3</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'pyt'</span></span><br></pre></td></tr></table></figure><p>用实参替换格式化形参：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">template = <span class="string">'%.2f %s are worth $%d'</span></span><br><span class="line">template % (<span class="number">4.5560</span>, <span class="string">'Argentine Pesos'</span>, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'4.56 Argentine Pesos are worth $1'</span></span><br></pre></td></tr></table></figure><h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>Python 中两个布尔值分别写作 True 和 False，可以用 and 和 or 关键字进行连接。<br>几乎所有内置的 Python 类型都能在 if 语句中被解释为 True 或 False：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"><span class="keyword">if</span> a:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'I found something!'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>I found something!</span><br></pre></td></tr></table></figure><p>想知道某个对象究竟会被强制转换成哪个布尔值，使用 <strong>bool 函数</strong>即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool([]), bool([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="literal">False</span>, <span class="literal">True</span>)</span><br></pre></td></tr></table></figure><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>str、bool、int、float 等类型，也可以作将值转换成该类型的函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="string">'3.14159'</span></span><br><span class="line">fval = float(s)</span><br><span class="line">type(fval)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>float</span><br></pre></td></tr></table></figure><h3 id="None"><a href="#None" class="headerlink" title="None"></a>None</h3><p>None 是 Python 的空值类型。如果一个函数没有显式地返回值，则隐式返回 None。<br>None 是函数可选参数的一种常见默认值。<br>None 不是一个保留关键字，只是 NoneType 的一个<strong>实例</strong>而已。</p><h3 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h3><p>Python 内置的 datetime 模块中，datetime 类型是用得最多的，它合并了保存在 date 和 time 中的信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, data, time</span><br><span class="line">dt = datetime(<span class="number">2011</span>, <span class="number">10</span>, <span class="number">29</span>, <span class="number">20</span>, <span class="number">30</span>, <span class="number">21</span>)</span><br><span class="line"></span><br><span class="line">dt.day</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">29</span></span><br><span class="line"></span><br><span class="line">dt.minute</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">30</span></span><br></pre></td></tr></table></figure><p>strftime 方法用于将 datetime 格式化为字符串（也可以反向解析）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dt.strftime(<span class="string">'%m/%d/%Y %H:%M'</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'10/29/2011 20:30'</span></span><br></pre></td></tr></table></figure><p>两个 datetime 对象的差会产生一个 datetime.timedelta 类型：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dt2 = datetime(<span class="number">2011</span>, <span class="number">11</span>, <span class="number">15</span>, <span class="number">22</span>, <span class="number">30</span>)</span><br><span class="line">delta = dt2 - dt</span><br><span class="line">delta</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>datetime.timedelta(<span class="number">17</span>, <span class="number">7179</span>)</span><br></pre></td></tr></table></figure><h2 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h2><h3 id="if、elif、else"><a href="#if、elif、else" class="headerlink" title="if、elif、else"></a>if、elif、else</h3><p>一条 if 语句可以跟上一个或多个 <strong>elif 块</strong>以及一个滴水不漏的 <strong>else 块</strong>（如果所有条件都为 False）。<br>对于用 and 或 or 组成的复合条件，各条件是按从左到右的顺序求值的，而且是<strong>短路型</strong>的。</p><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>for 循环用于对集合或迭代器进行迭代，<strong>标准语法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> collection:</span><br><span class="line">    <span class="comment"># 对 value 做一些处理</span></span><br></pre></td></tr></table></figure><h3 id="while-循环"><a href="#while-循环" class="headerlink" title="while 循环"></a>while 循环</h3><p>while 循环定义了<strong>一个条件</strong>和<strong>一个代码块</strong>。只要条件不为 False，代码块将一直不断地执行下去。</p><h3 id="pass"><a href="#pass" class="headerlink" title="pass"></a>pass</h3><p>Python 中的空操作语句，在开发一个新功能时，常常会将 pass 用作代码中的<strong>占位符：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f</span><span class="params">(x, y, z)</span></span></span><br><span class="line"><span class="function">    # <span class="title">TODO</span>:</span> 实现这个函数</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>优雅地处理 Python 错误或异常是构建健壮程序的重要环节。<br>把对函数的调用放在一个 <strong>try/except 块</strong>中，在 except 后面加上异常类型组成的元组，即可捕获多个异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">attempt_float</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">return</span> float(x)</span><br><span class="line">    <span class="keyword">except</span> (TypeError, ValueError):</span><br><span class="line">        <span class="keyword">return</span> x</span><br></pre></td></tr></table></figure><p>希望有一段代码不管 try 块代码成功与否都能被执行，使用 <strong>finally</strong> 即可；让某些代码只在 try 块成功时执行，使用 <strong>else</strong> 即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">f = open(path, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    write_to_file(f)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Failed'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'Succeeded'</span></span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><h3 id="range-和-xrange"><a href="#range-和-xrange" class="headerlink" title="range 和 xrange"></a>range 和 xrange</h3><p>range 函数用于产生一组间隔平均的整数，可以指定<strong>起始值、结束值、步长</strong>等信息：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">range(<span class="number">0</span>, <span class="number">20</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>]</span><br></pre></td></tr></table></figure><p>range 所产生的蒸熟不包括末端值，常用于按索引对序列进行迭代：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">seq = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(seq)):</span><br><span class="line">    val = seq[i]</span><br></pre></td></tr></table></figure><p>对于非常长的范围，建议使用 xrange。不会预先产生所有的值，而是返回一个用于逐个产生整数的<strong>迭代器</strong>。</p><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>允许将产生一个值的 <strong>if-else 块</strong>写到一行或一个表达式中，语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value = true_expr <span class="keyword">if</span> condition <span class="keyword">else</span> false_expr</span><br></pre></td></tr></table></figure><p>如果条件以及 true 和 false 表达式非常复杂，可能会牺牲可读性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">5</span></span><br><span class="line"><span class="string">'Non-negative'</span> <span class="keyword">if</span> x &gt;= <span class="number">0</span> <span class="keyword">else</span> <span class="string">'Negative'</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">'Non-negative'</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>决策树</title>
      <link href="2017/04/25/%E5%86%B3%E7%AD%96%E6%A0%91/"/>
      <url>2017/04/25/%E5%86%B3%E7%AD%96%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<h2 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h2><p>决策过程中提出的每个判定问题都是对某个属性的<strong>测试</strong><br>考虑范围在上一次决策结果的限定范围之内</p><ul><li>叶结点对应于决策结果</li><li>其他每个结点对应于一个属性测试</li><li>根结点包含样本全集</li></ul><h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>决策树学习的目的是为了，产生一棵处理未见示例能力强的决策树。<br>遵循简单且直观的分而治之（divide-and-comquer）策略。</p><a id="more"></a><h3 id="递归过程"><a href="#递归过程" class="headerlink" title="递归过程"></a>递归过程</h3><p>三种情形会导致递归返回：</p><ol><li>当前结点包含的样本全属于同一类别；</li><li>当前属性集为空，或是所有样本在所有属性上取值相同；</li><li>当前结点包含的样本集合为空；</li></ol><h2 id="划分选择"><a href="#划分选择" class="headerlink" title="划分选择"></a>划分选择</h2><p>决策树学习的<strong>关键</strong>是，如何选择最优划分属性。<br>随着划分过程不断进行，结点的<strong>纯度</strong>（purity）越来越高。</p><h3 id="信息增益"><a href="#信息增益" class="headerlink" title="信息增益"></a>信息增益</h3><p><strong>信息熵</strong>（information entropy）是度量样本集合纯度最常用的一种指标。<br>Ent(D) 的值越小，则 D 的纯度越高。<br>信息增益越大，使用属性a来进行划分所获得的纯度提升越大。<br><strong>ID3</strong> 以信息增益为准则来选择划分属性。</p><h3 id="增益率"><a href="#增益率" class="headerlink" title="增益率"></a>增益率</h3><p>信息增益准则对<strong>可取值数目</strong>较多的属性有所偏好。<br>增益率（gain ratio）准则对可取数目较少的属性有所偏好。<br><strong>C4.5</strong> 使用增益率来选择最优划分属性。<br><strong>启发式</strong>：</p><ol><li>从候选划分属性中找出信息增益高于平均水平的属性；</li><li>从中选择增益率最高的；</li></ol><h3 id="基尼指数"><a href="#基尼指数" class="headerlink" title="基尼指数"></a>基尼指数</h3><p>基尼指数（Gini index）反映了从数据集 D 中随机抽取两个样本，其类别标记不一致的概率。<br>Gini(D) 越小，则数据集 D 的纯度越高。<br><strong>CART</strong> 使用基尼指数来选择划分属性。</p><h2 id="剪枝处理"><a href="#剪枝处理" class="headerlink" title="剪枝处理"></a>剪枝处理</h2><p>剪枝（pruning）是决策树学习算法对付<strong>过拟合</strong>的主要手段。</p><ul><li>预剪枝（prepruning）：若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。</li><li>后剪枝（postpruning）：<strong>自底向上</strong>，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。</li></ul><h3 id="预剪枝"><a href="#预剪枝" class="headerlink" title="预剪枝"></a>预剪枝</h3><p>仅有一层划分的决策树，亦称决策树桩（decision stump）。<br>显著减少了决策树的训练时间开销和测试<strong>时间开销</strong>。</p><blockquote><p>后续划分有可能导致性能显著提高，禁止这些分支展开，带来了欠拟合的风险。</p></blockquote><h3 id="后剪枝"><a href="#后剪枝" class="headerlink" title="后剪枝"></a>后剪枝</h3><p>后剪枝决策树通常比预剪枝决策树保留了更多的分支。<br>训练时间开销比未剪枝和预剪枝都要大得多：</p><ul><li>在生成完全决策树之后进行的；</li><li>要自底向上地对树中所有非叶结点进行逐一考察；</li></ul><h2 id="连续与缺失值"><a href="#连续与缺失值" class="headerlink" title="连续与缺失值"></a>连续与缺失值</h2><h3 id="连续值处理"><a href="#连续值处理" class="headerlink" title="连续值处理"></a>连续值处理</h3><p>把区间的中位点作为候选划分点，选择使 Gain(D, a, t) 最大化的划分点。<br><strong>与离散属性不同</strong>，该属性还可作为其后代结点的划分属性。</p><h3 id="缺失值处理"><a href="#缺失值处理" class="headerlink" title="缺失值处理"></a>缺失值处理</h3><p>现实任务中常会遇到不完整样本，即样本的某些属性值缺失。<br>有必要考虑利用有缺失属性值的训练样例来进行学习。<br>解决两个问题：</p><ol><li>如何在属性值缺失的情况下进行划分属性选择：根据没有缺失值的样本子集来判断属性a的优劣；</li><li>给定划分属性，若样本在该属性上的值缺失，如何对样本进行划分：让同一个样本以不同的概率划入到不同的子结点去；</li></ol><h2 id="多变量决策树"><a href="#多变量决策树" class="headerlink" title="多变量决策树"></a>多变量决策树</h2><p>决策树所形成的分类边界有一个明显的特点：<strong>轴平行</strong>（axis-parallel），即分类边界由若干个与坐标轴平行的分段组成。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/4_1.jpeg" alt><br>多变量决策树（multivariate decision tree）：实现<strong>斜划分</strong>甚至更复杂划分的决策树。<br>不是为每个非叶结点寻找一个最优划分属性，而是试图建立一个合适的线性分类器。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/4_2.jpeg" alt></p><h2 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h2><p>剪枝方法和程度对决策树泛化性能的影响相当显著，最终规则集的泛化性能甚至可能优于原决策树。<br>有一些决策树学习算法可进行<strong>增量学习</strong>（incremental learning），接收到新样本后可对已学得的模型进行调整，不用完全重新学习。有效地降低每次接收到新样本后的训练时间开销。</p><p><a href="http://blog.csdn.net/icefire_tyh/article/details/52082054" target="_blank" rel="noopener">习题答案</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性模型</title>
      <link href="2017/04/06/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
      <url>2017/04/06/%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h2><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/3_1.jpeg" alt><br>xi 是 x 在第 i 个属性上的取值。<br>w 和 b 学得之后，模型就得以确定。<br>许多功能更为强大的非线性模型（nolinear model）可在线性模型的基础上，通过引入<strong>层级结构</strong>或<strong>高维映射</strong>而得。<br>w 直观表达了各属性在预测中的重要性，因此线性模型有很好的可解释性（comprehensibility）。</p><a id="more"></a><h2 id="线性回归（linear-regression）"><a href="#线性回归（linear-regression）" class="headerlink" title="线性回归（linear regression）"></a>线性回归（linear regression）</h2><p>试图学得一个线性模型以尽可能准确地预测实值输出标记。</p><ul><li>若属性值间存在序（order）关系，可通过连续化将其转化为连续值。如：高度的取值高、中、低，可转化为 {1.0, 0.5, 0.0}。</li><li>若属性值间不存在序关系，通常转化为 k 维向量。如：瓜类的取值西瓜、南瓜、黄瓜，可转化为：(0, 0, 1)、(0, 1, 0)、(1, 0, 0)。</li></ul><p>将无序属性连续化，会不恰当地引入序关系，对后续处理如距离计算等造成误导。<br>基于<strong>均方误差</strong>最小化来进行模型求解的方法称为<strong>最小二乘法</strong>（least square method）。<br>最小二乘法，试图找到一条直线，使所有样本到直线的<strong>欧氏距离</strong>（Eucidean distance）之和最小。<br>多元线性回归（multivariate linear regression）模型为：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/3_2.jpeg" alt><br>XTX 往往不是满秩矩阵，因变量过多，会解出多组解都能使均方误差最小化。选择哪一个解作为输出，将由学习算法的<strong>归纳偏好</strong>决定，常见的做法是引入正则化（regularization）。<br>广义线性模型（generalized linear model）：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/3_3.jpeg" alt><br>单调可微函数 g(·) 称为<strong>联系函数</strong>（link function），对数线性回归是广义线性模型在 g(·)=ln(·) 时的特例。<br>广义线性模型的参数估计（parameter estimation）常通过最小二乘法或<strong>极大似然法</strong>进行。</p><h2 id="对数几率回归"><a href="#对数几率回归" class="headerlink" title="对数几率回归"></a>对数几率回归</h2><p>对于分类任务，只需找一个单调可微函数将真实标记 y 与线性回归模型的预测值联系起来。<br><strong>单位阶跃函数</strong>（unit-step function）不连续，选择近似的<strong>对数几率函数</strong>（logistic function）作为<strong>替代函数</strong>（surrogate function）。<br>对率函数是 Sigmoid 函数最重要的代表<br>将 y 视为样本x作为正例的可能性，则 1-y 是其反例可能性。两者的比值 y/(1-y) 称为<strong>几率</strong>（odds），反映了x作为正例的相对可能性，取对数得到<strong>对数几率</strong>（log odds）：ln[y/(1-y)]。<br>对率回归实际是一种分类学习方法（优点）：</p><ul><li>避免了假设分布不准确带来的问题</li><li>对许多需利用概率辅助决策的任务很有用</li><li>对率函数是任意阶可导的凸函数，许多<strong>数值优化算法</strong>都可直接用于求取最优解。</li></ul><p>经典的数值优化算法：<strong>梯度下降法</strong>（gradient descent method）、<strong>牛顿法</strong>（Newton method）。</p><h2 id="线性判别分析"><a href="#线性判别分析" class="headerlink" title="线性判别分析"></a>线性判别分析</h2><p>线性判别分析（Linear Discriminant Analysis），亦称 Fisher 判别分析。<br>LDA 的思想非常朴素，设法将样例投影到一条直线上：</p><ul><li>使得同类样例的投影点尽可能接近，投影点的<strong>协方差</strong>尽可能小。</li><li>使得异样样例的投影点尽可能远离，让类中心之间的<strong>距离</strong>尽可能大。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/3_4.jpeg" alt></li></ul><p>定义：</p><ul><li>类内散度矩阵（within-class scatter matrix）：Sw</li><li>类间散度矩阵（between-class scatter matrix）：Sb</li></ul><p>LDA 欲最大化的目标，即 Sb 与 Sw 的<strong>广义瑞利商</strong>（generalized Rayleigh quotient）。<br>考虑到数值解的稳定性，在实践中通常是对 Sw 进行奇异值分解。<br>LDA 可从<strong>贝叶斯决策理论</strong>的角度阐释并证明。当两类数据同先验、满足高斯分布且协方差相等时，LDA 可达到最优分类。<br>可以将 LDA 推广到多分类任务中，多分类 LDA 将样本投影到 d’ 维空间，d’ 通常远小于数据原有的属性数 d。因此 LDA 也常被视为一种经典的监督降维技术。</p><h2 id="多分类学习"><a href="#多分类学习" class="headerlink" title="多分类学习"></a>多分类学习</h2><h3 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h3><p><strong>拆解法</strong>，将多分类任务拆为若干个二分类任务求解：</p><ul><li>如何对多分类任务进行拆分</li><li>如何对多个分类器（classifier）进行集成</li></ul><h3 id="拆分策略"><a href="#拆分策略" class="headerlink" title="拆分策略"></a>拆分策略</h3><p>最经典的拆分策略有三种：</p><ol><li>一对一（OvO）：产生 N(N-1)/2 个分类任务，把预测得最多的类别作为最终分类结果。</li><li>一对其余（OvR）：训练 N 个分类器，若有多个分类器预测为正类，选择置信度最大的类别标记作为分类结果。</li><li>多对多（MvM）：OvO、OvR 是 MvM 的特例，正、反类构造必须有特殊的设计。例如，<strong>纠错输出码</strong>（Error Correcting Output Codes）。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/3_5.jpeg" alt></li></ol><p>OvO 的存储开销和测试时间开销通常比 OvR 更大，在类别很多时，OvO 的训练时间开销通常比 OvR 更小。预测性能，多数情况下两者差不多。</p><h3 id="纠错输出码"><a href="#纠错输出码" class="headerlink" title="纠错输出码"></a>纠错输出码</h3><p>ECOC 工作过程主要分为两步：</p><ul><li>编码：将 N 个类别做M次划分，训练出 M 个分类器。</li><li>解码：将预测编码与每个类别各自的编码进行比较，返回其中距离最小的类别作为最终预测结果。</li></ul><p>类别划分通过<strong>编码矩阵</strong>（coding matrix）：</p><ul><li>二元码：正类、反类；</li><li>三元码：正类、反类、停用类；</li></ul><p>ECOC 编码越长，纠错能力越强，意味着所需训练的分类器越多，计算、存储开销都会增大。<br>由于类别数有限，可能的组合数目也是有限的，码长超过一定范围后就失去了意义。<br><strong>同等长度</strong>的编码，两个类别之间的编码距离越远，则纠错能力越强。通常并不需获得理论最优编码（原因）：</p><ul><li>非最优编码在实践中往往已能产生足够好的分类器。</li><li>机器学习问题涉及很多因素，不同拆解方式导致的二分类问题的难度不同。</li></ul><h2 id="类别不平衡问题"><a href="#类别不平衡问题" class="headerlink" title="类别不平衡问题"></a>类别不平衡问题</h2><p>类别不平衡（class-imbalance）就是指分类任务中不同类别的训练样例数目差别很大的情况。</p><h3 id="基本策略"><a href="#基本策略" class="headerlink" title="基本策略"></a>基本策略</h3><p>类别不平衡学习的一个基本策略——<strong>再缩放</strong>（rescaling）：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/3_6.jpeg" alt><br><strong>无偏采样</strong>意味着，真实样本总体的类别比例在训练集中得以保持。</p><h3 id="再缩放"><a href="#再缩放" class="headerlink" title="再缩放"></a>再缩放</h3><p>再缩放的三类做法：</p><ul><li>对训练集里的反类样例进行<strong>欠采样</strong>（undersampling），去除一些反例。避免丢失一些重要信息，代表性算法 EasyEnsemble。</li><li>对正类样例进行<strong>过采样</strong>（oversampling），增加一些正例。避免招致严重的过拟合，代表性算法 SMOTE。</li><li>直接基于原始训练集进行学习，预测时，将式 (3.48) 嵌入到决策过程中，称为<strong>阈值移动</strong>（threshold-moving）。</li></ul><p>再缩放是<strong>代价敏感学习</strong>（cost-sensitive learning）的基础。</p><h2 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h2><p>非均等代价和类别不平衡性虽然都可借助<strong>再缩放</strong>技术，但两者本质不同。<br>类别不平衡学习中通常是较小类的代价更高，否则无需进行特殊处理。<br>多分类学习中虽然有多个类别，但每个样例仅属于一个类别。如果希望一个样本同时预测出多个类别标记，这样的任务是<strong>多标记学习</strong>（multi-label learning）。</p><p><a href="http://blog.csdn.net/icefire_tyh/article/details/52069025" target="_blank" rel="noopener">习题答案</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模型评估与选择</title>
      <link href="2017/03/29/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/"/>
      <url>2017/03/29/%E6%A8%A1%E5%9E%8B%E8%AF%84%E4%BC%B0%E4%B8%8E%E9%80%89%E6%8B%A9/</url>
      
        <content type="html"><![CDATA[<h2 id="训练误差与过拟合"><a href="#训练误差与过拟合" class="headerlink" title="训练误差与过拟合"></a>训练误差与过拟合</h2><p>精度（accuracy），精度 = 1-错误率。</p><ul><li>在训练集上的误差称为<strong>训练误差</strong>（training error）</li><li>在新样本上的误差称为<strong>泛化误差</strong>（generalization error）</li></ul><p>实际希望的，是在新样本上能表现得很好的学习器。</p><ul><li>过拟合（overfitting）：把训练样本自身的一些特点，当作了所有潜在样本都会具有的一般性质。</li><li>欠拟合（underfitting）：对训练样本的一般性质尚未学好。</li></ul><p>过拟合是<strong>无法彻底避免</strong>的。若可彻底避免过拟合，则通过经验误差最小化就能获得最优解。</p><h2 id="评估方法"><a href="#评估方法" class="headerlink" title="评估方法"></a>评估方法</h2><p>以测试集的<strong>测量误差</strong>（testing error）作为泛化误差的近似。<br>测试集应该尽可能与训练集互斥，通过对<strong>数据集 D</strong> 进行适当的处理，从中产生<strong>训练集 S</strong> 和<strong>测试集 T</strong>。</p><a id="more"></a><h3 id="留出法（hold-out）"><a href="#留出法（hold-out）" class="headerlink" title="留出法（hold-out）"></a>留出法（hold-out）</h3><p>直接将数据集D划分为两个互斥的集合，其中一个集合作为训练集 S，另一个作为测试集 T。<br>尽可能保持数据<strong>分布</strong>的一致性，例如在分类任务中至少要保持样本的类别比例相似。<br>保留类别比例的采样方式通常称为<strong>分层采样</strong>（stratified sampling）。<br>一般要采用若干次随机划分、重复进行实验评估后取平均值作为留出法的评估结果。<br>测试集小时，评估结果的<strong>方差</strong>较大；训练集小时，评估结果的<strong>偏差</strong>较大。<br>常见做法是将大约 2/3～4/5 的样本用于训练，测试集至少应含 30 个样例。</p><h3 id="交叉验证法（cross-validation）"><a href="#交叉验证法（cross-validation）" class="headerlink" title="交叉验证法（cross validation）"></a>交叉验证法（cross validation）</h3><p>将数据集 D 划分为 k 个大小相似的互斥子集，每次用 k-1 个子集的并集作为训练集，余下的那个子集作为测试集。<br><strong>k 折</strong>（k-fold）交叉验证，k 的取值通常 5、10、20 等。<br>使用不同的划分重复 p 次</p><blockquote><p>“10 次 10 折交叉验证法”与“100 次留出法”都是进行了 100 次训练、测试。</p></blockquote><p><strong>留一法</strong>（Leave-One-Out）：数据集 D 中包含 m 个样本，k = m。</p><ul><li>优点：训练集与初始数据集相比只少了一个样本，评估结果往往被认为比较准确。</li><li>缺点：在数据集比较大时，训练 m 个模型的计算开销可能是难以忍受的。</li></ul><h3 id="自助法（bootstrapping）"><a href="#自助法（bootstrapping）" class="headerlink" title="自助法（bootstrapping）"></a>自助法（bootstrapping）</h3><p>自助采样亦称“可重复采样”或“有放回采样”。<br>初始数据集 D 中约有 36.8%（1/e）的样本未出现在采样数据集 D’ 中，将 D\D’ 用作测试集，这样的测试结果，亦称<strong>包外估计</strong>（out-of-bag estimate）。<br>在数据集较小、难以有效划分训练、测试集时很有用。<br>改变了初始数据集的分布，会引入估计偏差。在初始数据量足够时，留出法和交叉验证更常用一些。</p><h3 id="调参与最终模型"><a href="#调参与最终模型" class="headerlink" title="调参与最终模型"></a>调参与最终模型</h3><p>两类<strong>参数：</strong></p><ul><li>算法的参数：亦称超参数，由人工设定，数目常在 10 以内。</li><li>模型的参数：通过学习来产生，数目可能很多。</li></ul><p>对每个参数选定一个<strong>范围</strong>和变化<strong>步长</strong>，参数调得好不好往往对最终模型性能有关键性影响。<br>学习算法和参数配置已选定后，应该用数据集 D 重新训练模型。使用所有 m 个样本，这才是最终提交给用户的模型。<br>把训练数据另外划分为训练集和验证集（validation set），基于验证集上的性能进行模型选择和调参。</p><h2 id="性能度量"><a href="#性能度量" class="headerlink" title="性能度量"></a>性能度量</h2><p>不仅需要有效可行的实验估计方法，还需要有衡量模型泛化能力的评价标准，即性能度量（performance measure）。<br>什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求。<br>回归任务最常用的性能度量是，均方误差（mean squared error）。</p><h3 id="错误率与精度"><a href="#错误率与精度" class="headerlink" title="错误率与精度"></a>错误率与精度</h3><h3 id="查准率、查全率与-F1"><a href="#查准率、查全率与-F1" class="headerlink" title="查准率、查全率与 F1"></a>查准率、查全率与 F1</h3><p>查准率亦称“准确率”，查全率亦称“召回率”。<br>查准率和查全率是一对矛盾的度量<br>查准率-查全率曲线（P-R 曲线）：</p><ul><li>若一个学习器的 P-R 曲线被另一个学习器的曲线完全包住，后者性能优于前者。</li><li>交叉时，比较面积，可借助于平衡点（Break-Even Point），即“查准率 = 查全率”时的取值。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/2_1.jpeg" alt></li></ul><p>BEP 还是过于简化了些，更常用的是 F1 度量。F1 是基于查准率和查全率的调和平均（harmonic mean）定义的，调和平均更重视较小值。<br>有多个二分类混淆矩阵：</p><ul><li>宏（macro）～：先在各混淆矩阵上分别计算，再计算平均值。</li><li>微（micro）～：先将各混淆矩阵的对应元素进行平均，再计算。 </li></ul><h3 id="ROC-与-AUC"><a href="#ROC-与-AUC" class="headerlink" title="ROC 与 AUC"></a>ROC 与 AUC</h3><p>将预测值与一个分类阈值（threshold）进行比较，大于阈值则为正类。<br>“最可能”是正例的排在最前面，以某个截断点（cut point）将样本分成两部分。若更重视查准率，则选择靠前的位置进行截断。<br>排序本身的质量好坏，体现了“一般情况下”泛化性能的好坏。<br>ROC 全称是<strong>受试者工作特征</strong>（Receiver Operating Characteristic）曲线，纵轴是<strong>真正例率</strong>（TPR），横轴是<strong>假正例率</strong>（FPR）。<br>点 (0, 1) 对应于将所有正例排在所有反例之前的理想模型。<br>若 ROC 曲线发生交叉，较为合理的判据是比较 ROC 曲线下的面积，即 AUC（Area Under ROC Curve）。<br>排序损失（loss）：</p><ul><li>若正例的预测值小于反例，则记一个“罚分”，若相等，则记 0.5 个。</li><li>对应 ROC 曲线之上的面积，AUC = 1-lrank。 </li></ul><h3 id="代价敏感错误率与代价曲线"><a href="#代价敏感错误率与代价曲线" class="headerlink" title="代价敏感错误率与代价曲线"></a>代价敏感错误率与代价曲线</h3><p>为权衡不同类型错误所造成的不同损失，可为错误赋予<strong>非均等代价</strong>（unequal cost）。<br>根据任务的领域知识设定一个<strong>代价矩阵</strong>（cost matrix），cost ij 表示将第 i 类样本预测为第 j 类样本的代价。<br>以二分类任务为例，损失程度相差越大，cost 01 与 cost 10 值的差别越大，重要的是代价比值而非绝对值。<br>在非均等代价下，ROC 曲线不能直接反映出学习器的期望总体代价，<strong>代价曲线</strong>（cost curve）则可达到该目的。<br>规范化（normalization）是将不同变化范围的值映射到相同的固定范围中。常见的是 [0, 1]，此时亦称<strong>归一化</strong>。<br>在代价平面上绘制一条从 (0, FPR) 到 (1, FNR) 的线段，取所有线段的下界，围成的面积即为，在所有条件下学习器的期望总体代价。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/2_2.jpeg" alt></p><h2 id="比较检验"><a href="#比较检验" class="headerlink" title="比较检验"></a>比较检验</h2><h3 id="机器学习中性能的比较很复杂"><a href="#机器学习中性能的比较很复杂" class="headerlink" title="机器学习中性能的比较很复杂"></a>机器学习中性能的比较很复杂</h3><p>希望比较的是泛化性能，通过实验评估方法获得的是测试集上的性能，两者对比结果可能未必相同。<br>测试集上的性能与测试集本身的选择有很大关系（大小、样例）。<br>机器学习算法本身有一定的随机性。<br>统计假设检验（hypothesis test）为学习器性能的比较提供了重要依据（默认以错误率为性能度量）。</p><h3 id="假设检验"><a href="#假设检验" class="headerlink" title="假设检验"></a>假设检验</h3><p>1-α 反映了结论的置信度（confidence）。<br>s.t. 是“subject to”的简写，使左边式子在右边条件满足时成立。</p><h3 id="交叉验证-t-检验"><a href="#交叉验证-t-检验" class="headerlink" title="交叉验证 t 检验"></a>交叉验证 t 检验</h3><p>若两个学习器的性能相同，则使用相同的训练集、测试集得到的测试错误率应相同。<br>进行有效假设检验的<strong>重要前提：</strong>测试错误率均为泛化错误率的独立采样。<br>实际上，不同轮次的训练集会有一定程度的重叠，使得测试错误率并不独立，导致过高估计假设成立的概率。为缓解这一问题，可采用 <strong>5 X 2交叉验证</strong>（5 次二折交叉验证）。</p><h3 id="McNemar-检验"><a href="#McNemar-检验" class="headerlink" title="McNemar 检验"></a>McNemar 检验</h3><p>标准正态分布变量的平方，即卡方分布。</p><h3 id="Friedman-检验与-Nemenyi-后续检验"><a href="#Friedman-检验与-Nemenyi-后续检验" class="headerlink" title="Friedman 检验与 Nemenyi 后续检验"></a>Friedman 检验与 Nemenyi 后续检验</h3><p>在对一组数据集上<strong>对多个算法进行比较</strong><br>每个数据集上列出两两比较的结果。<br>使用基于算法排序的 Friedman 检验。</p><ul><li>若算法性能相同，则它们的平均序值应当相同。</li><li>若算法的性能显著不同，需进行后续检验（post-hoc test）。</li></ul><h2 id="偏差与方差"><a href="#偏差与方差" class="headerlink" title="偏差与方差"></a>偏差与方差</h2><h3 id="偏差—方差分解"><a href="#偏差—方差分解" class="headerlink" title="偏差—方差分解"></a>偏差—方差分解</h3><p>偏差—方差分解（bias-variance decompositon）是解释学习算法泛化性能的一种重要工具。<br>泛化误差可分解为，偏差、方差与噪声之和。</p><ul><li>偏差：刻画了学习算法本身的拟合能力。</li><li>方差：刻画了数据扰动所造成的影响。</li><li>噪声：刻画了学习问题本身的难度。</li></ul><h3 id="偏差—方差窘境"><a href="#偏差—方差窘境" class="headerlink" title="偏差—方差窘境"></a>偏差—方差窘境</h3><p>偏差—方差窘境（bias-variance dilemma）：很多学习算法都可控制<strong>训练程度</strong>。</p><ul><li>决策树：控制层数。</li><li>神经网络：控制训练轮数。</li><li>集成学习方法：控制基学习器个数。</li></ul><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/MachineLearning/2_3.jpeg" alt></p><h2 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h2><p>对分类任务，由于 0/1 损失函数的跳变性，推导出偏差-方差分解很困难。</p><p><a href="http://blog.csdn.net/icefire_tyh/article/details/52065867" target="_blank" rel="noopener">习题答案</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>AOAPC 读书笔记-1</title>
      <link href="2017/03/24/AOAPC-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/"/>
      <url>2017/03/24/AOAPC-%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h2 id="程序设计入门"><a href="#程序设计入门" class="headerlink" title="程序设计入门"></a>程序设计入门</h2><h3 id="算术表达式"><a href="#算术表达式" class="headerlink" title="算术表达式"></a>算术表达式</h3><p>整数 / 整数 = 整数，浮点数 / 浮点数 = 浮点数。</p><h3 id="变量及其输入"><a href="#变量及其输入" class="headerlink" title="变量及其输入"></a>变量及其输入</h3><p>scanf 中<strong>占位符</strong>和变量的数据类型一一对应，每个变量前需要加“&amp;”符号；<br>输入输出过程是自动的，没有人工干预。输入前不要打印提示信息，输出完毕后应立即终止程序；<br>尽量用 const 关键字声明常数。</p><h3 id="顺序结构程序设计"><a href="#顺序结构程序设计" class="headerlink" title="顺序结构程序设计"></a>顺序结构程序设计</h3><p><strong>交换变量：</strong></p><ul><li><p>三变量法（适用范围广，推荐使用）</p><a id="more"></a><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">t</span> = a<span class="comment">;</span></span><br><span class="line"><span class="attr">a</span> = b<span class="comment">;</span></span><br><span class="line"><span class="attr">b</span> = t<span class="comment">;</span></span><br></pre></td></tr></table></figure></li><li><p>加减法</p><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = a + <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">b </span>= a - <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">a </span>= a - <span class="keyword">b;</span></span><br><span class="line"><span class="keyword">//可用异或运算“^”，代替加法和减法</span></span><br></pre></td></tr></table></figure></li><li><p>KISS 法</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//比谁能更好地解决问题</span><br><span class="line">scanf(<span class="string">"%d%d"</span>, &amp;a, &amp;b);</span><br><span class="line"><span class="keyword">printf</span>(<span class="string">"%d %d\n"</span>, b, a);</span><br></pre></td></tr></table></figure></li></ul><h3 id="分支结构程序设计"><a href="#分支结构程序设计" class="headerlink" title="分支结构程序设计"></a>分支结构程序设计</h3><p>单个整数值可以表示真假，其中 0 为假，其他值为真；<br>C 语言中的逻辑运算符都是<strong>短路</strong>（short-circuit）运算符；<br>有多个并列、情况不交叉的条件需要一一处理，用 else if 语句。</p><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>gets 在 C11 中被移除了，ANSI C 即 C89；<br>需要把 C 语言程序当作 C++ 程序提交，学习的是 C++ 语言中与 C 兼容的部分；<br><strong>\n：</strong>n 是英文单词 newline 的首字母；<br>编译器会把双斜线“\\”理解成单个字符“\”。<br><strong>两条建议：</strong></p><ul><li>重视实验</li><li>学会模仿</li></ul><h2 id="循环结构程序设计"><a href="#循环结构程序设计" class="headerlink" title="循环结构程序设计"></a>循环结构程序设计</h2><h3 id="for-循环"><a href="#for-循环" class="headerlink" title="for 循环"></a>for 循环</h3><p>要特别留意“当前行”的跳转和变量的改变；<br>有经验的程序员总是尽量缩小变量定义的范围；<br>使用伪代码来思考和描述算法是一种值得推荐的做法；<br>进行浮点数比较时，应考虑<strong>浮点误差</strong>。四舍五入，即 floor(x+0.5)；<br><strong>continue</strong> 可以帮助我们偷懒，不必求出循环的起始点；有了 <strong>break</strong>，连循环终点也不必指定；<br>for(;;) 是一个死循环，三部分都是可以省略的。</p><h3 id="while-循环和-do-while-循环"><a href="#while-循环和-do-while-循环" class="headerlink" title="while 循环和 do-while 循环"></a>while 循环和 do-while 循环</h3><p>对于 n 不是“递增式”的循环，很适合用 while 循环来实现；<br>当需要统计某种事物的个数时，可以用一个变量来充当计数器；<br>int 都是 32 位整数，范围是 -2147483648～2147483637；<br>long long 在 Linux 下的输入输出格式符为 %lld，Windows 下有时为 %I64d。</p><h3 id="循环的代价"><a href="#循环的代价" class="headerlink" title="循环的代价"></a>循环的代价</h3><p>可以使用 time.h 和 clock() 函数获得程序运行时间，返回值应除以 CLOCKS_PER_SEC；<br>Windows 命令行下执行“echo 20 | 程序名”，操作系统会自动把 20 输入。<br><strong>两个实用工具：</strong></p><ul><li>输出中间结果</li><li>计时函数</li></ul><h3 id="输入输出框架"><a href="#输入输出框架" class="headerlink" title="输入输出框架"></a>输入输出框架</h3><p>对于 scanf，空格、TAB、回车都是无关紧要的；<br>变量在未赋值之前的值是不确定的，不一定等于 0。<br><strong>一个技巧：</strong><br>先读取第一个整数 x，然后令 max = min = x；<br>有经验的程序员往往会使用<strong>条件编译编译指令</strong>并且将重要的测试语句<strong>注释掉</strong>而非删除。<br>重定向和 fopen 两种方法各有优劣：</p><ul><li>重定向的方法写起来简单、自然，但不能同时读写文件；</li><li>fopen 的写法稍嫌繁琐，但灵活性比较大。</li></ul><p>程序的鲁棒性在工程中也非常重要；<br>多数据的题目中，一个<strong>常见的错误：</strong>计算完一组数据后某些变量没有重置，影响到下组数据的求解；<br>嵌套中有同名变量时，内层变量会屏蔽外层变量。</p><blockquote><p>用编译选项 -Wall 编译程序时，会给出很多警告信息。</p></blockquote><h2 id="数组和字符串"><a href="#数组和字符串" class="headerlink" title="数组和字符串"></a>数组和字符串</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>在空间够用的前提下，数组会声明得稍大一些；<br>“++”运算符是 C 语言的特色之一；<br>比较大的数组应尽量声明在 main 函数外。<br>数组 a 复制 k 个元素到数组 b：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">memcpy</span>(b, a, <span class="keyword">sizeof</span>(<span class="keyword">int</span>) * k);</span><br></pre></td></tr></table></figure><p>数组 a 全部复制到数组 b 中：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memcpy(<span class="name">b</span>, a, sizeof(<span class="name">a</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>把数组 a 清零：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">memset(<span class="name">a</span>, <span class="number">0</span>, sizeof(<span class="name">a</span>))<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>为了避免输出多余空格，可以设置一个标志变量 first：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//第一个变量前没有空格，其他变量都有</span><br><span class="line">int <span class="built_in">first</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">first</span> == <span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">first</span> = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">" "</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, i);</span><br></pre></td></tr></table></figure><p>用一条语句完成许多事情的前提是：保持代码的可读性。</p><blockquote><p>最好是在做一件事情之前检查是不是可以做，而不要做完再后悔。</p></blockquote><h3 id="字符数组"><a href="#字符数组" class="headerlink" title="字符数组"></a>字符数组</h3><p>字符串其实就是字符数组；<br>以反斜线开头的字符称为转义序列（Escape Sequence）；<br>字符常量可以用’a’表示，语法上可以把字符当作 int 型使用；<br><strong>字符串数组</strong> char s[a][b]，可以用 scanf(“%s”, s[i]) 读取第 i 个字符串；<br>scanf(“%s”, s) 遇到空白字符会停下来；<br>strchr 的作用是在一个字符串中查找单个字符首次出现的位置；<br>strlen(s) 返回字符串 s 中结束标记“\0”之前的字符个数；<br>“++”、“+=”等，每条语句最多只用一次这种运算符。</p><h3 id="题目选讲"><a href="#题目选讲" class="headerlink" title="题目选讲"></a>题目选讲</h3><p>读取一个字符可以用 getchar，它等价于 fgetc(stdin)；<br>在使用 fgetc 和 getchar 时，应避免写出和操作系统相关的程序。</p><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">int c;</span><br><span class="line"><span class="keyword">while</span>((c = <span class="built_in">getchar</span>()) != <span class="built_in">EOF</span>)</span><br><span class="line">&#123;</span><br><span class="line">    ... ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>fgets(buf, maxn, fin)，读取完整的一行<strong>存放</strong>在字符数组 buf 中；<br>善用常量数组往往能简化代码，定义时无须指明大小；<br>头文件 ctype.h 中定义的 isalpha、isdigit、isprint 等工具可以用来判断字符的属性；<br>字符串数组，就是二维字符数组。</p><h3 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h3><p>作为数组下标，i 经常代表“当前考虑的位置”；<br>八进制应写成“\o”，十六进制应写成“\x”；<br>“&lt;&lt;”运算符的优先级没有减法高；<br>多数计算机内部，整数采用的是补码表示法；<br>一个好玩的 bug，两种不同的 0：</p><ul><li>00000000（正零）</li><li>10000000（负零）</li></ul><p>数组的大小可以用 sizeof 在编译时获得（它不是一个函数）；<br>按照自己的方式处理字符串，千万要保证它以“\0”结尾；<br>如果 char 值为正，则是西文字符；如果为负，则是汉字的前一半（需再读一个 char）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器学习</title>
      <link href="2017/03/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>2017/03/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>经验通常以数据形式存在<br>机器学习是研究关于学习算法的学问<br><strong>模型</strong>指全局性结果，<strong>模式</strong>指局部性结果。</p><h2 id="基本术语"><a href="#基本术语" class="headerlink" title="基本术语"></a>基本术语</h2><p>记录的集合称为一个<strong>数据集</strong>（data set）<br>特征张成的空间称为特征空间（feature space）<br>一个样本（sample）称为一个特征向量（feature vector）<br>训练样本组成的集合称为<strong>训练集</strong>（training set）<br>拥有了标记（label）信息的样本，称为样例（example）。<br><strong>学习任务：</strong></p><ul><li>二分类任务（binary classification）</li><li>多分类任务（multi-class classfication）</li><li>回归任务（regression）</li></ul><a id="more"></a><p><strong>聚类</strong>（clustering）学习自动形成簇（cluster），学习过程中使用的训练样本通常不拥有标记信息。<br>分类和回归是<strong>监督学习</strong>（supervised learning）的代表，聚类是<strong>无监督学习</strong>（unsupervised learning）的代表。<br>学得模型适用于新样本的能力，称为泛化（generalization）能力。<br>样本空间中全体样本服从一个未知<strong>分布</strong>（distribution），每个样本都是独立地从这个分布上采样获得的，即独立同分布（independent and identically distributed）。</p><h2 id="假设空间"><a href="#假设空间" class="headerlink" title="假设空间"></a>假设空间</h2><p>归纳（induction）和演绎（deduction）是科学推理的两大基本手段：</p><ul><li>归纳是从特殊到一般的泛化过程</li><li>演绎是从一般到特殊的特化（specialization）过程</li></ul><p>学习过程可以看作一个在所有假设（hypothesis）组成的空间中进行搜索的过程<br>存在着一个与训练集一致的假设集合，称之为<strong>版本空间</strong>（version space）。</p><h2 id="归纳偏好"><a href="#归纳偏好" class="headerlink" title="归纳偏好"></a>归纳偏好</h2><p>有效的机器学习算法必有其归纳偏好<br>归纳偏好可看作对假设进行选择的启发式或价值观<br><strong>奥卡姆剃刀</strong>（Occam’s razor）：<br>若有多个假设与观察一致，则选最简单的那个。<br><strong>没有免费的午餐</strong>定理（No Free Lunch Theorem）：<br>一个学习算法 a，若它在某些问题上比学习算法 b 好，则必然存在另一些问题，在那里 b 比 a 好。总误差与学习算法无关。</p><blockquote><p>NFL 定理假设了 f 的均匀分布，实际情形并非如此，我们只关注正在试图解决的问题。</p></blockquote><p>脱离<strong>具体问题</strong>，空泛地谈论“什么学习算法更好”毫无意义。若考虑所有潜在的问题，则所有学习算法一样好。<br>归纳偏好与问题是否相配，往往会起到决定性的作用。</p><h2 id="发展历程"><a href="#发展历程" class="headerlink" title="发展历程"></a>发展历程</h2><p>典型的决策树学习以信息论为基础，以信息熵的最小化为目标。<br><strong>统计学习</strong>的代表性技术是支持向量机（Support Vector Machine)<br>深度学习，狭义地说就是很多层的神经网络。<br>深度学习模型拥有大量参数，若数据样本少，则很容易<strong>过拟合</strong>。</p><h2 id="应用现状"><a href="#应用现状" class="headerlink" title="应用现状"></a>应用现状</h2><h3 id="大数据时代的三大关键技术"><a href="#大数据时代的三大关键技术" class="headerlink" title="大数据时代的三大关键技术"></a>大数据时代的三大关键技术</h3><p>机器学习：提供数据分析能力<br>云计算：提供数据处理能力<br>众包（crowdsourcing）：提供数据标记能力</p><h3 id="数据挖掘的两大支撑"><a href="#数据挖掘的两大支撑" class="headerlink" title="数据挖掘的两大支撑"></a>数据挖掘的两大支撑</h3><ul><li>数据库领域：提供数据管理技术</li><li>机器学习领域：提供数据分析技术</li></ul><p>数据挖掘是从海量数据中发掘知识<br>要建立输入与输出之间的联系，内核必然需要机器学习技术。</p><blockquote><p>机器学习不仅在信息科学中占有重要地位，还具有一定的自然科学探索色彩。</p></blockquote><h2 id="阅读材料"><a href="#阅读材料" class="headerlink" title="阅读材料"></a>阅读材料</h2><p>多释原则（principle of multiple explanations）：<br>主张保留与经验观察一致的所有假设。<br>萨缪尔跳棋程序，否证了计算机不可能完成事先没有显式编程好的任务的假设，是最早在计算机上执行非数值计算任务的程序之一。</p><p><a href="http://blog.csdn.net/icefire_tyh/article/details/52065224" target="_blank" rel="noopener">习题答案</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>影视大数据分析</title>
      <link href="2017/03/12/%E5%BD%B1%E8%A7%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
      <url>2017/03/12/%E5%BD%B1%E8%A7%86%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h2 id="项目背景"><a href="#项目背景" class="headerlink" title="项目背景"></a>项目背景</h2><p>文本分析、情感分析和社交分析帮助你在一定规模上转化成客户、病人、公众以及市场的“声音”。这项技术目前大量地应用于一系列的工业产品中，从医疗健康到金融、媒体、甚至客户市场。它们从线上、社交网络、企业数据源中提取商业洞察力。<br>本次项目通过对爬取的用户评论数据进行分析，对各个不同的电影进行相关的预测。关键的分类部分是基于有监督的机器学习，以不同机器学习算法为基础构建分类器对文本分类。</p><h2 id="总体设计"><a href="#总体设计" class="headerlink" title="总体设计"></a>总体设计</h2><p>本课题采用有监督的机器学习方法。对初始数据处理后，通过人工标注、特征选取、降维、训练，最终得到准确度高的分类器对所有数据进行输出。</p><a id="more"></a><p><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_1.png" alt><br><strong>第一步，就是确定一个词是积极还是消极，是主观还是客观</strong>。<br>这一步主要依靠词典，英文已经有伟大词典资源：SentiWordNet。 无论积极消极、主观客观，还有词语的情感强度值都一并拿下。在中文领域，判断积极和消极已经有不少词典资源，如：Hownet、NTUSD 等。<br><strong>第二步，就是识别一个句子是积极还是消极，是主观还是客观</strong>。<br>有词典的时候，好办。直接去匹配看一个句子有什么词典里面的词，然后加总就可以计算出句子的情感分值。中文领域的难度：还是词典太差。还有就是用机器学习方法判断主客观非常麻烦，一般需要人工标注。<br><strong>第三步，情感挖掘就升级到意见挖掘（Opinion Mining）了</strong>。<br>这就需要在情感分析的基础上，先挖掘出产品的属性，再分析对应属性的情感。分析完每一条评论的所有属性的情感后，就可以汇总起来，形成消费者对一款产品各个部分的评价。</p><h2 id="详细设计"><a href="#详细设计" class="headerlink" title="详细设计"></a>详细设计</h2><h3 id="源文件处理"><a href="#源文件处理" class="headerlink" title="源文件处理"></a>源文件处理</h3><p>源文件保存在 excel 中，由于本项目使用有监督的机器学习算法，因此需要对文件进行类别的标注，以备接下来使用。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_2.png" alt></p><h3 id="评论录入与分词"><a href="#评论录入与分词" class="headerlink" title="评论录入与分词"></a>评论录入与分词</h3><p>评论是存放在 excel 格式的文件中，这可以由 python 提供的有关 excel 操作的 xlrd 库来进行读取。分词则是由 jieba 分词模块进行。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_3.png" alt> </p><h3 id="统计"><a href="#统计" class="headerlink" title="统计"></a>统计</h3><p>加载文件之后调用相关统计模块：包含分词，统计词频等。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_4.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_5.png" alt></p><h3 id="文本表示"><a href="#文本表示" class="headerlink" title="文本表示"></a>文本表示</h3><p>经第三步之后，进入文本分析，权重分析并记录。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_6.png" alt></p><h3 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h3><p>在权重计算和文本表示之后，就可以进行机器学习了，首先分集合，之后进行机器学习训练，预测，得出结果。<br>划分：<br>划分训练集和测试集用于机器学习<br>训练：<br>将权重列表作为参数进行训练<br>预测：<br>输入测试用例进行预测<br>结果：<br>得到概率，计算得出分数。</p><h2 id="成果展示"><a href="#成果展示" class="headerlink" title="成果展示"></a>成果展示</h2><h3 id="标记展示"><a href="#标记展示" class="headerlink" title="标记展示"></a>标记展示</h3><p>相关 excel 文件的标记展示，标记阶段尽量保证两类的数量要基本一致。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_7.png" alt></p><h3 id="界面展示"><a href="#界面展示" class="headerlink" title="界面展示"></a>界面展示</h3><p>界面设计由 python 的 tkinter 库参考设计。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_8.png" alt><br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_9.png" alt></p><h2 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h2><p>准备好 PyCharm和JDK 1.8</p><h3 id="安装-Homebrew"><a href="#安装-Homebrew" class="headerlink" title="安装 Homebrew"></a>安装 Homebrew</h3><p>在终端输入：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/usr/</span>bin<span class="regexp">/ruby -e "$(curl -fsSL https:/</span><span class="regexp">/raw.githubusercontent.com/</span>Homebrew<span class="regexp">/install/m</span>aster<span class="regexp">/install)"</span></span><br></pre></td></tr></table></figure><h3 id="安装-Python-3-x"><a href="#安装-Python-3-x" class="headerlink" title="安装 Python 3.x"></a>安装 Python 3.x</h3><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">brew </span><span class="keyword">install </span>python3</span><br></pre></td></tr></table></figure><h3 id="安装-numpy、scipy、scikit-learn-库"><a href="#安装-numpy、scipy、scikit-learn-库" class="headerlink" title="安装 numpy、scipy、scikit-learn 库"></a>安装 numpy、scipy、scikit-learn 库</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 <span class="keyword">install</span> numpy</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 <span class="keyword">install</span> scipy</span><br></pre></td></tr></table></figure><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo pip3 <span class="keyword">install</span> scikit-learn</span><br></pre></td></tr></table></figure><h3 id="安装-jieba、xlrd-库"><a href="#安装-jieba、xlrd-库" class="headerlink" title="安装 jieba、xlrd 库"></a>安装 jieba、xlrd 库</h3><p>jieba：</p><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/fxsjy/jieba.git</span><br></pre></td></tr></table></figure><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">git</span> checkout jieba3k</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-jieba-site</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python3</span> setup.<span class="keyword">py</span> install</span><br></pre></td></tr></table></figure><p>xlrd：<br><a href="https://pypi.python.org/pypi/xlrd" target="_blank" rel="noopener">下载xlrd</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> your-xlrd-site</span><br></pre></td></tr></table></figure><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">python3</span> setup.<span class="keyword">py</span> install</span><br></pre></td></tr></table></figure><h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>用 PyCharm 导入 natural_language.py、tkTest.py 并运行后者即可看见结果。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/EmotionAI/sa_10.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>医学辅助诊断系统</title>
      <link href="2017/03/08/%E5%8C%BB%E5%AD%A6%E8%BE%85%E5%8A%A9%E8%AF%8A%E6%96%AD%E7%B3%BB%E7%BB%9F/"/>
      <url>2017/03/08/%E5%8C%BB%E5%AD%A6%E8%BE%85%E5%8A%A9%E8%AF%8A%E6%96%AD%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h2 id="图像处理算法"><a href="#图像处理算法" class="headerlink" title="图像处理算法"></a>图像处理算法</h2><h3 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h3><p>在获取到上传的血常规化验单图片后，项目中对其进行了预处理，作用主要是为了减小噪声，为后边的识别算法服务，在这里主要用到了以下两个方法：</p><ul><li><p>高斯平滑</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">img_gb</span> = cv2.GaussianBlur(img_gray, (gb_param, gb_param), <span class="number">0</span>)</span><br></pre></td></tr></table></figure></li><li><p>腐蚀、膨胀</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">closed</span> = cv2.morphologyEx(img_gb, cv2.MORPH_CLOSE, kernel)</span><br><span class="line"><span class="attr">opened</span> = cv2.morphologyEx(closed, cv2.MORPH_OPEN, kernel)</span><br></pre></td></tr></table></figure></li></ul><a id="more"></a><h3 id="线段检测"><a href="#线段检测" class="headerlink" title="线段检测"></a>线段检测</h3><p>为了对图片各个数值所在的区域进行定位，这里需要检测出图片中比较明显的标识，3 条黑线，然后利用这三条线对整张图片进行标定。主要用到了以下 3 个步骤：</p><ol><li><p>Canny 边缘检测</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">edges</span> = cv2.Canny(opened, canny_param_lower, canny_param_upper)</span><br></pre></td></tr></table></figure></li><li><p>轮廓提取</p><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">contours, hierarchy = cv2.findContours(edges, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)</span><br></pre></td></tr></table></figure></li><li><p>求最小外接矩形</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def getbox(i):</span><br><span class="line">    rect = cv2.minAreaRect(contours[i])</span><br><span class="line">    <span class="built_in">box</span> = cv2.<span class="built_in">cv</span>.BoxPoints(rect)</span><br><span class="line">    <span class="built_in">box</span> = <span class="built_in">np</span>.int0(<span class="built_in">box</span>)</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">box</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="OCR"><a href="#OCR" class="headerlink" title="OCR"></a>OCR</h3><p>这里主要利用 OCR 对血常规报告中的字符进行识别，得到具体的数值，用于后续的预测。其中步骤主要是根据上边求得的三条线段对图片进行透射变换，根据标定好的像素位置，利用 pytesseract 进行字符识别。<br>透射变换：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">points = np.array([<span class="string">[line_upper[0</span>][<span class="symbol">0</span>], line<span class="emphasis">_upper[0][1]], [line_</span>upper[<span class="string">1</span>][<span class="symbol">0</span>], line<span class="emphasis">_upper[1][1]],[line_</span>lower[<span class="string">0</span>][<span class="symbol">0</span>], line<span class="emphasis">_lower[0][1]], [line_</span>lower[<span class="string">1</span>][<span class="symbol">0</span>], line_lower[<span class="string">1</span>][<span class="symbol">1</span>]]], np.float32)</span><br><span class="line">standard = np.array([[0,0], [1000, 0], [0, 760], [1000, 760]], np.float32)</span><br><span class="line">//设定透视变换的矩阵</span><br><span class="line"></span><br><span class="line">PerspectiveMatrix = cv2.getPerspectiveTransform(points,standard)</span><br><span class="line">self.PerspectiveImg = cv2.warpPerspective(self.img, PerspectiveMatrix, (1000, 760))</span><br><span class="line">//使用透视变换将表格区域转换为一个 1000*760 的图</span><br></pre></td></tr></table></figure><p>截图：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">def autocut(<span class="keyword">self</span>, num, param=<span class="keyword">default</span>):</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.PerspectiveImg is None: </span><br><span class="line">        <span class="keyword">self</span>.PerspectivImg = <span class="keyword">self</span>.filter(param)</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">self</span>.PerspectiveImg is None: </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">    <span class="comment">// 仍然是空，说明不是报告</span></span><br><span class="line">        </span><br><span class="line">    img_age = <span class="keyword">self</span>.PerspectiveImg[<span class="number">15</span> : <span class="number">70</span>, <span class="number">585</span> : <span class="number">690</span>]</span><br><span class="line">    cv2.imwrite(<span class="keyword">self</span>.output_path + <span class="string">'age.jpg'</span>, img_age)</span><br><span class="line">    <span class="comment">// 输出年龄</span></span><br><span class="line"></span><br><span class="line">    img_gender = <span class="keyword">self</span>.PerspectiveImg[<span class="number">15</span> : <span class="number">58</span>, <span class="number">365</span> : <span class="number">420</span>]</span><br><span class="line">    cv2.imwrite(<span class="keyword">self</span>.output_path + <span class="string">'gender.jpg'</span>, img_gender)</span><br><span class="line">    <span class="comment">// 输出性别</span></span><br><span class="line">        </span><br><span class="line">    img_time = <span class="keyword">self</span>.PerspectiveImg[<span class="number">722</span> : <span class="number">760</span>, <span class="number">430</span> : <span class="number">630</span>]</span><br><span class="line">    cv2.imwrite(<span class="keyword">self</span>.output_path + <span class="string">'time.jpg'</span>, img_time)</span><br><span class="line">    <span class="comment">// 输出时间</span></span><br><span class="line">        </span><br><span class="line">    startpoint = [<span class="number">199</span>, <span class="number">132</span>]</span><br><span class="line">    vertical_lenth = <span class="number">37</span></span><br><span class="line">    lateral_lenth = <span class="number">80</span></span><br><span class="line">    <span class="comment">// 转换后的图分辨率是已知的，所以直接从这个点开始读数据就可以了</span></span><br><span class="line">    </span><br><span class="line">    def getobjname(i, x, y):</span><br><span class="line">        region_roi = <span class="keyword">self</span>.PerspectiveImg[y : y+vertical_lenth,  x : x+<span class="number">170</span>]</span><br><span class="line">        filename = <span class="keyword">self</span>.output_path + <span class="string">'p'</span> + str(i) + <span class="string">'.jpg'</span></span><br><span class="line">        cv2.imwrite(filename, region_roi)</span><br><span class="line">    </span><br><span class="line">    def getobjdata(i, x, y):</span><br><span class="line">        region_roi = <span class="keyword">self</span>.PerspectiveImg[y :  y+vertical_lenth, x : x+lateral_lenth]</span><br><span class="line">        filename = <span class="keyword">self</span>.output_path + <span class="string">'data'</span> + str(i) + <span class="string">'.jpg'</span></span><br><span class="line">        cv2.imwrite(filename, region_roi)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">13</span> and num &gt; <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num):</span><br><span class="line">            getobjname(<span class="keyword">int</span>(i), <span class="number">25</span>, startpoint[<span class="number">1</span>])</span><br><span class="line">            getobjdata(<span class="keyword">int</span>(i), startpoint[<span class="number">0</span>], startpoint[<span class="number">1</span>])</span><br><span class="line">            startpoint[<span class="number">1</span>] = startpoint[<span class="number">1</span>] + <span class="number">40</span></span><br><span class="line">    elif num &gt; <span class="number">13</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">13</span>):</span><br><span class="line">            getobjname(<span class="keyword">int</span>(i), <span class="number">25</span>, startpoint[<span class="number">1</span>])</span><br><span class="line">            getobjdata(<span class="keyword">int</span>(i), startpoint[<span class="number">0</span>], startpoint[<span class="number">1</span>])</span><br><span class="line">            startpoint[<span class="number">1</span>] = startpoint[<span class="number">1</span>] + <span class="number">40</span></span><br><span class="line">            startpoint = [<span class="number">700</span>, <span class="number">135</span>]</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(num<span class="number">-13</span>):</span><br><span class="line">            getobjname(<span class="keyword">int</span>(i+<span class="number">13</span>), <span class="number">535</span>, startpoint[<span class="number">1</span>])</span><br><span class="line">            getobjdata(<span class="keyword">int</span>(i+<span class="number">13</span>), startpoint[<span class="number">0</span>], startpoint[<span class="number">1</span>])</span><br><span class="line">            startpoint[<span class="number">1</span>] = startpoint[<span class="number">1</span>] + <span class="number">40</span></span><br><span class="line">    <span class="comment">// 输出图片</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="comment">// 正常结束返回0</span></span><br></pre></td></tr></table></figure><p>pytesseract：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="built_in">num</span>):</span><br><span class="line">    <span class="keyword">item</span> = <span class="built_in">read</span>(<span class="string">'temp_pics/p'</span> + str(i) + <span class="string">'.jpg'</span>)</span><br><span class="line">    item_num = classifier.getItemNum(<span class="keyword">item</span>)</span><br><span class="line">    image = <span class="built_in">read</span>(<span class="string">'temp_pics/data'</span> + str(i) + <span class="string">'.jpg'</span>)</span><br><span class="line">    image = imgproc.digitsimg(image)</span><br><span class="line">    digtitstr = image_to_string(image)</span><br><span class="line">    digtitstr = digtitstr.<span class="built_in">replace</span>(<span class="string">" "</span>, <span class="string">''</span>)</span><br><span class="line">    digtitstr = digtitstr.<span class="built_in">replace</span>(<span class="string">"-"</span>, <span class="string">''</span>)</span><br><span class="line">    digtitstr = digtitstr.strip(<span class="string">"."</span>)</span><br><span class="line">    data[<span class="string">'bloodtest'</span>][item_num][<span class="string">'value'</span>] = digtitstr</span><br><span class="line">//识别检测项目编号及数字</span><br><span class="line"></span><br><span class="line">json_data = json.dumps(data,ensure_ascii=False,indent=<span class="number">4</span>)</span><br></pre></td></tr></table></figure><h2 id="机器学习算法"><a href="#机器学习算法" class="headerlink" title="机器学习算法"></a>机器学习算法</h2><p>工业革命让人造机器取代人类完成了大部分的体力劳动，随着机器学习能力的不断提升人类有望可以将部分脑力劳动也交给机器完成。深度学习通过模拟生物神经网络来构建学习框架（人造神经网络），每个人造神经元使用激活函数来非线性地编码数据，不同层级的人造神经元间依靠权重值来传输数据，最终整个人造神经网络就会像人类的大脑一样拥有学习的能力（目前人造神经网络的复杂度还远不及生物，仅拥有很基本的学习能力）。深度学习可以让机器以目前最接近生物思考的方法进行运转，进而可能代替人类完成一部分脑力劳动。<br>深度学习跟传统的机器学习相比最大的优势在于不需要人工进行特征采集。传统的机器学习需要专业人士在特定数据中发现其特征，而深度学习能够通过算法自动完成这一过程，我们只需要构建一个通用的框架，然后提供数据和所想要的结果，最后通过不断地训练框架及优化其参数就可以获得具备某项能力的机器。<br>生物神经网络主要由很多神经元相互连接而成，人造神经网络也一样由人造神经元互联而成，如下图所示。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_1.png" alt><br>一个人造神经元有一定数量的输入接口，每个输入都拥有一个对应的权重值，数据通过输入进入后要通过一个激活函数才能输出，这个函数需要是非线性的（模拟生物神经元），常见的激活函数包括 Sigmoid, Tanh 以及 ReLU ，如下图所示，其中 ReLU 是深度学习中最常用的。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_2.png" alt><br>一个人造神经元的输出可能是另一个的输入，如此不断连接在一起便构成了人造神经网络，如下图所示。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_3.png" alt><br>一个特定的人造神经网络可以解决一类特定的问题，要获得一个解决特定问题的人造神经网络需要使用相关数据对其进行训练，训练使用结合梯度检验的反向传导算法进行。通过大量相关数据的训练人造神经元的权重值会越来越接近真实的范围，其人造神经网络也就越来越成熟。</p><h3 id="数据预处理"><a href="#数据预处理" class="headerlink" title="数据预处理"></a>数据预处理</h3><p>为了提高机器学习的准确程度，避免由于数据本身的数值不统一等对学习结果造成影响，需要对样本集进行一定的预处理。在本门课程中，我用到的预处理方法主要是去均值与归一化。<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_4.jpg" alt><br><strong>去均值：</strong><br>去均值的具体做法是在每个样本上减去数据的统计平均值，去均值的意义主要在于扩大分类的效果。查看 TensorFlow 的 MNIST 源码时可以看到，程序中对每个像素点的像素值都减去了 128，这就是去均值操作。<br><strong>归一化：</strong><br>数据尺度归一化的原因是：数据中每个维度表示的意义不同，所以有可能导致该维度的变化范围不同，因此有必要将他们都归一化到一个固定的范围，一般情况下是归一化到 [0 1] 或者 [-1 1]。同样在 TensorFlow 的 MNIST 源码中可以看到，去均值后，会将每点的像素值除以 128，进行了归一化操作。<br>下边是我在本门课程中写的去均值与归一化代码，a 是训练集，b 是需要预测的一组样本。返回结果是去均值与归一化之后的样本 b。</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def normalized(a,b):</span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">i</span> in range(<span class="number">22</span>):</span><br><span class="line">    tmp = np.<span class="built_in">mean</span>(a[:, <span class="built_in">i</span>])</span><br><span class="line">    a[:, <span class="built_in">i</span>] = a[:, <span class="built_in">i</span>] - tmp</span><br><span class="line">    b[:, <span class="built_in">i</span>] = b[:, <span class="built_in">i</span>] - tmp</span><br><span class="line">    <span class="keyword">if</span> np.<span class="built_in">min</span>(a[:, <span class="built_in">i</span>]) != np.<span class="built_in">max</span>(a[:, <span class="built_in">i</span>]):</span><br><span class="line">        b[:, <span class="built_in">i</span>] = <span class="number">2</span> * (b[:, <span class="built_in">i</span>] - np.<span class="built_in">min</span>(a[:, <span class="built_in">i</span>])) / (np.<span class="built_in">max</span>(a[:, <span class="built_in">i</span>]) - np.<span class="built_in">min</span>(a[:, <span class="built_in">i</span>])) - <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        b[:, <span class="built_in">i</span>] = <span class="number">0</span></span><br><span class="line"><span class="keyword">return</span> b</span><br></pre></td></tr></table></figure><h3 id="深度学习平台"><a href="#深度学习平台" class="headerlink" title="深度学习平台"></a>深度学习平台</h3><p>为了实现上述的机器学习算法，需要选择一个深度学习的平台。在这里我选择的是 TensorFlow。对于我们学习来说，TensorFlow 的主要优点是文档齐全，更容易找到相关的 demo 和出现 bug 的解决方法。</p><p>在本课程中，学习了 TensorFlow 的基本使用，基本的使用流程如下：</p><ol><li><p>读取数据为 ndarray 类型</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">data</span> = np.loadtxt(open(<span class="string">"./data.csv"</span>,<span class="string">"rb"</span>),delimiter=<span class="string">","</span>,skiprows=<span class="number">0</span>)</span><br><span class="line"><span class="attr">tmp</span> = normalized(data[:,<span class="number">2</span>:])</span><br><span class="line"><span class="attr">tmp_label_sex</span> = <span class="literal">on</span>e_hot(data[:,<span class="number">0</span>:<span class="number">1</span>],data.shape[<span class="number">0</span>])</span><br><span class="line"><span class="attr">train_label_sex</span> = tmp_label_sex[:<span class="number">1858</span>, :]</span><br><span class="line"><span class="attr">test_label_sex</span> = tmp_label_sex[<span class="number">1858</span>:, :]</span><br><span class="line"><span class="attr">train_data</span> = tmp[:<span class="number">1858</span>,:]</span><br><span class="line"><span class="attr">test_data</span> = tmp[<span class="number">1858</span>:,:]</span><br></pre></td></tr></table></figure></li><li><p>定义模型（各层结构，损失，优化方法）</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">x</span> = <span class="keyword">tf</span>.placeholder(<span class="string">"float"</span>, [None, n_input])</span><br><span class="line"><span class="keyword">y</span> = <span class="keyword">tf</span>.placeholder(<span class="string">"float"</span>, [None, n_classes])</span><br><span class="line">keep_prob = <span class="keyword">tf</span>.placeholder(<span class="string">"float"</span>)</span><br><span class="line">def multilayer_perceptron(<span class="keyword">x</span>, weights, biases):</span><br><span class="line">    layer_1 = <span class="keyword">tf</span>.<span class="built_in">add</span>(<span class="keyword">tf</span>.matmul(<span class="keyword">x</span>, weights[<span class="string">'h1'</span>]), biases[<span class="string">'b1'</span>])</span><br><span class="line">    layer_1 = <span class="keyword">tf</span>.<span class="keyword">nn</span>.relu(layer_1)</span><br><span class="line">    layer_2 = <span class="keyword">tf</span>.<span class="built_in">add</span>(<span class="keyword">tf</span>.matmul(layer_1, weights[<span class="string">'h2'</span>]), biases[<span class="string">'b2'</span>])</span><br><span class="line">    layer_2 = <span class="keyword">tf</span>.<span class="keyword">nn</span>.relu(layer_2)</span><br><span class="line">    out_layer = <span class="keyword">tf</span>.matmul(layer_2, weights[<span class="string">'out'</span>]) + biases[<span class="string">'out'</span>]</span><br><span class="line"><span class="keyword">return</span> out_layer</span><br><span class="line">weights = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'h1'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([n_input, n_hidden_1])), </span><br><span class="line">    <span class="string">'h2'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([n_hidden_1, n_hidden_2])), </span><br><span class="line">    <span class="string">'out'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([n_hidden_2, n_classes]))</span><br><span class="line">&#125;</span><br><span class="line">biases = </span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">'b1'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([n_hidden_1])), </span><br><span class="line">    <span class="string">'b2'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([n_hidden_2])), </span><br><span class="line">    <span class="string">'out'</span>: <span class="keyword">tf</span>.Variable(<span class="keyword">tf</span>.random_normal([n_classes]))</span><br><span class="line">&#125;</span><br><span class="line">pred = multilayer_perceptron(<span class="keyword">x</span>, weights, biases)</span><br><span class="line">cost = <span class="keyword">tf</span>.reduce_mean(<span class="keyword">tf</span>.<span class="keyword">nn</span>.softmax_cross_entropy_with_logits(pred, <span class="keyword">y</span>))</span><br><span class="line">optimizer = <span class="keyword">tf</span>.train.AdamOptimizer(learning_rate=learning_rate).minimize(cost)</span><br></pre></td></tr></table></figure></li><li><p>训练</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> tf.Session() <span class="keyword">as</span> sess:</span><br><span class="line">    sess.<span class="built_in">run</span>(init)</span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> range(<span class="number">2000</span>):</span><br><span class="line">    _, c = sess.<span class="built_in">run</span>([optimizer, cost], feed_dict=&#123;x: train_data, y: train_label_sex&#125;)</span><br></pre></td></tr></table></figure></li><li><p>保存模型</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">saver</span> = tf.train.Saver()</span><br><span class="line"><span class="attr">save_path</span> = saver.save(sess, <span class="string">"./model_sex/sex.ckpt"</span>, write_meta_graph=None)</span><br></pre></td></tr></table></figure></li><li><p>恢复模型</p><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">saver</span><span class="selector-class">.restore</span>(sess1, <span class="string">"./model_sex/sex.ckpt"</span>)</span><br></pre></td></tr></table></figure></li><li><p>预测</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p = sess1.<span class="keyword">run</span><span class="bash">(pred, feed_dict=&#123;x: data_predict&#125;)</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Web-相关"><a href="#Web-相关" class="headerlink" title="Web 相关"></a>Web 相关</h2><p>这门课程名为《网络程序设计》，目标是完成一个 Web 系统，所以在这之中，除了项目的关注点机器学习，我还学到了一部分 Web 相关的知识。</p><h3 id="Vue-js"><a href="#Vue-js" class="headerlink" title="Vue.js"></a>Vue.js</h3><p>Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。<br>Vue.js 自身不是一个全能框架——它只聚焦于视图层。因此它非常容易学习，非常容易与其它库或已有项目整合。另一方面，在与相关工具和支持库一起使用时，Vue.js 也能完美地驱动复杂的单页应用。<br>在本项目中，利用 Vue.js 对数据进行绑定，以表格的左半边为例：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">data</span>: </span><br><span class="line">&#123;</span><br><span class="line">    <span class="attribute">report_items_left</span>: new <span class="built_in">Array</span>(),</span><br><span class="line">    report_items_right: new <span class="built_in">Array</span>(),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; json_data[<span class="string">"bloodtest"</span>].<span class="built_in">length</span>; <span class="built_in">i</span>++) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">i</span>&lt;<span class="number">13</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        report.report_items_left.push(&#123;count: <span class="built_in">i</span>+<span class="number">1</span>,</span><br><span class="line">            name: json_data.bloodtest[<span class="built_in">i</span>][<span class="string">"name"</span>],</span><br><span class="line">            alias: json_data.bloodtest[<span class="built_in">i</span>].alias,</span><br><span class="line">            value: json_data.bloodtest[<span class="built_in">i</span>].value,</span><br><span class="line">            range: json_data.bloodtest[<span class="built_in">i</span>].range,</span><br><span class="line">            unit: json_data.bloodtest[<span class="built_in">i</span>].unit</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">table</span> <span class="attr">id</span>= <span class="string">"table_left"</span> <span class="attr">class</span>=<span class="string">"table table-inverse table-hover table-bordered"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span> <span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>检测项目<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>结果<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>参考范围<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">th</span>&gt;</span>单位<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="xml">    </span><span class="xml"><span class="tag">&lt;<span class="name">tr</span> <span class="attr">v-for</span>=<span class="string">"item in report_items_left"</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123; <span class="type">item</span><span class="built_in">.count</span> &#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123; <span class="type">item</span><span class="built_in">.name</span> &#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">v-model</span>=<span class="string">"item.value"</span> <span class="attr">class</span>=<span class="string">"form-control"</span> <span class="attr">placeholder</span>=<span class="string">"检测值"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123; <span class="type">item</span>.range &#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">        </span><span class="xml"><span class="tag">&lt;<span class="name">td</span>&gt;</span></span><span class="xquery">&#123;&#123; <span class="type">item</span>.unit &#125;</span><span class="xml">&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p>然后当用户在界面修改后，因为已经绑定，只需要直接调用 data，即可获取到相关值：</p><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">data</span>[i] = <span class="keyword">Number</span>(this.report_items_left[i].<span class="keyword">value</span>);</span><br></pre></td></tr></table></figure><h3 id="Flask"><a href="#Flask" class="headerlink" title="Flask"></a>Flask</h3><p>Flask 是 Python 下的一个轻量级 Web 框架，主要用于处理前端的 http 请求。<br>首先在运行时启动服务器：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">app = Flask(__name__, <span class="attribute">static_url_path</span>=<span class="string">""</span>)</span><br><span class="line">app.config.from_object(<span class="string">'config'</span>)</span><br><span class="line">app.<span class="builtin-name">run</span>(<span class="attribute">host</span>=app.config[<span class="string">'SERVER_HOST'</span>], <span class="attribute">port</span>=app.config[<span class="string">'SERVER_PORT'</span>])</span><br></pre></td></tr></table></figure><p>然后在前端利用 Ajax 就可以访问到后端的对应函数：</p><figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">url</span> = <span class="string">'report/'</span> + <span class="built_in">url</span>.split(<span class="string">'/'</span>)[<span class="number">2</span>];</span><br><span class="line">$.ajax</span><br><span class="line">(</span><br><span class="line">    <span class="attribute">url</span>: <span class="built_in">url</span>,</span><br><span class="line">    <span class="attribute">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span></span><br><span class="line"><span class="function">)</span></span><br><span class="line"><span class="function">//对返回的 <span class="title">data</span> 进行处理</span></span><br></pre></td></tr></table></figure><p>在后端接受前端的 http 访问请求：</p><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@app.route(<span class="string">'/report/&lt;fid&gt;'</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_report</span><span class="params">(fid)</span></span><span class="symbol">:</span></span><br><span class="line">    <span class="symbol">try:</span></span><br><span class="line">        file = db.files.find_one(bson.objectid.ObjectId(fid))</span><br></pre></td></tr></table></figure><h3 id="MongoDB"><a href="#MongoDB" class="headerlink" title="MongoDB"></a>MongoDB</h3><p>在本课程中，用到的数据库是 MongoDB，主要用于将矫正后的图片与 OCR 识别结果存入数据库中。<br>首先是打开服务器的时候连接数据库：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">db</span> = MongoClient(app.config[<span class="string">'DB_HOST'</span>], app.config[<span class="string">'DB_PORT'</span>]).test</span><br></pre></td></tr></table></figure><p>在上传图片后，将校正后的图片以及识别到的各项数值存入数据库中：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">c = dict</span><br><span class="line">    (</span><br><span class="line">    <span class="attribute">report_data</span>=report_data,</span><br><span class="line">    <span class="attribute">content</span>=bson.binary.Binary(content.getvalue()),</span><br><span class="line">    <span class="attribute">filename</span>=secure_filename(f.name), mime = mime</span><br><span class="line">    )</span><br><span class="line">db.files.save(c)</span><br></pre></td></tr></table></figure><p>也可利用 fid，进行结果查询：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">file</span> = db.<span class="keyword">files</span>.find_one(bson.objectid.ObjectId(fid))</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">file</span> <span class="keyword">is</span> None:</span><br><span class="line">        raise bson.errors.InvalidId()</span><br><span class="line">    <span class="keyword">print</span> <span class="string">'type before transform:\n'</span>, <span class="built_in">type</span>(<span class="keyword">file</span>[<span class="string">'report_data'</span>])</span><br><span class="line">    report_data = bson.json_util.dumps(<span class="keyword">file</span>[<span class="string">'report_data'</span>])</span><br></pre></td></tr></table></figure><h2 id="版本库-URL"><a href="#版本库-URL" class="headerlink" title="版本库 URL"></a>版本库 URL</h2><p><a href="https://github.com/snlndod/np2106.git" target="_blank" rel="noopener">GitHub - snlndod/np2106: 对血常规检验报告的OCR识别、深度学习与分析。</a></p><h2 id="安装运行方法"><a href="#安装运行方法" class="headerlink" title="安装运行方法"></a>安装运行方法</h2><h3 id="运行环境"><a href="#运行环境" class="headerlink" title="运行环境"></a>运行环境</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get <span class="keyword">install</span> python-numpy</span><br><span class="line">//安装 numpy</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> python-opencv</span><br><span class="line">//安装 opencv</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> tesseract-ocr</span><br><span class="line">sudo pip <span class="keyword">install</span> pytesseract</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> python-tk</span><br><span class="line">sudo pip <span class="keyword">install</span> pillow</span><br><span class="line">//安装 OCR 和预处理相关依赖</span><br><span class="line">sudo pip <span class="keyword">install</span> Flask</span><br><span class="line">sudo apt-<span class="keyword">get</span> <span class="keyword">install</span> mongodb</span><br><span class="line">sudo service mongodb started</span><br><span class="line">sudo pip <span class="keyword">install</span> pymongo</span><br><span class="line">//安装 Flask 框架、MongoDB</span><br></pre></td></tr></table></figure><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cd</span> BloodTestReportOCR</span><br><span class="line"><span class="keyword">python</span> <span class="keyword">view</span>.<span class="keyword">py</span></span><br><span class="line">//upload 图像，在浏览器打开 http://yourip:<span class="number">8080</span></span><br></pre></td></tr></table></figure><h3 id="Demo-过程截图"><a href="#Demo-过程截图" class="headerlink" title="Demo 过程截图"></a>Demo 过程截图</h3><p>首先定位到 BloodTestReportOCR 中，输入 python view.py：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_5.png" alt><br>然后打开浏览器，输入 localhost:8080：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_6.png" alt><br>上传图片后得到矫正后的图片：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_7.png" alt><br>点击“生成报告”，得到 OCR 的结果：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_8.png" alt><br>点击“predict”，得到预测结果：<br><img src="https://raw.githubusercontent.com/snlndod/mPOST/master/np2016/yl_9.png" alt></p>]]></content>
      
      
      
        <tags>
            
            <tag> MachineLearning </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="2017/03/03/hello-world/"/>
      <url>2017/03/03/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
